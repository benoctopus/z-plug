<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session task-toolu_bdrk_01DaTPhSurXcmGJQnssE1q8v (2026-02-17 04:11Z) -->

# Explore z-plug codebase structure (2026-02-17 04:11Z)

_**Agent (model composer-1, mode Agent)**_


Exploring the codebase structure and key files. Starting with `src/core/` and `src/root.zig`.


---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **7** results in **1** directory</summary>

Directory: **undefined** (7 files)

| File |
|------|
| `./src/core/plugin.zig` |
| `./src/core/params.zig` |
| `./src/core/events.zig` |
| `./src/core/buffer.zig` |
| `./src/core/platform.zig` |
| `./src/core/state.zig` |
| `./src/core/audio_layout.zig` |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/root.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/AGENTS.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "utility functions for converting between dB and gain, frequency conversions",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 41
          }
        },
        "contents": "/// Comptime parameter declaration and runtime parameter state.\n///\n/// Plugin authors declare parameters as comptime arrays of &#96;Param&#96; values.\n/// The framework uses these declarations to generate metadata for both CLAP\n/// and VST3 at compile time and to manage runtime parameter values with\n/// lock-free atomics.\nconst std = @import(\"std\");\n\n// ---------------------------------------------------------------------------\n// Ranges\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter range.\npub const FloatRange = struct {\n    min: f32,\n    max: f32,\n\n    /// Map a plain value to the normalized 0.0–1.0 range.\n    pub fn normalize(self: FloatRange, plain: f32) f32 {\n        if (self.max == self.min) return 0.0;\n        return (self.clamp(plain) - self.min) / (self.max - self.min);\n    }\n\n    /// Map a normalized 0.0–1.0 value back to the plain range.\n    pub fn unnormalize(self: FloatRange, normalized: f32) f32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        return self.min + clamped * (self.max - self.min);\n    }\n\n    /// Clamp a plain value to the range [min, max].\n    pub fn clamp(self: FloatRange, value: f32) f32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n};\n\n/// A continuous floating-point parameter range with logarithmic mapping.\n/// Useful for parameters where human perception is logarithmic (frequency, gain).\npub const LogFloatRange = struct {\n    min: f32,\n    max: f32,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// Comptime parameter declaration and runtime parameter state.",
            "lineNumber": 1
          },
          {
            "text": "///",
            "lineNumber": 2
          },
          {
            "text": "/// Plugin authors declare parameters as comptime arrays of &#96;Param&#96; values.",
            "lineNumber": 3
          },
          {
            "text": "/// The framework uses these declarations to generate metadata for both CLAP",
            "lineNumber": 4
          },
          {
            "text": "/// and VST3 at compile time and to manage runtime parameter values with",
            "lineNumber": 5
          },
          {
            "text": "/// lock-free atomics.",
            "lineNumber": 6
          },
          {
            "text": "const std = @import(\"std\");",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 9
          },
          {
            "text": "// Ranges",
            "lineNumber": 10
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 11
          },
          {
            "lineNumber": 12
          },
          {
            "text": "/// A continuous floating-point parameter range.",
            "lineNumber": 13
          },
          {
            "text": "pub const FloatRange = struct {",
            "lineNumber": 14
          },
          {
            "text": "    min: f32,",
            "lineNumber": 15
          },
          {
            "text": "    max: f32,",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "    /// Map a plain value to the normalized 0.0–1.0 range.",
            "lineNumber": 18
          },
          {
            "text": "    pub fn normalize(self: FloatRange, plain: f32) f32 {",
            "lineNumber": 19
          },
          {
            "text": "        if (self.max == self.min) return 0.0;",
            "lineNumber": 20
          },
          {
            "text": "        return (self.clamp(plain) - self.min) / (self.max - self.min);",
            "lineNumber": 21
          },
          {
            "text": "    }",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to the plain range.",
            "lineNumber": 24
          },
          {
            "text": "    pub fn unnormalize(self: FloatRange, normalized: f32) f32 {",
            "lineNumber": 25
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 26
          },
          {
            "text": "        return self.min + clamped * (self.max - self.min);",
            "lineNumber": 27
          },
          {
            "text": "    }",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "    /// Clamp a plain value to the range [min, max].",
            "lineNumber": 30
          },
          {
            "text": "    pub fn clamp(self: FloatRange, value: f32) f32 {",
            "lineNumber": 31
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 32
          },
          {
            "text": "    }",
            "lineNumber": 33
          },
          {
            "text": "};",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/// A continuous floating-point parameter range with logarithmic mapping.",
            "lineNumber": 36
          },
          {
            "text": "/// Useful for parameters where human perception is logarithmic (frequency, gain).",
            "lineNumber": 37
          },
          {
            "text": "pub const LogFloatRange = struct {",
            "lineNumber": 38
          },
          {
            "text": "    min: f32,",
            "lineNumber": 39
          },
          {
            "text": "    max: f32,",
            "lineNumber": 40
          }
        ]
      },
      "score": 0.29657864570617676
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/common.zig",
        "range": {
          "startPosition": {
            "line": 91
          },
          "endPosition": {
            "line": 138
          }
        },
        "contents": "pub inline fn plainToNormalized(param: core.Param, plain_value: f64) f32 {\n    return switch (param) {\n        .float =&gt; |p| switch (p.range) {\n            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),\n            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),\n        },\n        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),\n        .boolean =&gt; if (plain_value &gt; 0.5) @as(f32, 1.0) else @as(f32, 0.0),\n        .choice =&gt; |p| blk: {\n            if (p.labels.len &lt;= 1) break :blk 0.0;\n            const idx = @min(@as(u32, @intFromFloat(plain_value)), @as(u32, @intCast(p.labels.len - 1)));\n            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));\n        },\n    };\n}\n\n/// Convert a normalized [0, 1] parameter value to plain value.\n///\n/// Used by both wrappers when returning parameter values to the host\n/// or when saving/loading state.\npub inline fn normalizedToPlain(param: core.Param, normalized: f32) f64 {\n    return switch (param) {\n        .float =&gt; |p| switch (p.range) {\n            .linear =&gt; |r| r.unnormalize(normalized),\n            .logarithmic =&gt; |r| r.unnormalize(normalized),\n        },\n        .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),\n        .boolean =&gt; if (normalized &gt; 0.5) @as(f64, 1.0) else @as(f64, 0.0),\n        .choice =&gt; |p| blk: {\n            if (p.labels.len &lt;= 1) break :blk 0.0;\n            const idx = @as(u32, @intFromFloat(normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n            break :blk @floatFromInt(idx);\n        },\n    };\n}\n\n// ---------------------------------------------------------------------------\n// Wrapper State Initialization\n// ---------------------------------------------------------------------------\n\n/// Initialize shared audio state fields on a wrapper instance.\n///\n/// Both wrappers have similar initialization logic for the audio processing state.\n/// This helper ensures consistency and reduces duplication.\npub inline fn initState(\n    comptime P: type,\n    self: anytype,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub inline fn plainToNormalized(param: core.Param, plain_value: f64) f32 {",
            "lineNumber": 92
          },
          {
            "text": "    return switch (param) {",
            "lineNumber": 93
          },
          {
            "text": "        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 94
          },
          {
            "text": "            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 95
          },
          {
            "text": "            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 96
          },
          {
            "text": "        },",
            "lineNumber": 97
          },
          {
            "text": "        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),",
            "lineNumber": 98
          },
          {
            "text": "        .boolean =&gt; if (plain_value &gt; 0.5) @as(f32, 1.0) else @as(f32, 0.0),",
            "lineNumber": 99
          },
          {
            "text": "        .choice =&gt; |p| blk: {",
            "lineNumber": 100
          },
          {
            "text": "            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 101
          },
          {
            "text": "            const idx = @min(@as(u32, @intFromFloat(plain_value)), @as(u32, @intCast(p.labels.len - 1)));",
            "lineNumber": 102
          },
          {
            "text": "            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 103
          },
          {
            "text": "        },",
            "lineNumber": 104
          },
          {
            "text": "    };",
            "lineNumber": 105
          },
          {
            "text": "}",
            "lineNumber": 106
          },
          {
            "lineNumber": 107
          },
          {
            "text": "/// Convert a normalized [0, 1] parameter value to plain value.",
            "lineNumber": 108
          },
          {
            "text": "///",
            "lineNumber": 109
          },
          {
            "text": "/// Used by both wrappers when returning parameter values to the host",
            "lineNumber": 110
          },
          {
            "text": "/// or when saving/loading state.",
            "lineNumber": 111
          },
          {
            "text": "pub inline fn normalizedToPlain(param: core.Param, normalized: f32) f64 {",
            "lineNumber": 112
          },
          {
            "text": "    return switch (param) {",
            "lineNumber": 113
          },
          {
            "text": "        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 114
          },
          {
            "text": "            .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 115
          },
          {
            "text": "            .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 116
          },
          {
            "text": "        },",
            "lineNumber": 117
          },
          {
            "text": "        .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),",
            "lineNumber": 118
          },
          {
            "text": "        .boolean =&gt; if (normalized &gt; 0.5) @as(f64, 1.0) else @as(f64, 0.0),",
            "lineNumber": 119
          },
          {
            "text": "        .choice =&gt; |p| blk: {",
            "lineNumber": 120
          },
          {
            "text": "            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 121
          },
          {
            "text": "            const idx = @as(u32, @intFromFloat(normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 122
          },
          {
            "text": "            break :blk @floatFromInt(idx);",
            "lineNumber": 123
          },
          {
            "text": "        },",
            "lineNumber": 124
          },
          {
            "text": "    };",
            "lineNumber": 125
          },
          {
            "text": "}",
            "lineNumber": 126
          },
          {
            "lineNumber": 127
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 128
          },
          {
            "text": "// Wrapper State Initialization",
            "lineNumber": 129
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 130
          },
          {
            "lineNumber": 131
          },
          {
            "text": "/// Initialize shared audio state fields on a wrapper instance.",
            "lineNumber": 132
          },
          {
            "text": "///",
            "lineNumber": 133
          },
          {
            "text": "/// Both wrappers have similar initialization logic for the audio processing state.",
            "lineNumber": 134
          },
          {
            "text": "/// This helper ensures consistency and reduces duplication.",
            "lineNumber": 135
          },
          {
            "text": "pub inline fn initState(",
            "lineNumber": 136
          },
          {
            "text": "    comptime P: type,",
            "lineNumber": 137
          },
          {
            "text": "    self: anytype,",
            "lineNumber": 138
          }
        ]
      },
      "score": 0.26387929916381836
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 37
          },
          "endPosition": {
            "line": 70
          }
        },
        "contents": "pub const LogFloatRange = struct {\n    min: f32,\n    max: f32,\n\n    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.\n    pub fn normalize(self: LogFloatRange, plain: f32) f32 {\n        if (self.max &lt;= self.min or self.min &lt;= 0.0) return 0.0;\n        const clamped = self.clamp(plain);\n        const log_min = @log(self.min);\n        const log_max = @log(self.max);\n        return (@log(clamped) - log_min) / (log_max - log_min);\n    }\n\n    /// Map a normalized 0.0–1.0 value back to the plain range using logarithmic scaling.\n    pub fn unnormalize(self: LogFloatRange, normalized: f32) f32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        const log_min = @log(self.min);\n        const log_max = @log(self.max);\n        return @exp(log_min + clamped * (log_max - log_min));\n    }\n\n    /// Clamp a plain value to the range [min, max].\n    pub fn clamp(self: LogFloatRange, value: f32) f32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n};\n\n/// A discrete integer parameter range.\npub const IntRange = struct {\n    min: i32,\n    max: i32,\n\n    /// Map a plain integer value to the normalized 0.0–1.0 range.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const LogFloatRange = struct {",
            "lineNumber": 38
          },
          {
            "text": "    min: f32,",
            "lineNumber": 39
          },
          {
            "text": "    max: f32,",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.",
            "lineNumber": 42
          },
          {
            "text": "    pub fn normalize(self: LogFloatRange, plain: f32) f32 {",
            "lineNumber": 43
          },
          {
            "text": "        if (self.max &lt;= self.min or self.min &lt;= 0.0) return 0.0;",
            "lineNumber": 44
          },
          {
            "text": "        const clamped = self.clamp(plain);",
            "lineNumber": 45
          },
          {
            "text": "        const log_min = @log(self.min);",
            "lineNumber": 46
          },
          {
            "text": "        const log_max = @log(self.max);",
            "lineNumber": 47
          },
          {
            "text": "        return (@log(clamped) - log_min) / (log_max - log_min);",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to the plain range using logarithmic scaling.",
            "lineNumber": 51
          },
          {
            "text": "    pub fn unnormalize(self: LogFloatRange, normalized: f32) f32 {",
            "lineNumber": 52
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 53
          },
          {
            "text": "        const log_min = @log(self.min);",
            "lineNumber": 54
          },
          {
            "text": "        const log_max = @log(self.max);",
            "lineNumber": 55
          },
          {
            "text": "        return @exp(log_min + clamped * (log_max - log_min));",
            "lineNumber": 56
          },
          {
            "text": "    }",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    /// Clamp a plain value to the range [min, max].",
            "lineNumber": 59
          },
          {
            "text": "    pub fn clamp(self: LogFloatRange, value: f32) f32 {",
            "lineNumber": 60
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 61
          },
          {
            "text": "    }",
            "lineNumber": 62
          },
          {
            "text": "};",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "/// A discrete integer parameter range.",
            "lineNumber": 65
          },
          {
            "text": "pub const IntRange = struct {",
            "lineNumber": 66
          },
          {
            "text": "    min: i32,",
            "lineNumber": 67
          },
          {
            "text": "    max: i32,",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "    /// Map a plain integer value to the normalized 0.0–1.0 range.",
            "lineNumber": 70
          }
        ]
      },
      "score": 0.23530733585357666
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 974
          },
          "endPosition": {
            "line": 1027
          }
        },
        "contents": "}\n\ntest \"Param toPlain conversion\" {\n    // Float param\n    const float_param = Param{ .float = .{\n        .name = \"Gain\",\n        .id = \"gain\",\n        .default = 0.0,\n        .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },\n    } };\n    const float_plain = float_param.toPlain(0.75); // 0.75 normalized = 12.0 in [-24, 24] range\n    try std.testing.expectApproxEqAbs(@as(f32, 12.0), float_plain, 1e-4);\n\n    // Int param\n    const int_param = Param{ .int = .{\n        .name = \"Cutoff\",\n        .id = \"cutoff\",\n        .default = 1000,\n        .range = .{ .min = 20, .max = 20000 },\n    } };\n    const int_plain = int_param.toPlain(0.5); // 0.5 normalized = ~10010 in [20, 20000] range\n    try std.testing.expectApproxEqAbs(@as(f32, 10010.0), int_plain, 1.0);\n\n    // Boolean param\n    const bool_param = Param{ .boolean = .{\n        .name = \"Bypass\",\n        .id = \"bypass\",\n        .default = false,\n    } };\n    try std.testing.expectApproxEqAbs(@as(f32, 0.0), bool_param.toPlain(0.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), bool_param.toPlain(1.0), 1e-6);\n\n    // Choice param\n    const choice_param = Param{ .choice = .{\n        .name = \"Mode\",\n        .id = \"mode\",\n        .default = 0,\n        .labels = &amp;.{ \"Low\", \"Mid\", \"High\" },\n    } };\n    const choice_plain = choice_param.toPlain(0.5); // Middle choice\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), choice_plain, 1e-6);\n}\n\ntest \"LogFloatRange normalize and unnormalize roundtrip\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    const plain: f32 = 1000.0;\n    const norm = range.normalize(plain);\n    const back = range.unnormalize(norm);\n    try std.testing.expectApproxEqAbs(plain, back, 1e-3);\n}\n\ntest \"LogFloatRange perceptually uniform\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
        "signatures": {},
        "detailedLines": [
          {
            "text": "}",
            "lineNumber": 975
          },
          {
            "lineNumber": 976
          },
          {
            "text": "test \"Param toPlain conversion\" {",
            "lineNumber": 977
          },
          {
            "text": "    // Float param",
            "lineNumber": 978
          },
          {
            "text": "    const float_param = Param{ .float = .{",
            "lineNumber": 979
          },
          {
            "text": "        .name = \"Gain\",",
            "lineNumber": 980
          },
          {
            "text": "        .id = \"gain\",",
            "lineNumber": 981
          },
          {
            "text": "        .default = 0.0,",
            "lineNumber": 982
          },
          {
            "text": "        .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },",
            "lineNumber": 983
          },
          {
            "text": "    } };",
            "lineNumber": 984
          },
          {
            "text": "    const float_plain = float_param.toPlain(0.75); // 0.75 normalized = 12.0 in [-24, 24] range",
            "lineNumber": 985
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 12.0), float_plain, 1e-4);",
            "lineNumber": 986
          },
          {
            "lineNumber": 987
          },
          {
            "text": "    // Int param",
            "lineNumber": 988
          },
          {
            "text": "    const int_param = Param{ .int = .{",
            "lineNumber": 989
          },
          {
            "text": "        .name = \"Cutoff\",",
            "lineNumber": 990
          },
          {
            "text": "        .id = \"cutoff\",",
            "lineNumber": 991
          },
          {
            "text": "        .default = 1000,",
            "lineNumber": 992
          },
          {
            "text": "        .range = .{ .min = 20, .max = 20000 },",
            "lineNumber": 993
          },
          {
            "text": "    } };",
            "lineNumber": 994
          },
          {
            "text": "    const int_plain = int_param.toPlain(0.5); // 0.5 normalized = ~10010 in [20, 20000] range",
            "lineNumber": 995
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 10010.0), int_plain, 1.0);",
            "lineNumber": 996
          },
          {
            "lineNumber": 997
          },
          {
            "text": "    // Boolean param",
            "lineNumber": 998
          },
          {
            "text": "    const bool_param = Param{ .boolean = .{",
            "lineNumber": 999
          },
          {
            "text": "        .name = \"Bypass\",",
            "lineNumber": 1000
          },
          {
            "text": "        .id = \"bypass\",",
            "lineNumber": 1001
          },
          {
            "text": "        .default = false,",
            "lineNumber": 1002
          },
          {
            "text": "    } };",
            "lineNumber": 1003
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.0), bool_param.toPlain(0.0), 1e-6);",
            "lineNumber": 1004
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), bool_param.toPlain(1.0), 1e-6);",
            "lineNumber": 1005
          },
          {
            "lineNumber": 1006
          },
          {
            "text": "    // Choice param",
            "lineNumber": 1007
          },
          {
            "text": "    const choice_param = Param{ .choice = .{",
            "lineNumber": 1008
          },
          {
            "text": "        .name = \"Mode\",",
            "lineNumber": 1009
          },
          {
            "text": "        .id = \"mode\",",
            "lineNumber": 1010
          },
          {
            "text": "        .default = 0,",
            "lineNumber": 1011
          },
          {
            "text": "        .labels = &amp;.{ \"Low\", \"Mid\", \"High\" },",
            "lineNumber": 1012
          },
          {
            "text": "    } };",
            "lineNumber": 1013
          },
          {
            "text": "    const choice_plain = choice_param.toPlain(0.5); // Middle choice",
            "lineNumber": 1014
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), choice_plain, 1e-6);",
            "lineNumber": 1015
          },
          {
            "text": "}",
            "lineNumber": 1016
          },
          {
            "lineNumber": 1017
          },
          {
            "text": "test \"LogFloatRange normalize and unnormalize roundtrip\" {",
            "lineNumber": 1018
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1019
          },
          {
            "text": "    const plain: f32 = 1000.0;",
            "lineNumber": 1020
          },
          {
            "text": "    const norm = range.normalize(plain);",
            "lineNumber": 1021
          },
          {
            "text": "    const back = range.unnormalize(norm);",
            "lineNumber": 1022
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(plain, back, 1e-3);",
            "lineNumber": 1023
          },
          {
            "text": "}",
            "lineNumber": 1024
          },
          {
            "lineNumber": 1025
          },
          {
            "text": "test \"LogFloatRange perceptually uniform\" {",
            "lineNumber": 1026
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1027
          }
        ]
      },
      "score": 0.22413676977157593
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./docs/plugin-authors.md",
        "range": {
          "startPosition": {
            "line": 131
          },
          "endPosition": {
            "line": 200
          }
        },
        "contents": "&#96;&#96;&#96;zig\npub const params = &amp;[_]z_plug.Param{\n    .{ .float = .{\n        .name = \"Gain\",\n        .id = \"gain\",\n        .default = 0.0,  // dB\n        .range = .{ .min = -24.0, .max = 24.0 },\n        .unit = \"dB\",\n        .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing\n    }},\n    .{ .boolean = .{\n        .name = \"Bypass\",\n        .id = \"bypass\",\n        .default = false,\n        .flags = .{ .bypass = true },\n    }},\n    .{ .choice = .{\n        .name = \"Mode\",\n        .id = \"mode\",\n        .default = 0,\n        .labels = &amp;.{ \"Clean\", \"Warm\", \"Vintage\" },\n    }},\n};\n&#96;&#96;&#96;\n\n### Parameter Types\n\n- **&#96;FloatParam&#96;** — Continuous floating-point (e.g., gain, frequency, mix)\n- **&#96;IntParam&#96;** — Discrete integer (e.g., semitones, sample count)\n- **&#96;BoolParam&#96;** — Boolean toggle (e.g., bypass, invert polarity)\n- **&#96;ChoiceParam&#96;** — Enum/choice from a list of labels\n\n### Parameter IDs\n\nThe &#96;id&#96; field must be a **stable string**. It's used to:\n- Generate a stable hash for VST3 &#96;ParamID&#96;\n- Identify parameters in state save/load\n- **Never change IDs after releasing a plugin** — it breaks presets and automation\n\n### Parameter Smoothing\n\nFloat parameters support automatic smoothing to prevent audio artifacts when values change. Add a &#96;smoothing&#96; field to enable:\n\n&#96;&#96;&#96;zig\n.{ .float = .{\n    .name = \"Cutoff\",\n    .id = \"cutoff\",\n    .default = 1000.0,\n    .range = .{ .min = 20.0, .max = 20000.0 },\n    .smoothing = .{ .linear = 10.0 },  // 10ms linear ramp\n}}\n&#96;&#96;&#96;\n\nAvailable smoothing styles:\n- **&#96;.linear&#96;** — Linear ramp over N milliseconds\n- **&#96;.exponential&#96;** — Exponential ramp over N milliseconds (better for frequency)\n- **&#96;.none&#96;** — No smoothing (instant value changes)\n\nTo use smoothed values in your &#96;process&#96; function, call &#96;context.nextSmoothed()&#96; for each sample:\n\n&#96;&#96;&#96;zig\npub fn process(\n    self: *MyPlugin,\n    buffer: *z_plug.Buffer,\n    aux: *z_plug.AuxBuffers,\n    context: *z_plug.ProcessContext,\n) z_plug.ProcessStatus {\n    var i: usize = 0;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 133
          },
          {
            "text": "pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 134
          },
          {
            "text": "    .{ .float = .{",
            "lineNumber": 135
          },
          {
            "text": "        .name = \"Gain\",",
            "lineNumber": 136
          },
          {
            "text": "        .id = \"gain\",",
            "lineNumber": 137
          },
          {
            "text": "        .default = 0.0,  // dB",
            "lineNumber": 138
          },
          {
            "text": "        .range = .{ .min = -24.0, .max = 24.0 },",
            "lineNumber": 139
          },
          {
            "text": "        .unit = \"dB\",",
            "lineNumber": 140
          },
          {
            "text": "        .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing",
            "lineNumber": 141
          },
          {
            "text": "    }},",
            "lineNumber": 142
          },
          {
            "text": "    .{ .boolean = .{",
            "lineNumber": 143
          },
          {
            "text": "        .name = \"Bypass\",",
            "lineNumber": 144
          },
          {
            "text": "        .id = \"bypass\",",
            "lineNumber": 145
          },
          {
            "text": "        .default = false,",
            "lineNumber": 146
          },
          {
            "text": "        .flags = .{ .bypass = true },",
            "lineNumber": 147
          },
          {
            "text": "    }},",
            "lineNumber": 148
          },
          {
            "text": "    .{ .choice = .{",
            "lineNumber": 149
          },
          {
            "text": "        .name = \"Mode\",",
            "lineNumber": 150
          },
          {
            "text": "        .id = \"mode\",",
            "lineNumber": 151
          },
          {
            "text": "        .default = 0,",
            "lineNumber": 152
          },
          {
            "text": "        .labels = &amp;.{ \"Clean\", \"Warm\", \"Vintage\" },",
            "lineNumber": 153
          },
          {
            "text": "    }},",
            "lineNumber": 154
          },
          {
            "text": "};",
            "lineNumber": 155
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 156
          },
          {
            "lineNumber": 157
          },
          {
            "text": "### Parameter Types",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "- **&#96;FloatParam&#96;** — Continuous floating-point (e.g., gain, frequency, mix)",
            "lineNumber": 160
          },
          {
            "text": "- **&#96;IntParam&#96;** — Discrete integer (e.g., semitones, sample count)",
            "lineNumber": 161
          },
          {
            "text": "- **&#96;BoolParam&#96;** — Boolean toggle (e.g., bypass, invert polarity)",
            "lineNumber": 162
          },
          {
            "text": "- **&#96;ChoiceParam&#96;** — Enum/choice from a list of labels",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "### Parameter IDs",
            "lineNumber": 165
          },
          {
            "lineNumber": 166
          },
          {
            "text": "The &#96;id&#96; field must be a **stable string**. It's used to:",
            "lineNumber": 167
          },
          {
            "text": "- Generate a stable hash for VST3 &#96;ParamID&#96;",
            "lineNumber": 168
          },
          {
            "text": "- Identify parameters in state save/load",
            "lineNumber": 169
          },
          {
            "text": "- **Never change IDs after releasing a plugin** — it breaks presets and automation",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "### Parameter Smoothing",
            "lineNumber": 172
          },
          {
            "lineNumber": 173
          },
          {
            "text": "Float parameters support automatic smoothing to prevent audio artifacts when values change. Add a &#96;smoothing&#96; field to enable:",
            "lineNumber": 174
          },
          {
            "lineNumber": 175
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 176
          },
          {
            "text": ".{ .float = .{",
            "lineNumber": 177
          },
          {
            "text": "    .name = \"Cutoff\",",
            "lineNumber": 178
          },
          {
            "text": "    .id = \"cutoff\",",
            "lineNumber": 179
          },
          {
            "text": "    .default = 1000.0,",
            "lineNumber": 180
          },
          {
            "text": "    .range = .{ .min = 20.0, .max = 20000.0 },",
            "lineNumber": 181
          },
          {
            "text": "    .smoothing = .{ .linear = 10.0 },  // 10ms linear ramp",
            "lineNumber": 182
          },
          {
            "text": "}}",
            "lineNumber": 183
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 184
          },
          {
            "lineNumber": 185
          },
          {
            "text": "Available smoothing styles:",
            "lineNumber": 186
          },
          {
            "text": "- **&#96;.linear&#96;** — Linear ramp over N milliseconds",
            "lineNumber": 187
          },
          {
            "text": "- **&#96;.exponential&#96;** — Exponential ramp over N milliseconds (better for frequency)",
            "lineNumber": 188
          },
          {
            "text": "- **&#96;.none&#96;** — No smoothing (instant value changes)",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "To use smoothed values in your &#96;process&#96; function, call &#96;context.nextSmoothed()&#96; for each sample:",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 193
          },
          {
            "text": "pub fn process(",
            "lineNumber": 194
          },
          {
            "text": "    self: *MyPlugin,",
            "lineNumber": 195
          },
          {
            "text": "    buffer: *z_plug.Buffer,",
            "lineNumber": 196
          },
          {
            "text": "    aux: *z_plug.AuxBuffers,",
            "lineNumber": 197
          },
          {
            "text": "    context: *z_plug.ProcessContext,",
            "lineNumber": 198
          },
          {
            "text": ") z_plug.ProcessStatus {",
            "lineNumber": 199
          },
          {
            "text": "    var i: usize = 0;",
            "lineNumber": 200
          }
        ]
      },
      "score": 0.22241589426994324
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./examples/gain.zig",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 58
          }
        },
        "contents": "/// Simple gain plugin example for zig-plug.\n///\n/// This plugin demonstrates the minimal viable plugin:\n/// - One FloatParam for gain control (0.0 to 2.0)\n/// - Stereo processing\n/// - Both CLAP and VST3 support\nconst z_plug = @import(\"z_plug\");\n\nconst GainPlugin = struct {\n    // Required metadata\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n    \n    // Audio configuration: stereo in/out\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n    \n    // Parameters: one gain parameter\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .linear = .{ .min = 0.0, .max = 2.0 } },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },\n        } },\n    };\n    \n    // No internal state needed for this simple plugin\n    \n    /// Initialize the plugin with the selected audio layout and buffer config.\n    pub fn init(\n        _: *@This(),\n        _: *const z_plug.AudioIOLayout,\n        _: *const z_plug.BufferConfig,\n    ) bool {\n        return true;\n    }\n    \n    /// Clean up plugin resources.\n    pub fn deinit(_: *@This()) void {\n        // No cleanup needed\n    }\n    \n    /// Process audio.\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// Simple gain plugin example for zig-plug.",
            "lineNumber": 1
          },
          {
            "text": "///",
            "lineNumber": 2
          },
          {
            "text": "/// This plugin demonstrates the minimal viable plugin:",
            "lineNumber": 3
          },
          {
            "text": "/// - One FloatParam for gain control (0.0 to 2.0)",
            "lineNumber": 4
          },
          {
            "text": "/// - Stereo processing",
            "lineNumber": 5
          },
          {
            "text": "/// - Both CLAP and VST3 support",
            "lineNumber": 6
          },
          {
            "text": "const z_plug = @import(\"z_plug\");",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 9
          },
          {
            "text": "    // Required metadata",
            "lineNumber": 10
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 11
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 12
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 13
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 14
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 15
          },
          {
            "text": "    ",
            "lineNumber": 16
          },
          {
            "text": "    // Audio configuration: stereo in/out",
            "lineNumber": 17
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 18
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 19
          },
          {
            "text": "    };",
            "lineNumber": 20
          },
          {
            "text": "    ",
            "lineNumber": 21
          },
          {
            "text": "    // Parameters: one gain parameter",
            "lineNumber": 22
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 23
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 24
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 25
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 26
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 27
          },
          {
            "text": "            .range = .{ .linear = .{ .min = 0.0, .max = 2.0 } },",
            "lineNumber": 28
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 29
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 30
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },",
            "lineNumber": 31
          },
          {
            "text": "        } },",
            "lineNumber": 32
          },
          {
            "text": "    };",
            "lineNumber": 33
          },
          {
            "text": "    ",
            "lineNumber": 34
          },
          {
            "text": "    // No internal state needed for this simple plugin",
            "lineNumber": 35
          },
          {
            "text": "    ",
            "lineNumber": 36
          },
          {
            "text": "    /// Initialize the plugin with the selected audio layout and buffer config.",
            "lineNumber": 37
          },
          {
            "text": "    pub fn init(",
            "lineNumber": 38
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 39
          },
          {
            "text": "        _: *const z_plug.AudioIOLayout,",
            "lineNumber": 40
          },
          {
            "text": "        _: *const z_plug.BufferConfig,",
            "lineNumber": 41
          },
          {
            "text": "    ) bool {",
            "lineNumber": 42
          },
          {
            "text": "        return true;",
            "lineNumber": 43
          },
          {
            "text": "    }",
            "lineNumber": 44
          },
          {
            "text": "    ",
            "lineNumber": 45
          },
          {
            "text": "    /// Clean up plugin resources.",
            "lineNumber": 46
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {",
            "lineNumber": 47
          },
          {
            "text": "        // No cleanup needed",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "text": "    ",
            "lineNumber": 50
          },
          {
            "text": "    /// Process audio.",
            "lineNumber": 51
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 52
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 53
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 54
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 55
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 56
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 57
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 58
          }
        ]
      },
      "score": 0.20843255519866943
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 64
          },
          "endPosition": {
            "line": 119
          }
        },
        "contents": "/// A discrete integer parameter range.\npub const IntRange = struct {\n    min: i32,\n    max: i32,\n\n    /// Map a plain integer value to the normalized 0.0–1.0 range.\n    pub fn normalize(self: IntRange, plain: i32) f32 {\n        if (self.max == self.min) return 0.0;\n        const clamped = self.clamp(plain);\n        return @as(f32, @floatFromInt(clamped - self.min)) /\n            @as(f32, @floatFromInt(self.max - self.min));\n    }\n\n    /// Map a normalized 0.0–1.0 value back to a plain integer (rounded).\n    pub fn unnormalize(self: IntRange, normalized: f32) i32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        const span: f32 = @floatFromInt(self.max - self.min);\n        return self.min + @as(i32, @intFromFloat(@round(clamped * span)));\n    }\n\n    /// Clamp a plain integer value to the range [min, max].\n    pub fn clamp(self: IntRange, value: i32) i32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n\n    /// The number of discrete steps in this range (max - min).\n    pub fn stepCount(self: IntRange) u32 {\n        return @intCast(self.max - self.min);\n    }\n};\n\n// ---------------------------------------------------------------------------\n// Flags\n// ---------------------------------------------------------------------------\n\n/// Flags that control how a parameter is exposed to the host.\npub const ParamFlags = packed struct {\n    /// Whether the host can automate this parameter. Default: &#96;true&#96;.\n    automatable: bool = true,\n    /// Whether the parameter supports per-voice modulation (CLAP).\n    modulatable: bool = false,\n    /// Hide this parameter from the host's generic parameter list.\n    hidden: bool = false,\n    /// Mark this parameter as the plugin's bypass control.\n    bypass: bool = false,\n    /// Hint that the parameter is stepped (e.g. switches, choices).\n    is_stepped: bool = false,\n    _padding: u3 = 0,\n};\n\n// ---------------------------------------------------------------------------\n// Parameter declarations (comptime)\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// A discrete integer parameter range.",
            "lineNumber": 65
          },
          {
            "text": "pub const IntRange = struct {",
            "lineNumber": 66
          },
          {
            "text": "    min: i32,",
            "lineNumber": 67
          },
          {
            "text": "    max: i32,",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "    /// Map a plain integer value to the normalized 0.0–1.0 range.",
            "lineNumber": 70
          },
          {
            "text": "    pub fn normalize(self: IntRange, plain: i32) f32 {",
            "lineNumber": 71
          },
          {
            "text": "        if (self.max == self.min) return 0.0;",
            "lineNumber": 72
          },
          {
            "text": "        const clamped = self.clamp(plain);",
            "lineNumber": 73
          },
          {
            "text": "        return @as(f32, @floatFromInt(clamped - self.min)) /",
            "lineNumber": 74
          },
          {
            "text": "            @as(f32, @floatFromInt(self.max - self.min));",
            "lineNumber": 75
          },
          {
            "text": "    }",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to a plain integer (rounded).",
            "lineNumber": 78
          },
          {
            "text": "    pub fn unnormalize(self: IntRange, normalized: f32) i32 {",
            "lineNumber": 79
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 80
          },
          {
            "text": "        const span: f32 = @floatFromInt(self.max - self.min);",
            "lineNumber": 81
          },
          {
            "text": "        return self.min + @as(i32, @intFromFloat(@round(clamped * span)));",
            "lineNumber": 82
          },
          {
            "text": "    }",
            "lineNumber": 83
          },
          {
            "lineNumber": 84
          },
          {
            "text": "    /// Clamp a plain integer value to the range [min, max].",
            "lineNumber": 85
          },
          {
            "text": "    pub fn clamp(self: IntRange, value: i32) i32 {",
            "lineNumber": 86
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 87
          },
          {
            "text": "    }",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "    /// The number of discrete steps in this range (max - min).",
            "lineNumber": 90
          },
          {
            "text": "    pub fn stepCount(self: IntRange) u32 {",
            "lineNumber": 91
          },
          {
            "text": "        return @intCast(self.max - self.min);",
            "lineNumber": 92
          },
          {
            "text": "    }",
            "lineNumber": 93
          },
          {
            "text": "};",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 96
          },
          {
            "text": "// Flags",
            "lineNumber": 97
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 98
          },
          {
            "lineNumber": 99
          },
          {
            "text": "/// Flags that control how a parameter is exposed to the host.",
            "lineNumber": 100
          },
          {
            "text": "pub const ParamFlags = packed struct {",
            "lineNumber": 101
          },
          {
            "text": "    /// Whether the host can automate this parameter. Default: &#96;true&#96;.",
            "lineNumber": 102
          },
          {
            "text": "    automatable: bool = true,",
            "lineNumber": 103
          },
          {
            "text": "    /// Whether the parameter supports per-voice modulation (CLAP).",
            "lineNumber": 104
          },
          {
            "text": "    modulatable: bool = false,",
            "lineNumber": 105
          },
          {
            "text": "    /// Hide this parameter from the host's generic parameter list.",
            "lineNumber": 106
          },
          {
            "text": "    hidden: bool = false,",
            "lineNumber": 107
          },
          {
            "text": "    /// Mark this parameter as the plugin's bypass control.",
            "lineNumber": 108
          },
          {
            "text": "    bypass: bool = false,",
            "lineNumber": 109
          },
          {
            "text": "    /// Hint that the parameter is stepped (e.g. switches, choices).",
            "lineNumber": 110
          },
          {
            "text": "    is_stepped: bool = false,",
            "lineNumber": 111
          },
          {
            "text": "    _padding: u3 = 0,",
            "lineNumber": 112
          },
          {
            "text": "};",
            "lineNumber": 113
          },
          {
            "lineNumber": 114
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 115
          },
          {
            "text": "// Parameter declarations (comptime)",
            "lineNumber": 116
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "/// A continuous floating-point parameter.",
            "lineNumber": 119
          }
        ]
      },
      "score": 0.20732414722442627
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 115
          },
          "endPosition": {
            "line": 174
          }
        },
        "contents": "// Parameter declarations (comptime)\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter.\npub const FloatParam = struct {\n    /// Human-readable parameter name shown in the host.\n    name: [:0]const u8,\n    /// Stable string identifier. Hashed to generate VST3 &#96;ParamID&#96;.\n    id: [:0]const u8,\n    /// Default plain value.\n    default: f32,\n    /// The value range - can be linear or logarithmic.\n    range: union(enum) {\n        linear: FloatRange,\n        logarithmic: LogFloatRange,\n    },\n    /// Optional step size for hosts that display discrete ticks.\n    step_size: ?f32 = null,\n    /// Unit label displayed after the value (e.g. \"dB\", \"Hz\", \"%\").\n    unit: [:0]const u8 = \"\",\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n    /// Optional smoothing style (default: no smoothing).\n    smoothing: SmoothingStyle = .none,\n};\n\n/// A discrete integer parameter.\npub const IntParam = struct {\n    /// Human-readable parameter name.\n    name: [:0]const u8,\n    /// Stable string identifier.\n    id: [:0]const u8,\n    /// Default plain value.\n    default: i32,\n    /// The integer value range.\n    range: IntRange,\n    /// Unit label (e.g. \"st\" for semitones).\n    unit: [:0]const u8 = \"\",\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n    /// Optional smoothing style (default: no smoothing).\n    smoothing: SmoothingStyle = .none,\n};\n\n/// A boolean (on/off, toggle) parameter.\npub const BoolParam = struct {\n    /// Human-readable parameter name.\n    name: [:0]const u8,\n    /// Stable string identifier.\n    id: [:0]const u8,\n    /// Default value.\n    default: bool,\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n};\n\n/// An enum / choice parameter backed by a list of labels.\npub const ChoiceParam = struct {\n    /// Human-readable parameter name.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "// Parameter declarations (comptime)",
            "lineNumber": 116
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "/// A continuous floating-point parameter.",
            "lineNumber": 119
          },
          {
            "text": "pub const FloatParam = struct {",
            "lineNumber": 120
          },
          {
            "text": "    /// Human-readable parameter name shown in the host.",
            "lineNumber": 121
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 122
          },
          {
            "text": "    /// Stable string identifier. Hashed to generate VST3 &#96;ParamID&#96;.",
            "lineNumber": 123
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 124
          },
          {
            "text": "    /// Default plain value.",
            "lineNumber": 125
          },
          {
            "text": "    default: f32,",
            "lineNumber": 126
          },
          {
            "text": "    /// The value range - can be linear or logarithmic.",
            "lineNumber": 127
          },
          {
            "text": "    range: union(enum) {",
            "lineNumber": 128
          },
          {
            "text": "        linear: FloatRange,",
            "lineNumber": 129
          },
          {
            "text": "        logarithmic: LogFloatRange,",
            "lineNumber": 130
          },
          {
            "text": "    },",
            "lineNumber": 131
          },
          {
            "text": "    /// Optional step size for hosts that display discrete ticks.",
            "lineNumber": 132
          },
          {
            "text": "    step_size: ?f32 = null,",
            "lineNumber": 133
          },
          {
            "text": "    /// Unit label displayed after the value (e.g. \"dB\", \"Hz\", \"%\").",
            "lineNumber": 134
          },
          {
            "text": "    unit: [:0]const u8 = \"\",",
            "lineNumber": 135
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 136
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 137
          },
          {
            "text": "    /// Optional smoothing style (default: no smoothing).",
            "lineNumber": 138
          },
          {
            "text": "    smoothing: SmoothingStyle = .none,",
            "lineNumber": 139
          },
          {
            "text": "};",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "/// A discrete integer parameter.",
            "lineNumber": 142
          },
          {
            "text": "pub const IntParam = struct {",
            "lineNumber": 143
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 144
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 145
          },
          {
            "text": "    /// Stable string identifier.",
            "lineNumber": 146
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 147
          },
          {
            "text": "    /// Default plain value.",
            "lineNumber": 148
          },
          {
            "text": "    default: i32,",
            "lineNumber": 149
          },
          {
            "text": "    /// The integer value range.",
            "lineNumber": 150
          },
          {
            "text": "    range: IntRange,",
            "lineNumber": 151
          },
          {
            "text": "    /// Unit label (e.g. \"st\" for semitones).",
            "lineNumber": 152
          },
          {
            "text": "    unit: [:0]const u8 = \"\",",
            "lineNumber": 153
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 154
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 155
          },
          {
            "text": "    /// Optional smoothing style (default: no smoothing).",
            "lineNumber": 156
          },
          {
            "text": "    smoothing: SmoothingStyle = .none,",
            "lineNumber": 157
          },
          {
            "text": "};",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "/// A boolean (on/off, toggle) parameter.",
            "lineNumber": 160
          },
          {
            "text": "pub const BoolParam = struct {",
            "lineNumber": 161
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 162
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 163
          },
          {
            "text": "    /// Stable string identifier.",
            "lineNumber": 164
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 165
          },
          {
            "text": "    /// Default value.",
            "lineNumber": 166
          },
          {
            "text": "    default: bool,",
            "lineNumber": 167
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 168
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 169
          },
          {
            "text": "};",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "/// An enum / choice parameter backed by a list of labels.",
            "lineNumber": 172
          },
          {
            "text": "pub const ChoiceParam = struct {",
            "lineNumber": 173
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 174
          }
        ]
      },
      "score": 0.20511305332183838
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 220
          },
          "endPosition": {
            "line": 277
          }
        },
        "contents": "    pub fn defaultNormalized(self: Param) f32 {\n        return switch (self) {\n            .float =&gt; |p| switch (p.range) {\n                .linear =&gt; |r| r.normalize(p.default),\n                .logarithmic =&gt; |r| r.normalize(p.default),\n            },\n            .int =&gt; |p| p.range.normalize(p.default),\n            .boolean =&gt; |p| if (p.default) @as(f32, 1.0) else @as(f32, 0.0),\n            .choice =&gt; |p| blk: {\n                if (p.labels.len &lt;= 1) break :blk 0.0;\n                break :blk @as(f32, @floatFromInt(p.default)) /\n                    @as(f32, @floatFromInt(p.labels.len - 1));\n            },\n        };\n    }\n\n    /// Convert a normalized value to plain (unnormalized) value.\n    pub fn toPlain(self: Param, normalized: f32) f32 {\n        return switch (self) {\n            .float =&gt; |p| switch (p.range) {\n                .linear =&gt; |r| r.unnormalize(normalized),\n                .logarithmic =&gt; |r| r.unnormalize(normalized),\n            },\n            .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),\n            .boolean =&gt; if (normalized &gt; 0.5) 1.0 else 0.0,\n            .choice =&gt; |p| blk: {\n                if (p.labels.len &lt;= 1) break :blk 0.0;\n                break :blk normalized * @as(f32, @floatFromInt(p.labels.len - 1));\n            },\n        };\n    }\n\n    /// Returns the flags for this parameter.\n    pub fn flags(self: Param) ParamFlags {\n        return switch (self) {\n            .float =&gt; |p| p.flags,\n            .int =&gt; |p| p.flags,\n            .boolean =&gt; |p| p.flags,\n            .choice =&gt; |p| p.flags,\n        };\n    }\n};\n\n// ---------------------------------------------------------------------------\n// Stable ID hashing\n// ---------------------------------------------------------------------------\n\n/// Compute a stable 32-bit hash from a parameter's string ID.\n///\n/// Uses FNV-1a to produce a deterministic &#96;u32&#96; suitable for use as a\n/// VST3 &#96;ParamID&#96;. The same string always produces the same hash.\npub fn idHash(comptime str: [:0]const u8) u32 {\n    comptime {\n        return fnv1a_32(str);\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub fn defaultNormalized(self: Param) f32 {",
            "lineNumber": 221
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 222
          },
          {
            "text": "            .float =&gt; |p| switch (p.range) {",
            "lineNumber": 223
          },
          {
            "text": "                .linear =&gt; |r| r.normalize(p.default),",
            "lineNumber": 224
          },
          {
            "text": "                .logarithmic =&gt; |r| r.normalize(p.default),",
            "lineNumber": 225
          },
          {
            "text": "            },",
            "lineNumber": 226
          },
          {
            "text": "            .int =&gt; |p| p.range.normalize(p.default),",
            "lineNumber": 227
          },
          {
            "text": "            .boolean =&gt; |p| if (p.default) @as(f32, 1.0) else @as(f32, 0.0),",
            "lineNumber": 228
          },
          {
            "text": "            .choice =&gt; |p| blk: {",
            "lineNumber": 229
          },
          {
            "text": "                if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 230
          },
          {
            "text": "                break :blk @as(f32, @floatFromInt(p.default)) /",
            "lineNumber": 231
          },
          {
            "text": "                    @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 232
          },
          {
            "text": "            },",
            "lineNumber": 233
          },
          {
            "text": "        };",
            "lineNumber": 234
          },
          {
            "text": "    }",
            "lineNumber": 235
          },
          {
            "lineNumber": 236
          },
          {
            "text": "    /// Convert a normalized value to plain (unnormalized) value.",
            "lineNumber": 237
          },
          {
            "text": "    pub fn toPlain(self: Param, normalized: f32) f32 {",
            "lineNumber": 238
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 239
          },
          {
            "text": "            .float =&gt; |p| switch (p.range) {",
            "lineNumber": 240
          },
          {
            "text": "                .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 241
          },
          {
            "text": "                .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 242
          },
          {
            "text": "            },",
            "lineNumber": 243
          },
          {
            "text": "            .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),",
            "lineNumber": 244
          },
          {
            "text": "            .boolean =&gt; if (normalized &gt; 0.5) 1.0 else 0.0,",
            "lineNumber": 245
          },
          {
            "text": "            .choice =&gt; |p| blk: {",
            "lineNumber": 246
          },
          {
            "text": "                if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 247
          },
          {
            "text": "                break :blk normalized * @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 248
          },
          {
            "text": "            },",
            "lineNumber": 249
          },
          {
            "text": "        };",
            "lineNumber": 250
          },
          {
            "text": "    }",
            "lineNumber": 251
          },
          {
            "lineNumber": 252
          },
          {
            "text": "    /// Returns the flags for this parameter.",
            "lineNumber": 253
          },
          {
            "text": "    pub fn flags(self: Param) ParamFlags {",
            "lineNumber": 254
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 255
          },
          {
            "text": "            .float =&gt; |p| p.flags,",
            "lineNumber": 256
          },
          {
            "text": "            .int =&gt; |p| p.flags,",
            "lineNumber": 257
          },
          {
            "text": "            .boolean =&gt; |p| p.flags,",
            "lineNumber": 258
          },
          {
            "text": "            .choice =&gt; |p| p.flags,",
            "lineNumber": 259
          },
          {
            "text": "        };",
            "lineNumber": 260
          },
          {
            "text": "    }",
            "lineNumber": 261
          },
          {
            "text": "};",
            "lineNumber": 262
          },
          {
            "lineNumber": 263
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 264
          },
          {
            "text": "// Stable ID hashing",
            "lineNumber": 265
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 266
          },
          {
            "lineNumber": 267
          },
          {
            "text": "/// Compute a stable 32-bit hash from a parameter's string ID.",
            "lineNumber": 268
          },
          {
            "text": "///",
            "lineNumber": 269
          },
          {
            "text": "/// Uses FNV-1a to produce a deterministic &#96;u32&#96; suitable for use as a",
            "lineNumber": 270
          },
          {
            "text": "/// VST3 &#96;ParamID&#96;. The same string always produces the same hash.",
            "lineNumber": 271
          },
          {
            "text": "pub fn idHash(comptime str: [:0]const u8) u32 {",
            "lineNumber": 272
          },
          {
            "text": "    comptime {",
            "lineNumber": 273
          },
          {
            "text": "        return fnv1a_32(str);",
            "lineNumber": 274
          },
          {
            "text": "    }",
            "lineNumber": 275
          },
          {
            "text": "}",
            "lineNumber": 276
          }
        ]
      },
      "score": 0.2013680338859558
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 421
          },
          "endPosition": {
            "line": 442
          }
        },
        "contents": "pub const SmoothingStyle = union(enum) {\n    /// No smoothing — parameter changes take effect immediately.\n    none,\n    /// Linear ramp over the specified duration in milliseconds.\n    linear: f32,\n    /// Exponential smoothing (single-pole IIR) over the specified duration.\n    /// Reaches approximately 99.99% of target, then snaps to target.\n    exponential: f32,\n    /// Logarithmic interpolation over the specified duration in milliseconds.\n    /// Smooths in log space, producing exponential curves in linear space.\n    /// Useful for frequency sweeps and gain changes.\n    logarithmic: f32,\n};\n\n/// A parameter value smoother that interpolates between current and target\n/// values over time.\n///\n/// Supports linear and exponential smoothing styles. Used to avoid audible\n/// clicks and pops when parameters change abruptly.\npub const Smoother = struct {\n    /// The smoothing style for this parameter.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const SmoothingStyle = union(enum) {",
            "lineNumber": 422
          },
          {
            "text": "    /// No smoothing — parameter changes take effect immediately.",
            "lineNumber": 423
          },
          {
            "text": "    none,",
            "lineNumber": 424
          },
          {
            "text": "    /// Linear ramp over the specified duration in milliseconds.",
            "lineNumber": 425
          },
          {
            "text": "    linear: f32,",
            "lineNumber": 426
          },
          {
            "text": "    /// Exponential smoothing (single-pole IIR) over the specified duration.",
            "lineNumber": 427
          },
          {
            "text": "    /// Reaches approximately 99.99% of target, then snaps to target.",
            "lineNumber": 428
          },
          {
            "text": "    exponential: f32,",
            "lineNumber": 429
          },
          {
            "text": "    /// Logarithmic interpolation over the specified duration in milliseconds.",
            "lineNumber": 430
          },
          {
            "text": "    /// Smooths in log space, producing exponential curves in linear space.",
            "lineNumber": 431
          },
          {
            "text": "    /// Useful for frequency sweeps and gain changes.",
            "lineNumber": 432
          },
          {
            "text": "    logarithmic: f32,",
            "lineNumber": 433
          },
          {
            "text": "};",
            "lineNumber": 434
          },
          {
            "lineNumber": 435
          },
          {
            "text": "/// A parameter value smoother that interpolates between current and target",
            "lineNumber": 436
          },
          {
            "text": "/// values over time.",
            "lineNumber": 437
          },
          {
            "text": "///",
            "lineNumber": 438
          },
          {
            "text": "/// Supports linear and exponential smoothing styles. Used to avoid audible",
            "lineNumber": 439
          },
          {
            "text": "/// clicks and pops when parameters change abruptly.",
            "lineNumber": 440
          },
          {
            "text": "pub const Smoother = struct {",
            "lineNumber": 441
          },
          {
            "text": "    /// The smoothing style for this parameter.",
            "lineNumber": 442
          }
        ]
      },
      "score": 0.198539137840271
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./README.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 75
          }
        },
        "contents": "# z-plug\n\nAudio plugin framework for Zig. Write a plugin once, get VST3 and CLAP binaries from the same source. Inspired by [nih-plug](https://github.com/robbert-vdh/nih-plug).\n\nRequires Zig 0.15.2.\n\n## Example\n\nA minimal gain plugin (&#96;examples/gain.zig&#96;):\n\n&#96;&#96;&#96;zig\nconst z_plug = @import(\"z_plug\");\n\nconst GainPlugin = struct {\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .min = 0.0, .max = 2.0 },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },\n        } },\n    };\n\n    pub fn init(_: *@This(), _: *const z_plug.AudioIOLayout, _: *const z_plug.BufferConfig) bool {\n        return true;\n    }\n\n    pub fn deinit(_: *@This()) void {}\n\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;\n        const num_channels = buffer.channel_data.len;\n\n        var i: usize = 0;\n        while (i &lt; num_samples) : (i += 1) {\n            const gain = context.nextSmoothed(1, 0);\n            for (buffer.channel_data[0..num_channels]) |channel| {\n                channel[i] *= gain;\n            }\n        }\n\n        return z_plug.ProcessStatus.ok();\n    }\n};\n\n// Export both formats\ncomptime {\n    _ = z_plug.ClapEntry(GainPlugin);\n    _ = z_plug.Vst3Factory(GainPlugin);\n}\n&#96;&#96;&#96;\n\nPlugin metadata, parameters, and audio layout are declared as comptime constants. The framework uses them to generate vtables, parameter lists, GUIDs, and lookup tables at compile time. No allocations happen on the audio thread.\n\n## Building\n\nThe &#96;flake.nix&#96; provides a dev environment with the right Zig version via Nix + direnv.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# z-plug",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "Audio plugin framework for Zig. Write a plugin once, get VST3 and CLAP binaries from the same source. Inspired by [nih-plug](https://github.com/robbert-vdh/nih-plug).",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "Requires Zig 0.15.2.",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "## Example",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "A minimal gain plugin (&#96;examples/gain.zig&#96;):",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 11
          },
          {
            "text": "const z_plug = @import(\"z_plug\");",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 14
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 15
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 16
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 17
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 18
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 21
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 22
          },
          {
            "text": "    };",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 25
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 26
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 27
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 28
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 29
          },
          {
            "text": "            .range = .{ .min = 0.0, .max = 2.0 },",
            "lineNumber": 30
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 31
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 32
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },",
            "lineNumber": 33
          },
          {
            "text": "        } },",
            "lineNumber": 34
          },
          {
            "text": "    };",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "    pub fn init(_: *@This(), _: *const z_plug.AudioIOLayout, _: *const z_plug.BufferConfig) bool {",
            "lineNumber": 37
          },
          {
            "text": "        return true;",
            "lineNumber": 38
          },
          {
            "text": "    }",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {}",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 43
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 44
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 45
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 46
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 47
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 48
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 49
          },
          {
            "text": "        const num_channels = buffer.channel_data.len;",
            "lineNumber": 50
          },
          {
            "lineNumber": 51
          },
          {
            "text": "        var i: usize = 0;",
            "lineNumber": 52
          },
          {
            "text": "        while (i &lt; num_samples) : (i += 1) {",
            "lineNumber": 53
          },
          {
            "text": "            const gain = context.nextSmoothed(1, 0);",
            "lineNumber": 54
          },
          {
            "text": "            for (buffer.channel_data[0..num_channels]) |channel| {",
            "lineNumber": 55
          },
          {
            "text": "                channel[i] *= gain;",
            "lineNumber": 56
          },
          {
            "text": "            }",
            "lineNumber": 57
          },
          {
            "text": "        }",
            "lineNumber": 58
          },
          {
            "lineNumber": 59
          },
          {
            "text": "        return z_plug.ProcessStatus.ok();",
            "lineNumber": 60
          },
          {
            "text": "    }",
            "lineNumber": 61
          },
          {
            "text": "};",
            "lineNumber": 62
          },
          {
            "lineNumber": 63
          },
          {
            "text": "// Export both formats",
            "lineNumber": 64
          },
          {
            "text": "comptime {",
            "lineNumber": 65
          },
          {
            "text": "    _ = z_plug.ClapEntry(GainPlugin);",
            "lineNumber": 66
          },
          {
            "text": "    _ = z_plug.Vst3Factory(GainPlugin);",
            "lineNumber": 67
          },
          {
            "text": "}",
            "lineNumber": 68
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "Plugin metadata, parameters, and audio layout are declared as comptime constants. The framework uses them to generate vtables, parameter lists, GUIDs, and lookup tables at compile time. No allocations happen on the audio thread.",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "## Building",
            "lineNumber": 73
          },
          {
            "lineNumber": 74
          },
          {
            "text": "The &#96;flake.nix&#96; provides a dev environment with the right Zig version via Nix + direnv.",
            "lineNumber": 75
          }
        ]
      },
      "score": 0.18565590679645538
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 268
          },
          "endPosition": {
            "line": 318
          }
        },
        "contents": "        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    return switch (param) {\n                        .float =&gt; |p| switch (p.range) {\n                            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),\n                            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),\n                        },\n                        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),\n                        .boolean =&gt; plain_value,\n                        .choice =&gt; |p| blk: {\n                            if (p.labels.len &lt;= 1) break :blk 0.0;\n                            const idx = @as(u32, @intFromFloat(plain_value));\n                            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));\n                        },\n                    };\n                }\n            }\n\n            return plain_value;\n        }\n\n        fn getParamNormalized(\n            self: *anyopaque,\n            id: vst3.types.ParamID,\n        ) callconv(.c) vst3.types.ParamValue {\n            const controller = fromController(self);\n\n            if (controller.param_values) |param_values| {\n                // Find parameter by ID\n                for (P.params, 0..) |_, idx| {\n                    const param_id = P.param_ids[idx];\n                    if (param_id == id) {\n                        return param_values.get(idx);\n                    }\n                }\n            }\n\n            return 0.0;\n        }\n\n        fn setParamNormalized(\n            self: *anyopaque,\n            id: vst3.types.ParamID,\n            value: vst3.types.ParamValue,\n        ) callconv(.c) vst3.tresult {\n            const controller = fromController(self);",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 269
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 270
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 271
          },
          {
            "text": "                const param_id = P.param_ids[i];",
            "lineNumber": 272
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 273
          },
          {
            "text": "                    return switch (param) {",
            "lineNumber": 274
          },
          {
            "text": "                        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 275
          },
          {
            "text": "                            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 276
          },
          {
            "text": "                            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 277
          },
          {
            "text": "                        },",
            "lineNumber": 278
          },
          {
            "text": "                        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),",
            "lineNumber": 279
          },
          {
            "text": "                        .boolean =&gt; plain_value,",
            "lineNumber": 280
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 281
          },
          {
            "text": "                            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 282
          },
          {
            "text": "                            const idx = @as(u32, @intFromFloat(plain_value));",
            "lineNumber": 283
          },
          {
            "text": "                            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 284
          },
          {
            "text": "                        },",
            "lineNumber": 285
          },
          {
            "text": "                    };",
            "lineNumber": 286
          },
          {
            "text": "                }",
            "lineNumber": 287
          },
          {
            "text": "            }",
            "lineNumber": 288
          },
          {
            "lineNumber": 289
          },
          {
            "text": "            return plain_value;",
            "lineNumber": 290
          },
          {
            "text": "        }",
            "lineNumber": 291
          },
          {
            "lineNumber": 292
          },
          {
            "text": "        fn getParamNormalized(",
            "lineNumber": 293
          },
          {
            "text": "            self: *anyopaque,",
            "lineNumber": 294
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 295
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 296
          },
          {
            "text": "            const controller = fromController(self);",
            "lineNumber": 297
          },
          {
            "lineNumber": 298
          },
          {
            "text": "            if (controller.param_values) |param_values| {",
            "lineNumber": 299
          },
          {
            "text": "                // Find parameter by ID",
            "lineNumber": 300
          },
          {
            "text": "                for (P.params, 0..) |_, idx| {",
            "lineNumber": 301
          },
          {
            "text": "                    const param_id = P.param_ids[idx];",
            "lineNumber": 302
          },
          {
            "text": "                    if (param_id == id) {",
            "lineNumber": 303
          },
          {
            "text": "                        return param_values.get(idx);",
            "lineNumber": 304
          },
          {
            "text": "                    }",
            "lineNumber": 305
          },
          {
            "text": "                }",
            "lineNumber": 306
          },
          {
            "text": "            }",
            "lineNumber": 307
          },
          {
            "lineNumber": 308
          },
          {
            "text": "            return 0.0;",
            "lineNumber": 309
          },
          {
            "text": "        }",
            "lineNumber": 310
          },
          {
            "lineNumber": 311
          },
          {
            "text": "        fn setParamNormalized(",
            "lineNumber": 312
          },
          {
            "text": "            self: *anyopaque,",
            "lineNumber": 313
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 314
          },
          {
            "text": "            value: vst3.types.ParamValue,",
            "lineNumber": 315
          },
          {
            "text": "        ) callconv(.c) vst3.tresult {",
            "lineNumber": 316
          },
          {
            "text": "            const controller = fromController(self);",
            "lineNumber": 317
          }
        ]
      },
      "score": 0.18242943286895752
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 227
          },
          "endPosition": {
            "line": 271,
            "column": 16
          }
        },
        "contents": "        fn getParamValueByString(\n            _: *anyopaque,\n            _: vst3.types.ParamID,\n            _: *vst3.types.char16,\n            _: *vst3.types.ParamValue,\n        ) callconv(.c) vst3.tresult {\n            // TODO: Implement string-to-value parsing\n            return vst3.types.kNotImplemented;\n        }\n\n        fn normalizedParamToPlain(\n            _: *anyopaque,\n            id: vst3.types.ParamID,\n            value_normalized: vst3.types.ParamValue,\n        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    return switch (param) {\n                        .float =&gt; |p| switch (p.range) {\n                            .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                            .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                        },\n                        .int =&gt; |p| @floatFromInt(p.range.unnormalize(@floatCast(value_normalized))),\n                        .boolean =&gt; value_normalized,\n                        .choice =&gt; |p| blk: {\n                            const idx = @as(u32, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n                            break :blk @floatFromInt(idx);\n                        },\n                    };\n                }\n            }\n\n            return value_normalized;\n        }\n\n        fn plainParamToNormalized(\n            _: *anyopaque,\n            id: vst3.types.ParamID,\n            plain_value: vst3.types.ParamValue,\n        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        fn getParamValueByString(",
            "lineNumber": 228
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 229
          },
          {
            "text": "            _: vst3.types.ParamID,",
            "lineNumber": 230
          },
          {
            "text": "            _: *vst3.types.char16,",
            "lineNumber": 231
          },
          {
            "text": "            _: *vst3.types.ParamValue,",
            "lineNumber": 232
          },
          {
            "text": "        ) callconv(.c) vst3.tresult {",
            "lineNumber": 233
          },
          {
            "text": "            // TODO: Implement string-to-value parsing",
            "lineNumber": 234
          },
          {
            "text": "            return vst3.types.kNotImplemented;",
            "lineNumber": 235
          },
          {
            "text": "        }",
            "lineNumber": 236
          },
          {
            "lineNumber": 237
          },
          {
            "text": "        fn normalizedParamToPlain(",
            "lineNumber": 238
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 239
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 240
          },
          {
            "text": "            value_normalized: vst3.types.ParamValue,",
            "lineNumber": 241
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 242
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 243
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 244
          },
          {
            "text": "                const param_id = P.param_ids[i];",
            "lineNumber": 245
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 246
          },
          {
            "text": "                    return switch (param) {",
            "lineNumber": 247
          },
          {
            "text": "                        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 248
          },
          {
            "text": "                            .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 249
          },
          {
            "text": "                            .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 250
          },
          {
            "text": "                        },",
            "lineNumber": 251
          },
          {
            "text": "                        .int =&gt; |p| @floatFromInt(p.range.unnormalize(@floatCast(value_normalized))),",
            "lineNumber": 252
          },
          {
            "text": "                        .boolean =&gt; value_normalized,",
            "lineNumber": 253
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 254
          },
          {
            "text": "                            const idx = @as(u32, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 255
          },
          {
            "text": "                            break :blk @floatFromInt(idx);",
            "lineNumber": 256
          },
          {
            "text": "                        },",
            "lineNumber": 257
          },
          {
            "text": "                    };",
            "lineNumber": 258
          },
          {
            "text": "                }",
            "lineNumber": 259
          },
          {
            "text": "            }",
            "lineNumber": 260
          },
          {
            "lineNumber": 261
          },
          {
            "text": "            return value_normalized;",
            "lineNumber": 262
          },
          {
            "text": "        }",
            "lineNumber": 263
          },
          {
            "lineNumber": 264
          },
          {
            "text": "        fn plainParamToNormalized(",
            "lineNumber": 265
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 266
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 267
          },
          {
            "text": "            plain_value: vst3.types.ParamValue,",
            "lineNumber": 268
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 269
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 270
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 271
          },
          {
            "text": "                ",
            "lineNumber": 272
          }
        ]
      },
      "score": 0.1780090034008026
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 186,
            "column": 16
          },
          "endPosition": {
            "line": 229
          }
        },
        "contents": "const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    // Format the value\n                    const text = switch (param) {\n                        .float =&gt; |p| blk: {\n                            const plain = switch (p.range) {\n                                .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                                .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                            };\n                            var buf: [64]u8 = undefined;\n                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}\", .{plain}) catch break :blk \"?\";\n                            break :blk formatted;\n                        },\n                        .int =&gt; |p| blk: {\n                            const plain = p.range.unnormalize(@floatCast(value_normalized));\n                            var buf: [64]u8 = undefined;\n                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{plain}) catch break :blk \"?\";\n                            break :blk formatted;\n                        },\n                        .boolean =&gt; if (value_normalized &gt; 0.5) \"On\" else \"Off\",\n                        .choice =&gt; |p| blk: {\n                            const idx = @as(usize, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n                            if (idx &lt; p.labels.len) break :blk p.labels[idx];\n                            break :blk \"?\";\n                        },\n                    };\n\n                    // Convert to UTF-16\n                    @memset(string, 0);\n                    var j: usize = 0;\n                    while (j &lt; text.len and j &lt; 128) : (j += 1) {\n                        string[j] = text[j];\n                    }\n\n                    return vst3.types.kResultOk;\n                }\n            }\n\n            return vst3.types.kResultFalse;\n        }\n\n        fn getParamValueByString(\n            _: *anyopaque,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "const param_id = P.param_ids[i];",
            "lineNumber": 187
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 188
          },
          {
            "text": "                    // Format the value",
            "lineNumber": 189
          },
          {
            "text": "                    const text = switch (param) {",
            "lineNumber": 190
          },
          {
            "text": "                        .float =&gt; |p| blk: {",
            "lineNumber": 191
          },
          {
            "text": "                            const plain = switch (p.range) {",
            "lineNumber": 192
          },
          {
            "text": "                                .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 193
          },
          {
            "text": "                                .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 194
          },
          {
            "text": "                            };",
            "lineNumber": 195
          },
          {
            "text": "                            var buf: [64]u8 = undefined;",
            "lineNumber": 196
          },
          {
            "text": "                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}\", .{plain}) catch break :blk \"?\";",
            "lineNumber": 197
          },
          {
            "text": "                            break :blk formatted;",
            "lineNumber": 198
          },
          {
            "text": "                        },",
            "lineNumber": 199
          },
          {
            "text": "                        .int =&gt; |p| blk: {",
            "lineNumber": 200
          },
          {
            "text": "                            const plain = p.range.unnormalize(@floatCast(value_normalized));",
            "lineNumber": 201
          },
          {
            "text": "                            var buf: [64]u8 = undefined;",
            "lineNumber": 202
          },
          {
            "text": "                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{plain}) catch break :blk \"?\";",
            "lineNumber": 203
          },
          {
            "text": "                            break :blk formatted;",
            "lineNumber": 204
          },
          {
            "text": "                        },",
            "lineNumber": 205
          },
          {
            "text": "                        .boolean =&gt; if (value_normalized &gt; 0.5) \"On\" else \"Off\",",
            "lineNumber": 206
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 207
          },
          {
            "text": "                            const idx = @as(usize, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 208
          },
          {
            "text": "                            if (idx &lt; p.labels.len) break :blk p.labels[idx];",
            "lineNumber": 209
          },
          {
            "text": "                            break :blk \"?\";",
            "lineNumber": 210
          },
          {
            "text": "                        },",
            "lineNumber": 211
          },
          {
            "text": "                    };",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "                    // Convert to UTF-16",
            "lineNumber": 214
          },
          {
            "text": "                    @memset(string, 0);",
            "lineNumber": 215
          },
          {
            "text": "                    var j: usize = 0;",
            "lineNumber": 216
          },
          {
            "text": "                    while (j &lt; text.len and j &lt; 128) : (j += 1) {",
            "lineNumber": 217
          },
          {
            "text": "                        string[j] = text[j];",
            "lineNumber": 218
          },
          {
            "text": "                    }",
            "lineNumber": 219
          },
          {
            "lineNumber": 220
          },
          {
            "text": "                    return vst3.types.kResultOk;",
            "lineNumber": 221
          },
          {
            "text": "                }",
            "lineNumber": 222
          },
          {
            "text": "            }",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "            return vst3.types.kResultFalse;",
            "lineNumber": 225
          },
          {
            "text": "        }",
            "lineNumber": 226
          },
          {
            "lineNumber": 227
          },
          {
            "text": "        fn getParamValueByString(",
            "lineNumber": 228
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 229
          }
        ]
      },
      "score": 0.17406679689884186
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 340
          },
          "endPosition": {
            "line": 387
          }
        },
        "contents": "pub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {\n    return struct {\n        const Self = @This();\n\n        values: *ParamValues(N),\n        smoothers: *SmootherBank(N),\n\n        /// Get the current plain value of a float parameter (no smoothing).\n        pub fn getFloat(self: *const Self, comptime index: usize) f32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .float) @compileError(\"Parameter at index is not a float\");\n            }\n\n            const normalized = self.values.get(index);\n            return switch (params_meta[index].float.range) {\n                .linear =&gt; |r| r.unnormalize(normalized),\n                .logarithmic =&gt; |r| r.unnormalize(normalized),\n            };\n        }\n\n        /// Get the current plain value of an int parameter.\n        pub fn getInt(self: *const Self, comptime index: usize) i32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .int) @compileError(\"Parameter at index is not an int\");\n            }\n\n            const normalized = self.values.get(index);\n            return params_meta[index].int.range.unnormalize(normalized);\n        }\n\n        /// Get the current value of a bool parameter.\n        pub fn getBool(self: *const Self, comptime index: usize) bool {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .boolean) @compileError(\"Parameter at index is not a boolean\");\n            }\n\n            const normalized = self.values.get(index);\n            return normalized &gt; 0.5;\n        }\n\n        /// Get the current choice index of a choice parameter.\n        pub fn getChoice(self: *const Self, comptime index: usize) u32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {",
            "lineNumber": 341
          },
          {
            "text": "    return struct {",
            "lineNumber": 342
          },
          {
            "text": "        const Self = @This();",
            "lineNumber": 343
          },
          {
            "lineNumber": 344
          },
          {
            "text": "        values: *ParamValues(N),",
            "lineNumber": 345
          },
          {
            "text": "        smoothers: *SmootherBank(N),",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "        /// Get the current plain value of a float parameter (no smoothing).",
            "lineNumber": 348
          },
          {
            "text": "        pub fn getFloat(self: *const Self, comptime index: usize) f32 {",
            "lineNumber": 349
          },
          {
            "text": "            comptime {",
            "lineNumber": 350
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 351
          },
          {
            "text": "                if (params_meta[index] != .float) @compileError(\"Parameter at index is not a float\");",
            "lineNumber": 352
          },
          {
            "text": "            }",
            "lineNumber": 353
          },
          {
            "lineNumber": 354
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 355
          },
          {
            "text": "            return switch (params_meta[index].float.range) {",
            "lineNumber": 356
          },
          {
            "text": "                .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 357
          },
          {
            "text": "                .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 358
          },
          {
            "text": "            };",
            "lineNumber": 359
          },
          {
            "text": "        }",
            "lineNumber": 360
          },
          {
            "lineNumber": 361
          },
          {
            "text": "        /// Get the current plain value of an int parameter.",
            "lineNumber": 362
          },
          {
            "text": "        pub fn getInt(self: *const Self, comptime index: usize) i32 {",
            "lineNumber": 363
          },
          {
            "text": "            comptime {",
            "lineNumber": 364
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 365
          },
          {
            "text": "                if (params_meta[index] != .int) @compileError(\"Parameter at index is not an int\");",
            "lineNumber": 366
          },
          {
            "text": "            }",
            "lineNumber": 367
          },
          {
            "lineNumber": 368
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 369
          },
          {
            "text": "            return params_meta[index].int.range.unnormalize(normalized);",
            "lineNumber": 370
          },
          {
            "text": "        }",
            "lineNumber": 371
          },
          {
            "lineNumber": 372
          },
          {
            "text": "        /// Get the current value of a bool parameter.",
            "lineNumber": 373
          },
          {
            "text": "        pub fn getBool(self: *const Self, comptime index: usize) bool {",
            "lineNumber": 374
          },
          {
            "text": "            comptime {",
            "lineNumber": 375
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 376
          },
          {
            "text": "                if (params_meta[index] != .boolean) @compileError(\"Parameter at index is not a boolean\");",
            "lineNumber": 377
          },
          {
            "text": "            }",
            "lineNumber": 378
          },
          {
            "lineNumber": 379
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 380
          },
          {
            "text": "            return normalized &gt; 0.5;",
            "lineNumber": 381
          },
          {
            "text": "        }",
            "lineNumber": 382
          },
          {
            "lineNumber": 383
          },
          {
            "text": "        /// Get the current choice index of a choice parameter.",
            "lineNumber": 384
          },
          {
            "text": "        pub fn getChoice(self: *const Self, comptime index: usize) u32 {",
            "lineNumber": 385
          },
          {
            "text": "            comptime {",
            "lineNumber": 386
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 387
          }
        ]
      },
      "score": 0.1739238053560257
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/clap/extensions.zig",
        "range": {
          "startPosition": {
            "line": 219
          },
          "endPosition": {
            "line": 262
          }
        },
        "contents": "        ) callconv(.c) bool {\n            // Find parameter by ID using binary search\n            if (P.findParamIndex(@intFromEnum(id))) |idx| {\n                const param = P.params[idx];\n                // Format the value\n                const text = switch (param) {\n                    .float =&gt; |p| blk: {\n                        var buf: [64]u8 = undefined;\n                        const unit = if (p.unit.len &gt; 0) p.unit else \"\";\n                        const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}{s}\", .{ value, unit }) catch break :blk \"?\";\n                        break :blk formatted;\n                    },\n                    .int =&gt; blk: {\n                        var buf: [64]u8 = undefined;\n                        const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{@as(i32, @intFromFloat(value))}) catch break :blk \"?\";\n                        break :blk formatted;\n                    },\n                    .boolean =&gt; if (value &gt; 0.5) \"On\" else \"Off\",\n                    .choice =&gt; |p| blk: {\n                        const choice_idx = @as(usize, @intFromFloat(value));\n                        if (choice_idx &lt; p.labels.len) break :blk p.labels[choice_idx];\n                        break :blk \"?\";\n                    },\n                };\n\n                const copy_len = @min(text.len, out_buffer_capacity - 1);\n                @memcpy(out_buffer[0..copy_len], text[0..copy_len]);\n                out_buffer[copy_len] = 0;\n                return true;\n            }\n\n            return false;\n        }\n\n        fn paramsTextToValue(\n            _: *const clap.Plugin,\n            id: clap.Id,\n            value_text: [*:0]const u8,\n            out_value: *f64,\n        ) callconv(.c) bool {\n            const text = std.mem.span(value_text);\n\n            // Find parameter by ID using binary search",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        ) callconv(.c) bool {",
            "lineNumber": 220
          },
          {
            "text": "            // Find parameter by ID using binary search",
            "lineNumber": 221
          },
          {
            "text": "            if (P.findParamIndex(@intFromEnum(id))) |idx| {",
            "lineNumber": 222
          },
          {
            "text": "                const param = P.params[idx];",
            "lineNumber": 223
          },
          {
            "text": "                // Format the value",
            "lineNumber": 224
          },
          {
            "text": "                const text = switch (param) {",
            "lineNumber": 225
          },
          {
            "text": "                    .float =&gt; |p| blk: {",
            "lineNumber": 226
          },
          {
            "text": "                        var buf: [64]u8 = undefined;",
            "lineNumber": 227
          },
          {
            "text": "                        const unit = if (p.unit.len &gt; 0) p.unit else \"\";",
            "lineNumber": 228
          },
          {
            "text": "                        const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}{s}\", .{ value, unit }) catch break :blk \"?\";",
            "lineNumber": 229
          },
          {
            "text": "                        break :blk formatted;",
            "lineNumber": 230
          },
          {
            "text": "                    },",
            "lineNumber": 231
          },
          {
            "text": "                    .int =&gt; blk: {",
            "lineNumber": 232
          },
          {
            "text": "                        var buf: [64]u8 = undefined;",
            "lineNumber": 233
          },
          {
            "text": "                        const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{@as(i32, @intFromFloat(value))}) catch break :blk \"?\";",
            "lineNumber": 234
          },
          {
            "text": "                        break :blk formatted;",
            "lineNumber": 235
          },
          {
            "text": "                    },",
            "lineNumber": 236
          },
          {
            "text": "                    .boolean =&gt; if (value &gt; 0.5) \"On\" else \"Off\",",
            "lineNumber": 237
          },
          {
            "text": "                    .choice =&gt; |p| blk: {",
            "lineNumber": 238
          },
          {
            "text": "                        const choice_idx = @as(usize, @intFromFloat(value));",
            "lineNumber": 239
          },
          {
            "text": "                        if (choice_idx &lt; p.labels.len) break :blk p.labels[choice_idx];",
            "lineNumber": 240
          },
          {
            "text": "                        break :blk \"?\";",
            "lineNumber": 241
          },
          {
            "text": "                    },",
            "lineNumber": 242
          },
          {
            "text": "                };",
            "lineNumber": 243
          },
          {
            "lineNumber": 244
          },
          {
            "text": "                const copy_len = @min(text.len, out_buffer_capacity - 1);",
            "lineNumber": 245
          },
          {
            "text": "                @memcpy(out_buffer[0..copy_len], text[0..copy_len]);",
            "lineNumber": 246
          },
          {
            "text": "                out_buffer[copy_len] = 0;",
            "lineNumber": 247
          },
          {
            "text": "                return true;",
            "lineNumber": 248
          },
          {
            "text": "            }",
            "lineNumber": 249
          },
          {
            "lineNumber": 250
          },
          {
            "text": "            return false;",
            "lineNumber": 251
          },
          {
            "text": "        }",
            "lineNumber": 252
          },
          {
            "lineNumber": 253
          },
          {
            "text": "        fn paramsTextToValue(",
            "lineNumber": 254
          },
          {
            "text": "            _: *const clap.Plugin,",
            "lineNumber": 255
          },
          {
            "text": "            id: clap.Id,",
            "lineNumber": 256
          },
          {
            "text": "            value_text: [*:0]const u8,",
            "lineNumber": 257
          },
          {
            "text": "            out_value: *f64,",
            "lineNumber": 258
          },
          {
            "text": "        ) callconv(.c) bool {",
            "lineNumber": 259
          },
          {
            "text": "            const text = std.mem.span(value_text);",
            "lineNumber": 260
          },
          {
            "lineNumber": 261
          },
          {
            "text": "            // Find parameter by ID using binary search",
            "lineNumber": 262
          }
        ]
      },
      "score": 0.16957439482212067
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./examples/gain.zig",
        "range": {
          "startPosition": {
            "line": 56
          },
          "endPosition": {
            "line": 85
          }
        },
        "contents": "    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;\n        const num_channels = buffer.channel_data.len;\n        \n        // Process sample-by-sample to advance smoothing correctly\n        var i: usize = 0;\n        while (i &lt; num_samples) : (i += 1) {\n            // Get the next smoothed gain value (advances smoother by 1 sample)\n            const gain = context.nextSmoothed(1, 0);\n            \n            // Apply gain to all channels for this sample\n            for (buffer.channel_data[0..num_channels]) |channel| {\n                channel[i] *= gain;\n            }\n        }\n        \n        return z_plug.ProcessStatus.ok();\n    }\n};\n\n// Export CLAP entry point\ncomptime {\n    _ = z_plug.ClapEntry(GainPlugin);\n}\n\n// Export VST3 factory\ncomptime {\n    _ = z_plug.Vst3Factory(GainPlugin);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 57
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 58
          },
          {
            "text": "        const num_channels = buffer.channel_data.len;",
            "lineNumber": 59
          },
          {
            "text": "        ",
            "lineNumber": 60
          },
          {
            "text": "        // Process sample-by-sample to advance smoothing correctly",
            "lineNumber": 61
          },
          {
            "text": "        var i: usize = 0;",
            "lineNumber": 62
          },
          {
            "text": "        while (i &lt; num_samples) : (i += 1) {",
            "lineNumber": 63
          },
          {
            "text": "            // Get the next smoothed gain value (advances smoother by 1 sample)",
            "lineNumber": 64
          },
          {
            "text": "            const gain = context.nextSmoothed(1, 0);",
            "lineNumber": 65
          },
          {
            "text": "            ",
            "lineNumber": 66
          },
          {
            "text": "            // Apply gain to all channels for this sample",
            "lineNumber": 67
          },
          {
            "text": "            for (buffer.channel_data[0..num_channels]) |channel| {",
            "lineNumber": 68
          },
          {
            "text": "                channel[i] *= gain;",
            "lineNumber": 69
          },
          {
            "text": "            }",
            "lineNumber": 70
          },
          {
            "text": "        }",
            "lineNumber": 71
          },
          {
            "text": "        ",
            "lineNumber": 72
          },
          {
            "text": "        return z_plug.ProcessStatus.ok();",
            "lineNumber": 73
          },
          {
            "text": "    }",
            "lineNumber": 74
          },
          {
            "text": "};",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "// Export CLAP entry point",
            "lineNumber": 77
          },
          {
            "text": "comptime {",
            "lineNumber": 78
          },
          {
            "text": "    _ = z_plug.ClapEntry(GainPlugin);",
            "lineNumber": 79
          },
          {
            "text": "}",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "// Export VST3 factory",
            "lineNumber": 82
          },
          {
            "text": "comptime {",
            "lineNumber": 83
          },
          {
            "text": "    _ = z_plug.Vst3Factory(GainPlugin);",
            "lineNumber": 84
          },
          {
            "text": "}",
            "lineNumber": 85
          }
        ]
      },
      "score": 0.16567620635032654
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 1025
          },
          "endPosition": {
            "line": 1069
          }
        },
        "contents": "test \"LogFloatRange perceptually uniform\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    // At 50% normalized, should be geometric mean\n    const mid = range.unnormalize(0.5);\n    const expected = @sqrt(20.0 * 20000.0); // ~632.5 Hz\n    try std.testing.expectApproxEqAbs(expected, mid, 1.0);\n}\n\ntest \"LogFloatRange boundaries\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    try std.testing.expectApproxEqAbs(@as(f32, 0.0), range.normalize(20.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), range.normalize(20000.0), 1e-6);\n}\n\ntest \"LogFloatRange clamp\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    try std.testing.expectApproxEqAbs(@as(f32, 20.0), range.clamp(10.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 20000.0), range.clamp(30000.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), range.clamp(1000.0), 1e-6);\n}\n\ntest \"Smoother logarithmic reaches target\" {\n    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });\n    const sample_rate = 1000.0;\n\n    smoother.setTarget(sample_rate, 1000.0);\n    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);\n\n    // Should multiply by constant factor each step\n    const v1 = smoother.next();\n    try std.testing.expect(v1 &gt; 100.0 and v1 &lt; 1000.0);\n\n    const v2 = smoother.next();\n    try std.testing.expect(v2 &gt; v1 and v2 &lt; 1000.0);\n\n    // Last step should snap to target\n    smoother.steps_left = 1;\n    smoother.current = 990.0;\n    const v_last = smoother.next();\n    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), v_last, 1e-6);\n}\n\ntest \"Smoother logarithmic geometric progression\" {\n    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
        "signatures": {},
        "detailedLines": [
          {
            "text": "test \"LogFloatRange perceptually uniform\" {",
            "lineNumber": 1026
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1027
          },
          {
            "text": "    // At 50% normalized, should be geometric mean",
            "lineNumber": 1028
          },
          {
            "text": "    const mid = range.unnormalize(0.5);",
            "lineNumber": 1029
          },
          {
            "text": "    const expected = @sqrt(20.0 * 20000.0); // ~632.5 Hz",
            "lineNumber": 1030
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(expected, mid, 1.0);",
            "lineNumber": 1031
          },
          {
            "text": "}",
            "lineNumber": 1032
          },
          {
            "lineNumber": 1033
          },
          {
            "text": "test \"LogFloatRange boundaries\" {",
            "lineNumber": 1034
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1035
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.0), range.normalize(20.0), 1e-6);",
            "lineNumber": 1036
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), range.normalize(20000.0), 1e-6);",
            "lineNumber": 1037
          },
          {
            "text": "}",
            "lineNumber": 1038
          },
          {
            "lineNumber": 1039
          },
          {
            "text": "test \"LogFloatRange clamp\" {",
            "lineNumber": 1040
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1041
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 20.0), range.clamp(10.0), 1e-6);",
            "lineNumber": 1042
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 20000.0), range.clamp(30000.0), 1e-6);",
            "lineNumber": 1043
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), range.clamp(1000.0), 1e-6);",
            "lineNumber": 1044
          },
          {
            "text": "}",
            "lineNumber": 1045
          },
          {
            "lineNumber": 1046
          },
          {
            "text": "test \"Smoother logarithmic reaches target\" {",
            "lineNumber": 1047
          },
          {
            "text": "    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
            "lineNumber": 1048
          },
          {
            "text": "    const sample_rate = 1000.0;",
            "lineNumber": 1049
          },
          {
            "lineNumber": 1050
          },
          {
            "text": "    smoother.setTarget(sample_rate, 1000.0);",
            "lineNumber": 1051
          },
          {
            "text": "    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);",
            "lineNumber": 1052
          },
          {
            "lineNumber": 1053
          },
          {
            "text": "    // Should multiply by constant factor each step",
            "lineNumber": 1054
          },
          {
            "text": "    const v1 = smoother.next();",
            "lineNumber": 1055
          },
          {
            "text": "    try std.testing.expect(v1 &gt; 100.0 and v1 &lt; 1000.0);",
            "lineNumber": 1056
          },
          {
            "lineNumber": 1057
          },
          {
            "text": "    const v2 = smoother.next();",
            "lineNumber": 1058
          },
          {
            "text": "    try std.testing.expect(v2 &gt; v1 and v2 &lt; 1000.0);",
            "lineNumber": 1059
          },
          {
            "lineNumber": 1060
          },
          {
            "text": "    // Last step should snap to target",
            "lineNumber": 1061
          },
          {
            "text": "    smoother.steps_left = 1;",
            "lineNumber": 1062
          },
          {
            "text": "    smoother.current = 990.0;",
            "lineNumber": 1063
          },
          {
            "text": "    const v_last = smoother.next();",
            "lineNumber": 1064
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), v_last, 1e-6);",
            "lineNumber": 1065
          },
          {
            "text": "}",
            "lineNumber": 1066
          },
          {
            "lineNumber": 1067
          },
          {
            "text": "test \"Smoother logarithmic geometric progression\" {",
            "lineNumber": 1068
          },
          {
            "text": "    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
            "lineNumber": 1069
          }
        ]
      },
      "score": 0.16421574354171753
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 464
          },
          "endPosition": {
            "line": 493
          }
        },
        "contents": "    pub fn setTarget(self: *Smoother, sample_rate: f32, new_target: f32) void {\n        self.target = new_target;\n\n        switch (self.style) {\n            .none =&gt; {\n                self.current = new_target;\n                self.steps_left = 0;\n                self.step_size = 0.0;\n            },\n            .linear =&gt; |duration_ms| {\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                self.steps_left = @intFromFloat(@max(1.0, duration_samples));\n                const delta = self.target - self.current;\n                self.step_size = delta / @as(f32, @floatFromInt(self.steps_left));\n            },\n            .exponential =&gt; |duration_ms| {\n                // Single-pole IIR: y[n] = y[n-1] + coeff * (target - y[n-1])\n                // We want to reach ~99.99% in duration_samples\n                // After N steps: remaining = (1 - coeff)^N ≈ 0.0001\n                // coeff = 1 - exp(ln(0.0001) / N)\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                const n = @max(1.0, duration_samples);\n                const ln_remaining = @log(0.0001);\n                self.step_size = 1.0 - @exp(ln_remaining / n);\n                // For exponential, steps_left is just a sentinel until we snap\n                self.steps_left = @intFromFloat(n);\n            },\n            .logarithmic =&gt; |duration_ms| {\n                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub fn setTarget(self: *Smoother, sample_rate: f32, new_target: f32) void {",
            "lineNumber": 465
          },
          {
            "text": "        self.target = new_target;",
            "lineNumber": 466
          },
          {
            "lineNumber": 467
          },
          {
            "text": "        switch (self.style) {",
            "lineNumber": 468
          },
          {
            "text": "            .none =&gt; {",
            "lineNumber": 469
          },
          {
            "text": "                self.current = new_target;",
            "lineNumber": 470
          },
          {
            "text": "                self.steps_left = 0;",
            "lineNumber": 471
          },
          {
            "text": "                self.step_size = 0.0;",
            "lineNumber": 472
          },
          {
            "text": "            },",
            "lineNumber": 473
          },
          {
            "text": "            .linear =&gt; |duration_ms| {",
            "lineNumber": 474
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 475
          },
          {
            "text": "                self.steps_left = @intFromFloat(@max(1.0, duration_samples));",
            "lineNumber": 476
          },
          {
            "text": "                const delta = self.target - self.current;",
            "lineNumber": 477
          },
          {
            "text": "                self.step_size = delta / @as(f32, @floatFromInt(self.steps_left));",
            "lineNumber": 478
          },
          {
            "text": "            },",
            "lineNumber": 479
          },
          {
            "text": "            .exponential =&gt; |duration_ms| {",
            "lineNumber": 480
          },
          {
            "text": "                // Single-pole IIR: y[n] = y[n-1] + coeff * (target - y[n-1])",
            "lineNumber": 481
          },
          {
            "text": "                // We want to reach ~99.99% in duration_samples",
            "lineNumber": 482
          },
          {
            "text": "                // After N steps: remaining = (1 - coeff)^N ≈ 0.0001",
            "lineNumber": 483
          },
          {
            "text": "                // coeff = 1 - exp(ln(0.0001) / N)",
            "lineNumber": 484
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 485
          },
          {
            "text": "                const n = @max(1.0, duration_samples);",
            "lineNumber": 486
          },
          {
            "text": "                const ln_remaining = @log(0.0001);",
            "lineNumber": 487
          },
          {
            "text": "                self.step_size = 1.0 - @exp(ln_remaining / n);",
            "lineNumber": 488
          },
          {
            "text": "                // For exponential, steps_left is just a sentinel until we snap",
            "lineNumber": 489
          },
          {
            "text": "                self.steps_left = @intFromFloat(n);",
            "lineNumber": 490
          },
          {
            "text": "            },",
            "lineNumber": 491
          },
          {
            "text": "            .logarithmic =&gt; |duration_ms| {",
            "lineNumber": 492
          },
          {
            "text": "                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
            "lineNumber": 493
          }
        ]
      },
      "score": 0.1635318398475647
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 491
          },
          "endPosition": {
            "line": 516
          }
        },
        "contents": "            .logarithmic =&gt; |duration_ms| {\n                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step\n                // Requires both current and target to be positive\n                if (self.current &lt;= 0.0 or new_target &lt;= 0.0) {\n                    // Fallback to linear if either value is non-positive\n                    self.current = new_target;\n                    self.steps_left = 0;\n                    self.step_size = 0.0;\n                    return;\n                }\n\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                self.steps_left = @intFromFloat(@max(1.0, duration_samples));\n                const log_delta = @log(self.target) - @log(self.current);\n                self.step_size = log_delta / @as(f32, @floatFromInt(self.steps_left));\n            },\n        }\n    }\n\n    /// Get the next smoothed sample value and advance the smoother.\n    pub inline fn next(self: *Smoother) f32 {\n        if (self.steps_left == 0) {\n            return self.current;\n        }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "            .logarithmic =&gt; |duration_ms| {",
            "lineNumber": 492
          },
          {
            "text": "                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
            "lineNumber": 493
          },
          {
            "text": "                // Requires both current and target to be positive",
            "lineNumber": 494
          },
          {
            "text": "                if (self.current &lt;= 0.0 or new_target &lt;= 0.0) {",
            "lineNumber": 495
          },
          {
            "text": "                    // Fallback to linear if either value is non-positive",
            "lineNumber": 496
          },
          {
            "text": "                    self.current = new_target;",
            "lineNumber": 497
          },
          {
            "text": "                    self.steps_left = 0;",
            "lineNumber": 498
          },
          {
            "text": "                    self.step_size = 0.0;",
            "lineNumber": 499
          },
          {
            "text": "                    return;",
            "lineNumber": 500
          },
          {
            "text": "                }",
            "lineNumber": 501
          },
          {
            "lineNumber": 502
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 503
          },
          {
            "text": "                self.steps_left = @intFromFloat(@max(1.0, duration_samples));",
            "lineNumber": 504
          },
          {
            "text": "                const log_delta = @log(self.target) - @log(self.current);",
            "lineNumber": 505
          },
          {
            "text": "                self.step_size = log_delta / @as(f32, @floatFromInt(self.steps_left));",
            "lineNumber": 506
          },
          {
            "text": "            },",
            "lineNumber": 507
          },
          {
            "text": "        }",
            "lineNumber": 508
          },
          {
            "text": "    }",
            "lineNumber": 509
          },
          {
            "lineNumber": 510
          },
          {
            "text": "    /// Get the next smoothed sample value and advance the smoother.",
            "lineNumber": 511
          },
          {
            "text": "    pub inline fn next(self: *Smoother) f32 {",
            "lineNumber": 512
          },
          {
            "text": "        if (self.steps_left == 0) {",
            "lineNumber": 513
          },
          {
            "text": "            return self.current;",
            "lineNumber": 514
          },
          {
            "text": "        }",
            "lineNumber": 515
          }
        ]
      },
      "score": 0.15782040357589722
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/clap/plugin.zig",
        "range": {
          "startPosition": {
            "line": 422
          },
          "endPosition": {
            "line": 441
          }
        },
        "contents": "                .param_value =&gt; {\n                    const event: *const clap.events.ParamValue = @ptrCast(@alignCast(header));\n                    // Find parameter index by ID using binary search\n                    if (P.params.len &gt; 0) {\n                        if (P.findParamIndex(@intFromEnum(event.param_id))) |idx| {\n                            const param = P.params[idx];\n                            // Convert plain value to normalized using shared helper\n                            const normalized = common.plainToNormalized(param, event.value);\n                            self.param_values.set(idx, normalized);\n\n                            // Update smoother target with the plain value\n                            const plain_value: f32 = @floatCast(event.value);\n                            self.smoother_bank.setTarget(idx, self.buffer_config.sample_rate, plain_value);\n                        }\n                    }\n                    return false; // Don't add to event list\n                },\n                .note_expression =&gt; {\n                    const event: *const clap.events.NoteExpression = @ptrCast(@alignCast(header));",
        "signatures": {},
        "detailedLines": [
          {
            "text": "                .param_value =&gt; {",
            "lineNumber": 423
          },
          {
            "text": "                    const event: *const clap.events.ParamValue = @ptrCast(@alignCast(header));",
            "lineNumber": 424
          },
          {
            "text": "                    // Find parameter index by ID using binary search",
            "lineNumber": 425
          },
          {
            "text": "                    if (P.params.len &gt; 0) {",
            "lineNumber": 426
          },
          {
            "text": "                        if (P.findParamIndex(@intFromEnum(event.param_id))) |idx| {",
            "lineNumber": 427
          },
          {
            "text": "                            const param = P.params[idx];",
            "lineNumber": 428
          },
          {
            "text": "                            // Convert plain value to normalized using shared helper",
            "lineNumber": 429
          },
          {
            "text": "                            const normalized = common.plainToNormalized(param, event.value);",
            "lineNumber": 430
          },
          {
            "text": "                            self.param_values.set(idx, normalized);",
            "lineNumber": 431
          },
          {
            "lineNumber": 432
          },
          {
            "text": "                            // Update smoother target with the plain value",
            "lineNumber": 433
          },
          {
            "text": "                            const plain_value: f32 = @floatCast(event.value);",
            "lineNumber": 434
          },
          {
            "text": "                            self.smoother_bank.setTarget(idx, self.buffer_config.sample_rate, plain_value);",
            "lineNumber": 435
          },
          {
            "text": "                        }",
            "lineNumber": 436
          },
          {
            "text": "                    }",
            "lineNumber": 437
          },
          {
            "text": "                    return false; // Don't add to event list",
            "lineNumber": 438
          },
          {
            "text": "                },",
            "lineNumber": 439
          },
          {
            "text": "                .note_expression =&gt; {",
            "lineNumber": 440
          },
          {
            "text": "                    const event: *const clap.events.NoteExpression = @ptrCast(@alignCast(header));",
            "lineNumber": 441
          }
        ]
      },
      "score": 0.15099585056304932
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./docs/plugin-authors.md",
        "range": {
          "startPosition": {
            "line": 448
          },
          "endPosition": {
            "line": 498
          }
        },
        "contents": "const GainPlugin = struct {\n    // Required metadata\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n    \n    // Audio configuration: stereo in/out\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n    \n    // Parameters: one gain parameter with linear smoothing\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .min = 0.0, .max = 2.0 },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing\n        } },\n    };\n    \n    // No internal state needed for this simple plugin\n    \n    /// Initialize the plugin with the selected audio layout and buffer config.\n    pub fn init(\n        _: *@This(),\n        _: *const z_plug.AudioIOLayout,\n        _: *const z_plug.BufferConfig,\n    ) bool {\n        return true;\n    }\n    \n    /// Clean up plugin resources.\n    pub fn deinit(_: *@This()) void {\n        // No cleanup needed\n    }\n    \n    /// Process audio.\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 449
          },
          {
            "text": "    // Required metadata",
            "lineNumber": 450
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 451
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 452
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 453
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 454
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 455
          },
          {
            "text": "    ",
            "lineNumber": 456
          },
          {
            "text": "    // Audio configuration: stereo in/out",
            "lineNumber": 457
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 458
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 459
          },
          {
            "text": "    };",
            "lineNumber": 460
          },
          {
            "text": "    ",
            "lineNumber": 461
          },
          {
            "text": "    // Parameters: one gain parameter with linear smoothing",
            "lineNumber": 462
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 463
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 464
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 465
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 466
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 467
          },
          {
            "text": "            .range = .{ .min = 0.0, .max = 2.0 },",
            "lineNumber": 468
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 469
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 470
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing",
            "lineNumber": 471
          },
          {
            "text": "        } },",
            "lineNumber": 472
          },
          {
            "text": "    };",
            "lineNumber": 473
          },
          {
            "text": "    ",
            "lineNumber": 474
          },
          {
            "text": "    // No internal state needed for this simple plugin",
            "lineNumber": 475
          },
          {
            "text": "    ",
            "lineNumber": 476
          },
          {
            "text": "    /// Initialize the plugin with the selected audio layout and buffer config.",
            "lineNumber": 477
          },
          {
            "text": "    pub fn init(",
            "lineNumber": 478
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 479
          },
          {
            "text": "        _: *const z_plug.AudioIOLayout,",
            "lineNumber": 480
          },
          {
            "text": "        _: *const z_plug.BufferConfig,",
            "lineNumber": 481
          },
          {
            "text": "    ) bool {",
            "lineNumber": 482
          },
          {
            "text": "        return true;",
            "lineNumber": 483
          },
          {
            "text": "    }",
            "lineNumber": 484
          },
          {
            "text": "    ",
            "lineNumber": 485
          },
          {
            "text": "    /// Clean up plugin resources.",
            "lineNumber": 486
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {",
            "lineNumber": 487
          },
          {
            "text": "        // No cleanup needed",
            "lineNumber": 488
          },
          {
            "text": "    }",
            "lineNumber": 489
          },
          {
            "text": "    ",
            "lineNumber": 490
          },
          {
            "text": "    /// Process audio.",
            "lineNumber": 491
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 492
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 493
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 494
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 495
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 496
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 497
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 498
          }
        ]
      },
      "score": 0.15084266662597656
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/bindings/vst3/types.zig",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 62
          }
        },
        "contents": "// VST3 C API Bindings - Fundamental Types\n// Based on steinbergmedia/vst3_c_api\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\n\n/// Result type for VST3 functions\npub const tresult = i32;\n\n/// Platform-aware result codes (COM-compatible on Windows, non-COM elsewhere)\npub const kResultOk: tresult = if (builtin.os.tag == .windows) 0x00000000 else 0;\npub const kResultTrue: tresult = kResultOk;\npub const kResultFalse: tresult = if (builtin.os.tag == .windows) 0x00000001 else 1;\npub const kNoInterface: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004002)) else -1;\npub const kInvalidArgument: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80070057)) else 2;\npub const kNotImplemented: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004001)) else 3;\npub const kInternalError: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004005)) else 4;\npub const kNotInitialized: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x8000FFFF)) else 5;\npub const kOutOfMemory: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x8007000E)) else 6;\n\n/// 16-byte unique identifier (GUID/UUID)\npub const TUID = [16]u8;\n\n/// Null-terminated string for interface IDs\npub const FIDString = [*:0]const u8;\n\n/// Boolean type (8-bit)\npub const TBool = u8;\n\n/// Pointer-sized integer\npub const TPtrInt = usize;\n\n/// Size type\npub const TSize = i64;\n\n/// Unicode character (16-bit)\npub const char16 = u16;\n\n/// VST3 string (128 char16 array)\npub const String128 = [128]char16;\n\n/// C-style string\npub const CString = [*:0]const u8;\n\n// Audio and parameter types\npub const ParamID = u32;\npub const ParamValue = f64;\npub const Sample32 = f32;\npub const Sample64 = f64;\npub const SampleRate = f64;\npub const TSamples = i64;\npub const TQuarterNotes = f64;\n\n/// Speaker arrangement bitmask\npub const SpeakerArrangement = u64;\npub const Speaker = u64;\n\n// Bus and I/O types\npub const MediaType = i32;\npub const BusDirection = i32;\npub const BusType = i32;\npub const IoMode = i32;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "// VST3 C API Bindings - Fundamental Types",
            "lineNumber": 1
          },
          {
            "text": "// Based on steinbergmedia/vst3_c_api",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "const std = @import(\"std\");",
            "lineNumber": 4
          },
          {
            "text": "const builtin = @import(\"builtin\");",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/// Result type for VST3 functions",
            "lineNumber": 7
          },
          {
            "text": "pub const tresult = i32;",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "/// Platform-aware result codes (COM-compatible on Windows, non-COM elsewhere)",
            "lineNumber": 10
          },
          {
            "text": "pub const kResultOk: tresult = if (builtin.os.tag == .windows) 0x00000000 else 0;",
            "lineNumber": 11
          },
          {
            "text": "pub const kResultTrue: tresult = kResultOk;",
            "lineNumber": 12
          },
          {
            "text": "pub const kResultFalse: tresult = if (builtin.os.tag == .windows) 0x00000001 else 1;",
            "lineNumber": 13
          },
          {
            "text": "pub const kNoInterface: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004002)) else -1;",
            "lineNumber": 14
          },
          {
            "text": "pub const kInvalidArgument: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80070057)) else 2;",
            "lineNumber": 15
          },
          {
            "text": "pub const kNotImplemented: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004001)) else 3;",
            "lineNumber": 16
          },
          {
            "text": "pub const kInternalError: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x80004005)) else 4;",
            "lineNumber": 17
          },
          {
            "text": "pub const kNotInitialized: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x8000FFFF)) else 5;",
            "lineNumber": 18
          },
          {
            "text": "pub const kOutOfMemory: tresult = if (builtin.os.tag == .windows) @bitCast(@as(u32, 0x8007000E)) else 6;",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "/// 16-byte unique identifier (GUID/UUID)",
            "lineNumber": 21
          },
          {
            "text": "pub const TUID = [16]u8;",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "/// Null-terminated string for interface IDs",
            "lineNumber": 24
          },
          {
            "text": "pub const FIDString = [*:0]const u8;",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "/// Boolean type (8-bit)",
            "lineNumber": 27
          },
          {
            "text": "pub const TBool = u8;",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "/// Pointer-sized integer",
            "lineNumber": 30
          },
          {
            "text": "pub const TPtrInt = usize;",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "/// Size type",
            "lineNumber": 33
          },
          {
            "text": "pub const TSize = i64;",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/// Unicode character (16-bit)",
            "lineNumber": 36
          },
          {
            "text": "pub const char16 = u16;",
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "/// VST3 string (128 char16 array)",
            "lineNumber": 39
          },
          {
            "text": "pub const String128 = [128]char16;",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "/// C-style string",
            "lineNumber": 42
          },
          {
            "text": "pub const CString = [*:0]const u8;",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "// Audio and parameter types",
            "lineNumber": 45
          },
          {
            "text": "pub const ParamID = u32;",
            "lineNumber": 46
          },
          {
            "text": "pub const ParamValue = f64;",
            "lineNumber": 47
          },
          {
            "text": "pub const Sample32 = f32;",
            "lineNumber": 48
          },
          {
            "text": "pub const Sample64 = f64;",
            "lineNumber": 49
          },
          {
            "text": "pub const SampleRate = f64;",
            "lineNumber": 50
          },
          {
            "text": "pub const TSamples = i64;",
            "lineNumber": 51
          },
          {
            "text": "pub const TQuarterNotes = f64;",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "/// Speaker arrangement bitmask",
            "lineNumber": 54
          },
          {
            "text": "pub const SpeakerArrangement = u64;",
            "lineNumber": 55
          },
          {
            "text": "pub const Speaker = u64;",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "// Bus and I/O types",
            "lineNumber": 58
          },
          {
            "text": "pub const MediaType = i32;",
            "lineNumber": 59
          },
          {
            "text": "pub const BusDirection = i32;",
            "lineNumber": 60
          },
          {
            "text": "pub const BusType = i32;",
            "lineNumber": 61
          },
          {
            "text": "pub const IoMode = i32;",
            "lineNumber": 62
          }
        ]
      },
      "score": 0.1503089964389801
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/plugin.zig",
        "range": {
          "startPosition": {
            "line": 60
          },
          "endPosition": {
            "line": 104,
            "column": 8
          }
        },
        "contents": "pub const ProcessContext = struct {\n    /// Current transport state and timeline info.\n    transport: Transport,\n    /// Incoming note/MIDI events for this buffer, pre-sorted by timing.\n    input_events: []const NoteEvent,\n    /// Output event list for sending events back to the host.\n    output_events: *EventOutputList,\n    /// The host's current sample rate in Hz.\n    sample_rate: f32,\n\n    // Parameter access (opaque pointers to avoid making ProcessContext generic)\n    param_values_ptr: ?*anyopaque = null,\n    smoothers_ptr: ?*anyopaque = null,\n    params_meta: []const Param = &amp;[_]Param{},\n\n    /// Get the current plain value of a float parameter at comptime-known index.\n    /// N is the total number of parameters.\n    pub fn getFloat(self: *const ProcessContext, comptime N: usize, comptime index: usize) f32 {\n        const param = self.params_meta[index];\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return switch (param.float.range) {\n            .linear =&gt; |r| r.unnormalize(normalized),\n            .logarithmic =&gt; |r| r.unnormalize(normalized),\n        };\n    }\n\n    /// Get the current plain value of an int parameter at comptime-known index.\n    pub fn getInt(self: *const ProcessContext, comptime N: usize, comptime index: usize) i32 {\n        const param = self.params_meta[index];\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return param.int.range.unnormalize(normalized);\n    }\n\n    /// Get the current value of a bool parameter at comptime-known index.\n    pub fn getBool(self: *const ProcessContext, comptime N: usize, comptime index: usize) bool {\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return normalized &gt; 0.5;\n    }\n\n    /// Get the current choice index of a choice parameter at comptime-known index.\n    pub fn getChoice(self: *const ProcessContext, comptime N: usize, comptime index: usize) u32 {\n        ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const ProcessContext = struct {",
            "lineNumber": 61
          },
          {
            "text": "    /// Current transport state and timeline info.",
            "lineNumber": 62
          },
          {
            "text": "    transport: Transport,",
            "lineNumber": 63
          },
          {
            "text": "    /// Incoming note/MIDI events for this buffer, pre-sorted by timing.",
            "lineNumber": 64
          },
          {
            "text": "    input_events: []const NoteEvent,",
            "lineNumber": 65
          },
          {
            "text": "    /// Output event list for sending events back to the host.",
            "lineNumber": 66
          },
          {
            "text": "    output_events: *EventOutputList,",
            "lineNumber": 67
          },
          {
            "text": "    /// The host's current sample rate in Hz.",
            "lineNumber": 68
          },
          {
            "text": "    sample_rate: f32,",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "    // Parameter access (opaque pointers to avoid making ProcessContext generic)",
            "lineNumber": 71
          },
          {
            "text": "    param_values_ptr: ?*anyopaque = null,",
            "lineNumber": 72
          },
          {
            "text": "    smoothers_ptr: ?*anyopaque = null,",
            "lineNumber": 73
          },
          {
            "text": "    params_meta: []const Param = &amp;[_]Param{},",
            "lineNumber": 74
          },
          {
            "lineNumber": 75
          },
          {
            "text": "    /// Get the current plain value of a float parameter at comptime-known index.",
            "lineNumber": 76
          },
          {
            "text": "    /// N is the total number of parameters.",
            "lineNumber": 77
          },
          {
            "text": "    pub fn getFloat(self: *const ProcessContext, comptime N: usize, comptime index: usize) f32 {",
            "lineNumber": 78
          },
          {
            "text": "        const param = self.params_meta[index];",
            "lineNumber": 79
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 80
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 81
          },
          {
            "text": "        return switch (param.float.range) {",
            "lineNumber": 82
          },
          {
            "text": "            .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 83
          },
          {
            "text": "            .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 84
          },
          {
            "text": "        };",
            "lineNumber": 85
          },
          {
            "text": "    }",
            "lineNumber": 86
          },
          {
            "lineNumber": 87
          },
          {
            "text": "    /// Get the current plain value of an int parameter at comptime-known index.",
            "lineNumber": 88
          },
          {
            "text": "    pub fn getInt(self: *const ProcessContext, comptime N: usize, comptime index: usize) i32 {",
            "lineNumber": 89
          },
          {
            "text": "        const param = self.params_meta[index];",
            "lineNumber": 90
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 91
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 92
          },
          {
            "text": "        return param.int.range.unnormalize(normalized);",
            "lineNumber": 93
          },
          {
            "text": "    }",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "    /// Get the current value of a bool parameter at comptime-known index.",
            "lineNumber": 96
          },
          {
            "text": "    pub fn getBool(self: *const ProcessContext, comptime N: usize, comptime index: usize) bool {",
            "lineNumber": 97
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 98
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 99
          },
          {
            "text": "        return normalized &gt; 0.5;",
            "lineNumber": 100
          },
          {
            "text": "    }",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "    /// Get the current choice index of a choice parameter at comptime-known index.",
            "lineNumber": 103
          },
          {
            "text": "    pub fn getChoice(self: *const ProcessContext, comptime N: usize, comptime index: usize) u32 {",
            "lineNumber": 104
          },
          {
            "text": "        ",
            "lineNumber": 105
          }
        ]
      },
      "score": 0.15013539791107178
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/clap/extensions.zig",
        "range": {
          "startPosition": {
            "line": 184
          },
          "endPosition": {
            "line": 221
          }
        },
        "contents": "            @memcpy(info.name[0..@min(name.len, clap.name_capacity)], name[0..@min(name.len, clap.name_capacity)]);\n\n            // Empty module path for now\n            @memset(&amp;info.module, 0);\n\n            return true;\n        }\n\n        fn paramsGetValue(\n            plugin: *const clap.Plugin,\n            id: clap.Id,\n            out_value: *f64,\n        ) callconv(.c) bool {\n            const wrapper = @as(*anyopaque, @ptrFromInt(@intFromPtr(plugin) - @offsetOf(@import(\"plugin.zig\").PluginWrapper(T), \"clap_plugin\")));\n            const self: *@import(\"plugin.zig\").PluginWrapper(T) = @ptrCast(@alignCast(wrapper));\n\n            // Find parameter by ID using binary search\n            if (P.findParamIndex(@intFromEnum(id))) |idx| {\n                const param = P.params[idx];\n                const normalized = self.param_values.get(idx);\n\n                // Convert normalized to plain value using shared helper\n                out_value.* = common.normalizedToPlain(param, normalized);\n                return true;\n            }\n\n            return false;\n        }\n\n        fn paramsValueToText(\n            _: *const clap.Plugin,\n            id: clap.Id,\n            value: f64,\n            out_buffer: [*]u8,\n            out_buffer_capacity: u32,\n        ) callconv(.c) bool {\n            // Find parameter by ID using binary search",
        "signatures": {},
        "detailedLines": [
          {
            "text": "            @memcpy(info.name[0..@min(name.len, clap.name_capacity)], name[0..@min(name.len, clap.name_capacity)]);",
            "lineNumber": 185
          },
          {
            "lineNumber": 186
          },
          {
            "text": "            // Empty module path for now",
            "lineNumber": 187
          },
          {
            "text": "            @memset(&amp;info.module, 0);",
            "lineNumber": 188
          },
          {
            "lineNumber": 189
          },
          {
            "text": "            return true;",
            "lineNumber": 190
          },
          {
            "text": "        }",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "        fn paramsGetValue(",
            "lineNumber": 193
          },
          {
            "text": "            plugin: *const clap.Plugin,",
            "lineNumber": 194
          },
          {
            "text": "            id: clap.Id,",
            "lineNumber": 195
          },
          {
            "text": "            out_value: *f64,",
            "lineNumber": 196
          },
          {
            "text": "        ) callconv(.c) bool {",
            "lineNumber": 197
          },
          {
            "text": "            const wrapper = @as(*anyopaque, @ptrFromInt(@intFromPtr(plugin) - @offsetOf(@import(\"plugin.zig\").PluginWrapper(T), \"clap_plugin\")));",
            "lineNumber": 198
          },
          {
            "text": "            const self: *@import(\"plugin.zig\").PluginWrapper(T) = @ptrCast(@alignCast(wrapper));",
            "lineNumber": 199
          },
          {
            "lineNumber": 200
          },
          {
            "text": "            // Find parameter by ID using binary search",
            "lineNumber": 201
          },
          {
            "text": "            if (P.findParamIndex(@intFromEnum(id))) |idx| {",
            "lineNumber": 202
          },
          {
            "text": "                const param = P.params[idx];",
            "lineNumber": 203
          },
          {
            "text": "                const normalized = self.param_values.get(idx);",
            "lineNumber": 204
          },
          {
            "lineNumber": 205
          },
          {
            "text": "                // Convert normalized to plain value using shared helper",
            "lineNumber": 206
          },
          {
            "text": "                out_value.* = common.normalizedToPlain(param, normalized);",
            "lineNumber": 207
          },
          {
            "text": "                return true;",
            "lineNumber": 208
          },
          {
            "text": "            }",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "            return false;",
            "lineNumber": 211
          },
          {
            "text": "        }",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "        fn paramsValueToText(",
            "lineNumber": 214
          },
          {
            "text": "            _: *const clap.Plugin,",
            "lineNumber": 215
          },
          {
            "text": "            id: clap.Id,",
            "lineNumber": 216
          },
          {
            "text": "            value: f64,",
            "lineNumber": 217
          },
          {
            "text": "            out_buffer: [*]u8,",
            "lineNumber": 218
          },
          {
            "text": "            out_buffer_capacity: u32,",
            "lineNumber": 219
          },
          {
            "text": "        ) callconv(.c) bool {",
            "lineNumber": 220
          },
          {
            "text": "            // Find parameter by ID using binary search",
            "lineNumber": 221
          }
        ]
      },
      "score": 0.14772570133209229
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Reading the core files to understand their exports:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/plugin.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/params.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/buffer.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/events.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/state.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/audio_layout.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/src/core/platform.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "\\b(dB|db|gain|frequency|freq|hz|Hz|convert|Convert|util|Util)\\b",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "\\b(dB|db|gain|frequency|freq|hz|Hz|convert|Convert|util|Util)\\b",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "./src/wrappers/vst3/controller.zig",
              "matches": [
                {
                  "lineNumber": 150,
                  "content": "            // Convert title to UTF-16"
                },
                {
                  "lineNumber": 214,
                  "content": "                    // Convert to UTF-16"
                }
              ]
            },
            {
              "file": "./examples/gain.zig",
              "matches": [
                {
                  "lineNumber": 1,
                  "content": "/// Simple gain plugin example for zig-plug."
                },
                {
                  "lineNumber": 4,
                  "content": "/// - One FloatParam for gain control (0.0 to 2.0)"
                },
                {
                  "lineNumber": 11,
                  "content": "    pub const name: [:0]const u8 = \"Zig Gain\";"
                },
                {
                  "lineNumber": 15,
                  "content": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";"
                },
                {
                  "lineNumber": 22,
                  "content": "    // Parameters: one gain parameter"
                },
                {
                  "lineNumber": 25,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 26,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 64,
                  "content": "            // Get the next smoothed gain value (advances smoother by 1 sample)"
                },
                {
                  "lineNumber": 65,
                  "content": "            const gain = context.nextSmoothed(1, 0);"
                },
                {
                  "lineNumber": 67,
                  "content": "            // Apply gain to all channels for this sample"
                },
                {
                  "lineNumber": 69,
                  "content": "                channel[i] *= gain;"
                }
              ]
            },
            {
              "file": "./src/wrappers/clap/extensions.zig",
              "matches": [
                {
                  "lineNumber": 206,
                  "content": "                // Convert normalized to plain value using shared helper"
                },
                {
                  "lineNumber": 320,
                  "content": "                            // Convert plain value to normalized using shared helper"
                }
              ]
            },
            {
              "file": "./src/wrappers/common.zig",
              "matches": [
                {
                  "lineNumber": 88,
                  "content": "/// Convert a plain parameter value to normalized [0, 1] range."
                },
                {
                  "lineNumber": 108,
                  "content": "/// Convert a normalized [0, 1] parameter value to plain value."
                }
              ]
            },
            {
              "file": "./src/core/plugin.zig",
              "matches": [
                {
                  "lineNumber": 68,
                  "content": "    /// The host's current sample rate in Hz."
                },
                {
                  "lineNumber": 484,
                  "content": "    gain: f32 = 1.0,"
                },
                {
                  "lineNumber": 542,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 543,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 578,
                  "content": "    const gain = context.getFloat(3, 0);"
                },
                {
                  "lineNumber": 579,
                  "content": "    try std.testing.expectApproxEqAbs(@as(f32, 12.0), gain, 1e-4);"
                }
              ]
            },
            {
              "file": "./src/core/params.zig",
              "matches": [
                {
                  "lineNumber": 37,
                  "content": "/// Useful for parameters where human perception is logarithmic (frequency, gain)."
                },
                {
                  "lineNumber": 134,
                  "content": "    /// Unit label displayed after the value (e.g. \"dB\", \"Hz\", \"%\")."
                },
                {
                  "lineNumber": 237,
                  "content": "    /// Convert a normalized value to plain (unnormalized) value."
                },
                {
                  "lineNumber": 432,
                  "content": "    /// Useful for frequency sweeps and gain changes."
                },
                {
                  "lineNumber": 746,
                  "content": "    const h1 = comptime idHash(\"gain\");"
                },
                {
                  "lineNumber": 747,
                  "content": "    const h2 = comptime idHash(\"gain\");"
                },
                {
                  "lineNumber": 752,
                  "content": "    const h1 = comptime idHash(\"gain\");"
                },
                {
                  "lineNumber": 759,
                  "content": "        .name = \"Gain\","
                },
                {
                  "lineNumber": 760,
                  "content": "        .id = \"gain\","
                },
                {
                  "lineNumber": 796,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 797,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 894,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 895,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 923,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 924,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 957,
                  "content": "    const gain = access.getFloat(0);"
                },
                {
                  "lineNumber": 958,
                  "content": "    try std.testing.expectApproxEqAbs(@as(f32, 12.0), gain, 1e-4);"
                },
                {
                  "lineNumber": 980,
                  "content": "        .name = \"Gain\","
                },
                {
                  "lineNumber": 981,
                  "content": "        .id = \"gain\","
                },
                {
                  "lineNumber": 1030,
                  "content": "    const expected = @sqrt(20.0 * 20000.0); // ~632.5 Hz"
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-17_01-56Z-library-inefficiencies-in-real-time-audio.md",
              "matches": [
                {
                  "lineNumber": 47,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_016HB3YEzyUe2iF12xjZASZc\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"dd775518-d6cb-4414-b9ec-058ceb260c20\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a1f9bdde-bb54-466e-9bc1-d95d0d418db5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"928765cf-3a0e-4d86-ba40-3391d7c183df\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"95dda49a-7043-4954-becb-649d3567ff6b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a6739330-1419-4564-9716-40490f3947d2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"26dad986-2b79-420a-85fe-dd756666a35b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7f1bca48-a8e9-4def-979a-558453067349\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"497615b3-cf8f-4ba9-8f10-1b1189725ddd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"58c80acf-b879-4fa3-ab45-f55195ff0180\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"25a047cb-740b-4d43-a965-8bf8885261d1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6b934efc-fe77-46f6-b319-4f8869e6844a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b8e17377-6082-4a17-82d2-5fc7d5a6cd12\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d776ab [... omitted end of long line]"
                },
                {
                  "lineNumber": 86,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01R4Fbshc2vFWA9qm4iMuzXA\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"5539947f-af3a-47ae-9ac6-d1c9f4e1e542\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e53f2510-85ef-4e83-8f13-31af266e28d7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"0447d9ed-a28b-4e6f-8109-ef3209fa46d1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7f268afd-3310-4629-a8ef-1d88f8e01996\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"8c9b5ebb-29df-4fb6-a55a-b171371aa8c7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7b192220-c142-4787-9797-2663eb965cbe\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4390e0c7-0406-4086-807a-68b169655203\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f1aba6e8-2160-4bc6-b084-e10e6eeae6cd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"617850b2-5f61-477a-89f4-221b64771e97\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d5433d19-1eb3-40da-8e01-cef964a60fa0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e5570b90-716f-4581-9a2d-8e57c08974a7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bc1ac664-b7a9-430e-90a3-a163933bf89d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f25ed5 [... omitted end of long line]"
                },
                {
                  "lineNumber": 2856,
                  "content": "src/wrappers/vst3/component.zig:151:20: note: '*align(8) wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '8'"
                },
                {
                  "lineNumber": 2857,
                  "content": "src/wrappers/vst3/component.zig:151:20: note: '*wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '128'"
                },
                {
                  "lineNumber": 2862,
                  "content": "src/wrappers/vst3/component.zig:156:20: note: '*align(8) wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '8'"
                },
                {
                  "lineNumber": 2863,
                  "content": "src/wrappers/vst3/component.zig:156:20: note: '*wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '128'"
                },
                {
                  "lineNumber": 2872,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 2896,
                  "content": "src/wrappers/vst3/component.zig:151:20: note: '*align(8) wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '8'"
                },
                {
                  "lineNumber": 2897,
                  "content": "src/wrappers/vst3/component.zig:151:20: note: '*wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '128'"
                },
                {
                  "lineNumber": 2902,
                  "content": "src/wrappers/vst3/component.zig:156:20: note: '*align(8) wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '8'"
                },
                {
                  "lineNumber": 2903,
                  "content": "src/wrappers/vst3/component.zig:156:20: note: '*wrappers.vst3.component.Vst3Component(gain.GainPlugin)' has alignment '128'"
                },
                {
                  "lineNumber": 2912,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 3049,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 3064,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 3190,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 3198,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 3606,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01LwFqNEk4FDaSRKRLTttLZR\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"16324590-0a10-4e5e-8d7b-5ea9458464dd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a7e4a610-330a-42ff-aa95-5107b30d235d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"05e27a4f-1331-40e8-b170-dd736e639246\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"16324590-0a10-4e5e-8d7b-5ea9458464dd\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"26af9354-f42a-42f2-ab8e-35a19fbbb356\\\\\\\",\\\\\\\"userResponsesToSuggestedCodeBlocks\\\\\\\":[],\\\\\\\"suggestedCodeBlocks\\\\\\\":[],\\\\\\\"diffsForCompressingFiles\\\\\\\":[],\\\\\\\"relevantFiles\\\\\\\":[],\\\\\\\"toolResults [... omitted end of long line]"
                },
                {
                  "lineNumber": 3645,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_018rKq8SA5MkkgCBRKGZsAzs\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"fdad9454-9814-45a1-8384-4291e5db33a1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a52da911-af10-4f7f-9a7e-9e8b6a721fe3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c2b8f2c7-808d-4471-b901-ad2eb9ab8bc9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a820ebb0-af23-4f63-983e-f202da186271\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5dc960c8-e559-4e17-9719-c0785fe1d387\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3b1e05e9-8444-42c6-9224-9ef21e2f1171\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bd3ce88a-93da-4134-9d8a-0d7ccc71889d\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"fdad9454-9814-45a1-8384-4291e5db33a1\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\" [... omitted end of long line]"
                },
                {
                  "lineNumber": 3684,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_0133Ntv7GfkCHq4T9ZECh57b\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"8f429e8f-aca2-4dd3-946e-a229bd20b1e8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6b128d53-410d-4d23-85b5-03741a96090f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dc6c25bc-4969-43db-bd8e-fbe067b94977\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"48d00467-33d3-43af-8036-473a876c4354\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1da2b605-6a83-4f6f-93b2-c2983a689f92\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"8f429e8f-aca2-4dd3-946e-a229bd20b1e8\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"215daf3b-a01d-4265-8804-61a847a2e996\\\\\\\",\\\\\\\"userResponsesTo [... omitted end of long line]"
                },
                {
                  "lineNumber": 3931,
                  "content": "  \"plan\": \"# Wrapper Code Deduplication\\n\\n## Context\\n\\nAfter the optimization pass, the VST3 and CLAP wrappers still share significant duplicated logic:\\n\\n- Identical constants (&amp;#96;max_events&amp;#96;, &amp;#96;max_aux_buses&amp;#96;, &amp;#96;max_channels&amp;#96;, &amp;#96;max_buffer_size&amp;#96;)\\n- Identical in-place buffer copy + zero-fill algorithm\\n- Identical &amp;#96;ProcessContext&amp;#96; construction\\n- Identical parameter plain-to-normalized conversion (duplicated 3 times in CLAP alone)\\n- Identical &amp;#96;NoteEvent&amp;#96; struct construction boilerplate across both event translators\\n\\nThe user chose a **namespace-only approach** for &amp;#96;WrapperState&amp;#96; -- shared constants, types, and helpers are centralized, but struct fields remain directly on each wrapper.\\n\\n---\\n\\n## Task 1: NoteEvent Helper Constructors\\n\\n**File:** [src/core/events.zig](src/core/events.zig)\\n\\nAdd factory functions directly on the &amp;#96;NoteEvent&amp;#96; union. These replace verbose inline struct construction with concise one-liners [... omitted end of long line]"
                },
                {
                  "lineNumber": 5141,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 5163,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 5353,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 5457,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 5652,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 5660,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 5790,
                  "content": "  \"prompt\": \"Explore the z-plug project at /Users/b/code/z-plug to find all files relevant to licensing. Specifically:\\n\\n1. Find any existing LICENSE files anywhere in the project\\n2. Check the README.md for any license references\\n3. Check build.zig.zon for any license field\\n4. Check if there are any license headers in source files (check a few representative files like src/root.zig, src/core/plugin.zig, src/core/params.zig, src/wrappers/common.zig, examples/gain.zig)\\n5. Check src/bindings/clap/LICENSE and src/bindings/clap/NOTICE if they exist\\n6. Check src/bindings/vst3/ for any license files\\n7. Check AGENTS.md for any license-related rules or mentions\\n\\nReturn the full contents of any LICENSE files found, the license sections of README.md, any license headers in source files, and the license field in build.zig.zon if present.\","
                },
                {
                  "lineNumber": 5801,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01RUhXfM3ts4nAKLQQERQ9wC\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"944a110d-6293-4cd2-b17b-ff9f03286d00\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"27a30228-1c2b-4b82-af4d-969ae6f1d028\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d02d77d3-0cb3-40c7-8b1b-a1e0bb2da263\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e9faae7-8fb2-4eef-8b6b-d197dcc7ced3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9eb4011d-3c81-4635-b6a8-ebdd6c45fd99\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1227c6ac-0907-4f49-8be0-1a3df2de20a7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d2dff2a7-2a47-426f-9f34-7109c8fd147c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a9295392-5e72-43f1-9191-8b8bcca2d506\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"25892b5e-f2ab-4862-98e8-2744fa39c8c4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bbbf08b7-b6c5-47a6-b346-2d063f30c1ad\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e39ab8da-0307-4b89-896f-33377e00fe55\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a79463de-d667-4fdb-a238-a7781504714a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b0eadd [... omitted end of long line]"
                },
                {
                  "lineNumber": 5828,
                  "content": "  \"plan\": \"# Add MPL 2.0 License to z-plug\\n\\n## Changes\\n\\n### 1. Add root LICENSE file\\n\\nCreate [LICENSE](LICENSE) with the full [MPL 2.0 text](https://www.mozilla.org/en-US/MPL/2.0/). This is the canonical license for the framework code.\\n\\n### 2. Add MPL 2.0 header to framework source files\\n\\nThe MPL 2.0 recommends (but does not require) a short header at the top of each source file. Add this to all framework-owned &amp;#96;.zig&amp;#96; files outside of &amp;#96;src/bindings/&amp;#96;:\\n\\n&amp;#96;&amp;#96;&amp;#96;\\n// This Source Code Form is subject to the terms of the Mozilla Public\\n// License, v. 2.0. If a copy of the MPL was not distributed with this\\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\\n&amp;#96;&amp;#96;&amp;#96;\\n\\nFiles to add the header to:\\n- &amp;#96;src/root.zig&amp;#96;\\n- &amp;#96;src/core/*.zig&amp;#96; (plugin.zig, params.zig, buffer.zig, events.zig, state.zig, audio_layout.zig, platform.zig, and any others)\\n- &amp;#96;src/wrappers/common.zig&amp;#96;\\n- &amp;#96;src/wrappers/clap/plugin.zig&amp;#96;, &amp;#9 [... omitted end of long line]"
                },
                {
                  "lineNumber": 6398,
                  "content": "          \"label\": \"Logarithmic range mapping (e.g., for frequency parameters like cutoff, where perception is logarithmic)\""
                },
                {
                  "lineNumber": 6453,
                  "content": "Perfect! Now I understand. You want both logarithmic range mapping (for parameters like frequency where human perception is logarithmic) and logarithmic interpolation (smoothing that happens in log space). Let me create a comprehensive plan."
                },
                {
                  "lineNumber": 6466,
                  "content": "  \"plan\": \"# Implement Logarithmic Smoothing\\n\\n## Overview\\n\\nAdd two logarithmic features to the parameter system:\\n1. **Logarithmic range mapping** - Map parameter ranges logarithmically (useful for frequency, gain in dB)\\n2. **Logarithmic smoothing style** - Interpolate in log space for smooth exponential transitions\\n\\n## Changes to [src/core/params.zig](src/core/params.zig)\\n\\n### 1. Add LogFloatRange type (lines 14-34, after FloatRange)\\n\\n&amp;#96;&amp;#96;&amp;#96;zig\\n/// A continuous floating-point parameter range with logarithmic mapping.\\n/// Useful for parameters where human perception is logarithmic (frequency, gain).\\npub const LogFloatRange = struct {\\n    min: f32,\\n    max: f32,\\n\\n    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.\\n    pub fn normalize(self: LogFloatRange, plain: f32) f32 {\\n        if (self.max &amp;lt;= self.min or self.min &amp;lt;= 0.0) return 0.0;\\n        const clamped = self.clamp(plain);\\n        const log_min = @log(self.min); [... omitted end of long line]"
                },
                {
                  "lineNumber": 6525,
                  "content": "      \"content\": \"Update examples/gain.zig to use new range syntax\","
                },
                {
                  "lineNumber": 6527,
                  "content": "      \"id\": \"update-gain-example\""
                },
                {
                  "lineNumber": 6550,
                  "content": "  \"overview\": \"Add logarithmic range mapping for float parameters and logarithmic interpolation smoothing style to support parameters with logarithmic perception (like frequency, gain in dB).\""
                },
                {
                  "lineNumber": 6983,
                  "content": "Mark done and continue with updating gain.zig:"
                },
                {
                  "lineNumber": 6997,
                  "content": "Now update examples/gain.zig:"
                },
                {
                  "lineNumber": 7002,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 7011,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **edit_file_v2** • Edit file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 7325,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 7359,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 7796,
                  "content": "1. **Added &#96;LogFloatRange&#96; struct** - Provides logarithmic range mapping with &#96;normalize()&#96;, &#96;unnormalize()&#96;, and &#96;clamp()&#96; methods for parameters like frequency (20Hz-20kHz) and gain (dB)"
                },
                {
                  "lineNumber": 7826,
                  "content": "   - &#96;examples/gain.zig&#96;"
                },
                {
                  "lineNumber": 7847,
                  "content": "nih-plug I believe has utility for converting values between different formats (db, gain, etc). Plan to implement useful utilities such as those"
                }
              ]
            },
            {
              "file": "./AGENTS.md",
              "matches": [
                {
                  "lineNumber": 187,
                  "content": "- **Integration tests**: Build a minimal gain plugin to both formats, verify it loads without crashing."
                }
              ]
            },
            {
              "file": "./README.md",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "A minimal gain plugin (&#96;examples/gain.zig&#96;):"
                },
                {
                  "lineNumber": 15,
                  "content": "    pub const name: [:0]const u8 = \"Zig Gain\";"
                },
                {
                  "lineNumber": 19,
                  "content": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";"
                },
                {
                  "lineNumber": 27,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 28,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 54,
                  "content": "            const gain = context.nextSmoothed(1, 0);"
                },
                {
                  "lineNumber": 56,
                  "content": "                channel[i] *= gain;"
                },
                {
                  "lineNumber": 122,
                  "content": "  gain.zig           # Gain plugin (CLAP + VST3)"
                },
                {
                  "lineNumber": 137,
                  "content": "The core framework, both wrappers, and the build system work. The example gain plugin loads and runs in DAWs. Still to do: "
                }
              ]
            },
            {
              "file": "./src/wrappers/vst3/component.zig",
              "matches": [
                {
                  "lineNumber": 286,
                  "content": "            // Convert UTF-8 to UTF-16 at runtime"
                },
                {
                  "lineNumber": 898,
                  "content": "        /// Convert a plugin ID string to a VST3 TUID."
                }
              ]
            },
            {
              "file": "./src/wrappers/clap/plugin.zig",
              "matches": [
                {
                  "lineNumber": 429,
                  "content": "                            // Convert plain value to normalized using shared helper"
                },
                {
                  "lineNumber": 487,
                  "content": "                            // Convert 0-16383 to -1.0 to +1.0"
                },
                {
                  "lineNumber": 744,
                  "content": "                    // Convert -1.0 to +1.0 back to 0-16383"
                }
              ]
            },
            {
              "file": "./src/core/events.zig",
              "matches": [
                {
                  "lineNumber": 98,
                  "content": "    /// Per-note volume/gain (0.0–1.0, linear)."
                }
              ]
            },
            {
              "file": "./src/core/buffer.zig",
              "matches": [
                {
                  "lineNumber": 87,
                  "content": "    ///     cs.set(0, left * gain);"
                },
                {
                  "lineNumber": 88,
                  "content": "    ///     cs.set(1, right * gain);"
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-17_01-55Z-core-library-inefficiencies-and-audio-optimization.md",
              "matches": [
                {
                  "lineNumber": 47,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_016aXjKPGcwEgcso76tCTbgw\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"ba391bfe-a1cb-46f2-94aa-613056d2c20e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d67ba024-17fa-41d1-81ef-324e252a1855\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"66989a91-91a7-4778-815b-1b3f6f8aa853\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ccc5ed17-b9d5-491d-b674-358fbafce3bb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3d489c9f-bc79-4547-8f44-cfe19c2e5ec8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a8697770-c59e-4beb-97e7-14d8401f1254\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a768e3a2-8aa7-49fb-911f-69afd5447d49\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"57e09148-882a-49a6-a5ec-5336429304fc\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bacfa837-9709-4e49-a056-2e418fdad4ee\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"19ecb6a8-ace5-423f-a86e-8b3af987d9eb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"cabf1a58-7b81-406f-8f2f-0adf009fcdc2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f33e8efb-28e5-463b-ba30-5a40b9738b9d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4f7af9 [... omitted end of long line]"
                },
                {
                  "lineNumber": 86,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01Vi8KxH33or5Ct1XbpB1VMK\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"342b29d7-1662-4853-9ed1-427d1618af61\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ef9ebbac-ba36-4deb-99f6-733251c100f7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"24d15de3-91c7-4fbe-a518-4e3d8eaa67e3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"16ce61a1-e24e-4afc-8b82-72c32a296f38\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"35c9198a-ed11-425a-aeaf-a2fbe013e7da\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"24ec23a2-76f8-4027-a926-50d8c38cb7e5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"74c81e5a-5b51-4621-8523-2bcb1a4db273\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"614d1b45-bb50-494c-a0f6-ce0bd534aec3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a053a073-68e2-45d2-af1f-c8108e0cebb8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d3ac3522-4e98-4896-9a88-16f95423f52a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"edee0edd-12d6-4f02-b996-7516223d70ab\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b382b13d-7185-4567-8a52-f96f331f3b47\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5a7f01 [... omitted end of long line]"
                }
              ]
            },
            {
              "file": "./src/wrappers/vst3/factory.zig",
              "matches": [
                {
                  "lineNumber": 242,
                  "content": "        /// Convert a plugin ID string to a VST3 TUID using a deterministic hash."
                }
              ]
            },
            {
              "file": "./docs/getting-started.md",
              "matches": [
                {
                  "lineNumber": 66,
                  "content": "# The gain plugin produces:"
                },
                {
                  "lineNumber": 143,
                  "content": "│   └── gain.zig                   # Simple gain plugin (CLAP + VST3)"
                }
              ]
            },
            {
              "file": "./docs/plugin-authors.md",
              "matches": [
                {
                  "lineNumber": 29,
                  "content": "    gain: f32,"
                },
                {
                  "lineNumber": 40,
                  "content": "        self.gain = 1.0;"
                },
                {
                  "lineNumber": 58,
                  "content": "        // Process audio: apply gain to all channels"
                },
                {
                  "lineNumber": 64,
                  "content": "                sample.* *= self.gain;"
                },
                {
                  "lineNumber": 136,
                  "content": "        .name = \"Gain\","
                },
                {
                  "lineNumber": 137,
                  "content": "        .id = \"gain\","
                },
                {
                  "lineNumber": 138,
                  "content": "        .default = 0.0,  // dB"
                },
                {
                  "lineNumber": 140,
                  "content": "        .unit = \"dB\","
                },
                {
                  "lineNumber": 160,
                  "content": "- **&#96;FloatParam&#96;** — Continuous floating-point (e.g., gain, frequency, mix)"
                },
                {
                  "lineNumber": 188,
                  "content": "- **&#96;.exponential&#96;** — Exponential ramp over N milliseconds (better for frequency)"
                },
                {
                  "lineNumber": 238,
                  "content": "        sample.* *= self.gain;"
                },
                {
                  "lineNumber": 250,
                  "content": "    cs.samples[0] = left * self.gain;"
                },
                {
                  "lineNumber": 251,
                  "content": "    cs.samples[1] = right * self.gain;"
                },
                {
                  "lineNumber": 288,
                  "content": "const gain = context.getFloat(1, 0);  // N=1 param, index=0"
                },
                {
                  "lineNumber": 351,
                  "content": "    ctx.write(f32, self.gain) catch return false;"
                },
                {
                  "lineNumber": 357,
                  "content": "    self.gain = ctx.read(f32) catch return false;"
                },
                {
                  "lineNumber": 436,
                  "content": "## Complete Example: Gain Plugin"
                },
                {
                  "lineNumber": 438,
                  "content": "This is the complete, working gain plugin from &#96;examples/gain.zig&#96; that loads and runs in DAWs:"
                },
                {
                  "lineNumber": 441,
                  "content": "/// Simple gain plugin example for zig-plug."
                },
                {
                  "lineNumber": 444,
                  "content": "/// - One FloatParam for gain control (0.0 to 2.0)"
                },
                {
                  "lineNumber": 451,
                  "content": "    pub const name: [:0]const u8 = \"Zig Gain\";"
                },
                {
                  "lineNumber": 455,
                  "content": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";"
                },
                {
                  "lineNumber": 462,
                  "content": "    // Parameters: one gain parameter with linear smoothing"
                },
                {
                  "lineNumber": 465,
                  "content": "            .name = \"Gain\","
                },
                {
                  "lineNumber": 466,
                  "content": "            .id = \"gain\","
                },
                {
                  "lineNumber": 504,
                  "content": "            // Get the next smoothed gain value (advances smoother by 1 sample)"
                },
                {
                  "lineNumber": 505,
                  "content": "            const gain = context.nextSmoothed(1, 0);"
                },
                {
                  "lineNumber": 507,
                  "content": "            // Apply gain to all channels for this sample"
                },
                {
                  "lineNumber": 509,
                  "content": "                channel[i] *= gain;"
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-16_20-51Z-format-wrappers-execution-plan.md",
              "matches": [
                {
                  "lineNumber": 53,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01K9TBoc3GWwND7c973n1no5\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"174b6f53-e7bc-4d3d-8fc9-32f9fcc8498a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d85f933a-7215-4eb7-aa27-f7ec63b691e7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"95107c12-7f02-4848-aaf3-db33637a0838\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1c039d6c-b286-40af-b467-b64478a96096\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"57dc49d0-9f4d-4c25-81ad-f62abd80bd04\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"be4e1b12-3314-4477-894a-4fac9b130563\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b715ee57-dbae-42fe-b21f-dc9b22f6d3e4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c17583f1-a8bb-421b-8c6d-ac13991aeb40\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a87b48ee-546b-42a9-86db-7845e9c5f175\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5101dc25-eefd-44c5-9482-12c0850b1fa6\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5ff3d7b7-4574-4521-ba7a-e0382781b571\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"198e956e-9526-4443-b927-2a0cdf9e3702\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c5e2e168-41 [... omitted end of long line]"
                },
                {
                  "lineNumber": 216,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01TKTJV7DQqJ1D2MMUVRfLyn\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"415494ed-2d60-47b3-bc89-694d2e7d8fcd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"35a8adf1-8839-4fcd-b9ff-12077275e0d8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c8ef227c-2776-485b-a93e-77743f5bd401\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6ada09c0-c34c-496a-855e-c737adf2fc60\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c1f4f871-d0b1-4bf1-a169-a3d054d28ee0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a5d9b250-35dc-4493-85d7-f7fb46d12e59\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"82a3755c-907a-4796-bd98-82abe5ebb372\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9bfcd6b9-1ab8-4c85-b13d-e13ac276344e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9ea32ff9-b961-4002-a77c-e12a5935b08c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a42ebac0-34ba-4f92-82e2-9f707dc504b1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bad34363-a97e-4d80-b1ca-898aef3414e0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e0458ec-c0b1-4134-a1f2-7afe35e6603e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"63f32d2c-70 [... omitted end of long line]"
                },
                {
                  "lineNumber": 370,
                  "content": "  \"plan\": \"# Format Wrappers Implementation (Design Section 2.3)\\n\\n## Current State\\n\\nAll prerequisite layers are complete:\\n- **Bindings layer**: CLAP (&amp;#96;src/bindings/clap/&amp;#96;) and VST3 (&amp;#96;src/bindings/vst3/&amp;#96;) are fully implemented\\n- **Core framework**: All 6 modules in &amp;#96;src/core/&amp;#96; are implemented (&amp;#96;plugin.zig&amp;#96;, &amp;#96;buffer.zig&amp;#96;, &amp;#96;params.zig&amp;#96;, &amp;#96;events.zig&amp;#96;, &amp;#96;state.zig&amp;#96;, &amp;#96;audio_layout.zig&amp;#96;)\\n- **Wrappers**: &amp;#96;src/wrappers/&amp;#96; does not exist yet -- this is the work to be done\\n\\n## Architecture\\n\\nEach wrapper must:\\n1. Implement the format's ABI entry points (exported C functions)\\n2. Own format-specific state (COM ref counts for VST3, host callback pointers for CLAP)\\n3. Translate between the format's process call and the framework's &amp;#96;processFn&amp;#96;\\n4. Map format-specific parameter changes to the framework's unified event model\\n\\n&amp;#96;&amp;#96;&amp;#96;mermaid\\nflowchart LR\\n    subgraph core [Framework Core]\\n      [... omitted end of long line]"
                },
                {
                  "lineNumber": 2782,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01TkaMtbaPtKL9unf788bBwB\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"aaec15f2-b532-4aab-8a1e-ffc940d911c8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"38a31a83-7fd8-4191-8331-bb5da2915e6a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"20815e33-3117-4583-97f1-0fbb5c29708c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fc424f4b-15c7-4dda-a631-128da809078a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"611125af-68b6-44ef-b0f5-668ee302a341\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e23a7df-b0c5-453e-84dd-915db340e279\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"33c77d7d-9817-497a-81c7-e30b54a933eb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fce36f4c-ee21-40f9-8676-06657c23b356\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"546c6b8e-058e-4e67-869b-3aca94ba0168\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a5fde776-70a2-44d3-b4bb-67a5b96150c9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"2f756eea-6c88-49b2-8362-c581b3f16f23\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3b862d37-948d-47b3-8137-8df3e90bbdd0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"441963c1-2d [... omitted end of long line]"
                },
                {
                  "lineNumber": 2821,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01HRvJKYo2MPc3yijoc9NGc3\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"ac62c0f5-5a91-4d11-bd3d-933cdf3f22da\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e21ee3c-20fe-47ab-8c89-3bfc1c399cab\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a45d3704-6a86-45aa-9306-82d03e827388\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dd83c3ec-8fbe-4b6f-93f1-df34aebc52a2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5d6b778a-db91-4a9b-916d-12ebb2dd832a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"30d1f112-cba4-4544-9a96-8f74c979246b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e13efb5-33a2-4aed-98be-36b1e34d40ec\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"95a0b50c-804a-4892-b838-0c9b71872e7c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f9246f0e-99ad-4aca-a3dd-7d2d4c68f39f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"59263deb-c10a-478d-8228-a9513ad66a0b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"32def252-f47e-4a77-8b2f-50105485dbea\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7b3b38b7-5f5e-416a-bc48-823fc0104e9c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"df9d014c-d7 [... omitted end of long line]"
                },
                {
                  "lineNumber": 4980,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01DSHNGzHLnD9vsCeiMLSQPw\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"0316b135-07c1-45cc-b19b-43291debf46a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"69ecc122-b89b-433a-8e02-17f98910088f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a6eba99a-46cd-48a0-a7a7-84a80c2604d7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e794b547-b3f0-4bb1-8684-67b9b2b9e024\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"0316b135-07c1-45cc-b19b-43291debf46a\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"00220655-b7d8-434f-acea-cac844bb4d18\\\\\\\",\\\\\\\"userResponsesToSuggestedCodeBlocks\\\\\\\":[],\\\\\\\"suggestedCodeBlocks\\\\\\\":[],\\\\\\\"diffsForCo [... omitted end of long line]"
                },
                {
                  "lineNumber": 5019,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01Bdq5UN8qLs3tkqMaa4AiyH\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"f57ae696-23a4-48af-ae42-d6426d89d014\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dbf51671-ded3-454f-9068-7774c7cf0794\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e625a78a-c81d-4618-9eb5-2c8c1a9535e4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c71306cb-9d27-4744-ac49-bc534fa373c5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3548f8df-e03a-420b-8794-65f49534ef53\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f104e9d7-07cf-4488-8c00-d5766519561e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"176070d5-007e-43a4-9ae9-3284c4b51542\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6070a98a-fe06-4a98-940e-6332ac3c2271\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1912b8fd-b1b1-46b4-8425-25ca9c8f7cc6\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a8f0e118-bd79-4def-a891-19fbbd2f36de\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"f57ae696-23a4-48af-ae42-d6426d89d014\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseConte [... omitted end of long line]"
                },
                {
                  "lineNumber": 5058,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01TuQFJkNCE1gvGm43SqHtrs\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"401acada-48c7-4ad6-9637-c8c1930d134d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f9f1e1a3-0876-43d0-bdd5-b4f91df5f6f7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3a3eec60-decf-4dec-9ac6-8a7cf4d02331\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e6da4035-c090-42ea-87eb-f5504651df9f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"77473778-6bf8-486f-9134-078db938ad75\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"af860dd7-461e-44a5-b92f-1b0afa907713\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"07e67c56-acfd-438a-9c87-9fb90e93521a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"005a0ccd-dabb-4a91-a6bd-1d370bac6350\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3ef8c62e-1a4b-40b5-aebd-7d4d155ba0b7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1ed2ce6e-dd31-4033-b8dd-97cc2333106b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4ebb6a53-df34-4a95-9ef6-b692477d3758\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d15f3b87-65e1-4227-9e6c-a6b139310205\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"18cc3bb6-2c [... omitted end of long line]"
                },
                {
                  "lineNumber": 6349,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_014biAftWtkCLSme3xLgU8tW\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"173fbd29-cce5-484f-a13d-befe3e822999\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"26968e06-902a-49a8-98ef-720075a2e0c0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"631ffd99-3f42-49ea-8b66-b757e5255b5f\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"173fbd29-cce5-484f-a13d-befe3e822999\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"f07db6bc-8293-4f34-a8f9-549f6370d5f1\\\\\\\",\\\\\\\"userResponsesToSuggestedCodeBlocks\\\\\\\":[],\\\\\\\"suggestedCodeBlocks\\\\\\\":[],\\\\\\\"diffsForCompressingFiles\\\\\\\":[],\\\\\\\"relevantFiles\\\\\\\":[],\\\\\\\"toolResults\\\\\\\": [... omitted end of long line]"
                },
                {
                  "lineNumber": 6427,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01CCwvAKvtE5P46FrLsQvvxb\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"32224754-e7e4-4239-bae1-eddf20b9bad4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"302c3b8c-ceba-46fb-a002-17f62cff21f9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a53af0e3-9c1e-4344-8c77-e00205d490f5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f8725c39-916a-4906-a32c-d0ca26c836cc\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"23371fa4-4bff-4cda-a19c-2894e1fb6572\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f98667f3-2493-4028-887b-8fdd59a53b95\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"32224754-e7e4-4239-bae1-eddf20b9bad4\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\ [... omitted end of long line]"
                },
                {
                  "lineNumber": 10186,
                  "content": "| &#96;./nih-plug/plugins/examples/gain/src/lib.rs&#96; |"
                },
                {
                  "lineNumber": 10187,
                  "content": "| &#96;./nih-plug/plugins/examples/gain/Cargo.toml&#96; |"
                },
                {
                  "lineNumber": 10336,
                  "content": "**CLAP is the easier target.** The CLAP ABI is simpler (C structs, function pointers), and CLAP hosts like Bitwig, REAPER, and the CLAP validator (&#96;clap-validator&#96;) are forgiving. If you fix the &#96;clap_entry&#96; export issue and write a simple gain plugin, you could plausibly load it in a CLAP-compatible DAW."
                },
                {
                  "lineNumber": 10338,
                  "content": "**For a minimal gain plugin**, you'd need roughly:"
                },
                {
                  "lineNumber": 10339,
                  "content": "- A Zig source file with the plugin struct (gain parameter, process = multiply samples by gain)"
                },
                {
                  "lineNumber": 10396,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01JZQGYaSSBoSadLSCfWSisU\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"589b4344-6e75-460d-a77c-266603c1a507\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"417004a5-ca4f-4557-8cc2-2341334a3b9b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d6c44bdd-270d-4f5b-b771-6cb7849c7496\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3dc726b1-0960-4a24-aa9f-ac6f59dc34c3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"37c37291-fb9c-4bb5-a904-365c76573817\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b06cb557-b998-4c96-8fa9-ad6db0b31619\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ca72b1ac-51b4-420e-bdf3-c262d4895e29\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"67866269-5d66-4b3f-89a7-9dfd98ad71c9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"76fef41c-1f6f-42bb-ac66-44edb141765e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"add2a544-331c-4f26-8621-d41244d598e2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c1d7a125-9597-4527-8ab7-efd41caca96c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fec9c67d-c9d0-451f-b19a-00a90741b9de\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bc3e7bc0-5a [... omitted end of long line]"
                },
                {
                  "lineNumber": 10435,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01BwphNDEjM3Nb993hdhD7XU\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"2ce7a02e-945c-43df-a796-42ae30515ae2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"efc7c4f0-34cd-4f90-a7ed-8a2b372c7edf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f157c35e-4692-49a2-9e2c-80198d37d495\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b64bf1c3-5e08-46dc-99ce-f7e2949b661e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"0ed06bef-c549-43cf-9dab-1e236856ab08\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e4b243d-7a22-43d8-b51a-f717d841bdfe\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7a16415a-57ab-476c-948e-77ff6f83e6ef\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"556f7858-815e-466a-980f-0a38df3ab49a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f1d7813d-96be-49e8-9e0f-ed7f5f4813c1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"391d1fa5-34a4-4052-98c2-fb3543de9691\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e080f4f1-8be6-4230-8ea7-f18fd833b02c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5b93b7b3-d3dc-4a01-9cfd-6104a413c40e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ffa4ba07-b9 [... omitted end of long line]"
                },
                {
                  "lineNumber": 10463,
                  "content": "  \"prompt\": \"In the project at /Users/b/code/z-plug, I need to understand how an example plugin would be structured and integrated into the build system.\\n\\n1. Read the test plugins defined in:\\n   - src/wrappers/clap/entry.zig (the TestPlugin struct in the test at the bottom)\\n   - src/wrappers/vst3/factory.zig (the TestPlugin struct in the test at the bottom)\\n   \\n2. Read nih-plug's simplest example plugin: ./nih-plug/plugins/examples/gain/src/lib.rs - understand the structure\\n\\n3. Read the build.zig addPlugin function (lines 1-89) to understand how a plugin source file would integrate\\n\\n4. Check if there are any existing example plugin files in the project (glob for examples/, plugins/, or similar directories at the root level)\\n\\n5. Read src/root.zig to see all the public API types available to plugin authors\\n\\nReturn:\\n- The complete list of required declarations for a plugin struct (name, vendor, url, version, plugin_id, audio_io_layouts, params, init, deinit, process)\\n- The [... omitted end of long line]"
                },
                {
                  "lineNumber": 10474,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_013G8TZFoh2XmBY7LtwtPSWM\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"be11034d-1a2a-45d2-a31e-6a609223c964\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e92445fb-c2ee-4752-a2cc-8bb8665f57bd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a258a025-89f8-4dbc-be7e-6dab68da07f0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4db2cc7c-b225-4e87-b13c-0720fa9cddce\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"85b55a80-282c-43eb-9c56-6c053f7278e2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"77812dc9-df5b-4aeb-b6d7-26aaaf1948cf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d2961313-d4cd-44f0-bb5e-d14723a9665a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9fca01a5-7c3e-4eb6-96b4-49425a29c0e7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f10d0777-9e66-493d-9ff7-b95a82bc4bcf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9b6d5f3a-f314-498e-8d7f-49b0f5a5ac01\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f3464cf5-da90-4250-81c8-3d22dd086dcb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7aa59949-0d78-41a1-ba82-b801bc64c0d6\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"536ccb73-4b [... omitted end of long line]"
                },
                {
                  "lineNumber": 11083,
                  "content": "  \"plan\": \"# DAW-Loadable Plugin Fixes\\n\\n## Problem Summary\\n\\nFour issues prevent plugins from loading in real DAWs:\\n\\n1. **CLAP &amp;#96;clap_entry&amp;#96; is not exported** as a C-ABI symbol (hosts use &amp;#96;dlsym&amp;#96; to find it)\\n2. **VST3 macOS bundle is missing &amp;#96;Info.plist&amp;#96; and &amp;#96;PkgInfo&amp;#96;** (macOS won't recognize it as a bundle)\\n3. **VST3 &amp;#96;createInstance&amp;#96; skips CID/IID validation** and is missing module-level exports (&amp;#96;bundleEntry&amp;#96;/&amp;#96;bundleExit&amp;#96;)\\n4. **No example plugin exists** to verify end-to-end loading\\n\\n---\\n\\n## Fix 1: CLAP &amp;#96;clap_entry&amp;#96; Export\\n\\n**Root cause:** &amp;#96;pub const clap_entry = ...&amp;#96; in Zig creates a compile-time constant, not a C-ABI exported symbol. CLAP hosts call &amp;#96;dlsym(lib, \\\"clap_entry\\\")&amp;#96; and find nothing.\\n\\n**The fix:** Use &amp;#96;@export&amp;#96; to create the linker-visible symbol. Provide a helper in the wrapper so plugin authors don't need to know about &amp;#96;@export&amp;#96;.\\n\\nIn [src/wrappers/clap/entr [... omitted end of long line]"
                },
                {
                  "lineNumber": 11107,
                  "content": "      \"content\": \"Create examples/gain.zig with a working stereo gain plugin, wire into build.zig\","
                },
                {
                  "lineNumber": 11109,
                  "content": "      \"id\": \"example-gain\""
                },
                {
                  "lineNumber": 11117,
                  "content": "  \"overview\": \"Fix the CLAP entry export, VST3 bundle/factory issues, add VST3 module exports, and create a working example gain plugin that can load in both CLAP and VST3 hosts.\""
                },
                {
                  "lineNumber": 11169,
                  "content": "- [ ] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 11249,
                  "content": "- [ ] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 11354,
                  "content": "- [ ] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 11474,
                  "content": "- [ ] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 11529,
                  "content": "Excellent! Now let's create the example gain plugin:"
                },
                {
                  "lineNumber": 11540,
                  "content": "- [-] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 11550,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **edit_file_v2** • Edit file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 11746,
                  "content": "examples/gain.zig:31:30: error: no field named 'style' in union 'core.params.SmoothingStyle'"
                },
                {
                  "lineNumber": 11755,
                  "content": "    comptime: examples/gain.zig:79:27"
                },
                {
                  "lineNumber": 11758,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 11762,
                  "content": "examples/gain.zig:31:30: error: no field named 'style' in union 'core.params.SmoothingStyle'"
                },
                {
                  "lineNumber": 11771,
                  "content": "    comptime: examples/gain.zig:79:27"
                },
                {
                  "lineNumber": 11774,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 11796,
                  "content": "Two issues - let me check the SmoothingStyle definition and fix the gain plugin:"
                },
                {
                  "lineNumber": 11878,
                  "content": "I see - it's a tagged union. Let me fix the gain plugin:"
                },
                {
                  "lineNumber": 11884,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **edit_file_v2** • Edit file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 11939,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 11971,
                  "content": "examples/gain.zig:62:29: error: type 'usize' is not indexable and not a range"
                },
                {
                  "lineNumber": 11983,
                  "content": "The first error is in the gain plugin - &#96;buffer.channels()&#96; returns usize, not a slice. Let me check the Buffer API:"
                },
                {
                  "lineNumber": 12034,
                  "content": "I see - &#96;channels()&#96; returns &#96;usize&#96;, not the actual channel data. I need to use &#96;channel_data&#96; directly or iterate a different way. Let me fix the gain plugin:"
                },
                {
                  "lineNumber": 12040,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **edit_file_v2** • Edit file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 12152,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 12249,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 12667,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 12687,
                  "content": "The issue is that &#96;event.param_id&#96; is type &#96;clap.Id&#96; (an enum), not &#96;u32&#96;. I need to convert it:"
                },
                {
                  "lineNumber": 13321,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 13331,
                  "content": "/Users/b/.zvm/0.15.2/zig build-lib -ODebug --dep z_plug -Mroot=/Users/b/code/z-plug/examples/gain.zig --dep clap-bindings --dep vst3-bindings -Mz_plug=/Users/b/code/z-plug/src/root.zig -Mclap-bindings=/Users/b/code/z-plug/src/bindings/clap/main.zig -Mvst3-bindings=/Users/b/code/z-plug/src/bindings/vst3/root.zig --cache-dir .zig-cache --global-cache-dir /Users/b/.cache/zig --name ZigGain -dynamic -install_name @rpath/libZigGain.dylib --zig-lib-dir /Users/b/.zvm/0.15.2/lib/ --listen=-"
                },
                {
                  "lineNumber": 13377,
                  "content": "Excellent! The build succeeded. Now let's verify everything and mark the example-gain todo as complete:"
                },
                {
                  "lineNumber": 13388,
                  "content": "- [x] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 13679,
                  "content": "- [x] Create examples/gain.zig with a working stereo gain plugin, wire into build.zig"
                },
                {
                  "lineNumber": 13718,
                  "content": "### ✅ 5. Example Gain Plugin"
                },
                {
                  "lineNumber": 13719,
                  "content": "- Created &#96;examples/gain.zig&#96; with a minimal stereo gain plugin"
                },
                {
                  "lineNumber": 13720,
                  "content": "- One FloatParam (Gain: 0.0-2.0, default 1.0)"
                },
                {
                  "lineNumber": 13832,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 13839,
                  "content": "The plugin should show up as **\"Zig Gain\"** by vendor **\"zig-plug\"** in Ableton."
                },
                {
                  "lineNumber": 13933,
                  "content": "  - **Plug-ins → VST3 → zig-plug → Zig Gain** (for VST3)"
                },
                {
                  "lineNumber": 13934,
                  "content": "  - **Plug-ins → CLAP → zig-plug → Zig Gain** (for CLAP, if Live 12+)"
                },
                {
                  "lineNumber": 13961,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **run_terminal_command_v2** • Run command: grep -i \"ziggain\\|zig-plug\\|zig gain\" ~/Library/Preferences/Ableton/Live\\ 12.3.5/Log.txt 2&gt;/dev/null | tail -20&lt;/summary&gt;"
                },
                {
                  "lineNumber": 13964,
                  "content": "grep -i \"ziggain\\|zig-plug\\|zig gain\" ~/Library/Preferences/Ableton/Live\\ 12.3.5/Log.txt 2&gt;/dev/null | tail -20"
                },
                {
                  "lineNumber": 14031,
                  "content": "   - Plugin Name: **Zig Gain**"
                },
                {
                  "lineNumber": 14032,
                  "content": "   - Location in browser: **Plug-ins → VST3 → zig-plug → Zig Gain**"
                },
                {
                  "lineNumber": 14042,
                  "content": "For now, try the rescan in Ableton. If it still doesn't show up, let me know and I'll help diagnose further. The plugin name should be **\"Zig Gain\"** from vendor **\"zig-plug\"**."
                },
                {
                  "lineNumber": 14282,
                  "content": "     - **VST3 → zig-plug → Zig Gain**, or"
                },
                {
                  "lineNumber": 14283,
                  "content": "     - **CLAP → zig-plug → Zig Gain**"
                },
                {
                  "lineNumber": 14405,
                  "content": "When loading Zig Gain in ableton, ableton immediately crashes, seemingly due to a segfault:"
                },
                {
                  "lineNumber": 14447,
                  "content": "0   ZigGain                       \t       0x38dcd616c wrappers.vst3.component.Vst3Component(gain.GainPlugin).create + 24"
                },
                {
                  "lineNumber": 14448,
                  "content": "1   ZigGain                       \t       0x38dcd6600 wrappers.vst3.factory.Vst3Factory(gain.GainPlugin).createInstance + 160"
                },
                {
                  "lineNumber": 15464,
                  "content": "  \"threads\" : [{\"threadState\":{\"x\":[{\"value\":6169074256},{\"value\":6169074048},{\"value\":16},{\"value\":6169074064},{\"value\":16},{\"value\":32},{\"value\":110},{\"value\":6169073152},{\"value\":6169074552},{\"value\":6169074056},{\"value\":1813544420},{\"value\":4},{\"value\":13141819184},{\"value\":4445963808},{\"value\":13141803008},{\"value\":0},{\"value\":6690983920,\"symbolLocation\":0,\"symbol\":\"_platform_memset\"},{\"value\":13155477584},{\"value\":0},{\"value\":6169075928},{\"value\":4391474948},{\"value\":6169075872},{\"value\":4410094952},{\"value\":15263950176,\"symbolLocation\":0,\"symbol\":\"wrappers.vst3.factory.Vst3Factory(gain.GainPlugin).createInstance\"},{\"value\":6169074840},{\"value\":1},{\"value\":0},{\"value\":13},{\"value\":5402264792}],\"flavor\":\"ARM_THREAD_STATE64\",\"lr\":{\"value\":15263950336},\"cpsr\":{\"value\":1610616832},\"fp\":{\"value\":6169074096},\"sp\":{\"value\":6160627328},\"esr\":{\"value\":2449473607,\"description\":\"(Data Abort) byte write Translation fault\"},\"pc\":{\"value\":15263949164,\"matchesCrashFrame\":1},\"far\":{\"value\":61606 [... omitted end of long line]"
                },
                {
                  "lineNumber": 15470,
                  "content": "Perfect! The crash report is very clear. The crash is happening in &#96;Vst3Component(gain.GainPlugin).create&#96; at offset +24 bytes, which is a **stack overflow** (trying to write to the stack guard region at &#96;0x000000016f33b6d0&#96;)."
                },
                {
                  "lineNumber": 15484,
                  "content": "0   ZigGain    wrappers.vst3.component.Vst3Component(gain.GainPlugin).create + 24"
                },
                {
                  "lineNumber": 15485,
                  "content": "1   ZigGain    wrappers.vst3.factory.Vst3Factory(gain.GainPlugin).createInstance + 160"
                },
                {
                  "lineNumber": 15653,
                  "content": "**Try loading the plugin in Ableton now.** It should no longer crash! Look for **\"Zig Gain\"** by **\"zig-plug\"** under the Audio Effects section."
                },
                {
                  "lineNumber": 15659,
                  "content": "Ok that worked, but new problem - The parameter smoothing seems to be aggregiously excessive. When moving the gain param I initially thought it wasn't working, but realized after a sec that it was smoothing VERY slowly. Please plan to fix this."
                },
                {
                  "lineNumber": 15683,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 16017,
                  "content": "Now let me check how the gain plugin calls &#96;nextSmoothed&#96; — it's calling it **once per process block**, not once per sample:"
                },
                {
                  "lineNumber": 16351,
                  "content": "Now I see the key issue. Let me look at the gain plugin's &#96;process&#96; function once more:"
                },
                {
                  "lineNumber": 16354,
                  "content": "const gain = context.nextSmoothed(1, 0);  // Called ONCE per block"
                },
                {
                  "lineNumber": 16357,
                  "content": "        sample.* *= gain;"
                },
                {
                  "lineNumber": 16362,
                  "content": "The plugin calls &#96;nextSmoothed&#96; **once per process block** (typically 256-1024 samples), but &#96;next()&#96; only advances the smoother by **one sample**. So if the buffer size is 512, the smoother only advances 1 step per 512 samples instead of 512 steps per 512 samples. A 10ms ramp at 44100 Hz = 441 steps. At one step per 512-sample block, that's 441 × 512 = ~225,792 samples ≈ **5 seconds** instead of 10ms."
                },
                {
                  "lineNumber": 16405,
                  "content": "  \"plan\": \"# Fix Parameter Smoothing\\n\\n## Root Cause\\n\\nThe gain plugin in [examples/gain.zig](examples/gain.zig) calls &amp;#96;context.nextSmoothed(1, 0)&amp;#96; **once per process block** (line 59), then uses that single value for all samples in the block. But &amp;#96;nextSmoothed&amp;#96; only advances the smoother by **one sample step**.\\n\\nAt 44100 Hz with a 512-sample buffer and 10ms smoothing:\\n- Expected: 441 steps total, completes in 10ms\\n- Actual: 1 step per 512-sample block = 441 blocks = ~5 seconds\\n\\n## Fix\\n\\nMove the &amp;#96;nextSmoothed&amp;#96; call **inside the per-sample loop** in [examples/gain.zig](examples/gain.zig):\\n\\n&amp;#96;&amp;#96;&amp;#96;zig\\npub fn process(\\n    _: *@This(),\\n    buffer: *z_plug.Buffer,\\n    _: *z_plug.AuxBuffers,\\n    context: *z_plug.ProcessContext,\\n) z_plug.ProcessStatus {\\n    const num_samples = buffer.num_samples;\\n    const num_channels = buffer.channel_data.len;\\n\\n    var i: usize = 0;\\n    while (i &amp;lt; num_samples) : (i += 1) {\\n        const gain = conte [... omitted end of long line]"
                },
                {
                  "lineNumber": 16409,
                  "content": "      \"content\": \"Fix examples/gain.zig to call nextSmoothed per-sample instead of per-block\","
                },
                {
                  "lineNumber": 16411,
                  "content": "      \"id\": \"fix-gain-process\""
                },
                {
                  "lineNumber": 16414,
                  "content": "  \"overview\": \"The gain plugin calls &amp;#96;nextSmoothed&amp;#96; once per process block but the smoother only advances one sample per call, causing ~500x slower smoothing than configured. Fix the example to call smoothing per-sample, and also fix the underlying API to be less error-prone.\""
                },
                {
                  "lineNumber": 16462,
                  "content": "- [-] Fix examples/gain.zig to call nextSmoothed per-sample instead of per-block"
                },
                {
                  "lineNumber": 16471,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **edit_file_v2** • Edit file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 16540,
                  "content": "- [x] Fix examples/gain.zig to call nextSmoothed per-sample instead of per-block"
                },
                {
                  "lineNumber": 16551,
                  "content": "**Problem**: The gain plugin was calling &#96;context.nextSmoothed(1, 0)&#96; once per audio block and applying the same gain value to all samples. Since &#96;nextSmoothed&#96; only advances the smoother by one sample step, this caused the 10ms smoothing to actually take ~5 seconds (500x slower)."
                },
                {
                  "lineNumber": 16553,
                  "content": "**Solution**: Changed the process loop in [examples/gain.zig](examples/gain.zig) to iterate **sample-by-sample** (outer loop) with **channels-inner**, calling &#96;nextSmoothed&#96; once per sample. This ensures the smoother advances at the correct rate."
                },
                {
                  "lineNumber": 16559,
                  "content": "**Restart Ableton or reload the plugin** to pick up the new version, and the gain parameter should now respond smoothly and quickly as expected!"
                },
                {
                  "lineNumber": 16601,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_012dZyjE93TP53t7KWumvmwj\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"edab848c-ce4a-4a27-93ca-c0f45e3d5fbc\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"2c01b13f-e4cc-486a-957b-ad23e23477a5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1f5220d8-2964-4ad9-952b-2064f5beeeb9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7fc84142-ad63-4b6b-a1e9-979883e2b238\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1c91f8c9-26f7-474b-b550-802329f81121\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"02d95bc8-59ae-4461-88b9-455bd93db6cd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"cd35b5a2-da5d-40ab-b982-49cb69a59511\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d3e1d1c4-1088-4d92-b56c-18b6b8414361\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"29a84c58-c41e-4d09-af8e-904d39949718\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"837f2553-5d3d-4497-8910-e2f3c732ff15\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fff00733-29b8-4034-a20e-8435aa0fb53c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9dbf68b6-a136-4044-b55a-a7eae2f08700\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3c2e1b [... omitted end of long line]"
                },
                {
                  "lineNumber": 16640,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01AXx7WKFAjivTi2ZztMfyt9\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"f03981e0-0f98-4a3b-970a-224d262c2e2d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6bc39412-3d0f-4d55-a978-66e09aebda4f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c481e794-bb57-4803-90fe-6f99c459242b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5691bbd8-ffcd-4a97-80a7-f9681efaee39\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ca3f6308-0873-42bd-9ecd-a53939c2964d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6282001f-c73e-473a-98fc-4a96d4a571c5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"2a5a35c4-d94d-413a-bf1f-ec0e2c0ed889\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d78c4080-ac8c-47ae-80a8-7f599554dc7c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7c663e8b-605b-4d3c-b547-b01d494df27f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7902d7bc-9a00-4950-b4b3-7f3691015879\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"79f854fc-e9c9-444a-b201-cb215d5d18f8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"031ab85b-07e9-479e-ac97-2c9ea49110a8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"342d41 [... omitted end of long line]"
                },
                {
                  "lineNumber": 16723,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: /Users/b/code/z-plug/examples/gain.zig&lt;/summary&gt;"
                },
                {
                  "lineNumber": 16918,
                  "content": "                  \"content\": \"    /// The host's current sample rate in Hz.\","
                },
                {
                  "lineNumber": 17076,
                  "content": "  \"plan\": \"# Update Documentation to Reflect MVP State\\n\\nNow that the framework has reached MVP (both CLAP and VST3 plugins build, load, and run in a DAW), the documentation has several significant gaps and inaccuracies.\\n\\n## Issues Found\\n\\n### 1. [README.md](README.md) -- Major: Project status is stale\\n\\n- Phase 3 (Format Wrappers) is marked \\\"Planned\\\" but is **complete**\\n- Phase 4 (Examples and Polish) is marked \\\"Planned\\\" but the gain example **exists and loads in DAWs**\\n- Building section says &amp;#96;# Future: Build a plugin (not yet implemented)&amp;#96; -- this is now implemented\\n- Project structure shows &amp;#96;wrappers/&amp;#96; as &amp;#96;(planned)&amp;#96; -- it is fully implemented\\n- Missing: &amp;#96;examples/&amp;#96; directory not shown in structure\\n- Missing: helper scripts (&amp;#96;install_plugins.sh&amp;#96;, &amp;#96;sign_plugins.sh&amp;#96;, &amp;#96;uninstall_plugins.sh&amp;#96;) not mentioned\\n\\n**Changes:**\\n- Update Phase 3 to \\\"Complete\\\" with details on what was implemented\\n- Update Phase 4 to \\\"In [... omitted end of long line]"
                },
                {
                  "lineNumber": 17085,
                  "content": "      \"content\": \"Update docs/plugin-authors.md: fix all code examples for Zig 0.15.2, add ClapEntry/Vst3Factory export pattern, document ProcessContext methods and parameter smoothing, replace complete example with actual gain.zig\","
                }
              ]
            },
            {
              "file": "./build.zig",
              "matches": [
                {
                  "lineNumber": 186,
                  "content": "    // Build example gain plugin"
                },
                {
                  "lineNumber": 189,
                  "content": "        .root_source_file = b.path(\"examples/gain.zig\"),"
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-16_20-46Z-format-wrappers-execution-plan.md",
              "matches": [
                {
                  "lineNumber": 73,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_011Wg5bw5Bh9JxYNXAzdS6sS\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"a7b9f6b0-2b19-4535-bac0-adedf3865f59\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"84a2bb42-06de-4478-a993-5d7bf1c6129a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"079c9905-315d-49c5-810f-10da33d56faa\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"0ed51878-0aac-446a-9e8e-7d7a540c93f1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c07451d5-d937-4b5f-b777-40ff10543b06\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"189140ac-3d3a-4da5-a8bc-522575daf34d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"393fa7e7-b85d-4939-8274-b2744fed3a63\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ad34f797-5ea9-41fb-85b2-0bdc3ddc9f47\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"aebcca83-abb2-46da-8917-1b6dfd29dab8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c6d767e2-8261-4df6-9519-0b17305e16fe\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dfe65f8a-9739-4c74-b983-88d2e760a59c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e9f1834b-3b99-4f7f-aa80-d1a18200aec4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f6e5e47c-2c [... omitted end of long line]"
                }
              ]
            },
            {
              "file": "./src/bindings/vst3/README.md",
              "matches": [
                {
                  "lineNumber": 51,
                  "content": "- **&#96;SampleRate&#96;** — &#96;f64&#96; — Sample rate in Hz."
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-16_20-27Z-2-2-framework-core-execution-plan.md",
              "matches": [
                {
                  "lineNumber": 49,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_012uCoexszbg9o9nTsZhGPR3\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"7aa7909a-714f-4770-a4f3-fa4e17b77702\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"10cdc19b-ccc8-4401-a353-268581cd714e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"8a8f544b-5866-4151-ba2c-f3b4cee8e1f3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d5a1e6f5-a773-40b0-afaf-7d96894eb1c7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"62fba475-6ecf-4fdb-ba18-6e47d435807f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ef020aee-5e76-470e-9061-24c902ff9a4d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"07f11c2f-63a1-4ae9-8ea8-848b57d76f2c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d5d696ca-be03-44f7-9ebc-ceb7f473feda\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"aaf489c8-4f4b-4104-a488-3ad4d00165d8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"0b2ced59-b3ce-4484-abe8-4da73bc3e44d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"2da79beb-9f2b-4388-906d-cbb78df4d417\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e1962c04-f834-4e1d-9943-6fcdd7d12d2f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e7f8d894-fb [... omitted end of long line]"
                },
                {
                  "lineNumber": 97,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01YXbG4ZpGjU1jdB9ggYu1p2\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"7f3d3ae8-897a-47ab-bf8b-ccf128eaa926\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"81ac4b50-5a48-4ad1-aaba-d8f97ca14460\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"2ec34e19-4ab2-4908-9924-587ecf313f50\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fb856695-b65d-4808-a72d-9b6de2f877a8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c2b2800c-c6bb-4623-a071-feb0a71d0cf2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f3b7d0e5-a4f6-4cc3-be53-6c9810e52537\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b208a9b2-b2e9-46f1-b974-ad071d36de0f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"21812aac-ae69-4bbc-83dc-6ece849d5070\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b668b41a-5352-450a-915d-3cf4e87fb743\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"8d86d3d6-d969-4bd6-ac4f-a3b01f3a6acd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4e5126e4-aa9a-491c-8839-7d94a65f1bdb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"928f37c7-8ebe-440d-9c4f-118a3f7e8678\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5860ea43-56 [... omitted end of long line]"
                },
                {
                  "lineNumber": 228,
                  "content": "  \"plan\": \"# Framework Core Implementation (Section 2.2)\\n\\n## Context\\n\\nThe bindings layer is complete (&amp;#96;src/bindings/clap/&amp;#96; and &amp;#96;src/bindings/vst3/&amp;#96;). The next step is to build &amp;#96;src/core/&amp;#96; -- the API-agnostic framework layer that plugin authors code against. No format-specific types should leak into this layer.\\n\\nAll code targets **Zig 0.15.2**: use &amp;#96;callconv(.c)&amp;#96;, no &amp;#96;usingnamespace&amp;#96;, new &amp;#96;std.io.Reader&amp;#96;/&amp;#96;std.io.Writer&amp;#96; interfaces.\\n\\n## Files to Create\\n\\nAll new files go under &amp;#96;src/core/&amp;#96;. Each file is one concern, targeting under ~500 lines.\\n\\n---\\n\\n### 1. &amp;#96;src/core/audio_layout.zig&amp;#96; -- Audio I/O and Process Configuration\\n\\nFoundational types used by everything else.\\n\\n- **&amp;#96;AudioIOLayout&amp;#96;** -- declares supported channel configurations (modeled after nih-plug &amp;#96;AudioIOLayout&amp;#96;):\\n  - &amp;#96;main_input_channels: ?u32&amp;#96; -- null means no main input\\n  - &amp;#96;main_output_channels: ?u32&amp;#96;\\n  [... omitted end of long line]"
                },
                {
                  "lineNumber": 574,
                  "content": "- &#96;std.io.AnyReader&#96; and &#96;std.io.AnyWriter&#96; are the type-erased versions, and concrete readers/writers have a &#96;.any()&#96; method to convert to them."
                },
                {
                  "lineNumber": 938,
                  "content": "- **Example plugin** - A simple gain plugin to validate the full stack"
                },
                {
                  "lineNumber": 1017,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_015pQR1xi2oK3a6Q4Y12MJRo\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"2709f35f-5c5b-4588-9931-1c503819eee5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7a9aa100-6ea7-4a0c-821f-8a2708e59f51\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d314ff53-5c81-43aa-843b-f5d0ff783432\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"22c6811a-aaf8-410a-a9b4-4891dd2f6a5a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4f2e398d-023a-4ba8-91a8-e585a6f87607\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"56dad756-001f-40f1-a1ab-070600202dba\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5b8474cd-fae5-4884-a1ca-7161279cdbc7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"56ebca67-c425-4ecf-90d3-3c937d9c9c31\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"8b0d0476-9c40-451f-a993-557b76f553d2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"813076d3-251f-41ca-a88c-fb59f362ef77\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b0cc11fe-eb88-47df-8623-b71e9d37e193\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c7652e04-e1ec-455b-aa53-9fc7998a337a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"736b0766-79 [... omitted end of long line]"
                }
              ]
            },
            {
              "file": "./src/core/audio_layout.zig",
              "matches": [
                {
                  "lineNumber": 68,
                  "content": "    /// The host's current sample rate in Hz."
                }
              ]
            },
            {
              "file": "./src/bindings/clap/plugin.zig",
              "matches": [
                {
                  "lineNumber": 54,
                  "content": "        pub const frequency_shifter = \"frequency-shifter\";"
                }
              ]
            },
            {
              "file": "./src/bindings/clap/ext/timer_support.zig",
              "matches": [
                {
                  "lineNumber": 11,
                  "content": "    /// a certain threshold. 30 hz should be allowed. returns true on success."
                }
              ]
            },
            {
              "file": "./zig-plug-design.md",
              "matches": [
                {
                  "lineNumber": 115,
                  "content": "    arbor.param.Float(\"Gain\", 0.0, 10.0, 0.666, .{ .flags = .{} }),"
                },
                {
                  "lineNumber": 223,
                  "content": "- **Milestone**: A simple gain plugin compiles to both CLAP and VST3, loads in a DAW, and processes audio with a working gain parameter."
                },
                {
                  "lineNumber": 254,
                  "content": "| VST3 C API Generator | https://github.com/steinbergmedia/vst3_c_api_generator | Includes a C gain test plugin[^27] |"
                }
              ]
            }
          ],
          "totalLines": 253,
          "totalMatchedLines": 253
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Searching for utility/conversion functions:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "\\b(dbToGain|gainToDb|freqTo|toFreq|hzTo|toHz|convert|Convert)\\b",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "\\b(dbToGain|gainToDb|freqTo|toFreq|hzTo|toHz|convert|Convert)\\b",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "./.specstory/history/2026-02-17_01-56Z-library-inefficiencies-in-real-time-audio.md",
              "matches": [
                {
                  "lineNumber": 3606,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_01LwFqNEk4FDaSRKRLTttLZR\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"16324590-0a10-4e5e-8d7b-5ea9458464dd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a7e4a610-330a-42ff-aa95-5107b30d235d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"05e27a4f-1331-40e8-b170-dd736e639246\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"16324590-0a10-4e5e-8d7b-5ea9458464dd\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"c97e2ba3-c24b-4cd2-85ea-1c2da7cc03d2\\\\\\\",\\\\\\\"userResponsesToSuggestedCodeBlocks\\\\\\\":[],\\\\\\\"suggestedCodeBlocks\\\\\\\":[],\\\\\\\"diffsForCompressingFiles\\\\\\\":[],\\\\\\\"relevantFiles\\\\\\\":[],\\\\\\\"toolResults [... omitted end of long line]"
                },
                {
                  "lineNumber": 3684,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_bdrk_0133Ntv7GfkCHq4T9ZECh57b\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"8f429e8f-aca2-4dd3-946e-a229bd20b1e8\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"6b128d53-410d-4d23-85b5-03741a96090f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dc6c25bc-4969-43db-bd8e-fbe067b94977\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"48d00467-33d3-43af-8036-473a876c4354\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1da2b605-6a83-4f6f-93b2-c2983a689f92\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"8f429e8f-aca2-4dd3-946e-a229bd20b1e8\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\\\\"e700f8b7-b25c-47b1-98a0-292c746ea790\\\\\\\",\\\\\\\"userResponsesTo [... omitted end of long line]"
                },
                {
                  "lineNumber": 3931,
                  "content": "  \"plan\": \"# Wrapper Code Deduplication\\n\\n## Context\\n\\nAfter the optimization pass, the VST3 and CLAP wrappers still share significant duplicated logic:\\n\\n- Identical constants (&amp;#96;max_events&amp;#96;, &amp;#96;max_aux_buses&amp;#96;, &amp;#96;max_channels&amp;#96;, &amp;#96;max_buffer_size&amp;#96;)\\n- Identical in-place buffer copy + zero-fill algorithm\\n- Identical &amp;#96;ProcessContext&amp;#96; construction\\n- Identical parameter plain-to-normalized conversion (duplicated 3 times in CLAP alone)\\n- Identical &amp;#96;NoteEvent&amp;#96; struct construction boilerplate across both event translators\\n\\nThe user chose a **namespace-only approach** for &amp;#96;WrapperState&amp;#96; -- shared constants, types, and helpers are centralized, but struct fields remain directly on each wrapper.\\n\\n---\\n\\n## Task 1: NoteEvent Helper Constructors\\n\\n**File:** [src/core/events.zig](src/core/events.zig)\\n\\nAdd factory functions directly on the &amp;#96;NoteEvent&amp;#96; union. These replace verbose inline struct construction with concise one-liners [... omitted end of long line]"
                },
                {
                  "lineNumber": 6466,
                  "content": "  \"plan\": \"# Implement Logarithmic Smoothing\\n\\n## Overview\\n\\nAdd two logarithmic features to the parameter system:\\n1. **Logarithmic range mapping** - Map parameter ranges logarithmically (useful for frequency, gain in dB)\\n2. **Logarithmic smoothing style** - Interpolate in log space for smooth exponential transitions\\n\\n## Changes to [src/core/params.zig](src/core/params.zig)\\n\\n### 1. Add LogFloatRange type (lines 14-34, after FloatRange)\\n\\n&amp;#96;&amp;#96;&amp;#96;zig\\n/// A continuous floating-point parameter range with logarithmic mapping.\\n/// Useful for parameters where human perception is logarithmic (frequency, gain).\\npub const LogFloatRange = struct {\\n    min: f32,\\n    max: f32,\\n\\n    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.\\n    pub fn normalize(self: LogFloatRange, plain: f32) f32 {\\n        if (self.max &amp;lt;= self.min or self.min &amp;lt;= 0.0) return 0.0;\\n        const clamped = self.clamp(plain);\\n        const log_min = @log(self.min); [... omitted end of long line]"
                }
              ]
            },
            {
              "file": "./src/wrappers/vst3/controller.zig",
              "matches": [
                {
                  "lineNumber": 150,
                  "content": "            // Convert title to UTF-16"
                },
                {
                  "lineNumber": 214,
                  "content": "                    // Convert to UTF-16"
                }
              ]
            },
            {
              "file": "./src/wrappers/clap/extensions.zig",
              "matches": [
                {
                  "lineNumber": 206,
                  "content": "                // Convert normalized to plain value using shared helper"
                },
                {
                  "lineNumber": 320,
                  "content": "                            // Convert plain value to normalized using shared helper"
                }
              ]
            },
            {
              "file": "./src/wrappers/common.zig",
              "matches": [
                {
                  "lineNumber": 88,
                  "content": "/// Convert a plain parameter value to normalized [0, 1] range."
                },
                {
                  "lineNumber": 108,
                  "content": "/// Convert a normalized [0, 1] parameter value to plain value."
                }
              ]
            },
            {
              "file": "./src/core/params.zig",
              "matches": [
                {
                  "lineNumber": 237,
                  "content": "    /// Convert a normalized value to plain (unnormalized) value."
                }
              ]
            },
            {
              "file": "./src/wrappers/vst3/component.zig",
              "matches": [
                {
                  "lineNumber": 286,
                  "content": "            // Convert UTF-8 to UTF-16 at runtime"
                },
                {
                  "lineNumber": 898,
                  "content": "        /// Convert a plugin ID string to a VST3 TUID."
                }
              ]
            },
            {
              "file": "./src/wrappers/clap/plugin.zig",
              "matches": [
                {
                  "lineNumber": 429,
                  "content": "                            // Convert plain value to normalized using shared helper"
                },
                {
                  "lineNumber": 487,
                  "content": "                            // Convert 0-16383 to -1.0 to +1.0"
                },
                {
                  "lineNumber": 744,
                  "content": "                    // Convert -1.0 to +1.0 back to 0-16383"
                }
              ]
            },
            {
              "file": "./src/wrappers/vst3/factory.zig",
              "matches": [
                {
                  "lineNumber": 242,
                  "content": "        /// Convert a plugin ID string to a VST3 TUID using a deterministic hash."
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-16_20-51Z-format-wrappers-execution-plan.md",
              "matches": [
                {
                  "lineNumber": 2821,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01HRvJKYo2MPc3yijoc9NGc3\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"ac62c0f5-5a91-4d11-bd3d-933cdf3f22da\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e21ee3c-20fe-47ab-8c89-3bfc1c399cab\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a45d3704-6a86-45aa-9306-82d03e827388\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"dd83c3ec-8fbe-4b6f-93f1-df34aebc52a2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5d6b778a-db91-4a9b-916d-12ebb2dd832a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"30d1f112-cba4-4544-9a96-8f74c979246b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e13efb5-33a2-4aed-98be-36b1e34d40ec\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"95a0b50c-804a-4892-b838-0c9b71872e7c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f9246f0e-99ad-4aca-a3dd-7d2d4c68f39f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"59263deb-c10a-478d-8228-a9513ad66a0b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"32def252-f47e-4a77-8b2f-50105485dbea\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7b3b38b7-5f5e-416a-bc48-823fc0104e9c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"df9d014c-d7 [... omitted end of long line]"
                },
                {
                  "lineNumber": 5058,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01TuQFJkNCE1gvGm43SqHtrs\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"401acada-48c7-4ad6-9637-c8c1930d134d\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f9f1e1a3-0876-43d0-bdd5-b4f91df5f6f7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3a3eec60-decf-4dec-9ac6-8a7cf4d02331\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e6da4035-c090-42ea-87eb-f5504651df9f\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"77473778-6bf8-486f-9134-078db938ad75\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"af860dd7-461e-44a5-b92f-1b0afa907713\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"07e67c56-acfd-438a-9c87-9fb90e93521a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"005a0ccd-dabb-4a91-a6bd-1d370bac6350\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3ef8c62e-1a4b-40b5-aebd-7d4d155ba0b7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1ed2ce6e-dd31-4033-b8dd-97cc2333106b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4ebb6a53-df34-4a95-9ef6-b692477d3758\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d15f3b87-65e1-4227-9e6c-a6b139310205\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"18cc3bb6-2c [... omitted end of long line]"
                },
                {
                  "lineNumber": 6427,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01CCwvAKvtE5P46FrLsQvvxb\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"32224754-e7e4-4239-bae1-eddf20b9bad4\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"302c3b8c-ceba-46fb-a002-17f62cff21f9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a53af0e3-9c1e-4344-8c77-e00205d490f5\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f8725c39-916a-4906-a32c-d0ca26c836cc\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"23371fa4-4bff-4cda-a19c-2894e1fb6572\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f98667f3-2493-4028-887b-8fdd59a53b95\\\",\\\"type\\\":2}],\\\"conversationMap\\\":{\\\"32224754-e7e4-4239-bae1-eddf20b9bad4\\\":\\\"{\\\\\\\"_v\\\\\\\":3,\\\\\\\"type\\\\\\\":2,\\\\\\\"approximateLintErrors\\\\\\\":[],\\\\\\\"lints\\\\\\\":[],\\\\\\\"codebaseContextChunks\\\\\\\":[],\\\\\\\"commits\\\\\\\":[],\\\\\\\"pullRequests\\\\\\\":[],\\\\\\\"attachedCodeChunks\\\\\\\":[],\\\\\\\"assistantSuggestedDiffs\\\\\\\":[],\\\\\\\"gitDiffs\\\\\\\":[],\\\\\\\"interpreterResults\\\\\\\":[],\\\\\\\"images\\\\\\\":[],\\\\\\\"attachedFolders\\\\\\\":[],\\\\\\\"attachedFoldersNew\\\\\\\":[],\\\\\\\"bubbleId\\\\\\\":\\\\ [... omitted end of long line]"
                },
                {
                  "lineNumber": 10396,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01JZQGYaSSBoSadLSCfWSisU\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"589b4344-6e75-460d-a77c-266603c1a507\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"417004a5-ca4f-4557-8cc2-2341334a3b9b\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d6c44bdd-270d-4f5b-b771-6cb7849c7496\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"3dc726b1-0960-4a24-aa9f-ac6f59dc34c3\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"37c37291-fb9c-4bb5-a904-365c76573817\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b06cb557-b998-4c96-8fa9-ad6db0b31619\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ca72b1ac-51b4-420e-bdf3-c262d4895e29\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"67866269-5d66-4b3f-89a7-9dfd98ad71c9\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"76fef41c-1f6f-42bb-ac66-44edb141765e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"add2a544-331c-4f26-8621-d41244d598e2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"c1d7a125-9597-4527-8ab7-efd41caca96c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"fec9c67d-c9d0-451f-b19a-00a90741b9de\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"bc3e7bc0-5a [... omitted end of long line]"
                },
                {
                  "lineNumber": 10435,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_01BwphNDEjM3Nb993hdhD7XU\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"2ce7a02e-945c-43df-a796-42ae30515ae2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"efc7c4f0-34cd-4f90-a7ed-8a2b372c7edf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f157c35e-4692-49a2-9e2c-80198d37d495\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"b64bf1c3-5e08-46dc-99ce-f7e2949b661e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"0ed06bef-c549-43cf-9dab-1e236856ab08\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"1e4b243d-7a22-43d8-b51a-f717d841bdfe\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7a16415a-57ab-476c-948e-77ff6f83e6ef\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"556f7858-815e-466a-980f-0a38df3ab49a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f1d7813d-96be-49e8-9e0f-ed7f5f4813c1\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"391d1fa5-34a4-4052-98c2-fb3543de9691\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e080f4f1-8be6-4230-8ea7-f18fd833b02c\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"5b93b7b3-d3dc-4a01-9cfd-6104a413c40e\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"ffa4ba07-b9 [... omitted end of long line]"
                },
                {
                  "lineNumber": 10474,
                  "content": "  \"composerData\": \"{\\\"_v\\\":13,\\\"composerId\\\":\\\"task-toolu_013G8TZFoh2XmBY7LtwtPSWM\\\",\\\"richText\\\":\\\"\\\",\\\"hasLoaded\\\":true,\\\"text\\\":\\\"\\\",\\\"fullConversationHeadersOnly\\\":[{\\\"bubbleId\\\":\\\"be11034d-1a2a-45d2-a31e-6a609223c964\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"e92445fb-c2ee-4752-a2cc-8bb8665f57bd\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"a258a025-89f8-4dbc-be7e-6dab68da07f0\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"4db2cc7c-b225-4e87-b13c-0720fa9cddce\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"85b55a80-282c-43eb-9c56-6c053f7278e2\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"77812dc9-df5b-4aeb-b6d7-26aaaf1948cf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"d2961313-d4cd-44f0-bb5e-d14723a9665a\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9fca01a5-7c3e-4eb6-96b4-49425a29c0e7\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f10d0777-9e66-493d-9ff7-b95a82bc4bcf\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"9b6d5f3a-f314-498e-8d7f-49b0f5a5ac01\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"f3464cf5-da90-4250-81c8-3d22dd086dcb\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"7aa59949-0d78-41a1-ba82-b801bc64c0d6\\\",\\\"type\\\":2},{\\\"bubbleId\\\":\\\"536ccb73-4b [... omitted end of long line]"
                },
                {
                  "lineNumber": 12687,
                  "content": "The issue is that &#96;event.param_id&#96; is type &#96;clap.Id&#96; (an enum), not &#96;u32&#96;. I need to convert it:"
                }
              ]
            },
            {
              "file": "./.specstory/history/2026-02-16_20-27Z-2-2-framework-core-execution-plan.md",
              "matches": [
                {
                  "lineNumber": 574,
                  "content": "- &#96;std.io.AnyReader&#96; and &#96;std.io.AnyWriter&#96; are the type-erased versions, and concrete readers/writers have a &#96;.any()&#96; method to convert to them."
                }
              ]
            }
          ],
          "totalLines": 25,
          "totalMatchedLines": 25
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "functions to convert between decibels and linear gain values",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/common.zig",
        "range": {
          "startPosition": {
            "line": 91
          },
          "endPosition": {
            "line": 138
          }
        },
        "contents": "pub inline fn plainToNormalized(param: core.Param, plain_value: f64) f32 {\n    return switch (param) {\n        .float =&gt; |p| switch (p.range) {\n            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),\n            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),\n        },\n        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),\n        .boolean =&gt; if (plain_value &gt; 0.5) @as(f32, 1.0) else @as(f32, 0.0),\n        .choice =&gt; |p| blk: {\n            if (p.labels.len &lt;= 1) break :blk 0.0;\n            const idx = @min(@as(u32, @intFromFloat(plain_value)), @as(u32, @intCast(p.labels.len - 1)));\n            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));\n        },\n    };\n}\n\n/// Convert a normalized [0, 1] parameter value to plain value.\n///\n/// Used by both wrappers when returning parameter values to the host\n/// or when saving/loading state.\npub inline fn normalizedToPlain(param: core.Param, normalized: f32) f64 {\n    return switch (param) {\n        .float =&gt; |p| switch (p.range) {\n            .linear =&gt; |r| r.unnormalize(normalized),\n            .logarithmic =&gt; |r| r.unnormalize(normalized),\n        },\n        .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),\n        .boolean =&gt; if (normalized &gt; 0.5) @as(f64, 1.0) else @as(f64, 0.0),\n        .choice =&gt; |p| blk: {\n            if (p.labels.len &lt;= 1) break :blk 0.0;\n            const idx = @as(u32, @intFromFloat(normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n            break :blk @floatFromInt(idx);\n        },\n    };\n}\n\n// ---------------------------------------------------------------------------\n// Wrapper State Initialization\n// ---------------------------------------------------------------------------\n\n/// Initialize shared audio state fields on a wrapper instance.\n///\n/// Both wrappers have similar initialization logic for the audio processing state.\n/// This helper ensures consistency and reduces duplication.\npub inline fn initState(\n    comptime P: type,\n    self: anytype,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub inline fn plainToNormalized(param: core.Param, plain_value: f64) f32 {",
            "lineNumber": 92
          },
          {
            "text": "    return switch (param) {",
            "lineNumber": 93
          },
          {
            "text": "        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 94
          },
          {
            "text": "            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 95
          },
          {
            "text": "            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 96
          },
          {
            "text": "        },",
            "lineNumber": 97
          },
          {
            "text": "        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),",
            "lineNumber": 98
          },
          {
            "text": "        .boolean =&gt; if (plain_value &gt; 0.5) @as(f32, 1.0) else @as(f32, 0.0),",
            "lineNumber": 99
          },
          {
            "text": "        .choice =&gt; |p| blk: {",
            "lineNumber": 100
          },
          {
            "text": "            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 101
          },
          {
            "text": "            const idx = @min(@as(u32, @intFromFloat(plain_value)), @as(u32, @intCast(p.labels.len - 1)));",
            "lineNumber": 102
          },
          {
            "text": "            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 103
          },
          {
            "text": "        },",
            "lineNumber": 104
          },
          {
            "text": "    };",
            "lineNumber": 105
          },
          {
            "text": "}",
            "lineNumber": 106
          },
          {
            "lineNumber": 107
          },
          {
            "text": "/// Convert a normalized [0, 1] parameter value to plain value.",
            "lineNumber": 108
          },
          {
            "text": "///",
            "lineNumber": 109
          },
          {
            "text": "/// Used by both wrappers when returning parameter values to the host",
            "lineNumber": 110
          },
          {
            "text": "/// or when saving/loading state.",
            "lineNumber": 111
          },
          {
            "text": "pub inline fn normalizedToPlain(param: core.Param, normalized: f32) f64 {",
            "lineNumber": 112
          },
          {
            "text": "    return switch (param) {",
            "lineNumber": 113
          },
          {
            "text": "        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 114
          },
          {
            "text": "            .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 115
          },
          {
            "text": "            .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 116
          },
          {
            "text": "        },",
            "lineNumber": 117
          },
          {
            "text": "        .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),",
            "lineNumber": 118
          },
          {
            "text": "        .boolean =&gt; if (normalized &gt; 0.5) @as(f64, 1.0) else @as(f64, 0.0),",
            "lineNumber": 119
          },
          {
            "text": "        .choice =&gt; |p| blk: {",
            "lineNumber": 120
          },
          {
            "text": "            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 121
          },
          {
            "text": "            const idx = @as(u32, @intFromFloat(normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 122
          },
          {
            "text": "            break :blk @floatFromInt(idx);",
            "lineNumber": 123
          },
          {
            "text": "        },",
            "lineNumber": 124
          },
          {
            "text": "    };",
            "lineNumber": 125
          },
          {
            "text": "}",
            "lineNumber": 126
          },
          {
            "lineNumber": 127
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 128
          },
          {
            "text": "// Wrapper State Initialization",
            "lineNumber": 129
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 130
          },
          {
            "lineNumber": 131
          },
          {
            "text": "/// Initialize shared audio state fields on a wrapper instance.",
            "lineNumber": 132
          },
          {
            "text": "///",
            "lineNumber": 133
          },
          {
            "text": "/// Both wrappers have similar initialization logic for the audio processing state.",
            "lineNumber": 134
          },
          {
            "text": "/// This helper ensures consistency and reduces duplication.",
            "lineNumber": 135
          },
          {
            "text": "pub inline fn initState(",
            "lineNumber": 136
          },
          {
            "text": "    comptime P: type,",
            "lineNumber": 137
          },
          {
            "text": "    self: anytype,",
            "lineNumber": 138
          }
        ]
      },
      "score": 0.3165552020072937
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 41
          }
        },
        "contents": "/// Comptime parameter declaration and runtime parameter state.\n///\n/// Plugin authors declare parameters as comptime arrays of &#96;Param&#96; values.\n/// The framework uses these declarations to generate metadata for both CLAP\n/// and VST3 at compile time and to manage runtime parameter values with\n/// lock-free atomics.\nconst std = @import(\"std\");\n\n// ---------------------------------------------------------------------------\n// Ranges\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter range.\npub const FloatRange = struct {\n    min: f32,\n    max: f32,\n\n    /// Map a plain value to the normalized 0.0–1.0 range.\n    pub fn normalize(self: FloatRange, plain: f32) f32 {\n        if (self.max == self.min) return 0.0;\n        return (self.clamp(plain) - self.min) / (self.max - self.min);\n    }\n\n    /// Map a normalized 0.0–1.0 value back to the plain range.\n    pub fn unnormalize(self: FloatRange, normalized: f32) f32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        return self.min + clamped * (self.max - self.min);\n    }\n\n    /// Clamp a plain value to the range [min, max].\n    pub fn clamp(self: FloatRange, value: f32) f32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n};\n\n/// A continuous floating-point parameter range with logarithmic mapping.\n/// Useful for parameters where human perception is logarithmic (frequency, gain).\npub const LogFloatRange = struct {\n    min: f32,\n    max: f32,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// Comptime parameter declaration and runtime parameter state.",
            "lineNumber": 1
          },
          {
            "text": "///",
            "lineNumber": 2
          },
          {
            "text": "/// Plugin authors declare parameters as comptime arrays of &#96;Param&#96; values.",
            "lineNumber": 3
          },
          {
            "text": "/// The framework uses these declarations to generate metadata for both CLAP",
            "lineNumber": 4
          },
          {
            "text": "/// and VST3 at compile time and to manage runtime parameter values with",
            "lineNumber": 5
          },
          {
            "text": "/// lock-free atomics.",
            "lineNumber": 6
          },
          {
            "text": "const std = @import(\"std\");",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 9
          },
          {
            "text": "// Ranges",
            "lineNumber": 10
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 11
          },
          {
            "lineNumber": 12
          },
          {
            "text": "/// A continuous floating-point parameter range.",
            "lineNumber": 13
          },
          {
            "text": "pub const FloatRange = struct {",
            "lineNumber": 14
          },
          {
            "text": "    min: f32,",
            "lineNumber": 15
          },
          {
            "text": "    max: f32,",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "    /// Map a plain value to the normalized 0.0–1.0 range.",
            "lineNumber": 18
          },
          {
            "text": "    pub fn normalize(self: FloatRange, plain: f32) f32 {",
            "lineNumber": 19
          },
          {
            "text": "        if (self.max == self.min) return 0.0;",
            "lineNumber": 20
          },
          {
            "text": "        return (self.clamp(plain) - self.min) / (self.max - self.min);",
            "lineNumber": 21
          },
          {
            "text": "    }",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to the plain range.",
            "lineNumber": 24
          },
          {
            "text": "    pub fn unnormalize(self: FloatRange, normalized: f32) f32 {",
            "lineNumber": 25
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 26
          },
          {
            "text": "        return self.min + clamped * (self.max - self.min);",
            "lineNumber": 27
          },
          {
            "text": "    }",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "    /// Clamp a plain value to the range [min, max].",
            "lineNumber": 30
          },
          {
            "text": "    pub fn clamp(self: FloatRange, value: f32) f32 {",
            "lineNumber": 31
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 32
          },
          {
            "text": "    }",
            "lineNumber": 33
          },
          {
            "text": "};",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/// A continuous floating-point parameter range with logarithmic mapping.",
            "lineNumber": 36
          },
          {
            "text": "/// Useful for parameters where human perception is logarithmic (frequency, gain).",
            "lineNumber": 37
          },
          {
            "text": "pub const LogFloatRange = struct {",
            "lineNumber": 38
          },
          {
            "text": "    min: f32,",
            "lineNumber": 39
          },
          {
            "text": "    max: f32,",
            "lineNumber": 40
          }
        ]
      },
      "score": 0.29476198554039
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 37
          },
          "endPosition": {
            "line": 70
          }
        },
        "contents": "pub const LogFloatRange = struct {\n    min: f32,\n    max: f32,\n\n    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.\n    pub fn normalize(self: LogFloatRange, plain: f32) f32 {\n        if (self.max &lt;= self.min or self.min &lt;= 0.0) return 0.0;\n        const clamped = self.clamp(plain);\n        const log_min = @log(self.min);\n        const log_max = @log(self.max);\n        return (@log(clamped) - log_min) / (log_max - log_min);\n    }\n\n    /// Map a normalized 0.0–1.0 value back to the plain range using logarithmic scaling.\n    pub fn unnormalize(self: LogFloatRange, normalized: f32) f32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        const log_min = @log(self.min);\n        const log_max = @log(self.max);\n        return @exp(log_min + clamped * (log_max - log_min));\n    }\n\n    /// Clamp a plain value to the range [min, max].\n    pub fn clamp(self: LogFloatRange, value: f32) f32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n};\n\n/// A discrete integer parameter range.\npub const IntRange = struct {\n    min: i32,\n    max: i32,\n\n    /// Map a plain integer value to the normalized 0.0–1.0 range.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const LogFloatRange = struct {",
            "lineNumber": 38
          },
          {
            "text": "    min: f32,",
            "lineNumber": 39
          },
          {
            "text": "    max: f32,",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "    /// Map a plain value to the normalized 0.0–1.0 range using logarithmic scaling.",
            "lineNumber": 42
          },
          {
            "text": "    pub fn normalize(self: LogFloatRange, plain: f32) f32 {",
            "lineNumber": 43
          },
          {
            "text": "        if (self.max &lt;= self.min or self.min &lt;= 0.0) return 0.0;",
            "lineNumber": 44
          },
          {
            "text": "        const clamped = self.clamp(plain);",
            "lineNumber": 45
          },
          {
            "text": "        const log_min = @log(self.min);",
            "lineNumber": 46
          },
          {
            "text": "        const log_max = @log(self.max);",
            "lineNumber": 47
          },
          {
            "text": "        return (@log(clamped) - log_min) / (log_max - log_min);",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to the plain range using logarithmic scaling.",
            "lineNumber": 51
          },
          {
            "text": "    pub fn unnormalize(self: LogFloatRange, normalized: f32) f32 {",
            "lineNumber": 52
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 53
          },
          {
            "text": "        const log_min = @log(self.min);",
            "lineNumber": 54
          },
          {
            "text": "        const log_max = @log(self.max);",
            "lineNumber": 55
          },
          {
            "text": "        return @exp(log_min + clamped * (log_max - log_min));",
            "lineNumber": 56
          },
          {
            "text": "    }",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    /// Clamp a plain value to the range [min, max].",
            "lineNumber": 59
          },
          {
            "text": "    pub fn clamp(self: LogFloatRange, value: f32) f32 {",
            "lineNumber": 60
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 61
          },
          {
            "text": "    }",
            "lineNumber": 62
          },
          {
            "text": "};",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "/// A discrete integer parameter range.",
            "lineNumber": 65
          },
          {
            "text": "pub const IntRange = struct {",
            "lineNumber": 66
          },
          {
            "text": "    min: i32,",
            "lineNumber": 67
          },
          {
            "text": "    max: i32,",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "    /// Map a plain integer value to the normalized 0.0–1.0 range.",
            "lineNumber": 70
          }
        ]
      },
      "score": 0.28470999002456665
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 220
          },
          "endPosition": {
            "line": 277
          }
        },
        "contents": "    pub fn defaultNormalized(self: Param) f32 {\n        return switch (self) {\n            .float =&gt; |p| switch (p.range) {\n                .linear =&gt; |r| r.normalize(p.default),\n                .logarithmic =&gt; |r| r.normalize(p.default),\n            },\n            .int =&gt; |p| p.range.normalize(p.default),\n            .boolean =&gt; |p| if (p.default) @as(f32, 1.0) else @as(f32, 0.0),\n            .choice =&gt; |p| blk: {\n                if (p.labels.len &lt;= 1) break :blk 0.0;\n                break :blk @as(f32, @floatFromInt(p.default)) /\n                    @as(f32, @floatFromInt(p.labels.len - 1));\n            },\n        };\n    }\n\n    /// Convert a normalized value to plain (unnormalized) value.\n    pub fn toPlain(self: Param, normalized: f32) f32 {\n        return switch (self) {\n            .float =&gt; |p| switch (p.range) {\n                .linear =&gt; |r| r.unnormalize(normalized),\n                .logarithmic =&gt; |r| r.unnormalize(normalized),\n            },\n            .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),\n            .boolean =&gt; if (normalized &gt; 0.5) 1.0 else 0.0,\n            .choice =&gt; |p| blk: {\n                if (p.labels.len &lt;= 1) break :blk 0.0;\n                break :blk normalized * @as(f32, @floatFromInt(p.labels.len - 1));\n            },\n        };\n    }\n\n    /// Returns the flags for this parameter.\n    pub fn flags(self: Param) ParamFlags {\n        return switch (self) {\n            .float =&gt; |p| p.flags,\n            .int =&gt; |p| p.flags,\n            .boolean =&gt; |p| p.flags,\n            .choice =&gt; |p| p.flags,\n        };\n    }\n};\n\n// ---------------------------------------------------------------------------\n// Stable ID hashing\n// ---------------------------------------------------------------------------\n\n/// Compute a stable 32-bit hash from a parameter's string ID.\n///\n/// Uses FNV-1a to produce a deterministic &#96;u32&#96; suitable for use as a\n/// VST3 &#96;ParamID&#96;. The same string always produces the same hash.\npub fn idHash(comptime str: [:0]const u8) u32 {\n    comptime {\n        return fnv1a_32(str);\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub fn defaultNormalized(self: Param) f32 {",
            "lineNumber": 221
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 222
          },
          {
            "text": "            .float =&gt; |p| switch (p.range) {",
            "lineNumber": 223
          },
          {
            "text": "                .linear =&gt; |r| r.normalize(p.default),",
            "lineNumber": 224
          },
          {
            "text": "                .logarithmic =&gt; |r| r.normalize(p.default),",
            "lineNumber": 225
          },
          {
            "text": "            },",
            "lineNumber": 226
          },
          {
            "text": "            .int =&gt; |p| p.range.normalize(p.default),",
            "lineNumber": 227
          },
          {
            "text": "            .boolean =&gt; |p| if (p.default) @as(f32, 1.0) else @as(f32, 0.0),",
            "lineNumber": 228
          },
          {
            "text": "            .choice =&gt; |p| blk: {",
            "lineNumber": 229
          },
          {
            "text": "                if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 230
          },
          {
            "text": "                break :blk @as(f32, @floatFromInt(p.default)) /",
            "lineNumber": 231
          },
          {
            "text": "                    @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 232
          },
          {
            "text": "            },",
            "lineNumber": 233
          },
          {
            "text": "        };",
            "lineNumber": 234
          },
          {
            "text": "    }",
            "lineNumber": 235
          },
          {
            "lineNumber": 236
          },
          {
            "text": "    /// Convert a normalized value to plain (unnormalized) value.",
            "lineNumber": 237
          },
          {
            "text": "    pub fn toPlain(self: Param, normalized: f32) f32 {",
            "lineNumber": 238
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 239
          },
          {
            "text": "            .float =&gt; |p| switch (p.range) {",
            "lineNumber": 240
          },
          {
            "text": "                .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 241
          },
          {
            "text": "                .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 242
          },
          {
            "text": "            },",
            "lineNumber": 243
          },
          {
            "text": "            .int =&gt; |p| @floatFromInt(p.range.unnormalize(normalized)),",
            "lineNumber": 244
          },
          {
            "text": "            .boolean =&gt; if (normalized &gt; 0.5) 1.0 else 0.0,",
            "lineNumber": 245
          },
          {
            "text": "            .choice =&gt; |p| blk: {",
            "lineNumber": 246
          },
          {
            "text": "                if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 247
          },
          {
            "text": "                break :blk normalized * @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 248
          },
          {
            "text": "            },",
            "lineNumber": 249
          },
          {
            "text": "        };",
            "lineNumber": 250
          },
          {
            "text": "    }",
            "lineNumber": 251
          },
          {
            "lineNumber": 252
          },
          {
            "text": "    /// Returns the flags for this parameter.",
            "lineNumber": 253
          },
          {
            "text": "    pub fn flags(self: Param) ParamFlags {",
            "lineNumber": 254
          },
          {
            "text": "        return switch (self) {",
            "lineNumber": 255
          },
          {
            "text": "            .float =&gt; |p| p.flags,",
            "lineNumber": 256
          },
          {
            "text": "            .int =&gt; |p| p.flags,",
            "lineNumber": 257
          },
          {
            "text": "            .boolean =&gt; |p| p.flags,",
            "lineNumber": 258
          },
          {
            "text": "            .choice =&gt; |p| p.flags,",
            "lineNumber": 259
          },
          {
            "text": "        };",
            "lineNumber": 260
          },
          {
            "text": "    }",
            "lineNumber": 261
          },
          {
            "text": "};",
            "lineNumber": 262
          },
          {
            "lineNumber": 263
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 264
          },
          {
            "text": "// Stable ID hashing",
            "lineNumber": 265
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 266
          },
          {
            "lineNumber": 267
          },
          {
            "text": "/// Compute a stable 32-bit hash from a parameter's string ID.",
            "lineNumber": 268
          },
          {
            "text": "///",
            "lineNumber": 269
          },
          {
            "text": "/// Uses FNV-1a to produce a deterministic &#96;u32&#96; suitable for use as a",
            "lineNumber": 270
          },
          {
            "text": "/// VST3 &#96;ParamID&#96;. The same string always produces the same hash.",
            "lineNumber": 271
          },
          {
            "text": "pub fn idHash(comptime str: [:0]const u8) u32 {",
            "lineNumber": 272
          },
          {
            "text": "    comptime {",
            "lineNumber": 273
          },
          {
            "text": "        return fnv1a_32(str);",
            "lineNumber": 274
          },
          {
            "text": "    }",
            "lineNumber": 275
          },
          {
            "text": "}",
            "lineNumber": 276
          }
        ]
      },
      "score": 0.26349353790283203
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./docs/plugin-authors.md",
        "range": {
          "startPosition": {
            "line": 131
          },
          "endPosition": {
            "line": 200
          }
        },
        "contents": "&#96;&#96;&#96;zig\npub const params = &amp;[_]z_plug.Param{\n    .{ .float = .{\n        .name = \"Gain\",\n        .id = \"gain\",\n        .default = 0.0,  // dB\n        .range = .{ .min = -24.0, .max = 24.0 },\n        .unit = \"dB\",\n        .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing\n    }},\n    .{ .boolean = .{\n        .name = \"Bypass\",\n        .id = \"bypass\",\n        .default = false,\n        .flags = .{ .bypass = true },\n    }},\n    .{ .choice = .{\n        .name = \"Mode\",\n        .id = \"mode\",\n        .default = 0,\n        .labels = &amp;.{ \"Clean\", \"Warm\", \"Vintage\" },\n    }},\n};\n&#96;&#96;&#96;\n\n### Parameter Types\n\n- **&#96;FloatParam&#96;** — Continuous floating-point (e.g., gain, frequency, mix)\n- **&#96;IntParam&#96;** — Discrete integer (e.g., semitones, sample count)\n- **&#96;BoolParam&#96;** — Boolean toggle (e.g., bypass, invert polarity)\n- **&#96;ChoiceParam&#96;** — Enum/choice from a list of labels\n\n### Parameter IDs\n\nThe &#96;id&#96; field must be a **stable string**. It's used to:\n- Generate a stable hash for VST3 &#96;ParamID&#96;\n- Identify parameters in state save/load\n- **Never change IDs after releasing a plugin** — it breaks presets and automation\n\n### Parameter Smoothing\n\nFloat parameters support automatic smoothing to prevent audio artifacts when values change. Add a &#96;smoothing&#96; field to enable:\n\n&#96;&#96;&#96;zig\n.{ .float = .{\n    .name = \"Cutoff\",\n    .id = \"cutoff\",\n    .default = 1000.0,\n    .range = .{ .min = 20.0, .max = 20000.0 },\n    .smoothing = .{ .linear = 10.0 },  // 10ms linear ramp\n}}\n&#96;&#96;&#96;\n\nAvailable smoothing styles:\n- **&#96;.linear&#96;** — Linear ramp over N milliseconds\n- **&#96;.exponential&#96;** — Exponential ramp over N milliseconds (better for frequency)\n- **&#96;.none&#96;** — No smoothing (instant value changes)\n\nTo use smoothed values in your &#96;process&#96; function, call &#96;context.nextSmoothed()&#96; for each sample:\n\n&#96;&#96;&#96;zig\npub fn process(\n    self: *MyPlugin,\n    buffer: *z_plug.Buffer,\n    aux: *z_plug.AuxBuffers,\n    context: *z_plug.ProcessContext,\n) z_plug.ProcessStatus {\n    var i: usize = 0;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 133
          },
          {
            "text": "pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 134
          },
          {
            "text": "    .{ .float = .{",
            "lineNumber": 135
          },
          {
            "text": "        .name = \"Gain\",",
            "lineNumber": 136
          },
          {
            "text": "        .id = \"gain\",",
            "lineNumber": 137
          },
          {
            "text": "        .default = 0.0,  // dB",
            "lineNumber": 138
          },
          {
            "text": "        .range = .{ .min = -24.0, .max = 24.0 },",
            "lineNumber": 139
          },
          {
            "text": "        .unit = \"dB\",",
            "lineNumber": 140
          },
          {
            "text": "        .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing",
            "lineNumber": 141
          },
          {
            "text": "    }},",
            "lineNumber": 142
          },
          {
            "text": "    .{ .boolean = .{",
            "lineNumber": 143
          },
          {
            "text": "        .name = \"Bypass\",",
            "lineNumber": 144
          },
          {
            "text": "        .id = \"bypass\",",
            "lineNumber": 145
          },
          {
            "text": "        .default = false,",
            "lineNumber": 146
          },
          {
            "text": "        .flags = .{ .bypass = true },",
            "lineNumber": 147
          },
          {
            "text": "    }},",
            "lineNumber": 148
          },
          {
            "text": "    .{ .choice = .{",
            "lineNumber": 149
          },
          {
            "text": "        .name = \"Mode\",",
            "lineNumber": 150
          },
          {
            "text": "        .id = \"mode\",",
            "lineNumber": 151
          },
          {
            "text": "        .default = 0,",
            "lineNumber": 152
          },
          {
            "text": "        .labels = &amp;.{ \"Clean\", \"Warm\", \"Vintage\" },",
            "lineNumber": 153
          },
          {
            "text": "    }},",
            "lineNumber": 154
          },
          {
            "text": "};",
            "lineNumber": 155
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 156
          },
          {
            "lineNumber": 157
          },
          {
            "text": "### Parameter Types",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "- **&#96;FloatParam&#96;** — Continuous floating-point (e.g., gain, frequency, mix)",
            "lineNumber": 160
          },
          {
            "text": "- **&#96;IntParam&#96;** — Discrete integer (e.g., semitones, sample count)",
            "lineNumber": 161
          },
          {
            "text": "- **&#96;BoolParam&#96;** — Boolean toggle (e.g., bypass, invert polarity)",
            "lineNumber": 162
          },
          {
            "text": "- **&#96;ChoiceParam&#96;** — Enum/choice from a list of labels",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "### Parameter IDs",
            "lineNumber": 165
          },
          {
            "lineNumber": 166
          },
          {
            "text": "The &#96;id&#96; field must be a **stable string**. It's used to:",
            "lineNumber": 167
          },
          {
            "text": "- Generate a stable hash for VST3 &#96;ParamID&#96;",
            "lineNumber": 168
          },
          {
            "text": "- Identify parameters in state save/load",
            "lineNumber": 169
          },
          {
            "text": "- **Never change IDs after releasing a plugin** — it breaks presets and automation",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "### Parameter Smoothing",
            "lineNumber": 172
          },
          {
            "lineNumber": 173
          },
          {
            "text": "Float parameters support automatic smoothing to prevent audio artifacts when values change. Add a &#96;smoothing&#96; field to enable:",
            "lineNumber": 174
          },
          {
            "lineNumber": 175
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 176
          },
          {
            "text": ".{ .float = .{",
            "lineNumber": 177
          },
          {
            "text": "    .name = \"Cutoff\",",
            "lineNumber": 178
          },
          {
            "text": "    .id = \"cutoff\",",
            "lineNumber": 179
          },
          {
            "text": "    .default = 1000.0,",
            "lineNumber": 180
          },
          {
            "text": "    .range = .{ .min = 20.0, .max = 20000.0 },",
            "lineNumber": 181
          },
          {
            "text": "    .smoothing = .{ .linear = 10.0 },  // 10ms linear ramp",
            "lineNumber": 182
          },
          {
            "text": "}}",
            "lineNumber": 183
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 184
          },
          {
            "lineNumber": 185
          },
          {
            "text": "Available smoothing styles:",
            "lineNumber": 186
          },
          {
            "text": "- **&#96;.linear&#96;** — Linear ramp over N milliseconds",
            "lineNumber": 187
          },
          {
            "text": "- **&#96;.exponential&#96;** — Exponential ramp over N milliseconds (better for frequency)",
            "lineNumber": 188
          },
          {
            "text": "- **&#96;.none&#96;** — No smoothing (instant value changes)",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "To use smoothed values in your &#96;process&#96; function, call &#96;context.nextSmoothed()&#96; for each sample:",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 193
          },
          {
            "text": "pub fn process(",
            "lineNumber": 194
          },
          {
            "text": "    self: *MyPlugin,",
            "lineNumber": 195
          },
          {
            "text": "    buffer: *z_plug.Buffer,",
            "lineNumber": 196
          },
          {
            "text": "    aux: *z_plug.AuxBuffers,",
            "lineNumber": 197
          },
          {
            "text": "    context: *z_plug.ProcessContext,",
            "lineNumber": 198
          },
          {
            "text": ") z_plug.ProcessStatus {",
            "lineNumber": 199
          },
          {
            "text": "    var i: usize = 0;",
            "lineNumber": 200
          }
        ]
      },
      "score": 0.25671321153640747
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 421
          },
          "endPosition": {
            "line": 442
          }
        },
        "contents": "pub const SmoothingStyle = union(enum) {\n    /// No smoothing — parameter changes take effect immediately.\n    none,\n    /// Linear ramp over the specified duration in milliseconds.\n    linear: f32,\n    /// Exponential smoothing (single-pole IIR) over the specified duration.\n    /// Reaches approximately 99.99% of target, then snaps to target.\n    exponential: f32,\n    /// Logarithmic interpolation over the specified duration in milliseconds.\n    /// Smooths in log space, producing exponential curves in linear space.\n    /// Useful for frequency sweeps and gain changes.\n    logarithmic: f32,\n};\n\n/// A parameter value smoother that interpolates between current and target\n/// values over time.\n///\n/// Supports linear and exponential smoothing styles. Used to avoid audible\n/// clicks and pops when parameters change abruptly.\npub const Smoother = struct {\n    /// The smoothing style for this parameter.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const SmoothingStyle = union(enum) {",
            "lineNumber": 422
          },
          {
            "text": "    /// No smoothing — parameter changes take effect immediately.",
            "lineNumber": 423
          },
          {
            "text": "    none,",
            "lineNumber": 424
          },
          {
            "text": "    /// Linear ramp over the specified duration in milliseconds.",
            "lineNumber": 425
          },
          {
            "text": "    linear: f32,",
            "lineNumber": 426
          },
          {
            "text": "    /// Exponential smoothing (single-pole IIR) over the specified duration.",
            "lineNumber": 427
          },
          {
            "text": "    /// Reaches approximately 99.99% of target, then snaps to target.",
            "lineNumber": 428
          },
          {
            "text": "    exponential: f32,",
            "lineNumber": 429
          },
          {
            "text": "    /// Logarithmic interpolation over the specified duration in milliseconds.",
            "lineNumber": 430
          },
          {
            "text": "    /// Smooths in log space, producing exponential curves in linear space.",
            "lineNumber": 431
          },
          {
            "text": "    /// Useful for frequency sweeps and gain changes.",
            "lineNumber": 432
          },
          {
            "text": "    logarithmic: f32,",
            "lineNumber": 433
          },
          {
            "text": "};",
            "lineNumber": 434
          },
          {
            "lineNumber": 435
          },
          {
            "text": "/// A parameter value smoother that interpolates between current and target",
            "lineNumber": 436
          },
          {
            "text": "/// values over time.",
            "lineNumber": 437
          },
          {
            "text": "///",
            "lineNumber": 438
          },
          {
            "text": "/// Supports linear and exponential smoothing styles. Used to avoid audible",
            "lineNumber": 439
          },
          {
            "text": "/// clicks and pops when parameters change abruptly.",
            "lineNumber": 440
          },
          {
            "text": "pub const Smoother = struct {",
            "lineNumber": 441
          },
          {
            "text": "    /// The smoothing style for this parameter.",
            "lineNumber": 442
          }
        ]
      },
      "score": 0.2560766041278839
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./examples/gain.zig",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 58
          }
        },
        "contents": "/// Simple gain plugin example for zig-plug.\n///\n/// This plugin demonstrates the minimal viable plugin:\n/// - One FloatParam for gain control (0.0 to 2.0)\n/// - Stereo processing\n/// - Both CLAP and VST3 support\nconst z_plug = @import(\"z_plug\");\n\nconst GainPlugin = struct {\n    // Required metadata\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n    \n    // Audio configuration: stereo in/out\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n    \n    // Parameters: one gain parameter\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .linear = .{ .min = 0.0, .max = 2.0 } },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },\n        } },\n    };\n    \n    // No internal state needed for this simple plugin\n    \n    /// Initialize the plugin with the selected audio layout and buffer config.\n    pub fn init(\n        _: *@This(),\n        _: *const z_plug.AudioIOLayout,\n        _: *const z_plug.BufferConfig,\n    ) bool {\n        return true;\n    }\n    \n    /// Clean up plugin resources.\n    pub fn deinit(_: *@This()) void {\n        // No cleanup needed\n    }\n    \n    /// Process audio.\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// Simple gain plugin example for zig-plug.",
            "lineNumber": 1
          },
          {
            "text": "///",
            "lineNumber": 2
          },
          {
            "text": "/// This plugin demonstrates the minimal viable plugin:",
            "lineNumber": 3
          },
          {
            "text": "/// - One FloatParam for gain control (0.0 to 2.0)",
            "lineNumber": 4
          },
          {
            "text": "/// - Stereo processing",
            "lineNumber": 5
          },
          {
            "text": "/// - Both CLAP and VST3 support",
            "lineNumber": 6
          },
          {
            "text": "const z_plug = @import(\"z_plug\");",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 9
          },
          {
            "text": "    // Required metadata",
            "lineNumber": 10
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 11
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 12
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 13
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 14
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 15
          },
          {
            "text": "    ",
            "lineNumber": 16
          },
          {
            "text": "    // Audio configuration: stereo in/out",
            "lineNumber": 17
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 18
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 19
          },
          {
            "text": "    };",
            "lineNumber": 20
          },
          {
            "text": "    ",
            "lineNumber": 21
          },
          {
            "text": "    // Parameters: one gain parameter",
            "lineNumber": 22
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 23
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 24
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 25
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 26
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 27
          },
          {
            "text": "            .range = .{ .linear = .{ .min = 0.0, .max = 2.0 } },",
            "lineNumber": 28
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 29
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 30
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },",
            "lineNumber": 31
          },
          {
            "text": "        } },",
            "lineNumber": 32
          },
          {
            "text": "    };",
            "lineNumber": 33
          },
          {
            "text": "    ",
            "lineNumber": 34
          },
          {
            "text": "    // No internal state needed for this simple plugin",
            "lineNumber": 35
          },
          {
            "text": "    ",
            "lineNumber": 36
          },
          {
            "text": "    /// Initialize the plugin with the selected audio layout and buffer config.",
            "lineNumber": 37
          },
          {
            "text": "    pub fn init(",
            "lineNumber": 38
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 39
          },
          {
            "text": "        _: *const z_plug.AudioIOLayout,",
            "lineNumber": 40
          },
          {
            "text": "        _: *const z_plug.BufferConfig,",
            "lineNumber": 41
          },
          {
            "text": "    ) bool {",
            "lineNumber": 42
          },
          {
            "text": "        return true;",
            "lineNumber": 43
          },
          {
            "text": "    }",
            "lineNumber": 44
          },
          {
            "text": "    ",
            "lineNumber": 45
          },
          {
            "text": "    /// Clean up plugin resources.",
            "lineNumber": 46
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {",
            "lineNumber": 47
          },
          {
            "text": "        // No cleanup needed",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "text": "    ",
            "lineNumber": 50
          },
          {
            "text": "    /// Process audio.",
            "lineNumber": 51
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 52
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 53
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 54
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 55
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 56
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 57
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 58
          }
        ]
      },
      "score": 0.2549448013305664
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 115
          },
          "endPosition": {
            "line": 174
          }
        },
        "contents": "// Parameter declarations (comptime)\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter.\npub const FloatParam = struct {\n    /// Human-readable parameter name shown in the host.\n    name: [:0]const u8,\n    /// Stable string identifier. Hashed to generate VST3 &#96;ParamID&#96;.\n    id: [:0]const u8,\n    /// Default plain value.\n    default: f32,\n    /// The value range - can be linear or logarithmic.\n    range: union(enum) {\n        linear: FloatRange,\n        logarithmic: LogFloatRange,\n    },\n    /// Optional step size for hosts that display discrete ticks.\n    step_size: ?f32 = null,\n    /// Unit label displayed after the value (e.g. \"dB\", \"Hz\", \"%\").\n    unit: [:0]const u8 = \"\",\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n    /// Optional smoothing style (default: no smoothing).\n    smoothing: SmoothingStyle = .none,\n};\n\n/// A discrete integer parameter.\npub const IntParam = struct {\n    /// Human-readable parameter name.\n    name: [:0]const u8,\n    /// Stable string identifier.\n    id: [:0]const u8,\n    /// Default plain value.\n    default: i32,\n    /// The integer value range.\n    range: IntRange,\n    /// Unit label (e.g. \"st\" for semitones).\n    unit: [:0]const u8 = \"\",\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n    /// Optional smoothing style (default: no smoothing).\n    smoothing: SmoothingStyle = .none,\n};\n\n/// A boolean (on/off, toggle) parameter.\npub const BoolParam = struct {\n    /// Human-readable parameter name.\n    name: [:0]const u8,\n    /// Stable string identifier.\n    id: [:0]const u8,\n    /// Default value.\n    default: bool,\n    /// Flags controlling automation, visibility, etc.\n    flags: ParamFlags = .{},\n};\n\n/// An enum / choice parameter backed by a list of labels.\npub const ChoiceParam = struct {\n    /// Human-readable parameter name.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "// Parameter declarations (comptime)",
            "lineNumber": 116
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "/// A continuous floating-point parameter.",
            "lineNumber": 119
          },
          {
            "text": "pub const FloatParam = struct {",
            "lineNumber": 120
          },
          {
            "text": "    /// Human-readable parameter name shown in the host.",
            "lineNumber": 121
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 122
          },
          {
            "text": "    /// Stable string identifier. Hashed to generate VST3 &#96;ParamID&#96;.",
            "lineNumber": 123
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 124
          },
          {
            "text": "    /// Default plain value.",
            "lineNumber": 125
          },
          {
            "text": "    default: f32,",
            "lineNumber": 126
          },
          {
            "text": "    /// The value range - can be linear or logarithmic.",
            "lineNumber": 127
          },
          {
            "text": "    range: union(enum) {",
            "lineNumber": 128
          },
          {
            "text": "        linear: FloatRange,",
            "lineNumber": 129
          },
          {
            "text": "        logarithmic: LogFloatRange,",
            "lineNumber": 130
          },
          {
            "text": "    },",
            "lineNumber": 131
          },
          {
            "text": "    /// Optional step size for hosts that display discrete ticks.",
            "lineNumber": 132
          },
          {
            "text": "    step_size: ?f32 = null,",
            "lineNumber": 133
          },
          {
            "text": "    /// Unit label displayed after the value (e.g. \"dB\", \"Hz\", \"%\").",
            "lineNumber": 134
          },
          {
            "text": "    unit: [:0]const u8 = \"\",",
            "lineNumber": 135
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 136
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 137
          },
          {
            "text": "    /// Optional smoothing style (default: no smoothing).",
            "lineNumber": 138
          },
          {
            "text": "    smoothing: SmoothingStyle = .none,",
            "lineNumber": 139
          },
          {
            "text": "};",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "/// A discrete integer parameter.",
            "lineNumber": 142
          },
          {
            "text": "pub const IntParam = struct {",
            "lineNumber": 143
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 144
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 145
          },
          {
            "text": "    /// Stable string identifier.",
            "lineNumber": 146
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 147
          },
          {
            "text": "    /// Default plain value.",
            "lineNumber": 148
          },
          {
            "text": "    default: i32,",
            "lineNumber": 149
          },
          {
            "text": "    /// The integer value range.",
            "lineNumber": 150
          },
          {
            "text": "    range: IntRange,",
            "lineNumber": 151
          },
          {
            "text": "    /// Unit label (e.g. \"st\" for semitones).",
            "lineNumber": 152
          },
          {
            "text": "    unit: [:0]const u8 = \"\",",
            "lineNumber": 153
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 154
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 155
          },
          {
            "text": "    /// Optional smoothing style (default: no smoothing).",
            "lineNumber": 156
          },
          {
            "text": "    smoothing: SmoothingStyle = .none,",
            "lineNumber": 157
          },
          {
            "text": "};",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "/// A boolean (on/off, toggle) parameter.",
            "lineNumber": 160
          },
          {
            "text": "pub const BoolParam = struct {",
            "lineNumber": 161
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 162
          },
          {
            "text": "    name: [:0]const u8,",
            "lineNumber": 163
          },
          {
            "text": "    /// Stable string identifier.",
            "lineNumber": 164
          },
          {
            "text": "    id: [:0]const u8,",
            "lineNumber": 165
          },
          {
            "text": "    /// Default value.",
            "lineNumber": 166
          },
          {
            "text": "    default: bool,",
            "lineNumber": 167
          },
          {
            "text": "    /// Flags controlling automation, visibility, etc.",
            "lineNumber": 168
          },
          {
            "text": "    flags: ParamFlags = .{},",
            "lineNumber": 169
          },
          {
            "text": "};",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "/// An enum / choice parameter backed by a list of labels.",
            "lineNumber": 172
          },
          {
            "text": "pub const ChoiceParam = struct {",
            "lineNumber": 173
          },
          {
            "text": "    /// Human-readable parameter name.",
            "lineNumber": 174
          }
        ]
      },
      "score": 0.23648490011692047
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 268
          },
          "endPosition": {
            "line": 318
          }
        },
        "contents": "        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    return switch (param) {\n                        .float =&gt; |p| switch (p.range) {\n                            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),\n                            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),\n                        },\n                        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),\n                        .boolean =&gt; plain_value,\n                        .choice =&gt; |p| blk: {\n                            if (p.labels.len &lt;= 1) break :blk 0.0;\n                            const idx = @as(u32, @intFromFloat(plain_value));\n                            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));\n                        },\n                    };\n                }\n            }\n\n            return plain_value;\n        }\n\n        fn getParamNormalized(\n            self: *anyopaque,\n            id: vst3.types.ParamID,\n        ) callconv(.c) vst3.types.ParamValue {\n            const controller = fromController(self);\n\n            if (controller.param_values) |param_values| {\n                // Find parameter by ID\n                for (P.params, 0..) |_, idx| {\n                    const param_id = P.param_ids[idx];\n                    if (param_id == id) {\n                        return param_values.get(idx);\n                    }\n                }\n            }\n\n            return 0.0;\n        }\n\n        fn setParamNormalized(\n            self: *anyopaque,\n            id: vst3.types.ParamID,\n            value: vst3.types.ParamValue,\n        ) callconv(.c) vst3.tresult {\n            const controller = fromController(self);",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 269
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 270
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 271
          },
          {
            "text": "                const param_id = P.param_ids[i];",
            "lineNumber": 272
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 273
          },
          {
            "text": "                    return switch (param) {",
            "lineNumber": 274
          },
          {
            "text": "                        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 275
          },
          {
            "text": "                            .linear =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 276
          },
          {
            "text": "                            .logarithmic =&gt; |r| r.normalize(@floatCast(plain_value)),",
            "lineNumber": 277
          },
          {
            "text": "                        },",
            "lineNumber": 278
          },
          {
            "text": "                        .int =&gt; |p| p.range.normalize(@intFromFloat(plain_value)),",
            "lineNumber": 279
          },
          {
            "text": "                        .boolean =&gt; plain_value,",
            "lineNumber": 280
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 281
          },
          {
            "text": "                            if (p.labels.len &lt;= 1) break :blk 0.0;",
            "lineNumber": 282
          },
          {
            "text": "                            const idx = @as(u32, @intFromFloat(plain_value));",
            "lineNumber": 283
          },
          {
            "text": "                            break :blk @as(f32, @floatFromInt(idx)) / @as(f32, @floatFromInt(p.labels.len - 1));",
            "lineNumber": 284
          },
          {
            "text": "                        },",
            "lineNumber": 285
          },
          {
            "text": "                    };",
            "lineNumber": 286
          },
          {
            "text": "                }",
            "lineNumber": 287
          },
          {
            "text": "            }",
            "lineNumber": 288
          },
          {
            "lineNumber": 289
          },
          {
            "text": "            return plain_value;",
            "lineNumber": 290
          },
          {
            "text": "        }",
            "lineNumber": 291
          },
          {
            "lineNumber": 292
          },
          {
            "text": "        fn getParamNormalized(",
            "lineNumber": 293
          },
          {
            "text": "            self: *anyopaque,",
            "lineNumber": 294
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 295
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 296
          },
          {
            "text": "            const controller = fromController(self);",
            "lineNumber": 297
          },
          {
            "lineNumber": 298
          },
          {
            "text": "            if (controller.param_values) |param_values| {",
            "lineNumber": 299
          },
          {
            "text": "                // Find parameter by ID",
            "lineNumber": 300
          },
          {
            "text": "                for (P.params, 0..) |_, idx| {",
            "lineNumber": 301
          },
          {
            "text": "                    const param_id = P.param_ids[idx];",
            "lineNumber": 302
          },
          {
            "text": "                    if (param_id == id) {",
            "lineNumber": 303
          },
          {
            "text": "                        return param_values.get(idx);",
            "lineNumber": 304
          },
          {
            "text": "                    }",
            "lineNumber": 305
          },
          {
            "text": "                }",
            "lineNumber": 306
          },
          {
            "text": "            }",
            "lineNumber": 307
          },
          {
            "lineNumber": 308
          },
          {
            "text": "            return 0.0;",
            "lineNumber": 309
          },
          {
            "text": "        }",
            "lineNumber": 310
          },
          {
            "lineNumber": 311
          },
          {
            "text": "        fn setParamNormalized(",
            "lineNumber": 312
          },
          {
            "text": "            self: *anyopaque,",
            "lineNumber": 313
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 314
          },
          {
            "text": "            value: vst3.types.ParamValue,",
            "lineNumber": 315
          },
          {
            "text": "        ) callconv(.c) vst3.tresult {",
            "lineNumber": 316
          },
          {
            "text": "            const controller = fromController(self);",
            "lineNumber": 317
          }
        ]
      },
      "score": 0.23601940274238586
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 974
          },
          "endPosition": {
            "line": 1027
          }
        },
        "contents": "}\n\ntest \"Param toPlain conversion\" {\n    // Float param\n    const float_param = Param{ .float = .{\n        .name = \"Gain\",\n        .id = \"gain\",\n        .default = 0.0,\n        .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },\n    } };\n    const float_plain = float_param.toPlain(0.75); // 0.75 normalized = 12.0 in [-24, 24] range\n    try std.testing.expectApproxEqAbs(@as(f32, 12.0), float_plain, 1e-4);\n\n    // Int param\n    const int_param = Param{ .int = .{\n        .name = \"Cutoff\",\n        .id = \"cutoff\",\n        .default = 1000,\n        .range = .{ .min = 20, .max = 20000 },\n    } };\n    const int_plain = int_param.toPlain(0.5); // 0.5 normalized = ~10010 in [20, 20000] range\n    try std.testing.expectApproxEqAbs(@as(f32, 10010.0), int_plain, 1.0);\n\n    // Boolean param\n    const bool_param = Param{ .boolean = .{\n        .name = \"Bypass\",\n        .id = \"bypass\",\n        .default = false,\n    } };\n    try std.testing.expectApproxEqAbs(@as(f32, 0.0), bool_param.toPlain(0.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), bool_param.toPlain(1.0), 1e-6);\n\n    // Choice param\n    const choice_param = Param{ .choice = .{\n        .name = \"Mode\",\n        .id = \"mode\",\n        .default = 0,\n        .labels = &amp;.{ \"Low\", \"Mid\", \"High\" },\n    } };\n    const choice_plain = choice_param.toPlain(0.5); // Middle choice\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), choice_plain, 1e-6);\n}\n\ntest \"LogFloatRange normalize and unnormalize roundtrip\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    const plain: f32 = 1000.0;\n    const norm = range.normalize(plain);\n    const back = range.unnormalize(norm);\n    try std.testing.expectApproxEqAbs(plain, back, 1e-3);\n}\n\ntest \"LogFloatRange perceptually uniform\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
        "signatures": {},
        "detailedLines": [
          {
            "text": "}",
            "lineNumber": 975
          },
          {
            "lineNumber": 976
          },
          {
            "text": "test \"Param toPlain conversion\" {",
            "lineNumber": 977
          },
          {
            "text": "    // Float param",
            "lineNumber": 978
          },
          {
            "text": "    const float_param = Param{ .float = .{",
            "lineNumber": 979
          },
          {
            "text": "        .name = \"Gain\",",
            "lineNumber": 980
          },
          {
            "text": "        .id = \"gain\",",
            "lineNumber": 981
          },
          {
            "text": "        .default = 0.0,",
            "lineNumber": 982
          },
          {
            "text": "        .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },",
            "lineNumber": 983
          },
          {
            "text": "    } };",
            "lineNumber": 984
          },
          {
            "text": "    const float_plain = float_param.toPlain(0.75); // 0.75 normalized = 12.0 in [-24, 24] range",
            "lineNumber": 985
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 12.0), float_plain, 1e-4);",
            "lineNumber": 986
          },
          {
            "lineNumber": 987
          },
          {
            "text": "    // Int param",
            "lineNumber": 988
          },
          {
            "text": "    const int_param = Param{ .int = .{",
            "lineNumber": 989
          },
          {
            "text": "        .name = \"Cutoff\",",
            "lineNumber": 990
          },
          {
            "text": "        .id = \"cutoff\",",
            "lineNumber": 991
          },
          {
            "text": "        .default = 1000,",
            "lineNumber": 992
          },
          {
            "text": "        .range = .{ .min = 20, .max = 20000 },",
            "lineNumber": 993
          },
          {
            "text": "    } };",
            "lineNumber": 994
          },
          {
            "text": "    const int_plain = int_param.toPlain(0.5); // 0.5 normalized = ~10010 in [20, 20000] range",
            "lineNumber": 995
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 10010.0), int_plain, 1.0);",
            "lineNumber": 996
          },
          {
            "lineNumber": 997
          },
          {
            "text": "    // Boolean param",
            "lineNumber": 998
          },
          {
            "text": "    const bool_param = Param{ .boolean = .{",
            "lineNumber": 999
          },
          {
            "text": "        .name = \"Bypass\",",
            "lineNumber": 1000
          },
          {
            "text": "        .id = \"bypass\",",
            "lineNumber": 1001
          },
          {
            "text": "        .default = false,",
            "lineNumber": 1002
          },
          {
            "text": "    } };",
            "lineNumber": 1003
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.0), bool_param.toPlain(0.0), 1e-6);",
            "lineNumber": 1004
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), bool_param.toPlain(1.0), 1e-6);",
            "lineNumber": 1005
          },
          {
            "lineNumber": 1006
          },
          {
            "text": "    // Choice param",
            "lineNumber": 1007
          },
          {
            "text": "    const choice_param = Param{ .choice = .{",
            "lineNumber": 1008
          },
          {
            "text": "        .name = \"Mode\",",
            "lineNumber": 1009
          },
          {
            "text": "        .id = \"mode\",",
            "lineNumber": 1010
          },
          {
            "text": "        .default = 0,",
            "lineNumber": 1011
          },
          {
            "text": "        .labels = &amp;.{ \"Low\", \"Mid\", \"High\" },",
            "lineNumber": 1012
          },
          {
            "text": "    } };",
            "lineNumber": 1013
          },
          {
            "text": "    const choice_plain = choice_param.toPlain(0.5); // Middle choice",
            "lineNumber": 1014
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), choice_plain, 1e-6);",
            "lineNumber": 1015
          },
          {
            "text": "}",
            "lineNumber": 1016
          },
          {
            "lineNumber": 1017
          },
          {
            "text": "test \"LogFloatRange normalize and unnormalize roundtrip\" {",
            "lineNumber": 1018
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1019
          },
          {
            "text": "    const plain: f32 = 1000.0;",
            "lineNumber": 1020
          },
          {
            "text": "    const norm = range.normalize(plain);",
            "lineNumber": 1021
          },
          {
            "text": "    const back = range.unnormalize(norm);",
            "lineNumber": 1022
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(plain, back, 1e-3);",
            "lineNumber": 1023
          },
          {
            "text": "}",
            "lineNumber": 1024
          },
          {
            "lineNumber": 1025
          },
          {
            "text": "test \"LogFloatRange perceptually uniform\" {",
            "lineNumber": 1026
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1027
          }
        ]
      },
      "score": 0.2353251576423645
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 464
          },
          "endPosition": {
            "line": 493
          }
        },
        "contents": "    pub fn setTarget(self: *Smoother, sample_rate: f32, new_target: f32) void {\n        self.target = new_target;\n\n        switch (self.style) {\n            .none =&gt; {\n                self.current = new_target;\n                self.steps_left = 0;\n                self.step_size = 0.0;\n            },\n            .linear =&gt; |duration_ms| {\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                self.steps_left = @intFromFloat(@max(1.0, duration_samples));\n                const delta = self.target - self.current;\n                self.step_size = delta / @as(f32, @floatFromInt(self.steps_left));\n            },\n            .exponential =&gt; |duration_ms| {\n                // Single-pole IIR: y[n] = y[n-1] + coeff * (target - y[n-1])\n                // We want to reach ~99.99% in duration_samples\n                // After N steps: remaining = (1 - coeff)^N ≈ 0.0001\n                // coeff = 1 - exp(ln(0.0001) / N)\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                const n = @max(1.0, duration_samples);\n                const ln_remaining = @log(0.0001);\n                self.step_size = 1.0 - @exp(ln_remaining / n);\n                // For exponential, steps_left is just a sentinel until we snap\n                self.steps_left = @intFromFloat(n);\n            },\n            .logarithmic =&gt; |duration_ms| {\n                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub fn setTarget(self: *Smoother, sample_rate: f32, new_target: f32) void {",
            "lineNumber": 465
          },
          {
            "text": "        self.target = new_target;",
            "lineNumber": 466
          },
          {
            "lineNumber": 467
          },
          {
            "text": "        switch (self.style) {",
            "lineNumber": 468
          },
          {
            "text": "            .none =&gt; {",
            "lineNumber": 469
          },
          {
            "text": "                self.current = new_target;",
            "lineNumber": 470
          },
          {
            "text": "                self.steps_left = 0;",
            "lineNumber": 471
          },
          {
            "text": "                self.step_size = 0.0;",
            "lineNumber": 472
          },
          {
            "text": "            },",
            "lineNumber": 473
          },
          {
            "text": "            .linear =&gt; |duration_ms| {",
            "lineNumber": 474
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 475
          },
          {
            "text": "                self.steps_left = @intFromFloat(@max(1.0, duration_samples));",
            "lineNumber": 476
          },
          {
            "text": "                const delta = self.target - self.current;",
            "lineNumber": 477
          },
          {
            "text": "                self.step_size = delta / @as(f32, @floatFromInt(self.steps_left));",
            "lineNumber": 478
          },
          {
            "text": "            },",
            "lineNumber": 479
          },
          {
            "text": "            .exponential =&gt; |duration_ms| {",
            "lineNumber": 480
          },
          {
            "text": "                // Single-pole IIR: y[n] = y[n-1] + coeff * (target - y[n-1])",
            "lineNumber": 481
          },
          {
            "text": "                // We want to reach ~99.99% in duration_samples",
            "lineNumber": 482
          },
          {
            "text": "                // After N steps: remaining = (1 - coeff)^N ≈ 0.0001",
            "lineNumber": 483
          },
          {
            "text": "                // coeff = 1 - exp(ln(0.0001) / N)",
            "lineNumber": 484
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 485
          },
          {
            "text": "                const n = @max(1.0, duration_samples);",
            "lineNumber": 486
          },
          {
            "text": "                const ln_remaining = @log(0.0001);",
            "lineNumber": 487
          },
          {
            "text": "                self.step_size = 1.0 - @exp(ln_remaining / n);",
            "lineNumber": 488
          },
          {
            "text": "                // For exponential, steps_left is just a sentinel until we snap",
            "lineNumber": 489
          },
          {
            "text": "                self.steps_left = @intFromFloat(n);",
            "lineNumber": 490
          },
          {
            "text": "            },",
            "lineNumber": 491
          },
          {
            "text": "            .logarithmic =&gt; |duration_ms| {",
            "lineNumber": 492
          },
          {
            "text": "                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
            "lineNumber": 493
          }
        ]
      },
      "score": 0.23411299288272858
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 227
          },
          "endPosition": {
            "line": 271,
            "column": 16
          }
        },
        "contents": "        fn getParamValueByString(\n            _: *anyopaque,\n            _: vst3.types.ParamID,\n            _: *vst3.types.char16,\n            _: *vst3.types.ParamValue,\n        ) callconv(.c) vst3.tresult {\n            // TODO: Implement string-to-value parsing\n            return vst3.types.kNotImplemented;\n        }\n\n        fn normalizedParamToPlain(\n            _: *anyopaque,\n            id: vst3.types.ParamID,\n            value_normalized: vst3.types.ParamValue,\n        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    return switch (param) {\n                        .float =&gt; |p| switch (p.range) {\n                            .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                            .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                        },\n                        .int =&gt; |p| @floatFromInt(p.range.unnormalize(@floatCast(value_normalized))),\n                        .boolean =&gt; value_normalized,\n                        .choice =&gt; |p| blk: {\n                            const idx = @as(u32, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n                            break :blk @floatFromInt(idx);\n                        },\n                    };\n                }\n            }\n\n            return value_normalized;\n        }\n\n        fn plainParamToNormalized(\n            _: *anyopaque,\n            id: vst3.types.ParamID,\n            plain_value: vst3.types.ParamValue,\n        ) callconv(.c) vst3.types.ParamValue {\n            // Find parameter by ID\n            for (P.params, 0..) |param, i| {\n                ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        fn getParamValueByString(",
            "lineNumber": 228
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 229
          },
          {
            "text": "            _: vst3.types.ParamID,",
            "lineNumber": 230
          },
          {
            "text": "            _: *vst3.types.char16,",
            "lineNumber": 231
          },
          {
            "text": "            _: *vst3.types.ParamValue,",
            "lineNumber": 232
          },
          {
            "text": "        ) callconv(.c) vst3.tresult {",
            "lineNumber": 233
          },
          {
            "text": "            // TODO: Implement string-to-value parsing",
            "lineNumber": 234
          },
          {
            "text": "            return vst3.types.kNotImplemented;",
            "lineNumber": 235
          },
          {
            "text": "        }",
            "lineNumber": 236
          },
          {
            "lineNumber": 237
          },
          {
            "text": "        fn normalizedParamToPlain(",
            "lineNumber": 238
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 239
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 240
          },
          {
            "text": "            value_normalized: vst3.types.ParamValue,",
            "lineNumber": 241
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 242
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 243
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 244
          },
          {
            "text": "                const param_id = P.param_ids[i];",
            "lineNumber": 245
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 246
          },
          {
            "text": "                    return switch (param) {",
            "lineNumber": 247
          },
          {
            "text": "                        .float =&gt; |p| switch (p.range) {",
            "lineNumber": 248
          },
          {
            "text": "                            .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 249
          },
          {
            "text": "                            .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 250
          },
          {
            "text": "                        },",
            "lineNumber": 251
          },
          {
            "text": "                        .int =&gt; |p| @floatFromInt(p.range.unnormalize(@floatCast(value_normalized))),",
            "lineNumber": 252
          },
          {
            "text": "                        .boolean =&gt; value_normalized,",
            "lineNumber": 253
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 254
          },
          {
            "text": "                            const idx = @as(u32, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 255
          },
          {
            "text": "                            break :blk @floatFromInt(idx);",
            "lineNumber": 256
          },
          {
            "text": "                        },",
            "lineNumber": 257
          },
          {
            "text": "                    };",
            "lineNumber": 258
          },
          {
            "text": "                }",
            "lineNumber": 259
          },
          {
            "text": "            }",
            "lineNumber": 260
          },
          {
            "lineNumber": 261
          },
          {
            "text": "            return value_normalized;",
            "lineNumber": 262
          },
          {
            "text": "        }",
            "lineNumber": 263
          },
          {
            "lineNumber": 264
          },
          {
            "text": "        fn plainParamToNormalized(",
            "lineNumber": 265
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 266
          },
          {
            "text": "            id: vst3.types.ParamID,",
            "lineNumber": 267
          },
          {
            "text": "            plain_value: vst3.types.ParamValue,",
            "lineNumber": 268
          },
          {
            "text": "        ) callconv(.c) vst3.types.ParamValue {",
            "lineNumber": 269
          },
          {
            "text": "            // Find parameter by ID",
            "lineNumber": 270
          },
          {
            "text": "            for (P.params, 0..) |param, i| {",
            "lineNumber": 271
          },
          {
            "text": "                ",
            "lineNumber": 272
          }
        ]
      },
      "score": 0.23158550262451172
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 491
          },
          "endPosition": {
            "line": 516
          }
        },
        "contents": "            .logarithmic =&gt; |duration_ms| {\n                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step\n                // Requires both current and target to be positive\n                if (self.current &lt;= 0.0 or new_target &lt;= 0.0) {\n                    // Fallback to linear if either value is non-positive\n                    self.current = new_target;\n                    self.steps_left = 0;\n                    self.step_size = 0.0;\n                    return;\n                }\n\n                const duration_samples = (sample_rate * duration_ms) / 1000.0;\n                self.steps_left = @intFromFloat(@max(1.0, duration_samples));\n                const log_delta = @log(self.target) - @log(self.current);\n                self.step_size = log_delta / @as(f32, @floatFromInt(self.steps_left));\n            },\n        }\n    }\n\n    /// Get the next smoothed sample value and advance the smoother.\n    pub inline fn next(self: *Smoother) f32 {\n        if (self.steps_left == 0) {\n            return self.current;\n        }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "            .logarithmic =&gt; |duration_ms| {",
            "lineNumber": 492
          },
          {
            "text": "                // Interpolate in log space: log(y[n]) = log(y[n-1]) + step",
            "lineNumber": 493
          },
          {
            "text": "                // Requires both current and target to be positive",
            "lineNumber": 494
          },
          {
            "text": "                if (self.current &lt;= 0.0 or new_target &lt;= 0.0) {",
            "lineNumber": 495
          },
          {
            "text": "                    // Fallback to linear if either value is non-positive",
            "lineNumber": 496
          },
          {
            "text": "                    self.current = new_target;",
            "lineNumber": 497
          },
          {
            "text": "                    self.steps_left = 0;",
            "lineNumber": 498
          },
          {
            "text": "                    self.step_size = 0.0;",
            "lineNumber": 499
          },
          {
            "text": "                    return;",
            "lineNumber": 500
          },
          {
            "text": "                }",
            "lineNumber": 501
          },
          {
            "lineNumber": 502
          },
          {
            "text": "                const duration_samples = (sample_rate * duration_ms) / 1000.0;",
            "lineNumber": 503
          },
          {
            "text": "                self.steps_left = @intFromFloat(@max(1.0, duration_samples));",
            "lineNumber": 504
          },
          {
            "text": "                const log_delta = @log(self.target) - @log(self.current);",
            "lineNumber": 505
          },
          {
            "text": "                self.step_size = log_delta / @as(f32, @floatFromInt(self.steps_left));",
            "lineNumber": 506
          },
          {
            "text": "            },",
            "lineNumber": 507
          },
          {
            "text": "        }",
            "lineNumber": 508
          },
          {
            "text": "    }",
            "lineNumber": 509
          },
          {
            "lineNumber": 510
          },
          {
            "text": "    /// Get the next smoothed sample value and advance the smoother.",
            "lineNumber": 511
          },
          {
            "text": "    pub inline fn next(self: *Smoother) f32 {",
            "lineNumber": 512
          },
          {
            "text": "        if (self.steps_left == 0) {",
            "lineNumber": 513
          },
          {
            "text": "            return self.current;",
            "lineNumber": 514
          },
          {
            "text": "        }",
            "lineNumber": 515
          }
        ]
      },
      "score": 0.22995305061340332
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./docs/plugin-authors.md",
        "range": {
          "startPosition": {
            "line": 448
          },
          "endPosition": {
            "line": 498
          }
        },
        "contents": "const GainPlugin = struct {\n    // Required metadata\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n    \n    // Audio configuration: stereo in/out\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n    \n    // Parameters: one gain parameter with linear smoothing\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .min = 0.0, .max = 2.0 },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing\n        } },\n    };\n    \n    // No internal state needed for this simple plugin\n    \n    /// Initialize the plugin with the selected audio layout and buffer config.\n    pub fn init(\n        _: *@This(),\n        _: *const z_plug.AudioIOLayout,\n        _: *const z_plug.BufferConfig,\n    ) bool {\n        return true;\n    }\n    \n    /// Clean up plugin resources.\n    pub fn deinit(_: *@This()) void {\n        // No cleanup needed\n    }\n    \n    /// Process audio.\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 449
          },
          {
            "text": "    // Required metadata",
            "lineNumber": 450
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 451
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 452
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 453
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 454
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 455
          },
          {
            "text": "    ",
            "lineNumber": 456
          },
          {
            "text": "    // Audio configuration: stereo in/out",
            "lineNumber": 457
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 458
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 459
          },
          {
            "text": "    };",
            "lineNumber": 460
          },
          {
            "text": "    ",
            "lineNumber": 461
          },
          {
            "text": "    // Parameters: one gain parameter with linear smoothing",
            "lineNumber": 462
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 463
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 464
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 465
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 466
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 467
          },
          {
            "text": "            .range = .{ .min = 0.0, .max = 2.0 },",
            "lineNumber": 468
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 469
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 470
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },  // 10ms linear smoothing",
            "lineNumber": 471
          },
          {
            "text": "        } },",
            "lineNumber": 472
          },
          {
            "text": "    };",
            "lineNumber": 473
          },
          {
            "text": "    ",
            "lineNumber": 474
          },
          {
            "text": "    // No internal state needed for this simple plugin",
            "lineNumber": 475
          },
          {
            "text": "    ",
            "lineNumber": 476
          },
          {
            "text": "    /// Initialize the plugin with the selected audio layout and buffer config.",
            "lineNumber": 477
          },
          {
            "text": "    pub fn init(",
            "lineNumber": 478
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 479
          },
          {
            "text": "        _: *const z_plug.AudioIOLayout,",
            "lineNumber": 480
          },
          {
            "text": "        _: *const z_plug.BufferConfig,",
            "lineNumber": 481
          },
          {
            "text": "    ) bool {",
            "lineNumber": 482
          },
          {
            "text": "        return true;",
            "lineNumber": 483
          },
          {
            "text": "    }",
            "lineNumber": 484
          },
          {
            "text": "    ",
            "lineNumber": 485
          },
          {
            "text": "    /// Clean up plugin resources.",
            "lineNumber": 486
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {",
            "lineNumber": 487
          },
          {
            "text": "        // No cleanup needed",
            "lineNumber": 488
          },
          {
            "text": "    }",
            "lineNumber": 489
          },
          {
            "text": "    ",
            "lineNumber": 490
          },
          {
            "text": "    /// Process audio.",
            "lineNumber": 491
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 492
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 493
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 494
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 495
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 496
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 497
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 498
          }
        ]
      },
      "score": 0.2293405532836914
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 340
          },
          "endPosition": {
            "line": 387
          }
        },
        "contents": "pub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {\n    return struct {\n        const Self = @This();\n\n        values: *ParamValues(N),\n        smoothers: *SmootherBank(N),\n\n        /// Get the current plain value of a float parameter (no smoothing).\n        pub fn getFloat(self: *const Self, comptime index: usize) f32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .float) @compileError(\"Parameter at index is not a float\");\n            }\n\n            const normalized = self.values.get(index);\n            return switch (params_meta[index].float.range) {\n                .linear =&gt; |r| r.unnormalize(normalized),\n                .logarithmic =&gt; |r| r.unnormalize(normalized),\n            };\n        }\n\n        /// Get the current plain value of an int parameter.\n        pub fn getInt(self: *const Self, comptime index: usize) i32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .int) @compileError(\"Parameter at index is not an int\");\n            }\n\n            const normalized = self.values.get(index);\n            return params_meta[index].int.range.unnormalize(normalized);\n        }\n\n        /// Get the current value of a bool parameter.\n        pub fn getBool(self: *const Self, comptime index: usize) bool {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");\n                if (params_meta[index] != .boolean) @compileError(\"Parameter at index is not a boolean\");\n            }\n\n            const normalized = self.values.get(index);\n            return normalized &gt; 0.5;\n        }\n\n        /// Get the current choice index of a choice parameter.\n        pub fn getChoice(self: *const Self, comptime index: usize) u32 {\n            comptime {\n                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {",
            "lineNumber": 341
          },
          {
            "text": "    return struct {",
            "lineNumber": 342
          },
          {
            "text": "        const Self = @This();",
            "lineNumber": 343
          },
          {
            "lineNumber": 344
          },
          {
            "text": "        values: *ParamValues(N),",
            "lineNumber": 345
          },
          {
            "text": "        smoothers: *SmootherBank(N),",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "        /// Get the current plain value of a float parameter (no smoothing).",
            "lineNumber": 348
          },
          {
            "text": "        pub fn getFloat(self: *const Self, comptime index: usize) f32 {",
            "lineNumber": 349
          },
          {
            "text": "            comptime {",
            "lineNumber": 350
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 351
          },
          {
            "text": "                if (params_meta[index] != .float) @compileError(\"Parameter at index is not a float\");",
            "lineNumber": 352
          },
          {
            "text": "            }",
            "lineNumber": 353
          },
          {
            "lineNumber": 354
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 355
          },
          {
            "text": "            return switch (params_meta[index].float.range) {",
            "lineNumber": 356
          },
          {
            "text": "                .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 357
          },
          {
            "text": "                .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 358
          },
          {
            "text": "            };",
            "lineNumber": 359
          },
          {
            "text": "        }",
            "lineNumber": 360
          },
          {
            "lineNumber": 361
          },
          {
            "text": "        /// Get the current plain value of an int parameter.",
            "lineNumber": 362
          },
          {
            "text": "        pub fn getInt(self: *const Self, comptime index: usize) i32 {",
            "lineNumber": 363
          },
          {
            "text": "            comptime {",
            "lineNumber": 364
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 365
          },
          {
            "text": "                if (params_meta[index] != .int) @compileError(\"Parameter at index is not an int\");",
            "lineNumber": 366
          },
          {
            "text": "            }",
            "lineNumber": 367
          },
          {
            "lineNumber": 368
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 369
          },
          {
            "text": "            return params_meta[index].int.range.unnormalize(normalized);",
            "lineNumber": 370
          },
          {
            "text": "        }",
            "lineNumber": 371
          },
          {
            "lineNumber": 372
          },
          {
            "text": "        /// Get the current value of a bool parameter.",
            "lineNumber": 373
          },
          {
            "text": "        pub fn getBool(self: *const Self, comptime index: usize) bool {",
            "lineNumber": 374
          },
          {
            "text": "            comptime {",
            "lineNumber": 375
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 376
          },
          {
            "text": "                if (params_meta[index] != .boolean) @compileError(\"Parameter at index is not a boolean\");",
            "lineNumber": 377
          },
          {
            "text": "            }",
            "lineNumber": 378
          },
          {
            "lineNumber": 379
          },
          {
            "text": "            const normalized = self.values.get(index);",
            "lineNumber": 380
          },
          {
            "text": "            return normalized &gt; 0.5;",
            "lineNumber": 381
          },
          {
            "text": "        }",
            "lineNumber": 382
          },
          {
            "lineNumber": 383
          },
          {
            "text": "        /// Get the current choice index of a choice parameter.",
            "lineNumber": 384
          },
          {
            "text": "        pub fn getChoice(self: *const Self, comptime index: usize) u32 {",
            "lineNumber": 385
          },
          {
            "text": "            comptime {",
            "lineNumber": 386
          },
          {
            "text": "                if (index &gt;= N) @compileError(\"Parameter index out of bounds\");",
            "lineNumber": 387
          }
        ]
      },
      "score": 0.22710764408111572
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 64
          },
          "endPosition": {
            "line": 119
          }
        },
        "contents": "/// A discrete integer parameter range.\npub const IntRange = struct {\n    min: i32,\n    max: i32,\n\n    /// Map a plain integer value to the normalized 0.0–1.0 range.\n    pub fn normalize(self: IntRange, plain: i32) f32 {\n        if (self.max == self.min) return 0.0;\n        const clamped = self.clamp(plain);\n        return @as(f32, @floatFromInt(clamped - self.min)) /\n            @as(f32, @floatFromInt(self.max - self.min));\n    }\n\n    /// Map a normalized 0.0–1.0 value back to a plain integer (rounded).\n    pub fn unnormalize(self: IntRange, normalized: f32) i32 {\n        const clamped = std.math.clamp(normalized, 0.0, 1.0);\n        const span: f32 = @floatFromInt(self.max - self.min);\n        return self.min + @as(i32, @intFromFloat(@round(clamped * span)));\n    }\n\n    /// Clamp a plain integer value to the range [min, max].\n    pub fn clamp(self: IntRange, value: i32) i32 {\n        return std.math.clamp(value, self.min, self.max);\n    }\n\n    /// The number of discrete steps in this range (max - min).\n    pub fn stepCount(self: IntRange) u32 {\n        return @intCast(self.max - self.min);\n    }\n};\n\n// ---------------------------------------------------------------------------\n// Flags\n// ---------------------------------------------------------------------------\n\n/// Flags that control how a parameter is exposed to the host.\npub const ParamFlags = packed struct {\n    /// Whether the host can automate this parameter. Default: &#96;true&#96;.\n    automatable: bool = true,\n    /// Whether the parameter supports per-voice modulation (CLAP).\n    modulatable: bool = false,\n    /// Hide this parameter from the host's generic parameter list.\n    hidden: bool = false,\n    /// Mark this parameter as the plugin's bypass control.\n    bypass: bool = false,\n    /// Hint that the parameter is stepped (e.g. switches, choices).\n    is_stepped: bool = false,\n    _padding: u3 = 0,\n};\n\n// ---------------------------------------------------------------------------\n// Parameter declarations (comptime)\n// ---------------------------------------------------------------------------\n\n/// A continuous floating-point parameter.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// A discrete integer parameter range.",
            "lineNumber": 65
          },
          {
            "text": "pub const IntRange = struct {",
            "lineNumber": 66
          },
          {
            "text": "    min: i32,",
            "lineNumber": 67
          },
          {
            "text": "    max: i32,",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "    /// Map a plain integer value to the normalized 0.0–1.0 range.",
            "lineNumber": 70
          },
          {
            "text": "    pub fn normalize(self: IntRange, plain: i32) f32 {",
            "lineNumber": 71
          },
          {
            "text": "        if (self.max == self.min) return 0.0;",
            "lineNumber": 72
          },
          {
            "text": "        const clamped = self.clamp(plain);",
            "lineNumber": 73
          },
          {
            "text": "        return @as(f32, @floatFromInt(clamped - self.min)) /",
            "lineNumber": 74
          },
          {
            "text": "            @as(f32, @floatFromInt(self.max - self.min));",
            "lineNumber": 75
          },
          {
            "text": "    }",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "    /// Map a normalized 0.0–1.0 value back to a plain integer (rounded).",
            "lineNumber": 78
          },
          {
            "text": "    pub fn unnormalize(self: IntRange, normalized: f32) i32 {",
            "lineNumber": 79
          },
          {
            "text": "        const clamped = std.math.clamp(normalized, 0.0, 1.0);",
            "lineNumber": 80
          },
          {
            "text": "        const span: f32 = @floatFromInt(self.max - self.min);",
            "lineNumber": 81
          },
          {
            "text": "        return self.min + @as(i32, @intFromFloat(@round(clamped * span)));",
            "lineNumber": 82
          },
          {
            "text": "    }",
            "lineNumber": 83
          },
          {
            "lineNumber": 84
          },
          {
            "text": "    /// Clamp a plain integer value to the range [min, max].",
            "lineNumber": 85
          },
          {
            "text": "    pub fn clamp(self: IntRange, value: i32) i32 {",
            "lineNumber": 86
          },
          {
            "text": "        return std.math.clamp(value, self.min, self.max);",
            "lineNumber": 87
          },
          {
            "text": "    }",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "    /// The number of discrete steps in this range (max - min).",
            "lineNumber": 90
          },
          {
            "text": "    pub fn stepCount(self: IntRange) u32 {",
            "lineNumber": 91
          },
          {
            "text": "        return @intCast(self.max - self.min);",
            "lineNumber": 92
          },
          {
            "text": "    }",
            "lineNumber": 93
          },
          {
            "text": "};",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 96
          },
          {
            "text": "// Flags",
            "lineNumber": 97
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 98
          },
          {
            "lineNumber": 99
          },
          {
            "text": "/// Flags that control how a parameter is exposed to the host.",
            "lineNumber": 100
          },
          {
            "text": "pub const ParamFlags = packed struct {",
            "lineNumber": 101
          },
          {
            "text": "    /// Whether the host can automate this parameter. Default: &#96;true&#96;.",
            "lineNumber": 102
          },
          {
            "text": "    automatable: bool = true,",
            "lineNumber": 103
          },
          {
            "text": "    /// Whether the parameter supports per-voice modulation (CLAP).",
            "lineNumber": 104
          },
          {
            "text": "    modulatable: bool = false,",
            "lineNumber": 105
          },
          {
            "text": "    /// Hide this parameter from the host's generic parameter list.",
            "lineNumber": 106
          },
          {
            "text": "    hidden: bool = false,",
            "lineNumber": 107
          },
          {
            "text": "    /// Mark this parameter as the plugin's bypass control.",
            "lineNumber": 108
          },
          {
            "text": "    bypass: bool = false,",
            "lineNumber": 109
          },
          {
            "text": "    /// Hint that the parameter is stepped (e.g. switches, choices).",
            "lineNumber": 110
          },
          {
            "text": "    is_stepped: bool = false,",
            "lineNumber": 111
          },
          {
            "text": "    _padding: u3 = 0,",
            "lineNumber": 112
          },
          {
            "text": "};",
            "lineNumber": 113
          },
          {
            "lineNumber": 114
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 115
          },
          {
            "text": "// Parameter declarations (comptime)",
            "lineNumber": 116
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "/// A continuous floating-point parameter.",
            "lineNumber": 119
          }
        ]
      },
      "score": 0.22451600432395935
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/plugin.zig",
        "range": {
          "startPosition": {
            "line": 60
          },
          "endPosition": {
            "line": 104,
            "column": 8
          }
        },
        "contents": "pub const ProcessContext = struct {\n    /// Current transport state and timeline info.\n    transport: Transport,\n    /// Incoming note/MIDI events for this buffer, pre-sorted by timing.\n    input_events: []const NoteEvent,\n    /// Output event list for sending events back to the host.\n    output_events: *EventOutputList,\n    /// The host's current sample rate in Hz.\n    sample_rate: f32,\n\n    // Parameter access (opaque pointers to avoid making ProcessContext generic)\n    param_values_ptr: ?*anyopaque = null,\n    smoothers_ptr: ?*anyopaque = null,\n    params_meta: []const Param = &amp;[_]Param{},\n\n    /// Get the current plain value of a float parameter at comptime-known index.\n    /// N is the total number of parameters.\n    pub fn getFloat(self: *const ProcessContext, comptime N: usize, comptime index: usize) f32 {\n        const param = self.params_meta[index];\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return switch (param.float.range) {\n            .linear =&gt; |r| r.unnormalize(normalized),\n            .logarithmic =&gt; |r| r.unnormalize(normalized),\n        };\n    }\n\n    /// Get the current plain value of an int parameter at comptime-known index.\n    pub fn getInt(self: *const ProcessContext, comptime N: usize, comptime index: usize) i32 {\n        const param = self.params_meta[index];\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return param.int.range.unnormalize(normalized);\n    }\n\n    /// Get the current value of a bool parameter at comptime-known index.\n    pub fn getBool(self: *const ProcessContext, comptime N: usize, comptime index: usize) bool {\n        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));\n        const normalized = values.get(index);\n        return normalized &gt; 0.5;\n    }\n\n    /// Get the current choice index of a choice parameter at comptime-known index.\n    pub fn getChoice(self: *const ProcessContext, comptime N: usize, comptime index: usize) u32 {\n        ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub const ProcessContext = struct {",
            "lineNumber": 61
          },
          {
            "text": "    /// Current transport state and timeline info.",
            "lineNumber": 62
          },
          {
            "text": "    transport: Transport,",
            "lineNumber": 63
          },
          {
            "text": "    /// Incoming note/MIDI events for this buffer, pre-sorted by timing.",
            "lineNumber": 64
          },
          {
            "text": "    input_events: []const NoteEvent,",
            "lineNumber": 65
          },
          {
            "text": "    /// Output event list for sending events back to the host.",
            "lineNumber": 66
          },
          {
            "text": "    output_events: *EventOutputList,",
            "lineNumber": 67
          },
          {
            "text": "    /// The host's current sample rate in Hz.",
            "lineNumber": 68
          },
          {
            "text": "    sample_rate: f32,",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "    // Parameter access (opaque pointers to avoid making ProcessContext generic)",
            "lineNumber": 71
          },
          {
            "text": "    param_values_ptr: ?*anyopaque = null,",
            "lineNumber": 72
          },
          {
            "text": "    smoothers_ptr: ?*anyopaque = null,",
            "lineNumber": 73
          },
          {
            "text": "    params_meta: []const Param = &amp;[_]Param{},",
            "lineNumber": 74
          },
          {
            "lineNumber": 75
          },
          {
            "text": "    /// Get the current plain value of a float parameter at comptime-known index.",
            "lineNumber": 76
          },
          {
            "text": "    /// N is the total number of parameters.",
            "lineNumber": 77
          },
          {
            "text": "    pub fn getFloat(self: *const ProcessContext, comptime N: usize, comptime index: usize) f32 {",
            "lineNumber": 78
          },
          {
            "text": "        const param = self.params_meta[index];",
            "lineNumber": 79
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 80
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 81
          },
          {
            "text": "        return switch (param.float.range) {",
            "lineNumber": 82
          },
          {
            "text": "            .linear =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 83
          },
          {
            "text": "            .logarithmic =&gt; |r| r.unnormalize(normalized),",
            "lineNumber": 84
          },
          {
            "text": "        };",
            "lineNumber": 85
          },
          {
            "text": "    }",
            "lineNumber": 86
          },
          {
            "lineNumber": 87
          },
          {
            "text": "    /// Get the current plain value of an int parameter at comptime-known index.",
            "lineNumber": 88
          },
          {
            "text": "    pub fn getInt(self: *const ProcessContext, comptime N: usize, comptime index: usize) i32 {",
            "lineNumber": 89
          },
          {
            "text": "        const param = self.params_meta[index];",
            "lineNumber": 90
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 91
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 92
          },
          {
            "text": "        return param.int.range.unnormalize(normalized);",
            "lineNumber": 93
          },
          {
            "text": "    }",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "    /// Get the current value of a bool parameter at comptime-known index.",
            "lineNumber": 96
          },
          {
            "text": "    pub fn getBool(self: *const ProcessContext, comptime N: usize, comptime index: usize) bool {",
            "lineNumber": 97
          },
          {
            "text": "        const values: *const params_mod.ParamValues(N) = @ptrCast(@alignCast(self.param_values_ptr));",
            "lineNumber": 98
          },
          {
            "text": "        const normalized = values.get(index);",
            "lineNumber": 99
          },
          {
            "text": "        return normalized &gt; 0.5;",
            "lineNumber": 100
          },
          {
            "text": "    }",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "    /// Get the current choice index of a choice parameter at comptime-known index.",
            "lineNumber": 103
          },
          {
            "text": "    pub fn getChoice(self: *const ProcessContext, comptime N: usize, comptime index: usize) u32 {",
            "lineNumber": 104
          },
          {
            "text": "        ",
            "lineNumber": 105
          }
        ]
      },
      "score": 0.2132941484451294
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./README.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 75
          }
        },
        "contents": "# z-plug\n\nAudio plugin framework for Zig. Write a plugin once, get VST3 and CLAP binaries from the same source. Inspired by [nih-plug](https://github.com/robbert-vdh/nih-plug).\n\nRequires Zig 0.15.2.\n\n## Example\n\nA minimal gain plugin (&#96;examples/gain.zig&#96;):\n\n&#96;&#96;&#96;zig\nconst z_plug = @import(\"z_plug\");\n\nconst GainPlugin = struct {\n    pub const name: [:0]const u8 = \"Zig Gain\";\n    pub const vendor: [:0]const u8 = \"zig-plug\";\n    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";\n    pub const version: [:0]const u8 = \"0.1.0\";\n    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";\n\n    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{\n        z_plug.AudioIOLayout.STEREO,\n    };\n\n    pub const params = &amp;[_]z_plug.Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 1.0,\n            .range = .{ .min = 0.0, .max = 2.0 },\n            .unit = \"\",\n            .flags = .{},\n            .smoothing = .{ .linear = 10.0 },\n        } },\n    };\n\n    pub fn init(_: *@This(), _: *const z_plug.AudioIOLayout, _: *const z_plug.BufferConfig) bool {\n        return true;\n    }\n\n    pub fn deinit(_: *@This()) void {}\n\n    pub fn process(\n        _: *@This(),\n        buffer: *z_plug.Buffer,\n        _: *z_plug.AuxBuffers,\n        context: *z_plug.ProcessContext,\n    ) z_plug.ProcessStatus {\n        const num_samples = buffer.num_samples;\n        const num_channels = buffer.channel_data.len;\n\n        var i: usize = 0;\n        while (i &lt; num_samples) : (i += 1) {\n            const gain = context.nextSmoothed(1, 0);\n            for (buffer.channel_data[0..num_channels]) |channel| {\n                channel[i] *= gain;\n            }\n        }\n\n        return z_plug.ProcessStatus.ok();\n    }\n};\n\n// Export both formats\ncomptime {\n    _ = z_plug.ClapEntry(GainPlugin);\n    _ = z_plug.Vst3Factory(GainPlugin);\n}\n&#96;&#96;&#96;\n\nPlugin metadata, parameters, and audio layout are declared as comptime constants. The framework uses them to generate vtables, parameter lists, GUIDs, and lookup tables at compile time. No allocations happen on the audio thread.\n\n## Building\n\nThe &#96;flake.nix&#96; provides a dev environment with the right Zig version via Nix + direnv.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# z-plug",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "Audio plugin framework for Zig. Write a plugin once, get VST3 and CLAP binaries from the same source. Inspired by [nih-plug](https://github.com/robbert-vdh/nih-plug).",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "Requires Zig 0.15.2.",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "## Example",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "A minimal gain plugin (&#96;examples/gain.zig&#96;):",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "&#96;&#96;&#96;zig",
            "lineNumber": 11
          },
          {
            "text": "const z_plug = @import(\"z_plug\");",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "const GainPlugin = struct {",
            "lineNumber": 14
          },
          {
            "text": "    pub const name: [:0]const u8 = \"Zig Gain\";",
            "lineNumber": 15
          },
          {
            "text": "    pub const vendor: [:0]const u8 = \"zig-plug\";",
            "lineNumber": 16
          },
          {
            "text": "    pub const url: [:0]const u8 = \"https://github.com/example/zig-plug\";",
            "lineNumber": 17
          },
          {
            "text": "    pub const version: [:0]const u8 = \"0.1.0\";",
            "lineNumber": 18
          },
          {
            "text": "    pub const plugin_id: [:0]const u8 = \"com.zig-plug.gain\";",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "    pub const audio_io_layouts = &amp;[_]z_plug.AudioIOLayout{",
            "lineNumber": 21
          },
          {
            "text": "        z_plug.AudioIOLayout.STEREO,",
            "lineNumber": 22
          },
          {
            "text": "    };",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "    pub const params = &amp;[_]z_plug.Param{",
            "lineNumber": 25
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 26
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 27
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 28
          },
          {
            "text": "            .default = 1.0,",
            "lineNumber": 29
          },
          {
            "text": "            .range = .{ .min = 0.0, .max = 2.0 },",
            "lineNumber": 30
          },
          {
            "text": "            .unit = \"\",",
            "lineNumber": 31
          },
          {
            "text": "            .flags = .{},",
            "lineNumber": 32
          },
          {
            "text": "            .smoothing = .{ .linear = 10.0 },",
            "lineNumber": 33
          },
          {
            "text": "        } },",
            "lineNumber": 34
          },
          {
            "text": "    };",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "    pub fn init(_: *@This(), _: *const z_plug.AudioIOLayout, _: *const z_plug.BufferConfig) bool {",
            "lineNumber": 37
          },
          {
            "text": "        return true;",
            "lineNumber": 38
          },
          {
            "text": "    }",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "    pub fn deinit(_: *@This()) void {}",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "    pub fn process(",
            "lineNumber": 43
          },
          {
            "text": "        _: *@This(),",
            "lineNumber": 44
          },
          {
            "text": "        buffer: *z_plug.Buffer,",
            "lineNumber": 45
          },
          {
            "text": "        _: *z_plug.AuxBuffers,",
            "lineNumber": 46
          },
          {
            "text": "        context: *z_plug.ProcessContext,",
            "lineNumber": 47
          },
          {
            "text": "    ) z_plug.ProcessStatus {",
            "lineNumber": 48
          },
          {
            "text": "        const num_samples = buffer.num_samples;",
            "lineNumber": 49
          },
          {
            "text": "        const num_channels = buffer.channel_data.len;",
            "lineNumber": 50
          },
          {
            "lineNumber": 51
          },
          {
            "text": "        var i: usize = 0;",
            "lineNumber": 52
          },
          {
            "text": "        while (i &lt; num_samples) : (i += 1) {",
            "lineNumber": 53
          },
          {
            "text": "            const gain = context.nextSmoothed(1, 0);",
            "lineNumber": 54
          },
          {
            "text": "            for (buffer.channel_data[0..num_channels]) |channel| {",
            "lineNumber": 55
          },
          {
            "text": "                channel[i] *= gain;",
            "lineNumber": 56
          },
          {
            "text": "            }",
            "lineNumber": 57
          },
          {
            "text": "        }",
            "lineNumber": 58
          },
          {
            "lineNumber": 59
          },
          {
            "text": "        return z_plug.ProcessStatus.ok();",
            "lineNumber": 60
          },
          {
            "text": "    }",
            "lineNumber": 61
          },
          {
            "text": "};",
            "lineNumber": 62
          },
          {
            "lineNumber": 63
          },
          {
            "text": "// Export both formats",
            "lineNumber": 64
          },
          {
            "text": "comptime {",
            "lineNumber": 65
          },
          {
            "text": "    _ = z_plug.ClapEntry(GainPlugin);",
            "lineNumber": 66
          },
          {
            "text": "    _ = z_plug.Vst3Factory(GainPlugin);",
            "lineNumber": 67
          },
          {
            "text": "}",
            "lineNumber": 68
          },
          {
            "text": "&#96;&#96;&#96;",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "Plugin metadata, parameters, and audio layout are declared as comptime constants. The framework uses them to generate vtables, parameter lists, GUIDs, and lookup tables at compile time. No allocations happen on the audio thread.",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "## Building",
            "lineNumber": 73
          },
          {
            "lineNumber": 74
          },
          {
            "text": "The &#96;flake.nix&#96; provides a dev environment with the right Zig version via Nix + direnv.",
            "lineNumber": 75
          }
        ]
      },
      "score": 0.2075033038854599
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 511
          },
          "endPosition": {
            "line": 555
          }
        },
        "contents": "    pub inline fn next(self: *Smoother) f32 {\n        if (self.steps_left == 0) {\n            return self.current;\n        }\n\n        switch (self.style) {\n            .none =&gt; {\n                return self.current;\n            },\n            .linear =&gt; {\n                self.current += self.step_size;\n                self.steps_left -= 1;\n                if (self.steps_left == 0) {\n                    self.current = self.target; // Snap to exact target\n                }\n                return self.current;\n            },\n            .exponential =&gt; {\n                self.current += self.step_size * (self.target - self.current);\n                self.steps_left -= 1;\n                if (self.steps_left == 0) {\n                    self.current = self.target; // Snap to exact target\n                }\n                return self.current;\n            },\n            .logarithmic =&gt; {\n                // Interpolate in log space: multiply by constant factor each step\n                const log_current = @log(self.current);\n                const log_next = log_current + self.step_size;\n                self.current = @exp(log_next);\n                self.steps_left -= 1;\n                if (self.steps_left == 0) {\n                    self.current = self.target; // Snap to exact target\n                }\n                return self.current;\n            },\n        }\n    }\n\n    /// Fill a block of samples with smoothed values.\n    pub inline fn nextBlock(self: *Smoother, out: []f32) void {\n        if (out.len == 0) return;\n\n        // Fast path: no smoothing needed",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub inline fn next(self: *Smoother) f32 {",
            "lineNumber": 512
          },
          {
            "text": "        if (self.steps_left == 0) {",
            "lineNumber": 513
          },
          {
            "text": "            return self.current;",
            "lineNumber": 514
          },
          {
            "text": "        }",
            "lineNumber": 515
          },
          {
            "lineNumber": 516
          },
          {
            "text": "        switch (self.style) {",
            "lineNumber": 517
          },
          {
            "text": "            .none =&gt; {",
            "lineNumber": 518
          },
          {
            "text": "                return self.current;",
            "lineNumber": 519
          },
          {
            "text": "            },",
            "lineNumber": 520
          },
          {
            "text": "            .linear =&gt; {",
            "lineNumber": 521
          },
          {
            "text": "                self.current += self.step_size;",
            "lineNumber": 522
          },
          {
            "text": "                self.steps_left -= 1;",
            "lineNumber": 523
          },
          {
            "text": "                if (self.steps_left == 0) {",
            "lineNumber": 524
          },
          {
            "text": "                    self.current = self.target; // Snap to exact target",
            "lineNumber": 525
          },
          {
            "text": "                }",
            "lineNumber": 526
          },
          {
            "text": "                return self.current;",
            "lineNumber": 527
          },
          {
            "text": "            },",
            "lineNumber": 528
          },
          {
            "text": "            .exponential =&gt; {",
            "lineNumber": 529
          },
          {
            "text": "                self.current += self.step_size * (self.target - self.current);",
            "lineNumber": 530
          },
          {
            "text": "                self.steps_left -= 1;",
            "lineNumber": 531
          },
          {
            "text": "                if (self.steps_left == 0) {",
            "lineNumber": 532
          },
          {
            "text": "                    self.current = self.target; // Snap to exact target",
            "lineNumber": 533
          },
          {
            "text": "                }",
            "lineNumber": 534
          },
          {
            "text": "                return self.current;",
            "lineNumber": 535
          },
          {
            "text": "            },",
            "lineNumber": 536
          },
          {
            "text": "            .logarithmic =&gt; {",
            "lineNumber": 537
          },
          {
            "text": "                // Interpolate in log space: multiply by constant factor each step",
            "lineNumber": 538
          },
          {
            "text": "                const log_current = @log(self.current);",
            "lineNumber": 539
          },
          {
            "text": "                const log_next = log_current + self.step_size;",
            "lineNumber": 540
          },
          {
            "text": "                self.current = @exp(log_next);",
            "lineNumber": 541
          },
          {
            "text": "                self.steps_left -= 1;",
            "lineNumber": 542
          },
          {
            "text": "                if (self.steps_left == 0) {",
            "lineNumber": 543
          },
          {
            "text": "                    self.current = self.target; // Snap to exact target",
            "lineNumber": 544
          },
          {
            "text": "                }",
            "lineNumber": 545
          },
          {
            "text": "                return self.current;",
            "lineNumber": 546
          },
          {
            "text": "            },",
            "lineNumber": 547
          },
          {
            "text": "        }",
            "lineNumber": 548
          },
          {
            "text": "    }",
            "lineNumber": 549
          },
          {
            "lineNumber": 550
          },
          {
            "text": "    /// Fill a block of samples with smoothed values.",
            "lineNumber": 551
          },
          {
            "text": "    pub inline fn nextBlock(self: *Smoother, out: []f32) void {",
            "lineNumber": 552
          },
          {
            "text": "        if (out.len == 0) return;",
            "lineNumber": 553
          },
          {
            "lineNumber": 554
          },
          {
            "text": "        // Fast path: no smoothing needed",
            "lineNumber": 555
          }
        ]
      },
      "score": 0.20153260231018066
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 297
          },
          "endPosition": {
            "line": 344
          }
        },
        "contents": "/// parameter declarations.\npub fn ParamValues(comptime N: usize) type {\n    return struct {\n        const Self = @This();\n\n        /// Normalized values (0.0–1.0) for each parameter.\n        /// Aligned to cache line for optimal access patterns on the audio thread.\n        values: [N]std.atomic.Value(f32) align(@import(\"../root.zig\").CACHE_LINE_SIZE),\n\n        /// Initialize all parameter values to their defaults.\n        pub fn init(comptime params: []const Param) Self {\n            var vals: [N]std.atomic.Value(f32) = undefined;\n            inline for (params, 0..) |p, i| {\n                vals[i] = std.atomic.Value(f32).init(p.defaultNormalized());\n            }\n            return Self{ .values = vals };\n        }\n\n        /// Get the normalized value of parameter at &#96;index&#96; (audio-thread safe).\n        pub inline fn get(self: *const Self, index: usize) f32 {\n            return self.values[index].load(.monotonic);\n        }\n\n        /// Set the normalized value of parameter at &#96;index&#96; (audio-thread safe).\n        pub inline fn set(self: *Self, index: usize, normalized: f32) void {\n            self.values[index].store(normalized, .monotonic);\n        }\n\n        /// The number of parameters.\n        pub fn count(_: *const Self) usize {\n            return N;\n        }\n    };\n}\n\n// ---------------------------------------------------------------------------\n// Parameter Access During Processing\n// ---------------------------------------------------------------------------\n\n/// Parameter access interface for plugins during &#96;process()&#96;.\n///\n/// Provides type-safe methods to read parameter values and smoothed values.\n/// The wrapper populates this with pointers to &#96;ParamValues&#96; and &#96;SmootherBank&#96;.\npub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {\n    return struct {\n        const Self = @This();",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/// parameter declarations.",
            "lineNumber": 298
          },
          {
            "text": "pub fn ParamValues(comptime N: usize) type {",
            "lineNumber": 299
          },
          {
            "text": "    return struct {",
            "lineNumber": 300
          },
          {
            "text": "        const Self = @This();",
            "lineNumber": 301
          },
          {
            "lineNumber": 302
          },
          {
            "text": "        /// Normalized values (0.0–1.0) for each parameter.",
            "lineNumber": 303
          },
          {
            "text": "        /// Aligned to cache line for optimal access patterns on the audio thread.",
            "lineNumber": 304
          },
          {
            "text": "        values: [N]std.atomic.Value(f32) align(@import(\"../root.zig\").CACHE_LINE_SIZE),",
            "lineNumber": 305
          },
          {
            "lineNumber": 306
          },
          {
            "text": "        /// Initialize all parameter values to their defaults.",
            "lineNumber": 307
          },
          {
            "text": "        pub fn init(comptime params: []const Param) Self {",
            "lineNumber": 308
          },
          {
            "text": "            var vals: [N]std.atomic.Value(f32) = undefined;",
            "lineNumber": 309
          },
          {
            "text": "            inline for (params, 0..) |p, i| {",
            "lineNumber": 310
          },
          {
            "text": "                vals[i] = std.atomic.Value(f32).init(p.defaultNormalized());",
            "lineNumber": 311
          },
          {
            "text": "            }",
            "lineNumber": 312
          },
          {
            "text": "            return Self{ .values = vals };",
            "lineNumber": 313
          },
          {
            "text": "        }",
            "lineNumber": 314
          },
          {
            "lineNumber": 315
          },
          {
            "text": "        /// Get the normalized value of parameter at &#96;index&#96; (audio-thread safe).",
            "lineNumber": 316
          },
          {
            "text": "        pub inline fn get(self: *const Self, index: usize) f32 {",
            "lineNumber": 317
          },
          {
            "text": "            return self.values[index].load(.monotonic);",
            "lineNumber": 318
          },
          {
            "text": "        }",
            "lineNumber": 319
          },
          {
            "lineNumber": 320
          },
          {
            "text": "        /// Set the normalized value of parameter at &#96;index&#96; (audio-thread safe).",
            "lineNumber": 321
          },
          {
            "text": "        pub inline fn set(self: *Self, index: usize, normalized: f32) void {",
            "lineNumber": 322
          },
          {
            "text": "            self.values[index].store(normalized, .monotonic);",
            "lineNumber": 323
          },
          {
            "text": "        }",
            "lineNumber": 324
          },
          {
            "lineNumber": 325
          },
          {
            "text": "        /// The number of parameters.",
            "lineNumber": 326
          },
          {
            "text": "        pub fn count(_: *const Self) usize {",
            "lineNumber": 327
          },
          {
            "text": "            return N;",
            "lineNumber": 328
          },
          {
            "text": "        }",
            "lineNumber": 329
          },
          {
            "text": "    };",
            "lineNumber": 330
          },
          {
            "text": "}",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 333
          },
          {
            "text": "// Parameter Access During Processing",
            "lineNumber": 334
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 335
          },
          {
            "lineNumber": 336
          },
          {
            "text": "/// Parameter access interface for plugins during &#96;process()&#96;.",
            "lineNumber": 337
          },
          {
            "text": "///",
            "lineNumber": 338
          },
          {
            "text": "/// Provides type-safe methods to read parameter values and smoothed values.",
            "lineNumber": 339
          },
          {
            "text": "/// The wrapper populates this with pointers to &#96;ParamValues&#96; and &#96;SmootherBank&#96;.",
            "lineNumber": 340
          },
          {
            "text": "pub fn ParamAccess(comptime N: usize, comptime params_meta: []const Param) type {",
            "lineNumber": 341
          },
          {
            "text": "    return struct {",
            "lineNumber": 342
          },
          {
            "text": "        const Self = @This();",
            "lineNumber": 343
          }
        ]
      },
      "score": 0.2006572037935257
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/vst3/controller.zig",
        "range": {
          "startPosition": {
            "line": 186,
            "column": 16
          },
          "endPosition": {
            "line": 229
          }
        },
        "contents": "const param_id = P.param_ids[i];\n                if (param_id == id) {\n                    // Format the value\n                    const text = switch (param) {\n                        .float =&gt; |p| blk: {\n                            const plain = switch (p.range) {\n                                .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                                .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),\n                            };\n                            var buf: [64]u8 = undefined;\n                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}\", .{plain}) catch break :blk \"?\";\n                            break :blk formatted;\n                        },\n                        .int =&gt; |p| blk: {\n                            const plain = p.range.unnormalize(@floatCast(value_normalized));\n                            var buf: [64]u8 = undefined;\n                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{plain}) catch break :blk \"?\";\n                            break :blk formatted;\n                        },\n                        .boolean =&gt; if (value_normalized &gt; 0.5) \"On\" else \"Off\",\n                        .choice =&gt; |p| blk: {\n                            const idx = @as(usize, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));\n                            if (idx &lt; p.labels.len) break :blk p.labels[idx];\n                            break :blk \"?\";\n                        },\n                    };\n\n                    // Convert to UTF-16\n                    @memset(string, 0);\n                    var j: usize = 0;\n                    while (j &lt; text.len and j &lt; 128) : (j += 1) {\n                        string[j] = text[j];\n                    }\n\n                    return vst3.types.kResultOk;\n                }\n            }\n\n            return vst3.types.kResultFalse;\n        }\n\n        fn getParamValueByString(\n            _: *anyopaque,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "const param_id = P.param_ids[i];",
            "lineNumber": 187
          },
          {
            "text": "                if (param_id == id) {",
            "lineNumber": 188
          },
          {
            "text": "                    // Format the value",
            "lineNumber": 189
          },
          {
            "text": "                    const text = switch (param) {",
            "lineNumber": 190
          },
          {
            "text": "                        .float =&gt; |p| blk: {",
            "lineNumber": 191
          },
          {
            "text": "                            const plain = switch (p.range) {",
            "lineNumber": 192
          },
          {
            "text": "                                .linear =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 193
          },
          {
            "text": "                                .logarithmic =&gt; |r| r.unnormalize(@floatCast(value_normalized)),",
            "lineNumber": 194
          },
          {
            "text": "                            };",
            "lineNumber": 195
          },
          {
            "text": "                            var buf: [64]u8 = undefined;",
            "lineNumber": 196
          },
          {
            "text": "                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d:.2}\", .{plain}) catch break :blk \"?\";",
            "lineNumber": 197
          },
          {
            "text": "                            break :blk formatted;",
            "lineNumber": 198
          },
          {
            "text": "                        },",
            "lineNumber": 199
          },
          {
            "text": "                        .int =&gt; |p| blk: {",
            "lineNumber": 200
          },
          {
            "text": "                            const plain = p.range.unnormalize(@floatCast(value_normalized));",
            "lineNumber": 201
          },
          {
            "text": "                            var buf: [64]u8 = undefined;",
            "lineNumber": 202
          },
          {
            "text": "                            const formatted = std.fmt.bufPrint(&amp;buf, \"{d}\", .{plain}) catch break :blk \"?\";",
            "lineNumber": 203
          },
          {
            "text": "                            break :blk formatted;",
            "lineNumber": 204
          },
          {
            "text": "                        },",
            "lineNumber": 205
          },
          {
            "text": "                        .boolean =&gt; if (value_normalized &gt; 0.5) \"On\" else \"Off\",",
            "lineNumber": 206
          },
          {
            "text": "                        .choice =&gt; |p| blk: {",
            "lineNumber": 207
          },
          {
            "text": "                            const idx = @as(usize, @intFromFloat(value_normalized * @as(f32, @floatFromInt(p.labels.len - 1))));",
            "lineNumber": 208
          },
          {
            "text": "                            if (idx &lt; p.labels.len) break :blk p.labels[idx];",
            "lineNumber": 209
          },
          {
            "text": "                            break :blk \"?\";",
            "lineNumber": 210
          },
          {
            "text": "                        },",
            "lineNumber": 211
          },
          {
            "text": "                    };",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "                    // Convert to UTF-16",
            "lineNumber": 214
          },
          {
            "text": "                    @memset(string, 0);",
            "lineNumber": 215
          },
          {
            "text": "                    var j: usize = 0;",
            "lineNumber": 216
          },
          {
            "text": "                    while (j &lt; text.len and j &lt; 128) : (j += 1) {",
            "lineNumber": 217
          },
          {
            "text": "                        string[j] = text[j];",
            "lineNumber": 218
          },
          {
            "text": "                    }",
            "lineNumber": 219
          },
          {
            "lineNumber": 220
          },
          {
            "text": "                    return vst3.types.kResultOk;",
            "lineNumber": 221
          },
          {
            "text": "                }",
            "lineNumber": 222
          },
          {
            "text": "            }",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "            return vst3.types.kResultFalse;",
            "lineNumber": 225
          },
          {
            "text": "        }",
            "lineNumber": 226
          },
          {
            "lineNumber": 227
          },
          {
            "text": "        fn getParamValueByString(",
            "lineNumber": 228
          },
          {
            "text": "            _: *anyopaque,",
            "lineNumber": 229
          }
        ]
      },
      "score": 0.19873106479644775
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/clap/plugin.zig",
        "range": {
          "startPosition": {
            "line": 422
          },
          "endPosition": {
            "line": 441
          }
        },
        "contents": "                .param_value =&gt; {\n                    const event: *const clap.events.ParamValue = @ptrCast(@alignCast(header));\n                    // Find parameter index by ID using binary search\n                    if (P.params.len &gt; 0) {\n                        if (P.findParamIndex(@intFromEnum(event.param_id))) |idx| {\n                            const param = P.params[idx];\n                            // Convert plain value to normalized using shared helper\n                            const normalized = common.plainToNormalized(param, event.value);\n                            self.param_values.set(idx, normalized);\n\n                            // Update smoother target with the plain value\n                            const plain_value: f32 = @floatCast(event.value);\n                            self.smoother_bank.setTarget(idx, self.buffer_config.sample_rate, plain_value);\n                        }\n                    }\n                    return false; // Don't add to event list\n                },\n                .note_expression =&gt; {\n                    const event: *const clap.events.NoteExpression = @ptrCast(@alignCast(header));",
        "signatures": {},
        "detailedLines": [
          {
            "text": "                .param_value =&gt; {",
            "lineNumber": 423
          },
          {
            "text": "                    const event: *const clap.events.ParamValue = @ptrCast(@alignCast(header));",
            "lineNumber": 424
          },
          {
            "text": "                    // Find parameter index by ID using binary search",
            "lineNumber": 425
          },
          {
            "text": "                    if (P.params.len &gt; 0) {",
            "lineNumber": 426
          },
          {
            "text": "                        if (P.findParamIndex(@intFromEnum(event.param_id))) |idx| {",
            "lineNumber": 427
          },
          {
            "text": "                            const param = P.params[idx];",
            "lineNumber": 428
          },
          {
            "text": "                            // Convert plain value to normalized using shared helper",
            "lineNumber": 429
          },
          {
            "text": "                            const normalized = common.plainToNormalized(param, event.value);",
            "lineNumber": 430
          },
          {
            "text": "                            self.param_values.set(idx, normalized);",
            "lineNumber": 431
          },
          {
            "lineNumber": 432
          },
          {
            "text": "                            // Update smoother target with the plain value",
            "lineNumber": 433
          },
          {
            "text": "                            const plain_value: f32 = @floatCast(event.value);",
            "lineNumber": 434
          },
          {
            "text": "                            self.smoother_bank.setTarget(idx, self.buffer_config.sample_rate, plain_value);",
            "lineNumber": 435
          },
          {
            "text": "                        }",
            "lineNumber": 436
          },
          {
            "text": "                    }",
            "lineNumber": 437
          },
          {
            "text": "                    return false; // Don't add to event list",
            "lineNumber": 438
          },
          {
            "text": "                },",
            "lineNumber": 439
          },
          {
            "text": "                .note_expression =&gt; {",
            "lineNumber": 440
          },
          {
            "text": "                    const event: *const clap.events.NoteExpression = @ptrCast(@alignCast(header));",
            "lineNumber": 441
          }
        ]
      },
      "score": 0.1921176016330719
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 780
          },
          "endPosition": {
            "line": 837
          }
        },
        "contents": "}\n\ntest \"Param defaultNormalized for choice\" {\n    const p = Param{ .choice = .{\n        .name = \"Mode\",\n        .id = \"mode\",\n        .default = 1,\n        .labels = &amp;.{ \"A\", \"B\", \"C\" },\n    } };\n    try std.testing.expectApproxEqAbs(@as(f32, 0.5), p.defaultNormalized(), 1e-6);\n}\n\ntest \"ParamValues init and get\" {\n    const params = [_]Param{\n        .{ .float = .{\n            .name = \"Gain\",\n            .id = \"gain\",\n            .default = 0.0,\n            .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },\n        } },\n        .{ .boolean = .{\n            .name = \"Bypass\",\n            .id = \"bypass\",\n            .default = true,\n        } },\n    };\n    var pv = ParamValues(2).init(&amp;params);\n    try std.testing.expectApproxEqAbs(@as(f32, 0.5), pv.get(0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), pv.get(1), 1e-6);\n\n    pv.set(0, 0.75);\n    try std.testing.expectApproxEqAbs(@as(f32, 0.75), pv.get(0), 1e-6);\n}\n\ntest \"Smoother linear reaches target\" {\n    var smoother = Smoother.init(0.0, .{ .linear = 10.0 }); // 10ms linear\n    const sample_rate = 1000.0; // 1kHz\n\n    smoother.setTarget(sample_rate, 10.0);\n\n    // Should reach target in 10 samples (10ms at 1kHz)\n    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);\n\n    // First sample\n    const v1 = smoother.next();\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), v1, 1e-4);\n\n    // Last sample should snap to target\n    smoother.steps_left = 1;\n    smoother.current = 9.9;\n    const v_last = smoother.next();\n    try std.testing.expectApproxEqAbs(@as(f32, 10.0), v_last, 1e-6);\n    try std.testing.expectEqual(@as(u32, 0), smoother.steps_left);\n}\n\ntest \"Smoother exponential converges\" {\n    var smoother = Smoother.init(0.0, .{ .exponential = 10.0 });",
        "signatures": {},
        "detailedLines": [
          {
            "text": "}",
            "lineNumber": 781
          },
          {
            "lineNumber": 782
          },
          {
            "text": "test \"Param defaultNormalized for choice\" {",
            "lineNumber": 783
          },
          {
            "text": "    const p = Param{ .choice = .{",
            "lineNumber": 784
          },
          {
            "text": "        .name = \"Mode\",",
            "lineNumber": 785
          },
          {
            "text": "        .id = \"mode\",",
            "lineNumber": 786
          },
          {
            "text": "        .default = 1,",
            "lineNumber": 787
          },
          {
            "text": "        .labels = &amp;.{ \"A\", \"B\", \"C\" },",
            "lineNumber": 788
          },
          {
            "text": "    } };",
            "lineNumber": 789
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.5), p.defaultNormalized(), 1e-6);",
            "lineNumber": 790
          },
          {
            "text": "}",
            "lineNumber": 791
          },
          {
            "lineNumber": 792
          },
          {
            "text": "test \"ParamValues init and get\" {",
            "lineNumber": 793
          },
          {
            "text": "    const params = [_]Param{",
            "lineNumber": 794
          },
          {
            "text": "        .{ .float = .{",
            "lineNumber": 795
          },
          {
            "text": "            .name = \"Gain\",",
            "lineNumber": 796
          },
          {
            "text": "            .id = \"gain\",",
            "lineNumber": 797
          },
          {
            "text": "            .default = 0.0,",
            "lineNumber": 798
          },
          {
            "text": "            .range = .{ .linear = .{ .min = -24.0, .max = 24.0 } },",
            "lineNumber": 799
          },
          {
            "text": "        } },",
            "lineNumber": 800
          },
          {
            "text": "        .{ .boolean = .{",
            "lineNumber": 801
          },
          {
            "text": "            .name = \"Bypass\",",
            "lineNumber": 802
          },
          {
            "text": "            .id = \"bypass\",",
            "lineNumber": 803
          },
          {
            "text": "            .default = true,",
            "lineNumber": 804
          },
          {
            "text": "        } },",
            "lineNumber": 805
          },
          {
            "text": "    };",
            "lineNumber": 806
          },
          {
            "text": "    var pv = ParamValues(2).init(&amp;params);",
            "lineNumber": 807
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.5), pv.get(0), 1e-6);",
            "lineNumber": 808
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), pv.get(1), 1e-6);",
            "lineNumber": 809
          },
          {
            "lineNumber": 810
          },
          {
            "text": "    pv.set(0, 0.75);",
            "lineNumber": 811
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.75), pv.get(0), 1e-6);",
            "lineNumber": 812
          },
          {
            "text": "}",
            "lineNumber": 813
          },
          {
            "lineNumber": 814
          },
          {
            "text": "test \"Smoother linear reaches target\" {",
            "lineNumber": 815
          },
          {
            "text": "    var smoother = Smoother.init(0.0, .{ .linear = 10.0 }); // 10ms linear",
            "lineNumber": 816
          },
          {
            "text": "    const sample_rate = 1000.0; // 1kHz",
            "lineNumber": 817
          },
          {
            "lineNumber": 818
          },
          {
            "text": "    smoother.setTarget(sample_rate, 10.0);",
            "lineNumber": 819
          },
          {
            "lineNumber": 820
          },
          {
            "text": "    // Should reach target in 10 samples (10ms at 1kHz)",
            "lineNumber": 821
          },
          {
            "text": "    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);",
            "lineNumber": 822
          },
          {
            "lineNumber": 823
          },
          {
            "text": "    // First sample",
            "lineNumber": 824
          },
          {
            "text": "    const v1 = smoother.next();",
            "lineNumber": 825
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), v1, 1e-4);",
            "lineNumber": 826
          },
          {
            "lineNumber": 827
          },
          {
            "text": "    // Last sample should snap to target",
            "lineNumber": 828
          },
          {
            "text": "    smoother.steps_left = 1;",
            "lineNumber": 829
          },
          {
            "text": "    smoother.current = 9.9;",
            "lineNumber": 830
          },
          {
            "text": "    const v_last = smoother.next();",
            "lineNumber": 831
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 10.0), v_last, 1e-6);",
            "lineNumber": 832
          },
          {
            "text": "    try std.testing.expectEqual(@as(u32, 0), smoother.steps_left);",
            "lineNumber": 833
          },
          {
            "text": "}",
            "lineNumber": 834
          },
          {
            "lineNumber": 835
          },
          {
            "text": "test \"Smoother exponential converges\" {",
            "lineNumber": 836
          },
          {
            "text": "    var smoother = Smoother.init(0.0, .{ .exponential = 10.0 });",
            "lineNumber": 837
          }
        ]
      },
      "score": 0.19129739701747894
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/wrappers/clap/extensions.zig",
        "range": {
          "startPosition": {
            "line": 387
          },
          "endPosition": {
            "line": 433
          }
        },
        "contents": "        ) callconv(.c) bool {\n            const wrapper = @as(*anyopaque, @ptrFromInt(@intFromPtr(plugin) - @offsetOf(@import(\"plugin.zig\").PluginWrapper(T), \"clap_plugin\")));\n            const self: *@import(\"plugin.zig\").PluginWrapper(T) = @ptrCast(@alignCast(wrapper));\n\n            // Create a reader adapter for the CLAP stream\n            const Reader = struct {\n                stream_ptr: *const clap.IStream,\n\n                pub fn read(ctx: *const anyopaque, buffer: []u8) !usize {\n                    const reader_self: *const @This() = @ptrCast(@alignCast(ctx));\n                    const result = reader_self.stream_ptr.read(reader_self.stream_ptr, buffer.ptr, buffer.len);\n                    const read_result = @intFromEnum(result);\n                    if (read_result &lt; 0) return error.ReadFailed;\n                    if (read_result == 0) return 0; // EOF\n                    return @intCast(read_result);\n                }\n            };\n\n            var reader_ctx = Reader{ .stream_ptr = stream };\n            const any_reader = std.io.AnyReader{\n                .context = @ptrCast(&amp;reader_ctx),\n                .readFn = Reader.read,\n            };\n\n            // Read state header\n            const version = core.readHeader(any_reader) catch return false;\n\n            // Read parameter values\n            for (0..P.params.len) |i| {\n                var normalized: f32 = undefined;\n                const bytes = std.mem.asBytes(&amp;normalized);\n                const read_count = any_reader.readAll(bytes) catch return false;\n                if (read_count != @sizeOf(f32)) return false;\n                self.param_values.set(i, normalized);\n\n                // Update smoother target\n                const param = P.params[i];\n                const plain_value = param.toPlain(normalized);\n                self.smoother_bank.setTarget(i, self.buffer_config.sample_rate, plain_value);\n            }\n\n            const load_context = core.LoadContext{\n                .reader = any_reader,\n                .version = version,\n            };",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        ) callconv(.c) bool {",
            "lineNumber": 388
          },
          {
            "text": "            const wrapper = @as(*anyopaque, @ptrFromInt(@intFromPtr(plugin) - @offsetOf(@import(\"plugin.zig\").PluginWrapper(T), \"clap_plugin\")));",
            "lineNumber": 389
          },
          {
            "text": "            const self: *@import(\"plugin.zig\").PluginWrapper(T) = @ptrCast(@alignCast(wrapper));",
            "lineNumber": 390
          },
          {
            "lineNumber": 391
          },
          {
            "text": "            // Create a reader adapter for the CLAP stream",
            "lineNumber": 392
          },
          {
            "text": "            const Reader = struct {",
            "lineNumber": 393
          },
          {
            "text": "                stream_ptr: *const clap.IStream,",
            "lineNumber": 394
          },
          {
            "lineNumber": 395
          },
          {
            "text": "                pub fn read(ctx: *const anyopaque, buffer: []u8) !usize {",
            "lineNumber": 396
          },
          {
            "text": "                    const reader_self: *const @This() = @ptrCast(@alignCast(ctx));",
            "lineNumber": 397
          },
          {
            "text": "                    const result = reader_self.stream_ptr.read(reader_self.stream_ptr, buffer.ptr, buffer.len);",
            "lineNumber": 398
          },
          {
            "text": "                    const read_result = @intFromEnum(result);",
            "lineNumber": 399
          },
          {
            "text": "                    if (read_result &lt; 0) return error.ReadFailed;",
            "lineNumber": 400
          },
          {
            "text": "                    if (read_result == 0) return 0; // EOF",
            "lineNumber": 401
          },
          {
            "text": "                    return @intCast(read_result);",
            "lineNumber": 402
          },
          {
            "text": "                }",
            "lineNumber": 403
          },
          {
            "text": "            };",
            "lineNumber": 404
          },
          {
            "lineNumber": 405
          },
          {
            "text": "            var reader_ctx = Reader{ .stream_ptr = stream };",
            "lineNumber": 406
          },
          {
            "text": "            const any_reader = std.io.AnyReader{",
            "lineNumber": 407
          },
          {
            "text": "                .context = @ptrCast(&amp;reader_ctx),",
            "lineNumber": 408
          },
          {
            "text": "                .readFn = Reader.read,",
            "lineNumber": 409
          },
          {
            "text": "            };",
            "lineNumber": 410
          },
          {
            "lineNumber": 411
          },
          {
            "text": "            // Read state header",
            "lineNumber": 412
          },
          {
            "text": "            const version = core.readHeader(any_reader) catch return false;",
            "lineNumber": 413
          },
          {
            "lineNumber": 414
          },
          {
            "text": "            // Read parameter values",
            "lineNumber": 415
          },
          {
            "text": "            for (0..P.params.len) |i| {",
            "lineNumber": 416
          },
          {
            "text": "                var normalized: f32 = undefined;",
            "lineNumber": 417
          },
          {
            "text": "                const bytes = std.mem.asBytes(&amp;normalized);",
            "lineNumber": 418
          },
          {
            "text": "                const read_count = any_reader.readAll(bytes) catch return false;",
            "lineNumber": 419
          },
          {
            "text": "                if (read_count != @sizeOf(f32)) return false;",
            "lineNumber": 420
          },
          {
            "text": "                self.param_values.set(i, normalized);",
            "lineNumber": 421
          },
          {
            "lineNumber": 422
          },
          {
            "text": "                // Update smoother target",
            "lineNumber": 423
          },
          {
            "text": "                const param = P.params[i];",
            "lineNumber": 424
          },
          {
            "text": "                const plain_value = param.toPlain(normalized);",
            "lineNumber": 425
          },
          {
            "text": "                self.smoother_bank.setTarget(i, self.buffer_config.sample_rate, plain_value);",
            "lineNumber": 426
          },
          {
            "text": "            }",
            "lineNumber": 427
          },
          {
            "lineNumber": 428
          },
          {
            "text": "            const load_context = core.LoadContext{",
            "lineNumber": 429
          },
          {
            "text": "                .reader = any_reader,",
            "lineNumber": 430
          },
          {
            "text": "                .version = version,",
            "lineNumber": 431
          },
          {
            "text": "            };",
            "lineNumber": 432
          }
        ]
      },
      "score": 0.1867702603340149
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/core/params.zig",
        "range": {
          "startPosition": {
            "line": 1025
          },
          "endPosition": {
            "line": 1069
          }
        },
        "contents": "test \"LogFloatRange perceptually uniform\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    // At 50% normalized, should be geometric mean\n    const mid = range.unnormalize(0.5);\n    const expected = @sqrt(20.0 * 20000.0); // ~632.5 Hz\n    try std.testing.expectApproxEqAbs(expected, mid, 1.0);\n}\n\ntest \"LogFloatRange boundaries\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    try std.testing.expectApproxEqAbs(@as(f32, 0.0), range.normalize(20.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1.0), range.normalize(20000.0), 1e-6);\n}\n\ntest \"LogFloatRange clamp\" {\n    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };\n    try std.testing.expectApproxEqAbs(@as(f32, 20.0), range.clamp(10.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 20000.0), range.clamp(30000.0), 1e-6);\n    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), range.clamp(1000.0), 1e-6);\n}\n\ntest \"Smoother logarithmic reaches target\" {\n    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });\n    const sample_rate = 1000.0;\n\n    smoother.setTarget(sample_rate, 1000.0);\n    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);\n\n    // Should multiply by constant factor each step\n    const v1 = smoother.next();\n    try std.testing.expect(v1 &gt; 100.0 and v1 &lt; 1000.0);\n\n    const v2 = smoother.next();\n    try std.testing.expect(v2 &gt; v1 and v2 &lt; 1000.0);\n\n    // Last step should snap to target\n    smoother.steps_left = 1;\n    smoother.current = 990.0;\n    const v_last = smoother.next();\n    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), v_last, 1e-6);\n}\n\ntest \"Smoother logarithmic geometric progression\" {\n    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
        "signatures": {},
        "detailedLines": [
          {
            "text": "test \"LogFloatRange perceptually uniform\" {",
            "lineNumber": 1026
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1027
          },
          {
            "text": "    // At 50% normalized, should be geometric mean",
            "lineNumber": 1028
          },
          {
            "text": "    const mid = range.unnormalize(0.5);",
            "lineNumber": 1029
          },
          {
            "text": "    const expected = @sqrt(20.0 * 20000.0); // ~632.5 Hz",
            "lineNumber": 1030
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(expected, mid, 1.0);",
            "lineNumber": 1031
          },
          {
            "text": "}",
            "lineNumber": 1032
          },
          {
            "lineNumber": 1033
          },
          {
            "text": "test \"LogFloatRange boundaries\" {",
            "lineNumber": 1034
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1035
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 0.0), range.normalize(20.0), 1e-6);",
            "lineNumber": 1036
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1.0), range.normalize(20000.0), 1e-6);",
            "lineNumber": 1037
          },
          {
            "text": "}",
            "lineNumber": 1038
          },
          {
            "lineNumber": 1039
          },
          {
            "text": "test \"LogFloatRange clamp\" {",
            "lineNumber": 1040
          },
          {
            "text": "    const range = LogFloatRange{ .min = 20.0, .max = 20000.0 };",
            "lineNumber": 1041
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 20.0), range.clamp(10.0), 1e-6);",
            "lineNumber": 1042
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 20000.0), range.clamp(30000.0), 1e-6);",
            "lineNumber": 1043
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), range.clamp(1000.0), 1e-6);",
            "lineNumber": 1044
          },
          {
            "text": "}",
            "lineNumber": 1045
          },
          {
            "lineNumber": 1046
          },
          {
            "text": "test \"Smoother logarithmic reaches target\" {",
            "lineNumber": 1047
          },
          {
            "text": "    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
            "lineNumber": 1048
          },
          {
            "text": "    const sample_rate = 1000.0;",
            "lineNumber": 1049
          },
          {
            "lineNumber": 1050
          },
          {
            "text": "    smoother.setTarget(sample_rate, 1000.0);",
            "lineNumber": 1051
          },
          {
            "text": "    try std.testing.expectEqual(@as(u32, 10), smoother.steps_left);",
            "lineNumber": 1052
          },
          {
            "lineNumber": 1053
          },
          {
            "text": "    // Should multiply by constant factor each step",
            "lineNumber": 1054
          },
          {
            "text": "    const v1 = smoother.next();",
            "lineNumber": 1055
          },
          {
            "text": "    try std.testing.expect(v1 &gt; 100.0 and v1 &lt; 1000.0);",
            "lineNumber": 1056
          },
          {
            "lineNumber": 1057
          },
          {
            "text": "    const v2 = smoother.next();",
            "lineNumber": 1058
          },
          {
            "text": "    try std.testing.expect(v2 &gt; v1 and v2 &lt; 1000.0);",
            "lineNumber": 1059
          },
          {
            "lineNumber": 1060
          },
          {
            "text": "    // Last step should snap to target",
            "lineNumber": 1061
          },
          {
            "text": "    smoother.steps_left = 1;",
            "lineNumber": 1062
          },
          {
            "text": "    smoother.current = 990.0;",
            "lineNumber": 1063
          },
          {
            "text": "    const v_last = smoother.next();",
            "lineNumber": 1064
          },
          {
            "text": "    try std.testing.expectApproxEqAbs(@as(f32, 1000.0), v_last, 1e-6);",
            "lineNumber": 1065
          },
          {
            "text": "}",
            "lineNumber": 1066
          },
          {
            "lineNumber": 1067
          },
          {
            "text": "test \"Smoother logarithmic geometric progression\" {",
            "lineNumber": 1068
          },
          {
            "text": "    var smoother = Smoother.init(100.0, .{ .logarithmic = 10.0 });",
            "lineNumber": 1069
          }
        ]
      },
      "score": 0.1848084032535553
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **0** result in **1** directory</summary>

Directory: **undefined** (0 file)

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **0** result in **1** directory</summary>

Directory: **undefined** (0 file)

</details>
</tool-use>

---


## Summary

### 1. Structure of `src/core/`

7 files:

1. **`plugin.zig`** (592 lines)
   - Purpose: Plugin interface and comptime validation
   - Exports: `Plugin(comptime T)`, `ProcessStatus`, `ProcessContext`, `EventOutputList`
   - Validates plugin structs at comptime and generates metadata for wrappers

2. **`params.zig`** (1,117 lines)
   - Purpose: Parameter declaration and runtime parameter state
   - Exports: `Param`, `FloatParam`, `IntParam`, `BoolParam`, `ChoiceParam`, `FloatRange`, `LogFloatRange`, `IntRange`, `ParamFlags`, `ParamValues(N)`, `Smoother`, `SmootherBank(N)`, `SmoothingStyle`, `ParamAccess`, `idHash`
   - Handles parameter normalization, smoothing, and lock-free atomic access

3. **`buffer.zig`** (393 lines)
   - Purpose: Zero-copy audio buffer abstraction
   - Exports: `Buffer`, `AuxBuffers`, `ChannelSamples`, `SamplesIter`, `Block`, `BlocksIter`, `BlockEntry`
   - Provides three access strategies: raw slice, per-sample iteration, per-block iteration

4. **`events.zig`** (285 lines)
   - Purpose: Unified note and MIDI event types
   - Exports: `NoteEvent`, `NoteData`, `PolyValueData`, `MidiCCData`, `MidiChannelData`, `MidiProgramData`
   - Tagged union unifying CLAP and VST3 events with factory functions

5. **`state.zig`** (235 lines)
   - Purpose: State persistence interface for plugin presets
   - Exports: `SaveContext`, `LoadContext`, `StateVersion`, `writeHeader`, `readHeader`, `MAGIC`
   - Uses Zig 0.15.2's `std.io.AnyReader`/`std.io.AnyWriter` for type erasure

6. **`audio_layout.zig`** (185 lines)
   - Purpose: Audio I/O layout, buffer configuration, and transport types
   - Exports: `AudioIOLayout`, `BufferConfig`, `ProcessMode`, `MidiConfig`, `Transport`
   - Defines channel configurations and runtime processing parameters

7. **`platform.zig`** (13 lines)
   - Purpose: Platform-specific constants and utilities
   - Exports: `CACHE_LINE_SIZE` (comptime constant: 128 bytes for aarch64, 64 bytes for x86_64)

### 2. Public API Surface (`src/root.zig`)

Re-exports from core modules:

- Plugin interface: `Plugin`, `ProcessStatus`, `ProcessContext`, `EventOutputList`
- Audio buffers: `Buffer`, `AuxBuffers`
- Events: `NoteEvent`, `NoteData`, `PolyValueData`, `MidiCCData`, `MidiChannelData`, `MidiProgramData`
- Parameters: `Param`, `FloatParam`, `IntParam`, `BoolParam`, `ChoiceParam`, `FloatRange`, `IntRange`, `ParamFlags`, `ParamValues`, `idHash`, `SmoothingStyle`, `Smoother`, `SmootherBank`, `ParamAccess`
- Audio I/O: `AudioIOLayout`, `BufferConfig`, `ProcessMode`, `MidiConfig`, `Transport`
- State: `SaveContext`, `LoadContext`, `StateVersion`, `writeHeader`, `readHeader`
- Platform: `platform`, `CACHE_LINE_SIZE`
- Format wrappers: `ClapEntry`, `Vst3Factory`

### 3. Utility/Conversion Functions

No dedicated utility/conversion functions for dB ↔ gain or frequency conversions.

Existing conversion utilities:
- Parameter normalization: `FloatRange.normalize()` / `unnormalize()`, `LogFloatRange.normalize()` / `unnormalize()` (in `params.zig`)
- Wrapper helpers: `plainToNormalized()` / `normalizedToPlain()` (in `wrappers/common.zig`) — internal wrapper use only

What's missing:
- `dbToGain()` / `gainToDb()` functions
- Frequency conversion utilities (e.g., MIDI note ↔ Hz, semitones ↔ ratio)
- Other common audio DSP conversions

### 4. Coding Guidelines (`AGENTS.md`)

- Zig 0.15.2 required (use Nix/direnv)
- Real-time audio safety: no allocations, locks, I/O, or blocking syscalls on the audio thread
- Comptime-driven metadata generation
- API-agnostic plugin interface
- Use SIMD where appropriate
- File organization: one concern per file, keep files under ~500 lines
- Documentation: module READMEs + `///` doc comments

## Recommendations

Consider adding a `src/core/utils.zig` module with common audio DSP conversion functions:
- `dbToGain(db: f32) f32` / `gainToDb(gain: f32) f32`
- `midiNoteToHz(note: u8) f32` / `hzToMidiNote(hz: f32) f32`
- `semitonesToRatio(semitones: f32) f32` / `ratioToSemitones(ratio: f32) f32`
- Other common conversions as needed

These would be useful for plugin authors and fit the framework's design.

---

