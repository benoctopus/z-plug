<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session a90c1ba5-13c0-4ceb-b804-4b52df3f2d80 (2026-02-24 17:05Z) -->

# Test harness waveform scrubbing (2026-02-24 17:05Z)

_**User**_

Please plan to update the test harness in @zloader/ such that you can scrub the the waveform to change playhead position with the mouse

---

_**Agent (model claude-4.6-sonnet-medium, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to plan updates to the test harness in the `zloader/` directory to add waveform scrubbing functionality (changing playhead position by clicking/dragging on the waveform with the mouse). Let me first explore the zloader directory to understand the current codebase structure and how the waveform is currently rendered.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="task_v2">
<details>
<summary>Tool use: **task_v2**</summary>


Parameters:

```json
{
  "description": "Explore zloader directory structure",
  "prompt": "Explore the /Users/b/code/z-plug/zloader/ directory thoroughly. I need to understand:\n1. The full directory structure\n2. What the project is (look at Cargo.toml, README, etc.)\n3. How the UI/waveform is rendered\n4. How audio playback and playhead position work\n5. Any existing mouse/input handling code\n\nReturn the directory tree, key file paths, and a summary of the architecture focusing on the waveform display and audio playback systems.",
  "subagentType": "explore",
  "model": "composer-1",
  "name": "explore"
}
```
Additional data:

```json
{
  "status": "success",
  "composerData": "{\"_v\":13,\"composerId\":\"task-toolu_bdrk_01A3fzxbnLgKWiHff5yGRxQM\",\"richText\":\"\",\"hasLoaded\":true,\"text\":\"\",\"fullConversationHeadersOnly\":[{\"bubbleId\":\"114de096-d6e8-4d5d-8a2e-86b1affce30d\",\"type\":2},{\"bubbleId\":\"8dd7fe06-77dd-460b-90e4-0079889ee1e2\",\"type\":2},{\"bubbleId\":\"eadbda0d-039b-481a-9a42-dfe65f1ccf23\",\"type\":2},{\"bubbleId\":\"144d9649-8e56-4693-ae5f-a87bd559a50e\",\"type\":2},{\"bubbleId\":\"b53f63ba-fc0c-486c-8b73-5353f995ea51\",\"type\":2},{\"bubbleId\":\"b21800d5-187c-45b1-a8c3-f1562a0c5f25\",\"type\":2},{\"bubbleId\":\"5d8d8ddb-55dc-40aa-8f44-af2ab8a808f5\",\"type\":2},{\"bubbleId\":\"7376ad5e-5a49-4fa6-a6f3-e4b334c9b1b2\",\"type\":2},{\"bubbleId\":\"9a69a783-f293-4655-a651-e63974234ff2\",\"type\":2},{\"bubbleId\":\"c246edbf-8390-4883-b2be-3b3e0f33fc78\",\"type\":2},{\"bubbleId\":\"eb3ff8e0-b393-42ae-9528-538edaefad91\",\"type\":2},{\"bubbleId\":\"68c7988a-5b30-47fe-9c00-f8ab5e1682e4\",\"type\":2},{\"bubbleId\":\"54ca0d29-b441-494f-abd8-87aab9479878\",\"type\":2},{\"bubbleId\":\"79156788-64f8-4c77-ab09-c4c3e03d9cd7\",\"type\":2},{\"bubbleId\":\"047aef0a-b772-4467-93fe-5becf9ea4ed8\",\"type\":2},{\"bubbleId\":\"77c27510-d714-49d5-9c0b-fd91adf281e7\",\"type\":2},{\"bubbleId\":\"0f47b6e2-0a59-4e60-8764-e6243f80b8e4\",\"type\":2},{\"bubbleId\":\"1567e8ab-f098-448c-be72-c448e41ba83d\",\"type\":2},{\"bubbleId\":\"71e4a15a-7e1a-4c67-8542-d876a6e5c0da\",\"type\":2},{\"bubbleId\":\"472df3d2-ae9c-47a4-b0fb-d117e4332d39\",\"type\":2},{\"bubbleId\":\"d31d7a78-e844-480a-b2fe-9a07ba263fe1\",\"type\":2},{\"bubbleId\":\"64ccfd4a-ead3-4caf-8d09-5fd504b162f6\",\"type\":2},{\"bubbleId\":\"22543eed-635f-4e18-acfe-31fda0e8186d\",\"type\":2},{\"bubbleId\":\"77ca8476-1767-47ec-ac80-35803b8f9a3f\",\"type\":2},{\"bubbleId\":\"3e7decbb-4bbd-47bf-be32-31a1dbc54144\",\"type\":2}],\"conversationMap\":{\"114de096-d6e8-4d5d-8a2e-86b1affce30d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"c62a443a-1295-4375-920e-45483ff3dc55\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.573Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nExploring the zloader directory. Gathering directory structure and key files first.\\\\n\\\"}\",\"8dd7fe06-77dd-460b-90e4-0079889ee1e2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f017ff7b-5c84-472c-8c85-ada1684ab3bc\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.573Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"tool\\\":15,\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"\\\",\\\"toolCallId\\\":\\\"tool_6d7e27c0-9b9a-46c6-8dd4-ff2023fc00c\\\",\\\"status\\\":\\\"error\\\",\\\"rawArgs\\\":\\\"\\\",\\\"name\\\":\\\"run_terminal_command_v2\\\",\\\"additionalData\\\":{\\\"status\\\":\\\"error\\\"},\\\"params\\\":\\\"{\\\\\\\"command\\\\\\\":\\\\\\\"find /Users/b/code/z-plug/zloader -type f -name \\\\\\\\\\\\\\\"*.rs\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.toml\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.md\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.json\\\\\\\\\\\\\\\" | head -50\\\\\\\",\\\\\\\"cwd\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"options\\\\\\\":{\\\\\\\"timeout\\\\\\\":300000},\\\\\\\"parsingResult\\\\\\\":{\\\\\\\"executableCommands\\\\\\\":[{\\\\\\\"name\\\\\\\":\\\\\\\"find\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-type\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"f\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-name\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"*.rs\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-o\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-name\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"*.toml\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-o\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-name\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"*.md\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-o\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-name\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"*.json\\\\\\\\\\\\\\\"\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"find /Users/b/code/z-plug/zloader -type f -name \\\\\\\\\\\\\\\"*.rs\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.toml\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.md\\\\\\\\\\\\\\\" -o -name \\\\\\\\\\\\\\\"*.json\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"head\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"number\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-50\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"head -50\\\\\\\"}]},\\\\\\\"requestedSandboxPolicy\\\\\\\":{\\\\\\\"type\\\\\\\":\\\\\\\"TYPE_WORKSPACE_READONLY\\\\\\\",\\\\\\\"networkAccess\\\\\\\":false,\\\\\\\"enableSharedBuildCache\\\\\\\":true}}\\\",\\\"error\\\":\\\"{\\\\\\\"clientVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"modelVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"actualErrorMessageOnlySendFromClientToServerNeverTheOtherWayAroundBecauseThatMayBeASecurityRisk\\\\\\\":\\\\\\\"This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\"}\\\"},\\\"capabilityType\\\":15}\",\"eadbda0d-039b-481a-9a42-dfe65f1ccf23\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"ad8e6f6a-5153-492d-b8f5-5e898829c4b2\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"tool\\\":15,\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"\\\",\\\"toolCallId\\\":\\\"tool_b1b86054-b9f0-461b-b8d4-2927b38aac4\\\",\\\"status\\\":\\\"error\\\",\\\"rawArgs\\\":\\\"\\\",\\\"name\\\":\\\"run_terminal_command_v2\\\",\\\"additionalData\\\":{\\\"status\\\":\\\"error\\\"},\\\"params\\\":\\\"{\\\\\\\"command\\\\\\\":\\\\\\\"tree -L 4 /Users/b/code/z-plug/zloader 2&gt;/dev/null || find /Users/b/code/z-plug/zloader -type d | sort\\\\\\\",\\\\\\\"cwd\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"options\\\\\\\":{\\\\\\\"timeout\\\\\\\":300000},\\\\\\\"parsingResult\\\\\\\":{\\\\\\\"executableCommands\\\\\\\":[{\\\\\\\"name\\\\\\\":\\\\\\\"tree\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-L\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"number\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"4\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"tree -L 4 /Users/b/code/z-plug/zloader\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"find\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-type\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"d\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"find /Users/b/code/z-plug/zloader -type d\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"sort\\\\\\\",\\\\\\\"fullText\\\\\\\":\\\\\\\"sort\\\\\\\"}],\\\\\\\"hasRedirects\\\\\\\":true},\\\\\\\"requestedSandboxPolicy\\\\\\\":{\\\\\\\"type\\\\\\\":\\\\\\\"TYPE_WORKSPACE_READONLY\\\\\\\",\\\\\\\"networkAccess\\\\\\\":false,\\\\\\\"enableSharedBuildCache\\\\\\\":true}}\\\",\\\"error\\\":\\\"{\\\\\\\"clientVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"modelVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"actualErrorMessageOnlySendFromClientToServerNeverTheOtherWayAroundBecauseThatMayBeASecurityRisk\\\\\\\":\\\\\\\"This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\"}\\\"},\\\"capabilityType\\\":15}\",\"144d9649-8e56-4693-ae5f-a87bd559a50e\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f0b4960c-aac6-4406-88d2-42ce19d4ff54\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b44613e6-b65f-45aa-9c80-9cc63977f83\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b44613e6-b65f-45aa-9c80-9cc63977f83\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"[package]\\\\\\\\nname = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\"\\\\\\\\nversion = \\\\\\\\\\\\\\\"0.1.0\\\\\\\\\\\\\\\"\\\\\\\\nedition = \\\\\\\\\\\\\\\"2021\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n[dependencies]\\\\\\\\ngpui = \\\\\\\\\\\\\\\"0.2.2\\\\\\\\\\\\\\\"\\\\\\\\ngpui-component = \\\\\\\\\\\\\\\"0.5.1\\\\\\\\\\\\\\\"\\\\\\\\nsmallvec = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\nclap = { version = \\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\", features = [\\\\\\\\\\\\\\\"derive\\\\\\\\\\\\\\\"] }\\\\\\\\nanyhow = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":12}\\\"},\\\"capabilityType\\\":15}\",\"b53f63ba-fc0c-486c-8b73-5353f995ea51\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d9febecf-0fc5-429f-9aa7-db4b5473f70c\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_86d48e2f-7c2d-4e9c-8f43-4bf8bd54d9f\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_86d48e2f-7c2d-4e9c-8f43-4bf8bd54d9f\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"README*\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"README*\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\"}]}\\\"},\\\"capabilityType\\\":15}\",\"b21800d5-187c-45b1-a8c3-f1562a0c5f25\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"dfccc163-2441-48e2-a021-acc1063ef4dd\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nExploring the directory structure using available tools:\\\\n\\\"}\",\"5d8d8ddb-55dc-40aa-8f44-af2ab8a808f5\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"882082fd-4e93-4fbd-ba14-04b447e7b04a\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_9c5e7faa-696a-44d2-bca2-5d3dfe441fd\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_9c5e7faa-696a-44d2-bca2-5d3dfe441fd\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/main.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/app.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"Cargo.toml\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/params.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/waveform.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/host.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/engine.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/ffi.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/transport.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"build.rs\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":10}]}\\\"},\\\"capabilityType\\\":15}\",\"7376ad5e-5a49-4fa6-a6f3-e4b334c9b1b2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d2757eb1-dc3a-439c-b596-cbd639284d5f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_8c28f696-92a4-487a-938f-fd66f1d5974\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_8c28f696-92a4-487a-938f-fd66f1d5974\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/Cargo.toml\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"[package]\\\\\\\\nname = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\"\\\\\\\\nversion = \\\\\\\\\\\\\\\"0.1.0\\\\\\\\\\\\\\\"\\\\\\\\nedition = \\\\\\\\\\\\\\\"2021\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n[dependencies]\\\\\\\\ngpui = \\\\\\\\\\\\\\\"0.2.2\\\\\\\\\\\\\\\"\\\\\\\\ngpui-component = \\\\\\\\\\\\\\\"0.5.1\\\\\\\\\\\\\\\"\\\\\\\\nsmallvec = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\nclap = { version = \\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\", features = [\\\\\\\\\\\\\\\"derive\\\\\\\\\\\\\\\"] }\\\\\\\\nanyhow = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":12}\\\"},\\\"capabilityType\\\":15}\",\"9a69a783-f293-4655-a651-e63974234ff2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"2c03f96f-9a5c-45ba-ab12-1f6c42af6b68\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.574Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_f39ca158-3989-4732-8ea8-79346efd210\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_f39ca158-3989-4732-8ea8-79346efd210\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is the waveform UI rendered and displayed?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"zloader\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is the waveform UI rendered and displayed?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"zloader\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":84},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":143,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\\n    pub position: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformView {\\\\\\\\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\\n        Self { peaks, position: 0 }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for WaveformView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let peaks = self.peaks.clone();\\\\\\\\n        let position = self.position;\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .w_full()\\\\\\\\n            .h(px(120.0))\\\\\\\\n            .bg(rgb(0x1a1a2e))\\\\\\\\n            .rounded(px(6.0))\\\\\\\\n            .overflow_hidden()\\\\\\\\n            .child(\\\\\\\\n                canvas(\\\\\\\\n                    move |_bounds, _window, _cx| {},\\\\\\\\n                    move |bounds, _prepaint, window, _cx| {\\\\\\\\n                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .w_full()\\\\\\\\n                .h_full(),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Drawing helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\\n    window.paint_quad(PaintQuad {\\\\\\\\n        bounds: Bounds {\\\\\\\\n            origin: Point { x: px(x), y: px(y) },\\\\\\\\n            size: Size {\\\\\\\\n                width: px(w),\\\\\\\\n                height: px(h),\\\\\\\\n            },\\\\\\\\n        },\\\\\\\\n        corner_radii: Corners::all(px(0.0)),\\\\\\\\n        background: Background::from(color),\\\\\\\\n        border_widths: Edges::all(px(0.0)),\\\\\\\\n        border_color: gpui::transparent_black(),\\\\\\\\n        border_style: BorderStyle::default(),\\\\\\\\n    });\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { peaks, position: 0 }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        let peaks = self.peaks.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        let position = self.position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"            .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"            .h(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x1a1a2e))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"            .rounded(px(6.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            .overflow_hidden()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                canvas(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_bounds, _window, _cx| {},\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |bounds, _prepaint, window, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"                .h_full(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"// Drawing helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"fn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    window.paint_quad(PaintQuad {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"        bounds: Bounds {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            origin: Point { x: px(x), y: px(y) },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            size: Size {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"                width: px(w),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"                height: px(h),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        corner_radii: Corners::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        background: Background::from(color),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_widths: Edges::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_color: gpui::transparent_black(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_style: BorderStyle::default(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144}]},\\\\\\\"score\\\\\\\":0.5304640531539917},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":139,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":180,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\\n    peaks: &amp;WaveformPeaks,\\\\\\\\n    position: u64,\\\\\\\\n) {\\\\\\\\n    let width = f32::from(bounds.size.width);\\\\\\\\n    let height = f32::from(bounds.size.height);\\\\\\\\n    let origin_x = f32::from(bounds.origin.x);\\\\\\\\n    let origin_y = f32::from(bounds.origin.y);\\\\\\\\n    let mid_y = origin_y + height / 2.0;\\\\\\\\n    let half_h = height / 2.0 * 0.9;\\\\\\\\n\\\\\\\\n    let num_cols = peaks.peaks.len().max(1);\\\\\\\\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\\n    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\\n    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\\n\\\\\\\\n    // Draw waveform bars.\\\\\\\\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\\n        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\\n\\\\\\\\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\\n        let bar_height = (bottom - top).max(1.0);\\\\\\\\n\\\\\\\\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Draw center line.\\\\\\\\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\\n\\\\\\\\n    // Draw playhead.\\\\\\\\n    if peaks.total_samples &gt; 0 {\\\\\\\\n        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    peaks: &amp;WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\") {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    let width = f32::from(bounds.size.width);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"    let height = f32::from(bounds.size.height);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_x = f32::from(bounds.origin.x);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_y = f32::from(bounds.origin.y);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mid_y = origin_y + height / 2.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    let half_h = height / 2.0 * 0.9;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    let num_cols = peaks.peaks.len().max(1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw waveform bars.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_height = (bottom - top).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw center line.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    if peaks.total_samples &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181}]},\\\\\\\"score\\\\\\\":0.4937899112701416},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":24,\\\\\\\"column\\\\\\\":18}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\\n//!\\\\\\\\n//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\\n//! playhead line indicating the current playback position.\\\\\\\\n\\\\\\\\nuse gpui::{\\\\\\\\n    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\\n    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\\n/// One entry per display column (pixel-width bucket).\\\\\\\\n#[derive(Clone)]\\\\\\\\npub struct WaveformPeaks {\\\\\\\\n    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\\n    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\\n    /// Total number of samples in the source file (for playhead math).\\\\\\\\n    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! playhead line indicating the current playback position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"/// One entry per display column (pixel-width bucket).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Total number of samples in the source file (for playhead math).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25}]},\\\\\\\"score\\\\\\\":0.39427289366722107},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":38,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":93,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\\n        peaks: WaveformPeaks,\\\\\\\\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\\n    ) -&gt; Self {\\\\\\\\n        let plugin_name: SharedString = state\\\\\\\\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\\n            .into();\\\\\\\\n\\\\\\\\n        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\\n\\\\\\\\n        // Build the waveform view.\\\\\\\\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\\n\\\\\\\\n        // Build the params view.\\\\\\\\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\\n\\\\\\\\n        // Subscribe to slider changes and forward to the plugin host.\\\\\\\\n        // This runs on the main thread with full access to cx.\\\\\\\\n        let state_for_params = state.clone();\\\\\\\\n        params_view\\\\\\\\n            .read_with(cx, |pv, _| {\\\\\\\\n                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\\n                pv.sliders\\\\\\\\n                    .iter()\\\\\\\\n                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\\n            })\\\\\\\\n            .into_iter()\\\\\\\\n            .for_each(|(param_id, slider_entity)| {\\\\\\\\n                let state_weak = state_for_params.downgrade();\\\\\\\\n                cx.subscribe(\\\\\\\\n                    &amp;slider_entity,\\\\\\\\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\\n                        let SliderEvent::Change(value) = event;\\\\\\\\n                        let v = value.start() as f64;\\\\\\\\n                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\\n                            state_entity.read_with(cx, |s, _| {\\\\\\\\n                                s.host.set_param_value(param_id, v);\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .detach();\\\\\\\\n            });\\\\\\\\n\\\\\\\\n        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\\n        let state_weak = state.downgrade();\\\\\\\\n        let waveform_weak = waveform.downgrade();\\\\\\\\n        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name: SharedString = state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the waveform view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the params view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Subscribe to slider changes and forward to the plugin host.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This runs on the main thread with full access to cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_for_params = state.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        params_view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |pv, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                pv.sliders\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into_iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            .for_each(|(param_id, slider_entity)| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"                let state_weak = state_for_params.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.subscribe(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;slider_entity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let SliderEvent::Change(value) = event;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let v = value.start() as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                            state_entity.read_with(cx, |s, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                                s.host.set_param_value(param_id, v);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_weak = state.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform_weak = waveform.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94}]},\\\\\\\"score\\\\\\\":0.37548279762268066},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":174,\\\\\\\"column\\\\\\\":51},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":208,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\\n            .bg(rgb(0x0f0f1a))\\\\\\\\n            .text_color(rgb(0xffffff))\\\\\\\\n            .p(px(16.0))\\\\\\\\n            .gap(px(16.0))\\\\\\\\n            // Header: plugin name\\\\\\\\n            .child(\\\\\\\\n                div().flex().flex_row().items_center().gap(px(8.0)).child(\\\\\\\\n                    div()\\\\\\\\n                        .text_size(px(20.0))\\\\\\\\n                        .size_full()\\\\\\\\n                        .bg(rgb(0x0000FF))\\\\\\\\n                        .text_color(rgb(0xffffff))\\\\\\\\n                        .child(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\".clone()),\\\\\\\\n                ),\\\\\\\\n            )\\\\\\\\n            // Waveform\\\\\\\\n            .child(waveform)\\\\\\\\n            // Bottom: transport + params\\\\\\\\n            .child(\\\\\\\\n                div()\\\\\\\\n                    .flex()\\\\\\\\n                    .flex_row()\\\\\\\\n                    .gap(px(24.0))\\\\\\\\n                    .flex_1()\\\\\\\\n                    .min_h(px(0.0))\\\\\\\\n                    // Transport controls\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x0f0f1a))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"            .text_color(rgb(0xffffff))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"            .p(px(16.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"            .gap(px(16.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Header: plugin name\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"                div().flex().flex_row().items_center().gap(px(8.0)).child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"                    div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_size(px(20.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .bg(rgb(0x0000FF))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_color(rgb(0xffffff))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .child(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\".clone()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"                ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Waveform\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(waveform)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Bottom: transport + params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .gap(px(24.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex_1()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .min_h(px(0.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Transport controls\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209}]},\\\\\\\"score\\\\\\\":0.34510403871536255},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":148,\\\\\\\"column\\\\\\\":20},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":179,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            if is_playing {\\\\\\\\n                s.engine.stop();\\\\\\\\n            } else {\\\\\\\\n                let _ = s.engine.play();\\\\\\\\n            }\\\\\\\\n        });\\\\\\\\n        self.is_playing = !is_playing;\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ZLoaderApp {\\\\\\\\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let play_label: SharedString = if self.is_playing {\\\\\\\\n            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\\n        } else {\\\\\\\\n            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\\n        };\\\\\\\\n        let plugin_name = self.plugin_name.clone();\\\\\\\\n        let waveform = self.waveform.clone();\\\\\\\\n        let params_view = self.params_view.clone();\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"            if is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                s.engine.stop();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"                let _ = s.engine.play();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.is_playing = !is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        let play_label: SharedString = if self.is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name = self.plugin_name.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = self.waveform.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = self.params_view.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180}]},\\\\\\\"score\\\\\\\":0.33254480361938477},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer(Duration::from_millis(30))\\\\\\\\n                    .await;\\\\\\\\n\\\\\\\\n                let should_stop = cx.update(|cx| {\\\\\\\\n                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    // Poll position and call idle.\\\\\\\\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\\n                        s.host.idle();\\\\\\\\n                        (s.engine.position(), s.engine.is_playing())\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update waveform playhead.\\\\\\\\n                    waveform_entity.update(cx, |w, cx| {\\\\\\\\n                        w.position = position;\\\\\\\\n                        cx.notify();\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update root view playing state.\\\\\\\\n                    this.update(cx, |app, cx| {\\\\\\\\n                        app.is_playing = is_playing;\\\\\\\\n                        cx.notify();\\\\\\\\n                    })\\\\\\\\n                    .is_err()\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                if should_stop.unwrap_or(true) {\\\\\\\\n                    break;\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        })\\\\\\\\n        .detach();\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            state,\\\\\\\\n            waveform,\\\\\\\\n            params_view,\\\\\\\\n            is_playing: false,\\\\\\\\n            plugin_name,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            s.engine.seek(0);\\\\\\\\n        });\\\\\\\\n        self.waveform.update(cx, |w, cx| {\\\\\\\\n            w.position = 0;\\\\\\\\n            cx.notify();\\\\\\\\n        });\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer(Duration::from_millis(30))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .await;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let should_stop = cx.update(|cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Poll position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                        s.host.idle();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                        (s.engine.position(), s.engine.is_playing())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update waveform playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                    waveform_entity.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                        w.position = position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update root view playing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                    this.update(cx, |app, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"                        app.is_playing = is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .is_err()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                if should_stop.unwrap_or(true) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"            state,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"            waveform,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"            params_view,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            is_playing: false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"            plugin_name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"            s.engine.seek(0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.waveform.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"            w.position = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"            cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152}]},\\\\\\\"score\\\\\\\":0.31049591302871704},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":42,\\\\\\\"column\\\\\\\":32}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\\n//!\\\\\\\\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\\n//! and drives the periodic idle/position-poll timer.\\\\\\\\n\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::button::{Button, ButtonVariants};\\\\\\\\nuse gpui_component::slider::SliderEvent;\\\\\\\\n\\\\\\\\nuse crate::engine::AudioEngine;\\\\\\\\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\\nuse crate::params::ParamsView;\\\\\\\\nuse crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AppState  owns the non-Send FFI resources\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\\npub struct AppState {\\\\\\\\n    pub host: PluginHost,\\\\\\\\n    pub engine: AudioEngine,\\\\\\\\n    pub plugin_info: PluginInfo,\\\\\\\\n    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ZLoaderApp  root view\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\npub struct ZLoaderApp {\\\\\\\\n    state: Entity&lt;AppState&gt;,\\\\\\\\n    waveform: Entity&lt;WaveformView&gt;,\\\\\\\\n    params_view: Entity&lt;ParamsView&gt;,\\\\\\\\n    is_playing: bool,\\\\\\\\n    plugin_name: SharedString,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! and drives the periodic idle/position-poll timer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::button::{Button, ButtonVariants};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::SliderEvent;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::params::ParamsView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// AppState  owns the non-Send FFI resources\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub host: PluginHost,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub engine: AudioEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub plugin_info: PluginInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"// ZLoaderApp  root view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    waveform: Entity&lt;WaveformView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    params_view: Entity&lt;ParamsView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    is_playing: bool,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_name: SharedString,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.3061102628707886},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":99,\\\\\\\"column\\\\\\\":46},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":154,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\\n/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\\nconst WAVEFORM_COLUMNS: usize = 1200;\\\\\\\\n\\\\\\\\nfn setup(\\\\\\\\n    cx: &amp;mut App,\\\\\\\\n    plugin_path: &amp;PathBuf,\\\\\\\\n    audio_path: &amp;PathBuf,\\\\\\\\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\\n    // Load the plugin.\\\\\\\\n    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\\n    let plugin_info = host.get_info()?;\\\\\\\\n    let params = host.get_params();\\\\\\\\n\\\\\\\\n    // Create the audio engine and load the WAV file.\\\\\\\\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    engine.load_file(audio_path)?;\\\\\\\\n\\\\\\\\n    // Activate and start processing.\\\\\\\\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    host.start_processing()?;\\\\\\\\n\\\\\\\\n    // Attach plugin to engine.\\\\\\\\n    engine.set_plugin(Some(&amp;mut host));\\\\\\\\n\\\\\\\\n    // Read the WAV file for waveform peak computation.\\\\\\\\n    let peaks = build_peaks(audio_path)?;\\\\\\\\n\\\\\\\\n    let state = cx.new(|_cx| AppState {\\\\\\\\n        host,\\\\\\\\n        engine,\\\\\\\\n        plugin_info,\\\\\\\\n        params,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok((state, peaks))\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read the WAV file and compute waveform peaks for display.\\\\\\\\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\\n    let data = std::fs::read(path)?;\\\\\\\\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\\n    Ok(peaks)\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\\n/// Returns (interleaved_f32_samples, channel_count).\\\\\\\\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"const WAVEFORM_COLUMNS: usize = 1200;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"fn setup(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    cx: &amp;mut App,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Load the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_info = host.get_info()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    let params = host.get_params();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Create the audio engine and load the WAV file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.load_file(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Activate and start processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.start_processing()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Attach plugin to engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.set_plugin(Some(&amp;mut host));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Read the WAV file for waveform peak computation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = build_peaks(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"    let state = cx.new(|_cx| AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        engine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        params,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((state, peaks))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Read the WAV file and compute waveform peaks for display.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"fn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    let data = std::fs::read(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(peaks)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Returns (interleaved_f32_samples, channel_count).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"fn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155}]},\\\\\\\"score\\\\\\\":0.29757168889045715},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":21},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":87}},\\\\\\\"contents\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks {\\\\\\\\n    /// Build peak data from raw interleaved f32 samples.\\\\\\\\n    ///\\\\\\\\n    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\\n    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\\n    /// bucket across all channels.\\\\\\\\n    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\\n        let total_frames = if channels &gt; 0 {\\\\\\\\n            samples.len() / channels\\\\\\\\n        } else {\\\\\\\\n            0\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let total_samples = total_frames as u64;\\\\\\\\n\\\\\\\\n        if total_frames == 0 || num_columns == 0 {\\\\\\\\n            return Self {\\\\\\\\n                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\\n                total_samples,\\\\\\\\n            };\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\\n        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\\n\\\\\\\\n        for col in 0..num_columns {\\\\\\\\n            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = end_frame.min(total_frames);\\\\\\\\n\\\\\\\\n            let mut min = 0.0f32;\\\\\\\\n            let mut max = 0.0f32;\\\\\\\\n\\\\\\\\n            for frame in start_frame..end_frame {\\\\\\\\n                for ch in 0..channels {\\\\\\\\n                    let sample = samples[frame * channels + ch];\\\\\\\\n                    if sample &lt; min {\\\\\\\\n                        min = sample;\\\\\\\\n                    }\\\\\\\\n                    if sample &gt; max {\\\\\\\\n                        max = sample;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            peaks.push((min, max));\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            peaks,\\\\\\\\n            total_samples,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// WaveformView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// A GPUI view that renders the waveform and a playhead.\\\\\\\\npub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build peak data from raw interleaved f32 samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// bucket across all channels.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_frames = if channels &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            samples.len() / channels\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"            0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_samples = total_frames as u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        if total_frames == 0 || num_columns == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"            return Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"                total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"        for col in 0..num_columns {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = end_frame.min(total_frames);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut min = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut max = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"            for frame in start_frame..end_frame {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"                for ch in 0..channels {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let sample = samples[frame * channels + ch];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &lt; min {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        min = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &gt; max {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                        max = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks.push((min, max));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"// WaveformView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A GPUI view that renders the waveform and a playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87}]},\\\\\\\"score\\\\\\\":0.29204869270324707},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":41,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":103,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\\n\\\\\\\\n    if !args.plugin_path.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\\n    }\\\\\\\\n    if !args.audio_file.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let plugin_path = args.plugin_path.clone();\\\\\\\\n    let audio_path = args.audio_file.clone();\\\\\\\\n\\\\\\\\n    Application::new().run(move |cx: &amp;mut App| {\\\\\\\\n        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\\n\\\\\\\\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\\n        gpui_component::init(cx);\\\\\\\\n\\\\\\\\n        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\\n            Ok(v) =&gt; v,\\\\\\\\n            Err(e) =&gt; {\\\\\\\\n                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\\n                cx.quit();\\\\\\\\n                return;\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\\n\\\\\\\\n        cx.open_window(\\\\\\\\n            WindowOptions {\\\\\\\\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\\n                titlebar: Some(gpui::TitlebarOptions {\\\\\\\\n                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\\n                    ..Default::default()\\\\\\\\n                }),\\\\\\\\n                ..Default::default()\\\\\\\\n            },\\\\\\\\n            move |window, cx| {\\\\\\\\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\\n            },\\\\\\\\n        )\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        cx.activate(true);\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Setup: load plugin + audio, build peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.plugin_path.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.audio_file.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_path = args.plugin_path.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    let audio_path = args.audio_file.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    Application::new().run(move |cx: &amp;mut App| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        gpui_component::init(cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            Ok(v) =&gt; v,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            Err(e) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.quit();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"                return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.open_window(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            WindowOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                titlebar: Some(gpui::TitlebarOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            move |window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.activate(true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"// Setup: load plugin + audio, build peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104}]},\\\\\\\"score\\\\\\\":0.2507641017436981},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/params.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":50,\\\\\\\"column\\\\\\\":24},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":86,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ParamsView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let mut rows = div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .gap(px(12.0))\\\\\\\\n            .w_full()\\\\\\\\n            .overflow_hidden();\\\\\\\\n\\\\\\\\n        for entry in &amp;self.sliders {\\\\\\\\n            let name: SharedString = entry.info.name.clone().into();\\\\\\\\n            let slider_entity = entry.slider.clone();\\\\\\\\n\\\\\\\\n            let row = div()\\\\\\\\n                .flex()\\\\\\\\n                .flex_col()\\\\\\\\n                .gap(px(4.0))\\\\\\\\n                .w_full()\\\\\\\\n                .child(\\\\\\\\n                    div()\\\\\\\\n                        .text_sm()\\\\\\\\n                        .text_color(rgb(0xcccccc))\\\\\\\\n                        .child(name),\\\\\\\\n                )\\\\\\\\n                .child(Slider::new(&amp;slider_entity));\\\\\\\\n\\\\\\\\n            rows = rows.child(row);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        rows\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut rows = div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"            .gap(px(12.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"            .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"            .overflow_hidden();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        for entry in &amp;self.sliders {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"            let name: SharedString = entry.info.name.clone().into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            let slider_entity = entry.slider.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            let row = div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"                .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"                .gap(px(4.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"                .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_sm()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_color(rgb(0xcccccc))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .child(name),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                .child(Slider::new(&amp;slider_entity));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"            rows = rows.child(row);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        rows\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87}]},\\\\\\\"score\\\\\\\":0.23677420616149902},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":205,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":237,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .w(px(120.0))\\\\\\\\n                            .flex_shrink_0()\\\\\\\\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .flex()\\\\\\\\n                                    .flex_row()\\\\\\\\n                                    .gap(px(8.0))\\\\\\\\n                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\\n                                        |app, _ev, window, cx| {\\\\\\\\n                                            app.on_rewind(window, cx);\\\\\\\\n                                        },\\\\\\\\n                                    )))\\\\\\\\n                                    .child(\\\\\\\\n                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\\n                                            .primary()\\\\\\\\n                                            .label(play_label)\\\\\\\\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\\n                                                app.on_play_stop(window, cx);\\\\\\\\n                                            })),\\\\\\\\n                                    ),\\\\\\\\n                            ),\\\\\\\\n                    )\\\\\\\\n                    // Parameter panel\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .w(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_shrink_0()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"                                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        |app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            app.on_rewind(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    )))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .primary()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .label(play_label)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                app.on_play_stop(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            })),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":231},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":232},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":233},{\\\\\\\"text\\\\\\\":\\\\\\\"                    )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":234},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Parameter panel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":235},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238}]},\\\\\\\"score\\\\\\\":0.22502046823501587},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/params.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":56,\\\\\\\"column\\\\\\\":13}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::slider::{Slider, SliderState};\\\\\\\\n\\\\\\\\nuse crate::host::ParamInfo;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Per-parameter slider entry\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Holds the GPUI entity for one parameter's slider state.\\\\\\\\npub struct ParamSlider {\\\\\\\\n    pub info: ParamInfo,\\\\\\\\n    pub slider: Entity&lt;SliderState&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ParamsView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Panel of parameter sliders.\\\\\\\\npub struct ParamsView {\\\\\\\\n    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ParamsView {\\\\\\\\n    /// Build the params view from a list of parameter infos.\\\\\\\\n    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\\n        let sliders = params\\\\\\\\n            .iter()\\\\\\\\n            .map(|info| {\\\\\\\\n                let min = info.min_value as f32;\\\\\\\\n                let max = info.max_value as f32;\\\\\\\\n                let default = info.default_value as f32;\\\\\\\\n\\\\\\\\n                let slider = cx.new(|_cx| {\\\\\\\\n                    SliderState::new()\\\\\\\\n                        .min(min)\\\\\\\\n                        .max(max)\\\\\\\\n                        .default_value(default)\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                ParamSlider {\\\\\\\\n                    info: info.clone(),\\\\\\\\n                    slider,\\\\\\\\n                }\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n\\\\\\\\n        Self { sliders }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ParamsView {\\\\\\\\n    fn render\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::{Slider, SliderState};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::ParamInfo;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"// Per-parameter slider entry\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Holds the GPUI entity for one parameter's slider state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub info: ParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub slider: Entity&lt;SliderState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ParamsView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Panel of parameter sliders.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build the params view from a list of parameter infos.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        let sliders = params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|info| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"                let min = info.min_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"                let max = info.max_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"                let default = info.default_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"                let slider = cx.new(|_cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"                    SliderState::new()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .min(min)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .max(max)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .default_value(default)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"                ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"                    info: info.clone(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"                    slider,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { sliders }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57}]},\\\\\\\"score\\\\\\\":0.19411176443099976},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":44,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\\n//!\\\\\\\\n//! Usage:\\\\\\\\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\\n\\\\\\\\nmod app;\\\\\\\\nmod engine;\\\\\\\\nmod ffi;\\\\\\\\nmod host;\\\\\\\\nmod params;\\\\\\\\nmod transport;\\\\\\\\nmod waveform;\\\\\\\\n\\\\\\\\nuse std::path::PathBuf;\\\\\\\\n\\\\\\\\nuse anyhow::Result;\\\\\\\\nuse clap::Parser;\\\\\\\\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\\nuse gpui_component::{theme::Theme, Root};\\\\\\\\n\\\\\\\\nuse app::{AppState, ZLoaderApp};\\\\\\\\nuse engine::AudioEngine;\\\\\\\\nuse host::PluginHost;\\\\\\\\nuse waveform::WaveformPeaks;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// CLI\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[derive(Parser, Debug)]\\\\\\\\n#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\\nstruct Args {\\\\\\\\n    /// Path to the .clap plugin file or bundle.\\\\\\\\n    plugin_path: PathBuf,\\\\\\\\n\\\\\\\\n    /// Path to a WAV audio file to play through the plugin.\\\\\\\\n    audio_file: PathBuf,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Entry point\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Usage:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod app;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod engine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"mod host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod transport;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"mod waveform;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::Result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap::Parser;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::{theme::Theme, Root};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"use app::{AppState, ZLoaderApp};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use waveform::WaveformPeaks;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// CLI\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Parser, Debug)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"struct Args {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to the .clap plugin file or bundle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to a WAV audio file to play through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_file: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Entry point\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45}]},\\\\\\\"score\\\\\\\":0.1827484369277954},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":28,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":94,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    ///\\\\\\\\n    /// Stops playback and resets position if a file was already loaded.\\\\\\\\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    ///\\\\\\\\n    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\\n    /// output. The plugin must be activated and processing-started before\\\\\\\\n    /// calling &#96;play()&#96;.\\\\\\\\n    ///\\\\\\\\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\\n        let plugin_ptr = host\\\\\\\\n            .map(|h| h.raw_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null_mut());\\\\\\\\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Pause playback. The current position is preserved.\\\\\\\\n    pub fn pause(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn stop(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stops playback and resets position if a file was already loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// output. The plugin must be activated and processing-started before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// calling &#96;play()&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_ptr = host\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|h| h.raw_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null_mut());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback. The current position is preserved.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn pause(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95}]},\\\\\\\"score\\\\\\\":0.15930719673633575},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":234,\\\\\\\"column\\\\\\\":38},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":252,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .flex_1()\\\\\\\\n                            .min_h(px(0.0))\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .text_sm()\\\\\\\\n                                    .text_color(rgb(0x888888))\\\\\\\\n                                    .child(\\\\\\\\\\\\\\\"Parameters\\\\\\\\\\\\\\\"),\\\\\\\\n                            )\\\\\\\\n                            .child(params_view),\\\\\\\\n                    ),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":239},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_1()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":240},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .min_h(px(0.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":241},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":242},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":243},{\\\\\\\"text\\\\\\\":\\\\\\\"                                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":244},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .text_sm()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":245},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .text_color(rgb(0x888888))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":246},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(\\\\\\\\\\\\\\\"Parameters\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":247},{\\\\\\\"text\\\\\\\":\\\\\\\"                            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":248},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(params_view),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":249},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":250},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":251},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":252},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":253}]},\\\\\\\"score\\\\\\\":0.14394189417362213},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":195,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":229,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\\n        (3, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\\n            .collect(),\\\\\\\\n        (1, 16) =&gt; raw\\\\\\\\n            .chunks_exact(2)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 32768.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 24) =&gt; raw\\\\\\\\n            .chunks_exact(3)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\\n                s as f32 / 8388608.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 2147483648.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        _ =&gt; anyhow::bail!(\\\\\\\\n            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\\n        ),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    Ok((samples, channels))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        (3, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 16) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(2)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 32768.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 24) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(3)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 8388608.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 2147483648.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; anyhow::bail!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"        ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((samples, channels))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230}]},\\\\\\\"score\\\\\\\":0.12630659341812134},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":160,\\\\\\\"column\\\\\\\":68},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":214,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\\n\\\\\\\\n    /// Destroy the engine and free all resources.\\\\\\\\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Pause playback (position preserved).\\\\\\\\n    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn zpe_set_looping\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy the engine and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback (position preserved).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_looping\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215}]},\\\\\\\"score\\\\\\\":0.10058750212192535},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":62},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":197,\\\\\\\"column\\\\\\\":62}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let mut pos = 12usize;\\\\\\\\n    let mut fmt_channels: u16 = 0;\\\\\\\\n    let mut fmt_bits: u16 = 0;\\\\\\\\n    let mut fmt_audio_format: u16 = 0;\\\\\\\\n    let mut data_start = 0usize;\\\\\\\\n    let mut data_len = 0usize;\\\\\\\\n\\\\\\\\n    while pos + 8 &lt;= data.len() {\\\\\\\\n        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\\n        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\\n        pos += 8;\\\\\\\\n\\\\\\\\n        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\\n            if chunk_size &gt;= 16 {\\\\\\\\n                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\\n                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\\n                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\\n            }\\\\\\\\n        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\\n            data_start = pos;\\\\\\\\n            data_len = chunk_size;\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        pos += chunk_size;\\\\\\\\n        if chunk_size % 2 != 0 {\\\\\\\\n            pos += 1;\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if data_start == 0 || fmt_channels == 0 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\\n    let channels = fmt_channels as usize;\\\\\\\\n\\\\\\\\n    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut pos = 12usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_channels: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_bits: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_audio_format: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_start = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_len = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"    while pos + 8 &lt;= data.len() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"            if chunk_size &gt;= 16 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_start = pos;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_len = chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"            break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_size % 2 != 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"            pos += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data_start == 0 || fmt_channels == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    let channels = fmt_channels as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198}]},\\\\\\\"score\\\\\\\":0.09687849879264832},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":92,\\\\\\\"column\\\\\\\":48},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":138,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn position(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn length(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\\n        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn position(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn length(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139}]},\\\\\\\"score\\\\\\\":0.08804889768362045},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":105,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":163}},\\\\\\\"contents\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\\n\\\\\\\\n    /// Destroy a plugin handle and free all resources.\\\\\\\\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start the audio processing state (call from audio thread after activate).\\\\\\\\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Process one block of audio through the plugin.\\\\\\\\n    pub fn zph_process(\\\\\\\\n        plugin: *mut ZphPlugin,\\\\\\\\n        inputs: *const *const f32,\\\\\\\\n        outputs: *const *mut f32,\\\\\\\\n        channel_count: u32,\\\\\\\\n        frame_count: u32,\\\\\\\\n    ) -&gt; ZphProcessStatus;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\\n    pub fn zph_get_param_info(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        index: u32,\\\\\\\\n        out: *mut ZphParamInfo,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn zph_get_param_value(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        param_id: u32,\\\\\\\\n        out: *mut f64,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\\n\\\\\\\\n    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy a plugin handle and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state (call from audio thread after activate).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Process one block of audio through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *mut ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"        inputs: *const *const f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        outputs: *const *mut f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        channel_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        frame_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; ZphProcessStatus;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the number of parameters the plugin exposes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_info(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"        index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut ZphParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the current value of a parameter by its stable ID.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163}]},\\\\\\\"score\\\\\\\":0.07598370313644409},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\nuse crate::host::PluginHost;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AudioEngine\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\\n///\\\\\\\\n/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\\n/// CoreAudio AudioQueue on macOS.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread.\\\\\\\\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct AudioEngine {\\\\\\\\n    ptr: *mut ffi::ZpeEngine,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Drop for AudioEngine {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// AudioEngine\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// CoreAudio AudioQueue on macOS.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZpeEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36}]},\\\\\\\"score\\\\\\\":0.07207799702882767},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/transport.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":6,\\\\\\\"column\\\\\\\":74}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\\n//!\\\\\\\\n//! This module is kept for organisational clarity; the actual transport\\\\\\\\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\\n\\\\\\\\n// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! This module is kept for organisational clarity; the actual transport\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7}]},\\\\\\\"score\\\\\\\":0.06763135641813278},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":61,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":119,\\\\\\\"column\\\\\\\":73}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\\n    ///\\\\\\\\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\\n            .transpose()?;\\\\\\\\n\\\\\\\\n        let id_ptr = id_cstr\\\\\\\\n            .as_ref()\\\\\\\\n            .map(|c| c.as_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null());\\\\\\\\n\\\\\\\\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn deactivate(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn stop_processing(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve plugin metadata.\\\\\\\\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            .transpose()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_ptr = id_cstr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|c| c.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn deactivate(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop_processing(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Retrieve plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120}]},\\\\\\\"score\\\\\\\":0.059956200420856476}]}\\\"},\\\"capabilityType\\\":15}\",\"c246edbf-8390-4883-b2be-3b3e0f33fc78\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"929a9ff2-de62-49ba-b686-f94d44ed768e\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.577Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_c0aad9a7-6e3d-49d9-9836-6a42acd3455\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_c0aad9a7-6e3d-49d9-9836-6a42acd3455\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does audio playback work and how is playhead position tracked?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"zloader\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does audio playback work and how is playhead position tracked?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"zloader\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer(Duration::from_millis(30))\\\\\\\\n                    .await;\\\\\\\\n\\\\\\\\n                let should_stop = cx.update(|cx| {\\\\\\\\n                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    // Poll position and call idle.\\\\\\\\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\\n                        s.host.idle();\\\\\\\\n                        (s.engine.position(), s.engine.is_playing())\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update waveform playhead.\\\\\\\\n                    waveform_entity.update(cx, |w, cx| {\\\\\\\\n                        w.position = position;\\\\\\\\n                        cx.notify();\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update root view playing state.\\\\\\\\n                    this.update(cx, |app, cx| {\\\\\\\\n                        app.is_playing = is_playing;\\\\\\\\n                        cx.notify();\\\\\\\\n                    })\\\\\\\\n                    .is_err()\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                if should_stop.unwrap_or(true) {\\\\\\\\n                    break;\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        })\\\\\\\\n        .detach();\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            state,\\\\\\\\n            waveform,\\\\\\\\n            params_view,\\\\\\\\n            is_playing: false,\\\\\\\\n            plugin_name,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            s.engine.seek(0);\\\\\\\\n        });\\\\\\\\n        self.waveform.update(cx, |w, cx| {\\\\\\\\n            w.position = 0;\\\\\\\\n            cx.notify();\\\\\\\\n        });\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer(Duration::from_millis(30))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .await;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let should_stop = cx.update(|cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Poll position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                        s.host.idle();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                        (s.engine.position(), s.engine.is_playing())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update waveform playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                    waveform_entity.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                        w.position = position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update root view playing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                    this.update(cx, |app, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"                        app.is_playing = is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .is_err()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                if should_stop.unwrap_or(true) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"            state,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"            waveform,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"            params_view,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            is_playing: false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"            plugin_name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"            s.engine.seek(0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.waveform.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"            w.position = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"            cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152}]},\\\\\\\"score\\\\\\\":0.43859583139419556},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":28,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":94,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    ///\\\\\\\\n    /// Stops playback and resets position if a file was already loaded.\\\\\\\\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    ///\\\\\\\\n    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\\n    /// output. The plugin must be activated and processing-started before\\\\\\\\n    /// calling &#96;play()&#96;.\\\\\\\\n    ///\\\\\\\\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\\n        let plugin_ptr = host\\\\\\\\n            .map(|h| h.raw_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null_mut());\\\\\\\\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Pause playback. The current position is preserved.\\\\\\\\n    pub fn pause(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn stop(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stops playback and resets position if a file was already loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// output. The plugin must be activated and processing-started before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// calling &#96;play()&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_ptr = host\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|h| h.raw_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null_mut());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback. The current position is preserved.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn pause(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95}]},\\\\\\\"score\\\\\\\":0.3967767059803009},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":92,\\\\\\\"column\\\\\\\":48},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":138,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn position(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn length(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\\n        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn position(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn length(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139}]},\\\\\\\"score\\\\\\\":0.37413346767425537},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":160,\\\\\\\"column\\\\\\\":68},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":214,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\\n\\\\\\\\n    /// Destroy the engine and free all resources.\\\\\\\\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Pause playback (position preserved).\\\\\\\\n    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn zpe_set_looping\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy the engine and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback (position preserved).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_looping\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215}]},\\\\\\\"score\\\\\\\":0.34863340854644775},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":139,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":180,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\\n    peaks: &amp;WaveformPeaks,\\\\\\\\n    position: u64,\\\\\\\\n) {\\\\\\\\n    let width = f32::from(bounds.size.width);\\\\\\\\n    let height = f32::from(bounds.size.height);\\\\\\\\n    let origin_x = f32::from(bounds.origin.x);\\\\\\\\n    let origin_y = f32::from(bounds.origin.y);\\\\\\\\n    let mid_y = origin_y + height / 2.0;\\\\\\\\n    let half_h = height / 2.0 * 0.9;\\\\\\\\n\\\\\\\\n    let num_cols = peaks.peaks.len().max(1);\\\\\\\\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\\n    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\\n    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\\n\\\\\\\\n    // Draw waveform bars.\\\\\\\\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\\n        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\\n\\\\\\\\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\\n        let bar_height = (bottom - top).max(1.0);\\\\\\\\n\\\\\\\\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Draw center line.\\\\\\\\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\\n\\\\\\\\n    // Draw playhead.\\\\\\\\n    if peaks.total_samples &gt; 0 {\\\\\\\\n        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    peaks: &amp;WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\") {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    let width = f32::from(bounds.size.width);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"    let height = f32::from(bounds.size.height);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_x = f32::from(bounds.origin.x);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_y = f32::from(bounds.origin.y);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mid_y = origin_y + height / 2.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    let half_h = height / 2.0 * 0.9;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    let num_cols = peaks.peaks.len().max(1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw waveform bars.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_height = (bottom - top).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw center line.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    if peaks.total_samples &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181}]},\\\\\\\"score\\\\\\\":0.320510596036911},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":99,\\\\\\\"column\\\\\\\":46},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":154,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\\n/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\\nconst WAVEFORM_COLUMNS: usize = 1200;\\\\\\\\n\\\\\\\\nfn setup(\\\\\\\\n    cx: &amp;mut App,\\\\\\\\n    plugin_path: &amp;PathBuf,\\\\\\\\n    audio_path: &amp;PathBuf,\\\\\\\\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\\n    // Load the plugin.\\\\\\\\n    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\\n    let plugin_info = host.get_info()?;\\\\\\\\n    let params = host.get_params();\\\\\\\\n\\\\\\\\n    // Create the audio engine and load the WAV file.\\\\\\\\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    engine.load_file(audio_path)?;\\\\\\\\n\\\\\\\\n    // Activate and start processing.\\\\\\\\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    host.start_processing()?;\\\\\\\\n\\\\\\\\n    // Attach plugin to engine.\\\\\\\\n    engine.set_plugin(Some(&amp;mut host));\\\\\\\\n\\\\\\\\n    // Read the WAV file for waveform peak computation.\\\\\\\\n    let peaks = build_peaks(audio_path)?;\\\\\\\\n\\\\\\\\n    let state = cx.new(|_cx| AppState {\\\\\\\\n        host,\\\\\\\\n        engine,\\\\\\\\n        plugin_info,\\\\\\\\n        params,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok((state, peaks))\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read the WAV file and compute waveform peaks for display.\\\\\\\\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\\n    let data = std::fs::read(path)?;\\\\\\\\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\\n    Ok(peaks)\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\\n/// Returns (interleaved_f32_samples, channel_count).\\\\\\\\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"const WAVEFORM_COLUMNS: usize = 1200;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"fn setup(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    cx: &amp;mut App,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Load the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_info = host.get_info()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    let params = host.get_params();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Create the audio engine and load the WAV file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.load_file(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Activate and start processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.start_processing()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Attach plugin to engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.set_plugin(Some(&amp;mut host));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Read the WAV file for waveform peak computation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = build_peaks(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"    let state = cx.new(|_cx| AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        engine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        params,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((state, peaks))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Read the WAV file and compute waveform peaks for display.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"fn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    let data = std::fs::read(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(peaks)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Returns (interleaved_f32_samples, channel_count).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"fn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155}]},\\\\\\\"score\\\\\\\":0.26222729682922363},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\nuse crate::host::PluginHost;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AudioEngine\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\\n///\\\\\\\\n/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\\n/// CoreAudio AudioQueue on macOS.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread.\\\\\\\\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct AudioEngine {\\\\\\\\n    ptr: *mut ffi::ZpeEngine,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Drop for AudioEngine {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// AudioEngine\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// CoreAudio AudioQueue on macOS.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZpeEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36}]},\\\\\\\"score\\\\\\\":0.2587951421737671},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":42,\\\\\\\"column\\\\\\\":32}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\\n//!\\\\\\\\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\\n//! and drives the periodic idle/position-poll timer.\\\\\\\\n\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::button::{Button, ButtonVariants};\\\\\\\\nuse gpui_component::slider::SliderEvent;\\\\\\\\n\\\\\\\\nuse crate::engine::AudioEngine;\\\\\\\\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\\nuse crate::params::ParamsView;\\\\\\\\nuse crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AppState  owns the non-Send FFI resources\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\\npub struct AppState {\\\\\\\\n    pub host: PluginHost,\\\\\\\\n    pub engine: AudioEngine,\\\\\\\\n    pub plugin_info: PluginInfo,\\\\\\\\n    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ZLoaderApp  root view\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\npub struct ZLoaderApp {\\\\\\\\n    state: Entity&lt;AppState&gt;,\\\\\\\\n    waveform: Entity&lt;WaveformView&gt;,\\\\\\\\n    params_view: Entity&lt;ParamsView&gt;,\\\\\\\\n    is_playing: bool,\\\\\\\\n    plugin_name: SharedString,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! and drives the periodic idle/position-poll timer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::button::{Button, ButtonVariants};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::SliderEvent;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::params::ParamsView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// AppState  owns the non-Send FFI resources\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub host: PluginHost,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub engine: AudioEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub plugin_info: PluginInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"// ZLoaderApp  root view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    waveform: Entity&lt;WaveformView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    params_view: Entity&lt;ParamsView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    is_playing: bool,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_name: SharedString,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.22863823175430298},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":148,\\\\\\\"column\\\\\\\":20},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":179,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            if is_playing {\\\\\\\\n                s.engine.stop();\\\\\\\\n            } else {\\\\\\\\n                let _ = s.engine.play();\\\\\\\\n            }\\\\\\\\n        });\\\\\\\\n        self.is_playing = !is_playing;\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ZLoaderApp {\\\\\\\\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let play_label: SharedString = if self.is_playing {\\\\\\\\n            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\\n        } else {\\\\\\\\n            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\\n        };\\\\\\\\n        let plugin_name = self.plugin_name.clone();\\\\\\\\n        let waveform = self.waveform.clone();\\\\\\\\n        let params_view = self.params_view.clone();\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"            if is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                s.engine.stop();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"                let _ = s.engine.play();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.is_playing = !is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        let play_label: SharedString = if self.is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name = self.plugin_name.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = self.waveform.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = self.params_view.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180}]},\\\\\\\"score\\\\\\\":0.22596290707588196},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":38,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":93,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\\n        peaks: WaveformPeaks,\\\\\\\\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\\n    ) -&gt; Self {\\\\\\\\n        let plugin_name: SharedString = state\\\\\\\\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\\n            .into();\\\\\\\\n\\\\\\\\n        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\\n\\\\\\\\n        // Build the waveform view.\\\\\\\\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\\n\\\\\\\\n        // Build the params view.\\\\\\\\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\\n\\\\\\\\n        // Subscribe to slider changes and forward to the plugin host.\\\\\\\\n        // This runs on the main thread with full access to cx.\\\\\\\\n        let state_for_params = state.clone();\\\\\\\\n        params_view\\\\\\\\n            .read_with(cx, |pv, _| {\\\\\\\\n                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\\n                pv.sliders\\\\\\\\n                    .iter()\\\\\\\\n                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\\n            })\\\\\\\\n            .into_iter()\\\\\\\\n            .for_each(|(param_id, slider_entity)| {\\\\\\\\n                let state_weak = state_for_params.downgrade();\\\\\\\\n                cx.subscribe(\\\\\\\\n                    &amp;slider_entity,\\\\\\\\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\\n                        let SliderEvent::Change(value) = event;\\\\\\\\n                        let v = value.start() as f64;\\\\\\\\n                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\\n                            state_entity.read_with(cx, |s, _| {\\\\\\\\n                                s.host.set_param_value(param_id, v);\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .detach();\\\\\\\\n            });\\\\\\\\n\\\\\\\\n        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\\n        let state_weak = state.downgrade();\\\\\\\\n        let waveform_weak = waveform.downgrade();\\\\\\\\n        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name: SharedString = state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the waveform view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the params view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Subscribe to slider changes and forward to the plugin host.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This runs on the main thread with full access to cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_for_params = state.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        params_view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |pv, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                pv.sliders\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into_iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            .for_each(|(param_id, slider_entity)| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"                let state_weak = state_for_params.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.subscribe(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;slider_entity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let SliderEvent::Change(value) = event;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let v = value.start() as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                            state_entity.read_with(cx, |s, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                                s.host.set_param_value(param_id, v);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_weak = state.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform_weak = waveform.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94}]},\\\\\\\"score\\\\\\\":0.20695990324020386},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":24,\\\\\\\"column\\\\\\\":18}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\\n//!\\\\\\\\n//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\\n//! playhead line indicating the current playback position.\\\\\\\\n\\\\\\\\nuse gpui::{\\\\\\\\n    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\\n    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\\n/// One entry per display column (pixel-width bucket).\\\\\\\\n#[derive(Clone)]\\\\\\\\npub struct WaveformPeaks {\\\\\\\\n    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\\n    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\\n    /// Total number of samples in the source file (for playhead math).\\\\\\\\n    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! playhead line indicating the current playback position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"/// One entry per display column (pixel-width bucket).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Total number of samples in the source file (for playhead math).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25}]},\\\\\\\"score\\\\\\\":0.1955839991569519},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":84},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":143,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\\n    pub position: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformView {\\\\\\\\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\\n        Self { peaks, position: 0 }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for WaveformView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let peaks = self.peaks.clone();\\\\\\\\n        let position = self.position;\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .w_full()\\\\\\\\n            .h(px(120.0))\\\\\\\\n            .bg(rgb(0x1a1a2e))\\\\\\\\n            .rounded(px(6.0))\\\\\\\\n            .overflow_hidden()\\\\\\\\n            .child(\\\\\\\\n                canvas(\\\\\\\\n                    move |_bounds, _window, _cx| {},\\\\\\\\n                    move |bounds, _prepaint, window, _cx| {\\\\\\\\n                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .w_full()\\\\\\\\n                .h_full(),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Drawing helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\\n    window.paint_quad(PaintQuad {\\\\\\\\n        bounds: Bounds {\\\\\\\\n            origin: Point { x: px(x), y: px(y) },\\\\\\\\n            size: Size {\\\\\\\\n                width: px(w),\\\\\\\\n                height: px(h),\\\\\\\\n            },\\\\\\\\n        },\\\\\\\\n        corner_radii: Corners::all(px(0.0)),\\\\\\\\n        background: Background::from(color),\\\\\\\\n        border_widths: Edges::all(px(0.0)),\\\\\\\\n        border_color: gpui::transparent_black(),\\\\\\\\n        border_style: BorderStyle::default(),\\\\\\\\n    });\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { peaks, position: 0 }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        let peaks = self.peaks.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        let position = self.position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"            .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"            .h(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x1a1a2e))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"            .rounded(px(6.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            .overflow_hidden()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                canvas(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_bounds, _window, _cx| {},\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |bounds, _prepaint, window, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"                .h_full(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"// Drawing helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"fn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    window.paint_quad(PaintQuad {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"        bounds: Bounds {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            origin: Point { x: px(x), y: px(y) },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            size: Size {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"                width: px(w),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"                height: px(h),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        corner_radii: Corners::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        background: Background::from(color),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_widths: Edges::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_color: gpui::transparent_black(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_style: BorderStyle::default(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144}]},\\\\\\\"score\\\\\\\":0.1902240514755249},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":105,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":163}},\\\\\\\"contents\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\\n\\\\\\\\n    /// Destroy a plugin handle and free all resources.\\\\\\\\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start the audio processing state (call from audio thread after activate).\\\\\\\\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Process one block of audio through the plugin.\\\\\\\\n    pub fn zph_process(\\\\\\\\n        plugin: *mut ZphPlugin,\\\\\\\\n        inputs: *const *const f32,\\\\\\\\n        outputs: *const *mut f32,\\\\\\\\n        channel_count: u32,\\\\\\\\n        frame_count: u32,\\\\\\\\n    ) -&gt; ZphProcessStatus;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\\n    pub fn zph_get_param_info(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        index: u32,\\\\\\\\n        out: *mut ZphParamInfo,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn zph_get_param_value(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        param_id: u32,\\\\\\\\n        out: *mut f64,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\\n\\\\\\\\n    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy a plugin handle and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state (call from audio thread after activate).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Process one block of audio through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *mut ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"        inputs: *const *const f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        outputs: *const *mut f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        channel_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        frame_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; ZphProcessStatus;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the number of parameters the plugin exposes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_info(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"        index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut ZphParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the current value of a parameter by its stable ID.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163}]},\\\\\\\"score\\\\\\\":0.18764279782772064},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":205,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":237,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .w(px(120.0))\\\\\\\\n                            .flex_shrink_0()\\\\\\\\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .flex()\\\\\\\\n                                    .flex_row()\\\\\\\\n                                    .gap(px(8.0))\\\\\\\\n                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\\n                                        |app, _ev, window, cx| {\\\\\\\\n                                            app.on_rewind(window, cx);\\\\\\\\n                                        },\\\\\\\\n                                    )))\\\\\\\\n                                    .child(\\\\\\\\n                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\\n                                            .primary()\\\\\\\\n                                            .label(play_label)\\\\\\\\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\\n                                                app.on_play_stop(window, cx);\\\\\\\\n                                            })),\\\\\\\\n                                    ),\\\\\\\\n                            ),\\\\\\\\n                    )\\\\\\\\n                    // Parameter panel\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .w(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_shrink_0()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"                                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        |app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            app.on_rewind(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    )))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .primary()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .label(play_label)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                app.on_play_stop(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            })),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":231},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":232},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":233},{\\\\\\\"text\\\\\\\":\\\\\\\"                    )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":234},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Parameter panel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":235},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238}]},\\\\\\\"score\\\\\\\":0.17904633283615112},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":61,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":119,\\\\\\\"column\\\\\\\":73}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\\n    ///\\\\\\\\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\\n            .transpose()?;\\\\\\\\n\\\\\\\\n        let id_ptr = id_cstr\\\\\\\\n            .as_ref()\\\\\\\\n            .map(|c| c.as_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null());\\\\\\\\n\\\\\\\\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn deactivate(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn stop_processing(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve plugin metadata.\\\\\\\\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            .transpose()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_ptr = id_cstr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|c| c.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn deactivate(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop_processing(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Retrieve plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120}]},\\\\\\\"score\\\\\\\":0.16635066270828247},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":62},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":197,\\\\\\\"column\\\\\\\":62}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let mut pos = 12usize;\\\\\\\\n    let mut fmt_channels: u16 = 0;\\\\\\\\n    let mut fmt_bits: u16 = 0;\\\\\\\\n    let mut fmt_audio_format: u16 = 0;\\\\\\\\n    let mut data_start = 0usize;\\\\\\\\n    let mut data_len = 0usize;\\\\\\\\n\\\\\\\\n    while pos + 8 &lt;= data.len() {\\\\\\\\n        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\\n        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\\n        pos += 8;\\\\\\\\n\\\\\\\\n        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\\n            if chunk_size &gt;= 16 {\\\\\\\\n                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\\n                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\\n                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\\n            }\\\\\\\\n        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\\n            data_start = pos;\\\\\\\\n            data_len = chunk_size;\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        pos += chunk_size;\\\\\\\\n        if chunk_size % 2 != 0 {\\\\\\\\n            pos += 1;\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if data_start == 0 || fmt_channels == 0 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\\n    let channels = fmt_channels as usize;\\\\\\\\n\\\\\\\\n    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut pos = 12usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_channels: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_bits: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_audio_format: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_start = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_len = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"    while pos + 8 &lt;= data.len() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"            if chunk_size &gt;= 16 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_start = pos;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_len = chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"            break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_size % 2 != 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"            pos += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data_start == 0 || fmt_channels == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    let channels = fmt_channels as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198}]},\\\\\\\"score\\\\\\\":0.1592186987400055},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":195,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":229,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\\n        (3, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\\n            .collect(),\\\\\\\\n        (1, 16) =&gt; raw\\\\\\\\n            .chunks_exact(2)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 32768.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 24) =&gt; raw\\\\\\\\n            .chunks_exact(3)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\\n                s as f32 / 8388608.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 2147483648.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        _ =&gt; anyhow::bail!(\\\\\\\\n            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\\n        ),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    Ok((samples, channels))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        (3, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 16) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(2)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 32768.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 24) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(3)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 8388608.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 2147483648.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; anyhow::bail!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"        ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((samples, channels))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230}]},\\\\\\\"score\\\\\\\":0.15209460258483887},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":57,\\\\\\\"column\\\\\\\":30}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Raw FFI bindings to z_plug_host and z_plug_engine C APIs.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n//!\\\\\\\\n//! These declarations mirror &#96;lib/z_plug_host/z_plug_host.h&#96; and\\\\\\\\n//! &#96;lib/z_plug_engine/z_plug_engine.h&#96; exactly. Do not use these types\\\\\\\\n//! directly; prefer the safe wrappers in &#96;host.rs&#96; and &#96;engine.rs&#96;.\\\\\\\\n\\\\\\\\nuse std::ffi::c_char;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Opaque handle types\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Opaque handle to a loaded CLAP plugin instance (&#96;ZphPlugin*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPlugin {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Opaque handle to an audio engine instance (&#96;ZpeEngine*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZpeEngine {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Process status (mirrors clap_process_status)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[repr(i32)]\\\\\\\\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\\\\\\\\npub enum ZphProcessStatus {\\\\\\\\n    Error = 0,\\\\\\\\n    Continue = 1,\\\\\\\\n    ContinueIfNotQuiet = 2,\\\\\\\\n    Tail = 3,\\\\\\\\n    Sleep = 4,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info struct (matches ZphPluginInfo in z_plug_host.h)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Plugin metadata returned by &#96;zph_get_plugin_info&#96;.\\\\\\\\n/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPluginInfo {\\\\\\\\n    pub id: *const c_char,\\\\\\\\n    pub name: *const c_char,\\\\\\\\n    pub vendor: *const c_char,\\\\\\\\n    pub version: *const c_char,\\\\\\\\n    pub description: *const c_char,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Default for ZphPluginInfo\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Raw FFI bindings to z_plug_host and z_plug_engine C APIs.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! These declarations mirror &#96;lib/z_plug_host/z_plug_host.h&#96; and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;lib/z_plug_engine/z_plug_engine.h&#96; exactly. Do not use these types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"//! directly; prefer the safe wrappers in &#96;host.rs&#96; and &#96;engine.rs&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// Opaque handle types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Opaque handle to a loaded CLAP plugin instance (&#96;ZphPlugin*&#96;).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZphPlugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    _private: [u8; 0],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Opaque handle to an audio engine instance (&#96;ZpeEngine*&#96;).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZpeEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    _private: [u8; 0],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// Process status (mirrors clap_process_status)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(i32)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone, Copy, PartialEq, Eq)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum ZphProcessStatus {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    Error = 0,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    Continue = 1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    ContinueIfNotQuiet = 2,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    Tail = 3,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    Sleep = 4,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Plugin info struct (matches ZphPluginInfo in z_plug_host.h)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Plugin metadata returned by &#96;zph_get_plugin_info&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZphPluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub description: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub latency_samples: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Default for ZphPluginInfo\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58}]},\\\\\\\"score\\\\\\\":0.1465774029493332},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":166,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":208,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    /// Thread-safe; may be called from any thread.\\\\\\\\n    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\\n        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn idle(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the raw pointer for passing to the engine.\\\\\\\\n    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\\n        self.ptr\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\\n    if ptr.is_null() {\\\\\\\\n        return String::new();\\\\\\\\n    }\\\\\\\\n    unsafe { CStr::from_ptr(ptr) }\\\\\\\\n        .to_string_lossy()\\\\\\\\n        .into_owned()\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\\n    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\\n    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Thread-safe; may be called from any thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn idle(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the raw pointer for passing to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.ptr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        return String::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe { CStr::from_ptr(ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_string_lossy()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        .into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209}]},\\\\\\\"score\\\\\\\":0.1410904973745346},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":41,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":103,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\\n\\\\\\\\n    if !args.plugin_path.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\\n    }\\\\\\\\n    if !args.audio_file.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let plugin_path = args.plugin_path.clone();\\\\\\\\n    let audio_path = args.audio_file.clone();\\\\\\\\n\\\\\\\\n    Application::new().run(move |cx: &amp;mut App| {\\\\\\\\n        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\\n\\\\\\\\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\\n        gpui_component::init(cx);\\\\\\\\n\\\\\\\\n        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\\n            Ok(v) =&gt; v,\\\\\\\\n            Err(e) =&gt; {\\\\\\\\n                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\\n                cx.quit();\\\\\\\\n                return;\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\\n\\\\\\\\n        cx.open_window(\\\\\\\\n            WindowOptions {\\\\\\\\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\\n                titlebar: Some(gpui::TitlebarOptions {\\\\\\\\n                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\\n                    ..Default::default()\\\\\\\\n                }),\\\\\\\\n                ..Default::default()\\\\\\\\n            },\\\\\\\\n            move |window, cx| {\\\\\\\\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\\n            },\\\\\\\\n        )\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        cx.activate(true);\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Setup: load plugin + audio, build peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.plugin_path.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.audio_file.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_path = args.plugin_path.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    let audio_path = args.audio_file.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    Application::new().run(move |cx: &amp;mut App| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        gpui_component::init(cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            Ok(v) =&gt; v,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            Err(e) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.quit();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"                return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.open_window(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            WindowOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                titlebar: Some(gpui::TitlebarOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            move |window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.activate(true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"// Setup: load plugin + audio, build peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104}]},\\\\\\\"score\\\\\\\":0.14078235626220703},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":21},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":87}},\\\\\\\"contents\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks {\\\\\\\\n    /// Build peak data from raw interleaved f32 samples.\\\\\\\\n    ///\\\\\\\\n    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\\n    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\\n    /// bucket across all channels.\\\\\\\\n    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\\n        let total_frames = if channels &gt; 0 {\\\\\\\\n            samples.len() / channels\\\\\\\\n        } else {\\\\\\\\n            0\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let total_samples = total_frames as u64;\\\\\\\\n\\\\\\\\n        if total_frames == 0 || num_columns == 0 {\\\\\\\\n            return Self {\\\\\\\\n                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\\n                total_samples,\\\\\\\\n            };\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\\n        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\\n\\\\\\\\n        for col in 0..num_columns {\\\\\\\\n            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = end_frame.min(total_frames);\\\\\\\\n\\\\\\\\n            let mut min = 0.0f32;\\\\\\\\n            let mut max = 0.0f32;\\\\\\\\n\\\\\\\\n            for frame in start_frame..end_frame {\\\\\\\\n                for ch in 0..channels {\\\\\\\\n                    let sample = samples[frame * channels + ch];\\\\\\\\n                    if sample &lt; min {\\\\\\\\n                        min = sample;\\\\\\\\n                    }\\\\\\\\n                    if sample &gt; max {\\\\\\\\n                        max = sample;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            peaks.push((min, max));\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            peaks,\\\\\\\\n            total_samples,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// WaveformView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// A GPUI view that renders the waveform and a playhead.\\\\\\\\npub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build peak data from raw interleaved f32 samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// bucket across all channels.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_frames = if channels &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            samples.len() / channels\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"            0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_samples = total_frames as u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        if total_frames == 0 || num_columns == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"            return Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"                total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"        for col in 0..num_columns {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = end_frame.min(total_frames);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut min = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut max = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"            for frame in start_frame..end_frame {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"                for ch in 0..channels {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let sample = samples[frame * channels + ch];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &lt; min {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        min = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &gt; max {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                        max = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks.push((min, max));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"// WaveformView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A GPUI view that renders the waveform and a playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87}]},\\\\\\\"score\\\\\\\":0.13768279552459717},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/transport.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":6,\\\\\\\"column\\\\\\\":74}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\\n//!\\\\\\\\n//! This module is kept for organisational clarity; the actual transport\\\\\\\\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\\n\\\\\\\\n// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! This module is kept for organisational clarity; the actual transport\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7}]},\\\\\\\"score\\\\\\\":0.1340045928955078},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":44,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\\n//!\\\\\\\\n//! Usage:\\\\\\\\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\\n\\\\\\\\nmod app;\\\\\\\\nmod engine;\\\\\\\\nmod ffi;\\\\\\\\nmod host;\\\\\\\\nmod params;\\\\\\\\nmod transport;\\\\\\\\nmod waveform;\\\\\\\\n\\\\\\\\nuse std::path::PathBuf;\\\\\\\\n\\\\\\\\nuse anyhow::Result;\\\\\\\\nuse clap::Parser;\\\\\\\\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\\nuse gpui_component::{theme::Theme, Root};\\\\\\\\n\\\\\\\\nuse app::{AppState, ZLoaderApp};\\\\\\\\nuse engine::AudioEngine;\\\\\\\\nuse host::PluginHost;\\\\\\\\nuse waveform::WaveformPeaks;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// CLI\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[derive(Parser, Debug)]\\\\\\\\n#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\\nstruct Args {\\\\\\\\n    /// Path to the .clap plugin file or bundle.\\\\\\\\n    plugin_path: PathBuf,\\\\\\\\n\\\\\\\\n    /// Path to a WAV audio file to play through the plugin.\\\\\\\\n    audio_file: PathBuf,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Entry point\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Usage:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod app;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod engine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"mod host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod transport;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"mod waveform;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::Result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap::Parser;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::{theme::Theme, Root};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"use app::{AppState, ZLoaderApp};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use waveform::WaveformPeaks;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// CLI\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Parser, Debug)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"struct Args {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to the .clap plugin file or bundle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to a WAV audio file to play through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_file: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Entry point\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45}]},\\\\\\\"score\\\\\\\":0.13095200061798096},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/build.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":59}},\\\\\\\"contents\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\\nuse std::process::Command;\\\\\\\\n\\\\\\\\nfn main() {\\\\\\\\n    let repo_root = PathBuf::from(env!(\\\\\\\\\\\\\\\"CARGO_MANIFEST_DIR\\\\\\\\\\\\\\\"))\\\\\\\\n        .parent()\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"zloader must be inside the z-plug repo\\\\\\\\\\\\\\\")\\\\\\\\n        .to_path_buf();\\\\\\\\n\\\\\\\\n    // Tell cargo to re-run this script if Zig sources change.\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_host\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_engine\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"build.zig\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n\\\\\\\\n    // Build the Zig static libraries. We need to activate the Nix/direnv\\\\\\\\n    // environment to get Zig 0.15.2 on PATH. We do this by running direnv\\\\\\\\n    // export bash and sourcing its output before invoking zig.\\\\\\\\n    //\\\\\\\\n    // If direnv is not available (e.g. CI without Nix), fall back to\\\\\\\\n    // expecting &#96;zig&#96; to already be on PATH.\\\\\\\\n    let zig_path = find_zig(&amp;repo_root);\\\\\\\\n\\\\\\\\n    let status = Command::new(&amp;zig_path)\\\\\\\\n        .args([\\\\\\\\\\\\\\\"build\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"host\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"engine\\\\\\\\\\\\\\\"])\\\\\\\\n        .current_dir(&amp;repo_root)\\\\\\\\n        .status()\\\\\\\\n        .unwrap_or_else(|e| panic!(\\\\\\\\\\\\\\\"failed to run zig build: {e}\\\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    if !status.success() {\\\\\\\\n        panic!(\\\\\\\\\\\\\\\"zig build host engine failed with status: {status}\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Link the produced static libraries.\\\\\\\\n    let lib_dir = repo_root.join(\\\\\\\\\\\\\\\"zig-out/lib\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-search=native={}\\\\\\\\\\\\\\\", lib_dir.display());\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_host\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_engine\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // macOS frameworks required by z_plug_engine (CoreAudio via AudioQueue).\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=AudioToolbox\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=CoreAudio\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // libc is needed because the Zig libraries call into it.\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=c\\\\\\\\\\\\\\\");\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Locate the &#96;zig&#96; binary. Tries:\\\\\\\\n///   1. &#96;&lt;repo_root&gt;/.direnv&#96; paths (Nix devShell via direnv)\\\\\\\\n///   2. The &#96;ZIG&#96; environment variable\\\\\\\\n///   3. Plain &#96;zig&#96; on PATH\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::process::Command;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"    let repo_root = PathBuf::from(env!(\\\\\\\\\\\\\\\"CARGO_MANIFEST_DIR\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"        .parent()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"zloader must be inside the z-plug repo\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_path_buf();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Tell cargo to re-run this script if Zig sources change.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_host\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_engine\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"build.zig\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Build the Zig static libraries. We need to activate the Nix/direnv\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    // environment to get Zig 0.15.2 on PATH. We do this by running direnv\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    // export bash and sourcing its output before invoking zig.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    //\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    // If direnv is not available (e.g. CI without Nix), fall back to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    // expecting &#96;zig&#96; to already be on PATH.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    let zig_path = find_zig(&amp;repo_root);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"    let status = Command::new(&amp;zig_path)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"        .args([\\\\\\\\\\\\\\\"build\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"host\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"engine\\\\\\\\\\\\\\\"])\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"        .current_dir(&amp;repo_root)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"        .status()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        .unwrap_or_else(|e| panic!(\\\\\\\\\\\\\\\"failed to run zig build: {e}\\\\\\\\\\\\\\\"));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !status.success() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"        panic!(\\\\\\\\\\\\\\\"zig build host engine failed with status: {status}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Link the produced static libraries.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"    let lib_dir = repo_root.join(\\\\\\\\\\\\\\\"zig-out/lib\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-search=native={}\\\\\\\\\\\\\\\", lib_dir.display());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_host\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_engine\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    // macOS frameworks required by z_plug_engine (CoreAudio via AudioQueue).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=AudioToolbox\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=CoreAudio\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    // libc is needed because the Zig libraries call into it.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=c\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Locate the &#96;zig&#96; binary. Tries:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"///   1. &#96;&lt;repo_root&gt;/.direnv&#96; paths (Nix devShell via direnv)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"///   2. The &#96;ZIG&#96; environment variable\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"///   3. Plain &#96;zig&#96; on PATH\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59}]},\\\\\\\"score\\\\\\\":0.13002470135688782},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":67,\\\\\\\"column\\\\\\\":7}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::ffi::{CStr, CString};\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Param info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of a plugin parameter.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct ParamInfo {\\\\\\\\n    pub id: u32,\\\\\\\\n    pub name: String,\\\\\\\\n    pub module: String,\\\\\\\\n    pub min_value: f64,\\\\\\\\n    pub max_value: f64,\\\\\\\\n    pub default_value: f64,\\\\\\\\n    pub flags: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of plugin metadata.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub id: String,\\\\\\\\n    pub name: String,\\\\\\\\n    pub vendor: String,\\\\\\\\n    pub version: String,\\\\\\\\n    pub description: String,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// PluginHost\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread unless otherwise noted.\\\\\\\\n/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct PluginHost {\\\\\\\\n    ptr: *mut ffi::ZphPlugin,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// The Zig host library is designed for single-threaded main-thread use.\\\\\\\\n// We assert this by not implementing Send/Sync.\\\\\\\\n\\\\\\\\nimpl Drop for PluginHost {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::{CStr, CString};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Param info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of a plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub module: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub min_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub max_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub default_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub flags: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// Plugin info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub description: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub latency_samples: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"// PluginHost\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread unless otherwise noted.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"// The Zig host library is designed for single-threaded main-thread use.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"// We assert this by not implementing Send/Sync.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68}]},\\\\\\\"score\\\\\\\":0.12852509319782257}]}\\\"},\\\"capabilityType\\\":15}\",\"eb3ff8e0-b393-42ae-9528-538edaefad91\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"c8bb4043-49da-47ac-b110-f37a66d42333\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.579Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_d9c1f778-878e-4ff1-9ee1-f4f105f65ed\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_d9c1f778-878e-4ff1-9ee1-f4f105f65ed\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How are mouse clicks and input events handled?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"zloader\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How are mouse clicks and input events handled?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"zloader\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":38,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":93,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\\n        peaks: WaveformPeaks,\\\\\\\\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\\n    ) -&gt; Self {\\\\\\\\n        let plugin_name: SharedString = state\\\\\\\\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\\n            .into();\\\\\\\\n\\\\\\\\n        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\\n\\\\\\\\n        // Build the waveform view.\\\\\\\\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\\n\\\\\\\\n        // Build the params view.\\\\\\\\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\\n\\\\\\\\n        // Subscribe to slider changes and forward to the plugin host.\\\\\\\\n        // This runs on the main thread with full access to cx.\\\\\\\\n        let state_for_params = state.clone();\\\\\\\\n        params_view\\\\\\\\n            .read_with(cx, |pv, _| {\\\\\\\\n                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\\n                pv.sliders\\\\\\\\n                    .iter()\\\\\\\\n                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\\n            })\\\\\\\\n            .into_iter()\\\\\\\\n            .for_each(|(param_id, slider_entity)| {\\\\\\\\n                let state_weak = state_for_params.downgrade();\\\\\\\\n                cx.subscribe(\\\\\\\\n                    &amp;slider_entity,\\\\\\\\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\\n                        let SliderEvent::Change(value) = event;\\\\\\\\n                        let v = value.start() as f64;\\\\\\\\n                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\\n                            state_entity.read_with(cx, |s, _| {\\\\\\\\n                                s.host.set_param_value(param_id, v);\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .detach();\\\\\\\\n            });\\\\\\\\n\\\\\\\\n        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\\n        let state_weak = state.downgrade();\\\\\\\\n        let waveform_weak = waveform.downgrade();\\\\\\\\n        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name: SharedString = state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the waveform view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the params view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Subscribe to slider changes and forward to the plugin host.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This runs on the main thread with full access to cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_for_params = state.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        params_view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |pv, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                pv.sliders\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into_iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            .for_each(|(param_id, slider_entity)| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"                let state_weak = state_for_params.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.subscribe(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;slider_entity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let SliderEvent::Change(value) = event;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let v = value.start() as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                            state_entity.read_with(cx, |s, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                                s.host.set_param_value(param_id, v);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_weak = state.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform_weak = waveform.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94}]},\\\\\\\"score\\\\\\\":0.20485299825668335},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":41,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":103,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\\n\\\\\\\\n    if !args.plugin_path.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\\n    }\\\\\\\\n    if !args.audio_file.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let plugin_path = args.plugin_path.clone();\\\\\\\\n    let audio_path = args.audio_file.clone();\\\\\\\\n\\\\\\\\n    Application::new().run(move |cx: &amp;mut App| {\\\\\\\\n        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\\n\\\\\\\\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\\n        gpui_component::init(cx);\\\\\\\\n\\\\\\\\n        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\\n            Ok(v) =&gt; v,\\\\\\\\n            Err(e) =&gt; {\\\\\\\\n                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\\n                cx.quit();\\\\\\\\n                return;\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\\n\\\\\\\\n        cx.open_window(\\\\\\\\n            WindowOptions {\\\\\\\\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\\n                titlebar: Some(gpui::TitlebarOptions {\\\\\\\\n                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\\n                    ..Default::default()\\\\\\\\n                }),\\\\\\\\n                ..Default::default()\\\\\\\\n            },\\\\\\\\n            move |window, cx| {\\\\\\\\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\\n            },\\\\\\\\n        )\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        cx.activate(true);\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Setup: load plugin + audio, build peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.plugin_path.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.audio_file.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_path = args.plugin_path.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    let audio_path = args.audio_file.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    Application::new().run(move |cx: &amp;mut App| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        gpui_component::init(cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            Ok(v) =&gt; v,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            Err(e) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.quit();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"                return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.open_window(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            WindowOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                titlebar: Some(gpui::TitlebarOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            move |window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.activate(true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"// Setup: load plugin + audio, build peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104}]},\\\\\\\"score\\\\\\\":0.20024895668029785},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":99,\\\\\\\"column\\\\\\\":46},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":154,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\\n/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\\nconst WAVEFORM_COLUMNS: usize = 1200;\\\\\\\\n\\\\\\\\nfn setup(\\\\\\\\n    cx: &amp;mut App,\\\\\\\\n    plugin_path: &amp;PathBuf,\\\\\\\\n    audio_path: &amp;PathBuf,\\\\\\\\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\\n    // Load the plugin.\\\\\\\\n    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\\n    let plugin_info = host.get_info()?;\\\\\\\\n    let params = host.get_params();\\\\\\\\n\\\\\\\\n    // Create the audio engine and load the WAV file.\\\\\\\\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    engine.load_file(audio_path)?;\\\\\\\\n\\\\\\\\n    // Activate and start processing.\\\\\\\\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    host.start_processing()?;\\\\\\\\n\\\\\\\\n    // Attach plugin to engine.\\\\\\\\n    engine.set_plugin(Some(&amp;mut host));\\\\\\\\n\\\\\\\\n    // Read the WAV file for waveform peak computation.\\\\\\\\n    let peaks = build_peaks(audio_path)?;\\\\\\\\n\\\\\\\\n    let state = cx.new(|_cx| AppState {\\\\\\\\n        host,\\\\\\\\n        engine,\\\\\\\\n        plugin_info,\\\\\\\\n        params,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok((state, peaks))\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read the WAV file and compute waveform peaks for display.\\\\\\\\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\\n    let data = std::fs::read(path)?;\\\\\\\\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\\n    Ok(peaks)\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\\n/// Returns (interleaved_f32_samples, channel_count).\\\\\\\\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"const WAVEFORM_COLUMNS: usize = 1200;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"fn setup(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    cx: &amp;mut App,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Load the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_info = host.get_info()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    let params = host.get_params();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Create the audio engine and load the WAV file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.load_file(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Activate and start processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.start_processing()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Attach plugin to engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.set_plugin(Some(&amp;mut host));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Read the WAV file for waveform peak computation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = build_peaks(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"    let state = cx.new(|_cx| AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        engine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        params,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((state, peaks))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Read the WAV file and compute waveform peaks for display.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"fn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    let data = std::fs::read(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(peaks)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Returns (interleaved_f32_samples, channel_count).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"fn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155}]},\\\\\\\"score\\\\\\\":0.1922374963760376},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":42,\\\\\\\"column\\\\\\\":32}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\\n//!\\\\\\\\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\\n//! and drives the periodic idle/position-poll timer.\\\\\\\\n\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::button::{Button, ButtonVariants};\\\\\\\\nuse gpui_component::slider::SliderEvent;\\\\\\\\n\\\\\\\\nuse crate::engine::AudioEngine;\\\\\\\\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\\nuse crate::params::ParamsView;\\\\\\\\nuse crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AppState  owns the non-Send FFI resources\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\\npub struct AppState {\\\\\\\\n    pub host: PluginHost,\\\\\\\\n    pub engine: AudioEngine,\\\\\\\\n    pub plugin_info: PluginInfo,\\\\\\\\n    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ZLoaderApp  root view\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\npub struct ZLoaderApp {\\\\\\\\n    state: Entity&lt;AppState&gt;,\\\\\\\\n    waveform: Entity&lt;WaveformView&gt;,\\\\\\\\n    params_view: Entity&lt;ParamsView&gt;,\\\\\\\\n    is_playing: bool,\\\\\\\\n    plugin_name: SharedString,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! and drives the periodic idle/position-poll timer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::button::{Button, ButtonVariants};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::SliderEvent;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::params::ParamsView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// AppState  owns the non-Send FFI resources\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub host: PluginHost,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub engine: AudioEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub plugin_info: PluginInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"// ZLoaderApp  root view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    waveform: Entity&lt;WaveformView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    params_view: Entity&lt;ParamsView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    is_playing: bool,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_name: SharedString,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.15442979335784912},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer(Duration::from_millis(30))\\\\\\\\n                    .await;\\\\\\\\n\\\\\\\\n                let should_stop = cx.update(|cx| {\\\\\\\\n                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    // Poll position and call idle.\\\\\\\\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\\n                        s.host.idle();\\\\\\\\n                        (s.engine.position(), s.engine.is_playing())\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update waveform playhead.\\\\\\\\n                    waveform_entity.update(cx, |w, cx| {\\\\\\\\n                        w.position = position;\\\\\\\\n                        cx.notify();\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update root view playing state.\\\\\\\\n                    this.update(cx, |app, cx| {\\\\\\\\n                        app.is_playing = is_playing;\\\\\\\\n                        cx.notify();\\\\\\\\n                    })\\\\\\\\n                    .is_err()\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                if should_stop.unwrap_or(true) {\\\\\\\\n                    break;\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        })\\\\\\\\n        .detach();\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            state,\\\\\\\\n            waveform,\\\\\\\\n            params_view,\\\\\\\\n            is_playing: false,\\\\\\\\n            plugin_name,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            s.engine.seek(0);\\\\\\\\n        });\\\\\\\\n        self.waveform.update(cx, |w, cx| {\\\\\\\\n            w.position = 0;\\\\\\\\n            cx.notify();\\\\\\\\n        });\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer(Duration::from_millis(30))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .await;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let should_stop = cx.update(|cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Poll position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                        s.host.idle();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                        (s.engine.position(), s.engine.is_playing())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update waveform playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                    waveform_entity.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                        w.position = position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update root view playing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                    this.update(cx, |app, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"                        app.is_playing = is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .is_err()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                if should_stop.unwrap_or(true) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"            state,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"            waveform,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"            params_view,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            is_playing: false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"            plugin_name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"            s.engine.seek(0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.waveform.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"            w.position = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"            cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152}]},\\\\\\\"score\\\\\\\":0.15034162998199463},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":28,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":94,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    ///\\\\\\\\n    /// Stops playback and resets position if a file was already loaded.\\\\\\\\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    ///\\\\\\\\n    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\\n    /// output. The plugin must be activated and processing-started before\\\\\\\\n    /// calling &#96;play()&#96;.\\\\\\\\n    ///\\\\\\\\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\\n        let plugin_ptr = host\\\\\\\\n            .map(|h| h.raw_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null_mut());\\\\\\\\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Pause playback. The current position is preserved.\\\\\\\\n    pub fn pause(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn stop(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stops playback and resets position if a file was already loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// output. The plugin must be activated and processing-started before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// calling &#96;play()&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_ptr = host\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|h| h.raw_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null_mut());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback. The current position is preserved.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn pause(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95}]},\\\\\\\"score\\\\\\\":0.144690603017807},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":44,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\\n//!\\\\\\\\n//! Usage:\\\\\\\\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\\n\\\\\\\\nmod app;\\\\\\\\nmod engine;\\\\\\\\nmod ffi;\\\\\\\\nmod host;\\\\\\\\nmod params;\\\\\\\\nmod transport;\\\\\\\\nmod waveform;\\\\\\\\n\\\\\\\\nuse std::path::PathBuf;\\\\\\\\n\\\\\\\\nuse anyhow::Result;\\\\\\\\nuse clap::Parser;\\\\\\\\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\\nuse gpui_component::{theme::Theme, Root};\\\\\\\\n\\\\\\\\nuse app::{AppState, ZLoaderApp};\\\\\\\\nuse engine::AudioEngine;\\\\\\\\nuse host::PluginHost;\\\\\\\\nuse waveform::WaveformPeaks;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// CLI\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[derive(Parser, Debug)]\\\\\\\\n#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\\nstruct Args {\\\\\\\\n    /// Path to the .clap plugin file or bundle.\\\\\\\\n    plugin_path: PathBuf,\\\\\\\\n\\\\\\\\n    /// Path to a WAV audio file to play through the plugin.\\\\\\\\n    audio_file: PathBuf,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Entry point\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Usage:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod app;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod engine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"mod host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod transport;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"mod waveform;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::Result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap::Parser;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::{theme::Theme, Root};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"use app::{AppState, ZLoaderApp};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use waveform::WaveformPeaks;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// CLI\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Parser, Debug)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"struct Args {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to the .clap plugin file or bundle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to a WAV audio file to play through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_file: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Entry point\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45}]},\\\\\\\"score\\\\\\\":0.12233967334032059},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":148,\\\\\\\"column\\\\\\\":20},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":179,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            if is_playing {\\\\\\\\n                s.engine.stop();\\\\\\\\n            } else {\\\\\\\\n                let _ = s.engine.play();\\\\\\\\n            }\\\\\\\\n        });\\\\\\\\n        self.is_playing = !is_playing;\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ZLoaderApp {\\\\\\\\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let play_label: SharedString = if self.is_playing {\\\\\\\\n            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\\n        } else {\\\\\\\\n            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\\n        };\\\\\\\\n        let plugin_name = self.plugin_name.clone();\\\\\\\\n        let waveform = self.waveform.clone();\\\\\\\\n        let params_view = self.params_view.clone();\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"            if is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                s.engine.stop();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"                let _ = s.engine.play();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.is_playing = !is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        let play_label: SharedString = if self.is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name = self.plugin_name.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = self.waveform.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = self.params_view.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180}]},\\\\\\\"score\\\\\\\":0.12203619629144669},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":105,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":163}},\\\\\\\"contents\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\\n\\\\\\\\n    /// Destroy a plugin handle and free all resources.\\\\\\\\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start the audio processing state (call from audio thread after activate).\\\\\\\\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Process one block of audio through the plugin.\\\\\\\\n    pub fn zph_process(\\\\\\\\n        plugin: *mut ZphPlugin,\\\\\\\\n        inputs: *const *const f32,\\\\\\\\n        outputs: *const *mut f32,\\\\\\\\n        channel_count: u32,\\\\\\\\n        frame_count: u32,\\\\\\\\n    ) -&gt; ZphProcessStatus;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\\n    pub fn zph_get_param_info(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        index: u32,\\\\\\\\n        out: *mut ZphParamInfo,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn zph_get_param_value(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        param_id: u32,\\\\\\\\n        out: *mut f64,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\\n\\\\\\\\n    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy a plugin handle and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state (call from audio thread after activate).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Process one block of audio through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *mut ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"        inputs: *const *const f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        outputs: *const *mut f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        channel_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        frame_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; ZphProcessStatus;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the number of parameters the plugin exposes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_info(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"        index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut ZphParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the current value of a parameter by its stable ID.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163}]},\\\\\\\"score\\\\\\\":0.11826193332672119},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":61,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":119,\\\\\\\"column\\\\\\\":73}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\\n    ///\\\\\\\\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\\n            .transpose()?;\\\\\\\\n\\\\\\\\n        let id_ptr = id_cstr\\\\\\\\n            .as_ref()\\\\\\\\n            .map(|c| c.as_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null());\\\\\\\\n\\\\\\\\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn deactivate(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn stop_processing(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve plugin metadata.\\\\\\\\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            .transpose()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_ptr = id_cstr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|c| c.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn deactivate(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop_processing(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Retrieve plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120}]},\\\\\\\"score\\\\\\\":0.11284332722425461},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":160,\\\\\\\"column\\\\\\\":68},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":214,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\\n\\\\\\\\n    /// Destroy the engine and free all resources.\\\\\\\\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Pause playback (position preserved).\\\\\\\\n    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn zpe_set_looping\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy the engine and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback (position preserved).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_looping\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215}]},\\\\\\\"score\\\\\\\":0.10535573959350586},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":166,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":208,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    /// Thread-safe; may be called from any thread.\\\\\\\\n    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\\n        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn idle(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the raw pointer for passing to the engine.\\\\\\\\n    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\\n        self.ptr\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\\n    if ptr.is_null() {\\\\\\\\n        return String::new();\\\\\\\\n    }\\\\\\\\n    unsafe { CStr::from_ptr(ptr) }\\\\\\\\n        .to_string_lossy()\\\\\\\\n        .into_owned()\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\\n    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\\n    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Thread-safe; may be called from any thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn idle(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the raw pointer for passing to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.ptr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        return String::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe { CStr::from_ptr(ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_string_lossy()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        .into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209}]},\\\\\\\"score\\\\\\\":0.08990240097045898},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\nuse crate::host::PluginHost;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AudioEngine\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\\n///\\\\\\\\n/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\\n/// CoreAudio AudioQueue on macOS.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread.\\\\\\\\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct AudioEngine {\\\\\\\\n    ptr: *mut ffi::ZpeEngine,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Drop for AudioEngine {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// AudioEngine\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// CoreAudio AudioQueue on macOS.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZpeEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36}]},\\\\\\\"score\\\\\\\":0.08042079955339432},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":67,\\\\\\\"column\\\\\\\":7}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::ffi::{CStr, CString};\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Param info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of a plugin parameter.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct ParamInfo {\\\\\\\\n    pub id: u32,\\\\\\\\n    pub name: String,\\\\\\\\n    pub module: String,\\\\\\\\n    pub min_value: f64,\\\\\\\\n    pub max_value: f64,\\\\\\\\n    pub default_value: f64,\\\\\\\\n    pub flags: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of plugin metadata.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub id: String,\\\\\\\\n    pub name: String,\\\\\\\\n    pub vendor: String,\\\\\\\\n    pub version: String,\\\\\\\\n    pub description: String,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// PluginHost\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread unless otherwise noted.\\\\\\\\n/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct PluginHost {\\\\\\\\n    ptr: *mut ffi::ZphPlugin,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// The Zig host library is designed for single-threaded main-thread use.\\\\\\\\n// We assert this by not implementing Send/Sync.\\\\\\\\n\\\\\\\\nimpl Drop for PluginHost {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::{CStr, CString};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Param info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of a plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub module: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub min_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub max_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub default_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub flags: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// Plugin info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub description: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub latency_samples: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"// PluginHost\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread unless otherwise noted.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"// The Zig host library is designed for single-threaded main-thread use.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"// We assert this by not implementing Send/Sync.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68}]},\\\\\\\"score\\\\\\\":0.07981439679861069},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":205,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":237,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .w(px(120.0))\\\\\\\\n                            .flex_shrink_0()\\\\\\\\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .flex()\\\\\\\\n                                    .flex_row()\\\\\\\\n                                    .gap(px(8.0))\\\\\\\\n                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\\n                                        |app, _ev, window, cx| {\\\\\\\\n                                            app.on_rewind(window, cx);\\\\\\\\n                                        },\\\\\\\\n                                    )))\\\\\\\\n                                    .child(\\\\\\\\n                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\\n                                            .primary()\\\\\\\\n                                            .label(play_label)\\\\\\\\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\\n                                                app.on_play_stop(window, cx);\\\\\\\\n                                            })),\\\\\\\\n                                    ),\\\\\\\\n                            ),\\\\\\\\n                    )\\\\\\\\n                    // Parameter panel\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .w(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_shrink_0()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"                                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        |app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            app.on_rewind(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    )))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .primary()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .label(play_label)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                app.on_play_stop(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            })),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":231},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":232},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":233},{\\\\\\\"text\\\\\\\":\\\\\\\"                    )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":234},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Parameter panel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":235},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238}]},\\\\\\\"score\\\\\\\":0.07488399744033813},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":92,\\\\\\\"column\\\\\\\":48},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":138,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn position(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn length(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\\n        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn position(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn length(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139}]},\\\\\\\"score\\\\\\\":0.06756210327148438},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/params.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":56,\\\\\\\"column\\\\\\\":13}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::slider::{Slider, SliderState};\\\\\\\\n\\\\\\\\nuse crate::host::ParamInfo;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Per-parameter slider entry\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Holds the GPUI entity for one parameter's slider state.\\\\\\\\npub struct ParamSlider {\\\\\\\\n    pub info: ParamInfo,\\\\\\\\n    pub slider: Entity&lt;SliderState&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ParamsView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Panel of parameter sliders.\\\\\\\\npub struct ParamsView {\\\\\\\\n    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ParamsView {\\\\\\\\n    /// Build the params view from a list of parameter infos.\\\\\\\\n    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\\n        let sliders = params\\\\\\\\n            .iter()\\\\\\\\n            .map(|info| {\\\\\\\\n                let min = info.min_value as f32;\\\\\\\\n                let max = info.max_value as f32;\\\\\\\\n                let default = info.default_value as f32;\\\\\\\\n\\\\\\\\n                let slider = cx.new(|_cx| {\\\\\\\\n                    SliderState::new()\\\\\\\\n                        .min(min)\\\\\\\\n                        .max(max)\\\\\\\\n                        .default_value(default)\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                ParamSlider {\\\\\\\\n                    info: info.clone(),\\\\\\\\n                    slider,\\\\\\\\n                }\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n\\\\\\\\n        Self { sliders }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ParamsView {\\\\\\\\n    fn render\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::{Slider, SliderState};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::ParamInfo;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"// Per-parameter slider entry\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Holds the GPUI entity for one parameter's slider state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub info: ParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub slider: Entity&lt;SliderState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ParamsView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Panel of parameter sliders.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build the params view from a list of parameter infos.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        let sliders = params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|info| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"                let min = info.min_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"                let max = info.max_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"                let default = info.default_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"                let slider = cx.new(|_cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"                    SliderState::new()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .min(min)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .max(max)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .default_value(default)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"                ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"                    info: info.clone(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"                    slider,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { sliders }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57}]},\\\\\\\"score\\\\\\\":0.05094100162386894},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":57,\\\\\\\"column\\\\\\\":30}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Raw FFI bindings to z_plug_host and z_plug_engine C APIs.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n//!\\\\\\\\n//! These declarations mirror &#96;lib/z_plug_host/z_plug_host.h&#96; and\\\\\\\\n//! &#96;lib/z_plug_engine/z_plug_engine.h&#96; exactly. Do not use these types\\\\\\\\n//! directly; prefer the safe wrappers in &#96;host.rs&#96; and &#96;engine.rs&#96;.\\\\\\\\n\\\\\\\\nuse std::ffi::c_char;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Opaque handle types\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Opaque handle to a loaded CLAP plugin instance (&#96;ZphPlugin*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPlugin {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Opaque handle to an audio engine instance (&#96;ZpeEngine*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZpeEngine {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Process status (mirrors clap_process_status)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[repr(i32)]\\\\\\\\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\\\\\\\\npub enum ZphProcessStatus {\\\\\\\\n    Error = 0,\\\\\\\\n    Continue = 1,\\\\\\\\n    ContinueIfNotQuiet = 2,\\\\\\\\n    Tail = 3,\\\\\\\\n    Sleep = 4,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info struct (matches ZphPluginInfo in z_plug_host.h)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Plugin metadata returned by &#96;zph_get_plugin_info&#96;.\\\\\\\\n/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPluginInfo {\\\\\\\\n    pub id: *const c_char,\\\\\\\\n    pub name: *const c_char,\\\\\\\\n    pub vendor: *const c_char,\\\\\\\\n    pub version: *const c_char,\\\\\\\\n    pub description: *const c_char,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Default for ZphPluginInfo\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Raw FFI bindings to z_plug_host and z_plug_engine C APIs.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! These declarations mirror &#96;lib/z_plug_host/z_plug_host.h&#96; and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;lib/z_plug_engine/z_plug_engine.h&#96; exactly. Do not use these types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"//! directly; prefer the safe wrappers in &#96;host.rs&#96; and &#96;engine.rs&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// Opaque handle types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Opaque handle to a loaded CLAP plugin instance (&#96;ZphPlugin*&#96;).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZphPlugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    _private: [u8; 0],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Opaque handle to an audio engine instance (&#96;ZpeEngine*&#96;).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZpeEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    _private: [u8; 0],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// Process status (mirrors clap_process_status)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(i32)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone, Copy, PartialEq, Eq)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum ZphProcessStatus {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    Error = 0,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    Continue = 1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    ContinueIfNotQuiet = 2,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    Tail = 3,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    Sleep = 4,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Plugin info struct (matches ZphPluginInfo in z_plug_host.h)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Plugin metadata returned by &#96;zph_get_plugin_info&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"#[repr(C)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZphPluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub description: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub latency_samples: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Default for ZphPluginInfo\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58}]},\\\\\\\"score\\\\\\\":0.048905130475759506},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/build.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":59}},\\\\\\\"contents\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\\nuse std::process::Command;\\\\\\\\n\\\\\\\\nfn main() {\\\\\\\\n    let repo_root = PathBuf::from(env!(\\\\\\\\\\\\\\\"CARGO_MANIFEST_DIR\\\\\\\\\\\\\\\"))\\\\\\\\n        .parent()\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"zloader must be inside the z-plug repo\\\\\\\\\\\\\\\")\\\\\\\\n        .to_path_buf();\\\\\\\\n\\\\\\\\n    // Tell cargo to re-run this script if Zig sources change.\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_host\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_engine\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"build.zig\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n\\\\\\\\n    // Build the Zig static libraries. We need to activate the Nix/direnv\\\\\\\\n    // environment to get Zig 0.15.2 on PATH. We do this by running direnv\\\\\\\\n    // export bash and sourcing its output before invoking zig.\\\\\\\\n    //\\\\\\\\n    // If direnv is not available (e.g. CI without Nix), fall back to\\\\\\\\n    // expecting &#96;zig&#96; to already be on PATH.\\\\\\\\n    let zig_path = find_zig(&amp;repo_root);\\\\\\\\n\\\\\\\\n    let status = Command::new(&amp;zig_path)\\\\\\\\n        .args([\\\\\\\\\\\\\\\"build\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"host\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"engine\\\\\\\\\\\\\\\"])\\\\\\\\n        .current_dir(&amp;repo_root)\\\\\\\\n        .status()\\\\\\\\n        .unwrap_or_else(|e| panic!(\\\\\\\\\\\\\\\"failed to run zig build: {e}\\\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    if !status.success() {\\\\\\\\n        panic!(\\\\\\\\\\\\\\\"zig build host engine failed with status: {status}\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Link the produced static libraries.\\\\\\\\n    let lib_dir = repo_root.join(\\\\\\\\\\\\\\\"zig-out/lib\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-search=native={}\\\\\\\\\\\\\\\", lib_dir.display());\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_host\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_engine\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // macOS frameworks required by z_plug_engine (CoreAudio via AudioQueue).\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=AudioToolbox\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=CoreAudio\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // libc is needed because the Zig libraries call into it.\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=c\\\\\\\\\\\\\\\");\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Locate the &#96;zig&#96; binary. Tries:\\\\\\\\n///   1. &#96;&lt;repo_root&gt;/.direnv&#96; paths (Nix devShell via direnv)\\\\\\\\n///   2. The &#96;ZIG&#96; environment variable\\\\\\\\n///   3. Plain &#96;zig&#96; on PATH\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::process::Command;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"    let repo_root = PathBuf::from(env!(\\\\\\\\\\\\\\\"CARGO_MANIFEST_DIR\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"        .parent()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"zloader must be inside the z-plug repo\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_path_buf();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Tell cargo to re-run this script if Zig sources change.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_host\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_engine\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"        repo_root.join(\\\\\\\\\\\\\\\"build.zig\\\\\\\\\\\\\\\").display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Build the Zig static libraries. We need to activate the Nix/direnv\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    // environment to get Zig 0.15.2 on PATH. We do this by running direnv\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    // export bash and sourcing its output before invoking zig.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    //\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    // If direnv is not available (e.g. CI without Nix), fall back to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    // expecting &#96;zig&#96; to already be on PATH.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    let zig_path = find_zig(&amp;repo_root);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"    let status = Command::new(&amp;zig_path)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"        .args([\\\\\\\\\\\\\\\"build\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"host\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"engine\\\\\\\\\\\\\\\"])\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"        .current_dir(&amp;repo_root)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"        .status()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        .unwrap_or_else(|e| panic!(\\\\\\\\\\\\\\\"failed to run zig build: {e}\\\\\\\\\\\\\\\"));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !status.success() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"        panic!(\\\\\\\\\\\\\\\"zig build host engine failed with status: {status}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Link the produced static libraries.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"    let lib_dir = repo_root.join(\\\\\\\\\\\\\\\"zig-out/lib\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-search=native={}\\\\\\\\\\\\\\\", lib_dir.display());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_host\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_engine\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    // macOS frameworks required by z_plug_engine (CoreAudio via AudioQueue).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=AudioToolbox\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=CoreAudio\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    // libc is needed because the Zig libraries call into it.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=c\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Locate the &#96;zig&#96; binary. Tries:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"///   1. &#96;&lt;repo_root&gt;/.direnv&#96; paths (Nix devShell via direnv)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"///   2. The &#96;ZIG&#96; environment variable\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"///   3. Plain &#96;zig&#96; on PATH\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59}]},\\\\\\\"score\\\\\\\":0.04583879932761192},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":84},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":143,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\\n    pub position: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformView {\\\\\\\\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\\n        Self { peaks, position: 0 }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for WaveformView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let peaks = self.peaks.clone();\\\\\\\\n        let position = self.position;\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .w_full()\\\\\\\\n            .h(px(120.0))\\\\\\\\n            .bg(rgb(0x1a1a2e))\\\\\\\\n            .rounded(px(6.0))\\\\\\\\n            .overflow_hidden()\\\\\\\\n            .child(\\\\\\\\n                canvas(\\\\\\\\n                    move |_bounds, _window, _cx| {},\\\\\\\\n                    move |bounds, _prepaint, window, _cx| {\\\\\\\\n                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .w_full()\\\\\\\\n                .h_full(),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Drawing helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\\n    window.paint_quad(PaintQuad {\\\\\\\\n        bounds: Bounds {\\\\\\\\n            origin: Point { x: px(x), y: px(y) },\\\\\\\\n            size: Size {\\\\\\\\n                width: px(w),\\\\\\\\n                height: px(h),\\\\\\\\n            },\\\\\\\\n        },\\\\\\\\n        corner_radii: Corners::all(px(0.0)),\\\\\\\\n        background: Background::from(color),\\\\\\\\n        border_widths: Edges::all(px(0.0)),\\\\\\\\n        border_color: gpui::transparent_black(),\\\\\\\\n        border_style: BorderStyle::default(),\\\\\\\\n    });\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { peaks, position: 0 }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        let peaks = self.peaks.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        let position = self.position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"            .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"            .h(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x1a1a2e))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"            .rounded(px(6.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            .overflow_hidden()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                canvas(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_bounds, _window, _cx| {},\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |bounds, _prepaint, window, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"                .h_full(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"// Drawing helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"fn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    window.paint_quad(PaintQuad {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"        bounds: Bounds {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            origin: Point { x: px(x), y: px(y) },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            size: Size {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"                width: px(w),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"                height: px(h),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        corner_radii: Corners::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        background: Background::from(color),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_widths: Edges::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_color: gpui::transparent_black(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_style: BorderStyle::default(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144}]},\\\\\\\"score\\\\\\\":0.03742874041199684},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":139,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":180,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\\n    peaks: &amp;WaveformPeaks,\\\\\\\\n    position: u64,\\\\\\\\n) {\\\\\\\\n    let width = f32::from(bounds.size.width);\\\\\\\\n    let height = f32::from(bounds.size.height);\\\\\\\\n    let origin_x = f32::from(bounds.origin.x);\\\\\\\\n    let origin_y = f32::from(bounds.origin.y);\\\\\\\\n    let mid_y = origin_y + height / 2.0;\\\\\\\\n    let half_h = height / 2.0 * 0.9;\\\\\\\\n\\\\\\\\n    let num_cols = peaks.peaks.len().max(1);\\\\\\\\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\\n    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\\n    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\\n\\\\\\\\n    // Draw waveform bars.\\\\\\\\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\\n        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\\n\\\\\\\\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\\n        let bar_height = (bottom - top).max(1.0);\\\\\\\\n\\\\\\\\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Draw center line.\\\\\\\\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\\n\\\\\\\\n    // Draw playhead.\\\\\\\\n    if peaks.total_samples &gt; 0 {\\\\\\\\n        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    peaks: &amp;WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\") {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    let width = f32::from(bounds.size.width);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"    let height = f32::from(bounds.size.height);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_x = f32::from(bounds.origin.x);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_y = f32::from(bounds.origin.y);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mid_y = origin_y + height / 2.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    let half_h = height / 2.0 * 0.9;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    let num_cols = peaks.peaks.len().max(1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw waveform bars.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_height = (bottom - top).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw center line.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    if peaks.total_samples &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181}]},\\\\\\\"score\\\\\\\":0.03184086084365845},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/Cargo.toml\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":11}},\\\\\\\"contents\\\\\\\":\\\\\\\"[package]\\\\\\\\nname = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\"\\\\\\\\nversion = \\\\\\\\\\\\\\\"0.1.0\\\\\\\\\\\\\\\"\\\\\\\\nedition = \\\\\\\\\\\\\\\"2021\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n[dependencies]\\\\\\\\ngpui = \\\\\\\\\\\\\\\"0.2.2\\\\\\\\\\\\\\\"\\\\\\\\ngpui-component = \\\\\\\\\\\\\\\"0.5.1\\\\\\\\\\\\\\\"\\\\\\\\nsmallvec = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\\nclap = { version = \\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\", features = [\\\\\\\\\\\\\\\"derive\\\\\\\\\\\\\\\"] }\\\\\\\\nanyhow = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"[package]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"version = \\\\\\\\\\\\\\\"0.1.0\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"edition = \\\\\\\\\\\\\\\"2021\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"[dependencies]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"gpui = \\\\\\\\\\\\\\\"0.2.2\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"gpui-component = \\\\\\\\\\\\\\\"0.5.1\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"smallvec = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"clap = { version = \\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\", features = [\\\\\\\\\\\\\\\"derive\\\\\\\\\\\\\\\"] }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"anyhow = \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11}]},\\\\\\\"score\\\\\\\":0.024565700441598892},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/transport.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":6,\\\\\\\"column\\\\\\\":74}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\\n//!\\\\\\\\n//! This module is kept for organisational clarity; the actual transport\\\\\\\\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\\n\\\\\\\\n// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! This module is kept for organisational clarity; the actual transport\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7}]},\\\\\\\"score\\\\\\\":0.023911360651254654},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":195,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":229,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\\n        (3, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\\n            .collect(),\\\\\\\\n        (1, 16) =&gt; raw\\\\\\\\n            .chunks_exact(2)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 32768.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 24) =&gt; raw\\\\\\\\n            .chunks_exact(3)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\\n                s as f32 / 8388608.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 2147483648.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        _ =&gt; anyhow::bail!(\\\\\\\\n            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\\n        ),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    Ok((samples, channels))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        (3, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 16) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(2)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 32768.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 24) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(3)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 8388608.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 2147483648.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; anyhow::bail!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"        ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((samples, channels))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230}]},\\\\\\\"score\\\\\\\":0.023207660764455795},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":117,\\\\\\\"column\\\\\\\":48},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":169}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_get_plugin_info failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(PluginInfo {\\\\\\\\n            id: cstr_ptr_to_string(raw.id),\\\\\\\\n            name: cstr_ptr_to_string(raw.name),\\\\\\\\n            vendor: cstr_ptr_to_string(raw.vendor),\\\\\\\\n            version: cstr_ptr_to_string(raw.version),\\\\\\\\n            description: cstr_ptr_to_string(raw.description),\\\\\\\\n            input_channels: raw.input_channels,\\\\\\\\n            output_channels: raw.output_channels,\\\\\\\\n            latency_samples: raw.latency_samples,\\\\\\\\n        })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn param_count(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zph_get_param_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve metadata for all parameters.\\\\\\\\n    pub fn get_params(&amp;self) -&gt; Vec&lt;ParamInfo&gt; {\\\\\\\\n        let count = self.param_count();\\\\\\\\n        let mut params = Vec::with_capacity(count as usize);\\\\\\\\n        for i in 0..count {\\\\\\\\n            let mut raw = ffi::ZphParamInfo::default();\\\\\\\\n            if unsafe { ffi::zph_get_param_info(self.ptr, i, &amp;mut raw) } {\\\\\\\\n                params.push(ParamInfo {\\\\\\\\n                    id: raw.id,\\\\\\\\n                    name: cstr_bytes_to_string(&amp;raw.name),\\\\\\\\n                    module: cstr_bytes_to_string(&amp;raw.module),\\\\\\\\n                    min_value: raw.min_value,\\\\\\\\n                    max_value: raw.max_value,\\\\\\\\n                    default_value: raw.default_value,\\\\\\\\n                    flags: raw.flags,\\\\\\\\n                });\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n        params\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn get_param_value(&amp;self, param_id: u32) -&gt; Option&lt;f64&gt; {\\\\\\\\n        let mut value: f64 = 0.0;\\\\\\\\n        let ok = unsafe { ffi::zph_get_param_value(self.ptr, param_id, &amp;mut value) };\\\\\\\\n        if ok { Some(value) } else { None }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_get_plugin_info failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"            id: cstr_ptr_to_string(raw.id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"            name: cstr_ptr_to_string(raw.name),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"            vendor: cstr_ptr_to_string(raw.vendor),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            version: cstr_ptr_to_string(raw.version),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            description: cstr_ptr_to_string(raw.description),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"            input_channels: raw.input_channels,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"            output_channels: raw.output_channels,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"            latency_samples: raw.latency_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the number of parameters the plugin exposes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn param_count(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_get_param_count(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Retrieve metadata for all parameters.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_params(&amp;self) -&gt; Vec&lt;ParamInfo&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"        let count = self.param_count();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut params = Vec::with_capacity(count as usize);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        for i in 0..count {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut raw = ffi::ZphParamInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"            if unsafe { ffi::zph_get_param_info(self.ptr, i, &amp;mut raw) } {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"                params.push(ParamInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"                    id: raw.id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"                    name: cstr_bytes_to_string(&amp;raw.name),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"                    module: cstr_bytes_to_string(&amp;raw.module),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"                    min_value: raw.min_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"                    max_value: raw.max_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"                    default_value: raw.default_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"                    flags: raw.flags,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"        params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the current value of a parameter by its stable ID.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_param_value(&amp;self, param_id: u32) -&gt; Option&lt;f64&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut value: f64 = 0.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_param_value(self.ptr, param_id, &amp;mut value) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ok { Some(value) } else { None }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169}]},\\\\\\\"score\\\\\\\":0.012086399830877781}]}\\\"},\\\"capabilityType\\\":15}\",\"68c7988a-5b30-47fe-9c00-f8ab5e1682e4\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"c7532ddc-4cee-467e-9556-3bb33125ea09\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.580Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nReading the main source files to understand the architecture:\\\\n\\\"}\",\"54ca0d29-b441-494f-abd8-87aab9479878\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f8cc2d7e-0659-438e-826d-ab446aca0030\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.580Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_5b01e42d-18a6-481f-a311-a96d8c2b8f2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_5b01e42d-18a6-481f-a311-a96d8c2b8f2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/main.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/main.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/main.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\\n//!\\\\\\\\n//! Usage:\\\\\\\\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\\n\\\\\\\\nmod app;\\\\\\\\nmod engine;\\\\\\\\nmod ffi;\\\\\\\\nmod host;\\\\\\\\nmod params;\\\\\\\\nmod transport;\\\\\\\\nmod waveform;\\\\\\\\n\\\\\\\\nuse std::path::PathBuf;\\\\\\\\n\\\\\\\\nuse anyhow::Result;\\\\\\\\nuse clap::Parser;\\\\\\\\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\\nuse gpui_component::{theme::Theme, Root};\\\\\\\\n\\\\\\\\nuse app::{AppState, ZLoaderApp};\\\\\\\\nuse engine::AudioEngine;\\\\\\\\nuse host::PluginHost;\\\\\\\\nuse waveform::WaveformPeaks;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// CLI\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[derive(Parser, Debug)]\\\\\\\\n#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\\nstruct Args {\\\\\\\\n    /// Path to the .clap plugin file or bundle.\\\\\\\\n    plugin_path: PathBuf,\\\\\\\\n\\\\\\\\n    /// Path to a WAV audio file to play through the plugin.\\\\\\\\n    audio_file: PathBuf,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Entry point\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\\n\\\\\\\\n    if !args.plugin_path.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\\n    }\\\\\\\\n    if !args.audio_file.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let plugin_path = args.plugin_path.clone();\\\\\\\\n    let audio_path = args.audio_file.clone();\\\\\\\\n\\\\\\\\n    Application::new().run(move |cx: &amp;mut App| {\\\\\\\\n        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\\n\\\\\\\\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\\n        gpui_component::init(cx);\\\\\\\\n\\\\\\\\n        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\\n            Ok(v) =&gt; v,\\\\\\\\n            Err(e) =&gt; {\\\\\\\\n                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\\n                cx.quit();\\\\\\\\n                return;\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\\n\\\\\\\\n        cx.open_window(\\\\\\\\n            WindowOptions {\\\\\\\\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\\n                titlebar: Some(gpui::TitlebarOptions {\\\\\\\\n                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\\n                    ..Default::default()\\\\\\\\n                }),\\\\\\\\n                ..Default::default()\\\\\\\\n            },\\\\\\\\n            move |window, cx| {\\\\\\\\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\\n            },\\\\\\\\n        )\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        cx.activate(true);\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Setup: load plugin + audio, build peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\\n/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\\nconst WAVEFORM_COLUMNS: usize = 1200;\\\\\\\\n\\\\\\\\nfn setup(\\\\\\\\n    cx: &amp;mut App,\\\\\\\\n    plugin_path: &amp;PathBuf,\\\\\\\\n    audio_path: &amp;PathBuf,\\\\\\\\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\\n    // Load the plugin.\\\\\\\\n    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\\n    let plugin_info = host.get_info()?;\\\\\\\\n    let params = host.get_params();\\\\\\\\n\\\\\\\\n    // Create the audio engine and load the WAV file.\\\\\\\\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    engine.load_file(audio_path)?;\\\\\\\\n\\\\\\\\n    // Activate and start processing.\\\\\\\\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    host.start_processing()?;\\\\\\\\n\\\\\\\\n    // Attach plugin to engine.\\\\\\\\n    engine.set_plugin(Some(&amp;mut host));\\\\\\\\n\\\\\\\\n    // Read the WAV file for waveform peak computation.\\\\\\\\n    let peaks = build_peaks(audio_path)?;\\\\\\\\n\\\\\\\\n    let state = cx.new(|_cx| AppState {\\\\\\\\n        host,\\\\\\\\n        engine,\\\\\\\\n        plugin_info,\\\\\\\\n        params,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok((state, peaks))\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read the WAV file and compute waveform peaks for display.\\\\\\\\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\\n    let data = std::fs::read(path)?;\\\\\\\\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\\n    Ok(peaks)\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\\n/// Returns (interleaved_f32_samples, channel_count).\\\\\\\\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let mut pos = 12usize;\\\\\\\\n    let mut fmt_channels: u16 = 0;\\\\\\\\n    let mut fmt_bits: u16 = 0;\\\\\\\\n    let mut fmt_audio_format: u16 = 0;\\\\\\\\n    let mut data_start = 0usize;\\\\\\\\n    let mut data_len = 0usize;\\\\\\\\n\\\\\\\\n    while pos + 8 &lt;= data.len() {\\\\\\\\n        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\\n        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\\n        pos += 8;\\\\\\\\n\\\\\\\\n        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\\n            if chunk_size &gt;= 16 {\\\\\\\\n                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\\n                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\\n                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\\n            }\\\\\\\\n        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\\n            data_start = pos;\\\\\\\\n            data_len = chunk_size;\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        pos += chunk_size;\\\\\\\\n        if chunk_size % 2 != 0 {\\\\\\\\n            pos += 1;\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if data_start == 0 || fmt_channels == 0 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\\n    let channels = fmt_channels as usize;\\\\\\\\n\\\\\\\\n    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\\n        (3, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\\n            .collect(),\\\\\\\\n        (1, 16) =&gt; raw\\\\\\\\n            .chunks_exact(2)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 32768.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 24) =&gt; raw\\\\\\\\n            .chunks_exact(3)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\\n                s as f32 / 8388608.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 2147483648.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        _ =&gt; anyhow::bail!(\\\\\\\\n            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\\n        ),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    Ok((samples, channels))\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":231}\\\"},\\\"capabilityType\\\":15}\",\"79156788-64f8-4c77-ab09-c4c3e03d9cd7\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"20b98f29-6fe9-4fc6-a079-efd46fc22fb5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.580Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_ea37b369-c9d0-485e-9691-1414adff7b2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_ea37b369-c9d0-485e-9691-1414adff7b2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/app.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/app.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/app.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\\n//!\\\\\\\\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\\n//! and drives the periodic idle/position-poll timer.\\\\\\\\n\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::button::{Button, ButtonVariants};\\\\\\\\nuse gpui_component::slider::SliderEvent;\\\\\\\\n\\\\\\\\nuse crate::engine::AudioEngine;\\\\\\\\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\\nuse crate::params::ParamsView;\\\\\\\\nuse crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AppState  owns the non-Send FFI resources\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\\npub struct AppState {\\\\\\\\n    pub host: PluginHost,\\\\\\\\n    pub engine: AudioEngine,\\\\\\\\n    pub plugin_info: PluginInfo,\\\\\\\\n    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ZLoaderApp  root view\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\npub struct ZLoaderApp {\\\\\\\\n    state: Entity&lt;AppState&gt;,\\\\\\\\n    waveform: Entity&lt;WaveformView&gt;,\\\\\\\\n    params_view: Entity&lt;ParamsView&gt;,\\\\\\\\n    is_playing: bool,\\\\\\\\n    plugin_name: SharedString,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\\n        peaks: WaveformPeaks,\\\\\\\\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\\n    ) -&gt; Self {\\\\\\\\n        let plugin_name: SharedString = state\\\\\\\\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\\n            .into();\\\\\\\\n\\\\\\\\n        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\\n\\\\\\\\n        // Build the waveform view.\\\\\\\\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\\n\\\\\\\\n        // Build the params view.\\\\\\\\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\\n\\\\\\\\n        // Subscribe to slider changes and forward to the plugin host.\\\\\\\\n        // This runs on the main thread with full access to cx.\\\\\\\\n        let state_for_params = state.clone();\\\\\\\\n        params_view\\\\\\\\n            .read_with(cx, |pv, _| {\\\\\\\\n                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\\n                pv.sliders\\\\\\\\n                    .iter()\\\\\\\\n                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\\n            })\\\\\\\\n            .into_iter()\\\\\\\\n            .for_each(|(param_id, slider_entity)| {\\\\\\\\n                let state_weak = state_for_params.downgrade();\\\\\\\\n                cx.subscribe(\\\\\\\\n                    &amp;slider_entity,\\\\\\\\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\\n                        let SliderEvent::Change(value) = event;\\\\\\\\n                        let v = value.start() as f64;\\\\\\\\n                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\\n                            state_entity.read_with(cx, |s, _| {\\\\\\\\n                                s.host.set_param_value(param_id, v);\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .detach();\\\\\\\\n            });\\\\\\\\n\\\\\\\\n        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\\n        let state_weak = state.downgrade();\\\\\\\\n        let waveform_weak = waveform.downgrade();\\\\\\\\n        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer(Duration::from_millis(30))\\\\\\\\n                    .await;\\\\\\\\n\\\\\\\\n                let should_stop = cx.update(|cx| {\\\\\\\\n                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    // Poll position and call idle.\\\\\\\\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\\n                        s.host.idle();\\\\\\\\n                        (s.engine.position(), s.engine.is_playing())\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update waveform playhead.\\\\\\\\n                    waveform_entity.update(cx, |w, cx| {\\\\\\\\n                        w.position = position;\\\\\\\\n                        cx.notify();\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update root view playing state.\\\\\\\\n                    this.update(cx, |app, cx| {\\\\\\\\n                        app.is_playing = is_playing;\\\\\\\\n                        cx.notify();\\\\\\\\n                    })\\\\\\\\n                    .is_err()\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                if should_stop.unwrap_or(true) {\\\\\\\\n                    break;\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        })\\\\\\\\n        .detach();\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            state,\\\\\\\\n            waveform,\\\\\\\\n            params_view,\\\\\\\\n            is_playing: false,\\\\\\\\n            plugin_name,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            s.engine.seek(0);\\\\\\\\n        });\\\\\\\\n        self.waveform.update(cx, |w, cx| {\\\\\\\\n            w.position = 0;\\\\\\\\n            cx.notify();\\\\\\\\n        });\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            if is_playing {\\\\\\\\n                s.engine.stop();\\\\\\\\n            } else {\\\\\\\\n                let _ = s.engine.play();\\\\\\\\n            }\\\\\\\\n        });\\\\\\\\n        self.is_playing = !is_playing;\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ZLoaderApp {\\\\\\\\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let play_label: SharedString = if self.is_playing {\\\\\\\\n            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\\n        } else {\\\\\\\\n            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\\n        };\\\\\\\\n        let plugin_name = self.plugin_name.clone();\\\\\\\\n        let waveform = self.waveform.clone();\\\\\\\\n        let params_view = self.params_view.clone();\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\\n            .bg(rgb(0x0f0f1a))\\\\\\\\n            .text_color(rgb(0xffffff))\\\\\\\\n            .p(px(16.0))\\\\\\\\n            .gap(px(16.0))\\\\\\\\n            // Header: plugin name\\\\\\\\n            .child(\\\\\\\\n                div().flex().flex_row().items_center().gap(px(8.0)).child(\\\\\\\\n                    div()\\\\\\\\n                        .text_size(px(20.0))\\\\\\\\n                        .size_full()\\\\\\\\n                        .bg(rgb(0x0000FF))\\\\\\\\n                        .text_color(rgb(0xffffff))\\\\\\\\n                        .child(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\".clone()),\\\\\\\\n                ),\\\\\\\\n            )\\\\\\\\n            // Waveform\\\\\\\\n            .child(waveform)\\\\\\\\n            // Bottom: transport + params\\\\\\\\n            .child(\\\\\\\\n                div()\\\\\\\\n                    .flex()\\\\\\\\n                    .flex_row()\\\\\\\\n                    .gap(px(24.0))\\\\\\\\n                    .flex_1()\\\\\\\\n                    .min_h(px(0.0))\\\\\\\\n                    // Transport controls\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .w(px(120.0))\\\\\\\\n                            .flex_shrink_0()\\\\\\\\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .flex()\\\\\\\\n                                    .flex_row()\\\\\\\\n                                    .gap(px(8.0))\\\\\\\\n                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\\n                                        |app, _ev, window, cx| {\\\\\\\\n                                            app.on_rewind(window, cx);\\\\\\\\n                                        },\\\\\\\\n                                    )))\\\\\\\\n                                    .child(\\\\\\\\n                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\\n                                            .primary()\\\\\\\\n                                            .label(play_label)\\\\\\\\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\\n                                                app.on_play_stop(window, cx);\\\\\\\\n                                            })),\\\\\\\\n                                    ),\\\\\\\\n                            ),\\\\\\\\n                    )\\\\\\\\n                    // Parameter panel\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .flex_1()\\\\\\\\n                            .min_h(px(0.0))\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .text_sm()\\\\\\\\n                                    .text_color(rgb(0x888888))\\\\\\\\n                                    .child(\\\\\\\\\\\\\\\"Parameters\\\\\\\\\\\\\\\"),\\\\\\\\n                            )\\\\\\\\n                            .child(params_view),\\\\\\\\n                    ),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":254}\\\"},\\\"capabilityType\\\":15}\",\"047aef0a-b772-4467-93fe-5becf9ea4ed8\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"00bfb609-2b2c-4cd5-a710-7bb67cd07199\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.580Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b2752089-6bfe-4a22-900f-8239def75c4\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b2752089-6bfe-4a22-900f-8239def75c4\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/waveform.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/waveform.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/waveform.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\\n//!\\\\\\\\n//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\\n//! playhead line indicating the current playback position.\\\\\\\\n\\\\\\\\nuse gpui::{\\\\\\\\n    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\\n    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\\n/// One entry per display column (pixel-width bucket).\\\\\\\\n#[derive(Clone)]\\\\\\\\npub struct WaveformPeaks {\\\\\\\\n    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\\n    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\\n    /// Total number of samples in the source file (for playhead math).\\\\\\\\n    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks {\\\\\\\\n    /// Build peak data from raw interleaved f32 samples.\\\\\\\\n    ///\\\\\\\\n    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\\n    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\\n    /// bucket across all channels.\\\\\\\\n    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\\n        let total_frames = if channels &gt; 0 {\\\\\\\\n            samples.len() / channels\\\\\\\\n        } else {\\\\\\\\n            0\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let total_samples = total_frames as u64;\\\\\\\\n\\\\\\\\n        if total_frames == 0 || num_columns == 0 {\\\\\\\\n            return Self {\\\\\\\\n                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\\n                total_samples,\\\\\\\\n            };\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\\n        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\\n\\\\\\\\n        for col in 0..num_columns {\\\\\\\\n            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = end_frame.min(total_frames);\\\\\\\\n\\\\\\\\n            let mut min = 0.0f32;\\\\\\\\n            let mut max = 0.0f32;\\\\\\\\n\\\\\\\\n            for frame in start_frame..end_frame {\\\\\\\\n                for ch in 0..channels {\\\\\\\\n                    let sample = samples[frame * channels + ch];\\\\\\\\n                    if sample &lt; min {\\\\\\\\n                        min = sample;\\\\\\\\n                    }\\\\\\\\n                    if sample &gt; max {\\\\\\\\n                        max = sample;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            peaks.push((min, max));\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            peaks,\\\\\\\\n            total_samples,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// WaveformView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// A GPUI view that renders the waveform and a playhead.\\\\\\\\npub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\\n    pub position: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformView {\\\\\\\\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\\n        Self { peaks, position: 0 }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for WaveformView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let peaks = self.peaks.clone();\\\\\\\\n        let position = self.position;\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .w_full()\\\\\\\\n            .h(px(120.0))\\\\\\\\n            .bg(rgb(0x1a1a2e))\\\\\\\\n            .rounded(px(6.0))\\\\\\\\n            .overflow_hidden()\\\\\\\\n            .child(\\\\\\\\n                canvas(\\\\\\\\n                    move |_bounds, _window, _cx| {},\\\\\\\\n                    move |bounds, _prepaint, window, _cx| {\\\\\\\\n                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .w_full()\\\\\\\\n                .h_full(),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Drawing helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\\n    window.paint_quad(PaintQuad {\\\\\\\\n        bounds: Bounds {\\\\\\\\n            origin: Point { x: px(x), y: px(y) },\\\\\\\\n            size: Size {\\\\\\\\n                width: px(w),\\\\\\\\n                height: px(h),\\\\\\\\n            },\\\\\\\\n        },\\\\\\\\n        corner_radii: Corners::all(px(0.0)),\\\\\\\\n        background: Background::from(color),\\\\\\\\n        border_widths: Edges::all(px(0.0)),\\\\\\\\n        border_color: gpui::transparent_black(),\\\\\\\\n        border_style: BorderStyle::default(),\\\\\\\\n    });\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\\n    peaks: &amp;WaveformPeaks,\\\\\\\\n    position: u64,\\\\\\\\n) {\\\\\\\\n    let width = f32::from(bounds.size.width);\\\\\\\\n    let height = f32::from(bounds.size.height);\\\\\\\\n    let origin_x = f32::from(bounds.origin.x);\\\\\\\\n    let origin_y = f32::from(bounds.origin.y);\\\\\\\\n    let mid_y = origin_y + height / 2.0;\\\\\\\\n    let half_h = height / 2.0 * 0.9;\\\\\\\\n\\\\\\\\n    let num_cols = peaks.peaks.len().max(1);\\\\\\\\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\\n    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\\n    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\\n\\\\\\\\n    // Draw waveform bars.\\\\\\\\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\\n        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\\n\\\\\\\\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\\n        let bar_height = (bottom - top).max(1.0);\\\\\\\\n\\\\\\\\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Draw center line.\\\\\\\\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\\n\\\\\\\\n    // Draw playhead.\\\\\\\\n    if peaks.total_samples &gt; 0 {\\\\\\\\n        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":182}\\\"},\\\"capabilityType\\\":15}\",\"77c27510-d714-49d5-9c0b-fd91adf281e7\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"b6cf39bc-1446-4e52-914d-a62e6080daf5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b22b69b5-fa2b-4198-a927-7512a046065\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b22b69b5-fa2b-4198-a927-7512a046065\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/engine.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/engine.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/engine.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\nuse crate::host::PluginHost;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AudioEngine\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\\n///\\\\\\\\n/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\\n/// CoreAudio AudioQueue on macOS.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread.\\\\\\\\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct AudioEngine {\\\\\\\\n    ptr: *mut ffi::ZpeEngine,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Drop for AudioEngine {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    ///\\\\\\\\n    /// Stops playback and resets position if a file was already loaded.\\\\\\\\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    ///\\\\\\\\n    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\\n    /// output. The plugin must be activated and processing-started before\\\\\\\\n    /// calling &#96;play()&#96;.\\\\\\\\n    ///\\\\\\\\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\\n        let plugin_ptr = host\\\\\\\\n            .map(|h| h.raw_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null_mut());\\\\\\\\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Pause playback. The current position is preserved.\\\\\\\\n    pub fn pause(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn stop(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn position(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn length(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\\n        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":140}\\\"},\\\"capabilityType\\\":15}\",\"0f47b6e2-0a59-4e60-8764-e6243f80b8e4\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"1706f4b9-ed17-483f-8600-2273bd25c0da\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_d77e0809-b6a5-42e3-aaa1-8eae29c23ab\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_d77e0809-b6a5-42e3-aaa1-8eae29c23ab\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/host.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/host.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/host.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::ffi::{CStr, CString};\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Param info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of a plugin parameter.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct ParamInfo {\\\\\\\\n    pub id: u32,\\\\\\\\n    pub name: String,\\\\\\\\n    pub module: String,\\\\\\\\n    pub min_value: f64,\\\\\\\\n    pub max_value: f64,\\\\\\\\n    pub default_value: f64,\\\\\\\\n    pub flags: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of plugin metadata.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub id: String,\\\\\\\\n    pub name: String,\\\\\\\\n    pub vendor: String,\\\\\\\\n    pub version: String,\\\\\\\\n    pub description: String,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// PluginHost\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread unless otherwise noted.\\\\\\\\n/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct PluginHost {\\\\\\\\n    ptr: *mut ffi::ZphPlugin,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// The Zig host library is designed for single-threaded main-thread use.\\\\\\\\n// We assert this by not implementing Send/Sync.\\\\\\\\n\\\\\\\\nimpl Drop for PluginHost {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\\n    ///\\\\\\\\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\\n            .transpose()?;\\\\\\\\n\\\\\\\\n        let id_ptr = id_cstr\\\\\\\\n            .as_ref()\\\\\\\\n            .map(|c| c.as_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null());\\\\\\\\n\\\\\\\\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn deactivate(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn stop_processing(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve plugin metadata.\\\\\\\\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_get_plugin_info failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(PluginInfo {\\\\\\\\n            id: cstr_ptr_to_string(raw.id),\\\\\\\\n            name: cstr_ptr_to_string(raw.name),\\\\\\\\n            vendor: cstr_ptr_to_string(raw.vendor),\\\\\\\\n            version: cstr_ptr_to_string(raw.version),\\\\\\\\n            description: cstr_ptr_to_string(raw.description),\\\\\\\\n            input_channels: raw.input_channels,\\\\\\\\n            output_channels: raw.output_channels,\\\\\\\\n            latency_samples: raw.latency_samples,\\\\\\\\n        })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn param_count(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zph_get_param_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve metadata for all parameters.\\\\\\\\n    pub fn get_params(&amp;self) -&gt; Vec&lt;ParamInfo&gt; {\\\\\\\\n        let count = self.param_count();\\\\\\\\n        let mut params = Vec::with_capacity(count as usize);\\\\\\\\n        for i in 0..count {\\\\\\\\n            let mut raw = ffi::ZphParamInfo::default();\\\\\\\\n            if unsafe { ffi::zph_get_param_info(self.ptr, i, &amp;mut raw) } {\\\\\\\\n                params.push(ParamInfo {\\\\\\\\n                    id: raw.id,\\\\\\\\n                    name: cstr_bytes_to_string(&amp;raw.name),\\\\\\\\n                    module: cstr_bytes_to_string(&amp;raw.module),\\\\\\\\n                    min_value: raw.min_value,\\\\\\\\n                    max_value: raw.max_value,\\\\\\\\n                    default_value: raw.default_value,\\\\\\\\n                    flags: raw.flags,\\\\\\\\n                });\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n        params\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn get_param_value(&amp;self, param_id: u32) -&gt; Option&lt;f64&gt; {\\\\\\\\n        let mut value: f64 = 0.0;\\\\\\\\n        let ok = unsafe { ffi::zph_get_param_value(self.ptr, param_id, &amp;mut value) };\\\\\\\\n        if ok { Some(value) } else { None }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    /// Thread-safe; may be called from any thread.\\\\\\\\n    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\\n        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn idle(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the raw pointer for passing to the engine.\\\\\\\\n    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\\n        self.ptr\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\\n    if ptr.is_null() {\\\\\\\\n        return String::new();\\\\\\\\n    }\\\\\\\\n    unsafe { CStr::from_ptr(ptr) }\\\\\\\\n        .to_string_lossy()\\\\\\\\n        .into_owned()\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\\n    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\\n    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":210}\\\"},\\\"capabilityType\\\":15}\",\"1567e8ab-f098-448c-be72-c448e41ba83d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"69a8fb00-348a-495e-a540-d7b1c8a21801\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_a99bbfe6-5ae8-40a0-b6a4-f07f2aeb989\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_a99bbfe6-5ae8-40a0-b6a4-f07f2aeb989\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/params.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/params.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/params.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::slider::{Slider, SliderState};\\\\\\\\n\\\\\\\\nuse crate::host::ParamInfo;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Per-parameter slider entry\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Holds the GPUI entity for one parameter's slider state.\\\\\\\\npub struct ParamSlider {\\\\\\\\n    pub info: ParamInfo,\\\\\\\\n    pub slider: Entity&lt;SliderState&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ParamsView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Panel of parameter sliders.\\\\\\\\npub struct ParamsView {\\\\\\\\n    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ParamsView {\\\\\\\\n    /// Build the params view from a list of parameter infos.\\\\\\\\n    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\\n        let sliders = params\\\\\\\\n            .iter()\\\\\\\\n            .map(|info| {\\\\\\\\n                let min = info.min_value as f32;\\\\\\\\n                let max = info.max_value as f32;\\\\\\\\n                let default = info.default_value as f32;\\\\\\\\n\\\\\\\\n                let slider = cx.new(|_cx| {\\\\\\\\n                    SliderState::new()\\\\\\\\n                        .min(min)\\\\\\\\n                        .max(max)\\\\\\\\n                        .default_value(default)\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                ParamSlider {\\\\\\\\n                    info: info.clone(),\\\\\\\\n                    slider,\\\\\\\\n                }\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n\\\\\\\\n        Self { sliders }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ParamsView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let mut rows = div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .gap(px(12.0))\\\\\\\\n            .w_full()\\\\\\\\n            .overflow_hidden();\\\\\\\\n\\\\\\\\n        for entry in &amp;self.sliders {\\\\\\\\n            let name: SharedString = entry.info.name.clone().into();\\\\\\\\n            let slider_entity = entry.slider.clone();\\\\\\\\n\\\\\\\\n            let row = div()\\\\\\\\n                .flex()\\\\\\\\n                .flex_col()\\\\\\\\n                .gap(px(4.0))\\\\\\\\n                .w_full()\\\\\\\\n                .child(\\\\\\\\n                    div()\\\\\\\\n                        .text_sm()\\\\\\\\n                        .text_color(rgb(0xcccccc))\\\\\\\\n                        .child(name),\\\\\\\\n                )\\\\\\\\n                .child(Slider::new(&amp;slider_entity));\\\\\\\\n\\\\\\\\n            rows = rows.child(row);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        rows\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":88}\\\"},\\\"capabilityType\\\":15}\",\"71e4a15a-7e1a-4c67-8542-d876a6e5c0da\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f858b500-1ab8-4edf-95f8-d14216d7581f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_eb65f99d-3efd-409c-a704-fd090cc6360\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_eb65f99d-3efd-409c-a704-fd090cc6360\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/transport.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/transport.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/transport.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\\n//!\\\\\\\\n//! This module is kept for organisational clarity; the actual transport\\\\\\\\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\\n\\\\\\\\n// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":8}\\\"},\\\"capabilityType\\\":15}\",\"472df3d2-ae9c-47a4-b0fb-d117e4332d39\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"47e1f31c-f56e-411f-a943-b676f0f1e540\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_8a42764b-4e2e-4733-810f-72925842499\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_8a42764b-4e2e-4733-810f-72925842499\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/ffi.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/ffi.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/src/ffi.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Raw FFI bindings to z_plug_host and z_plug_engine C APIs.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n//!\\\\\\\\n//! These declarations mirror &#96;lib/z_plug_host/z_plug_host.h&#96; and\\\\\\\\n//! &#96;lib/z_plug_engine/z_plug_engine.h&#96; exactly. Do not use these types\\\\\\\\n//! directly; prefer the safe wrappers in &#96;host.rs&#96; and &#96;engine.rs&#96;.\\\\\\\\n\\\\\\\\nuse std::ffi::c_char;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Opaque handle types\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Opaque handle to a loaded CLAP plugin instance (&#96;ZphPlugin*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPlugin {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Opaque handle to an audio engine instance (&#96;ZpeEngine*&#96;).\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZpeEngine {\\\\\\\\n    _private: [u8; 0],\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Process status (mirrors clap_process_status)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[repr(i32)]\\\\\\\\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\\\\\\\\npub enum ZphProcessStatus {\\\\\\\\n    Error = 0,\\\\\\\\n    Continue = 1,\\\\\\\\n    ContinueIfNotQuiet = 2,\\\\\\\\n    Tail = 3,\\\\\\\\n    Sleep = 4,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info struct (matches ZphPluginInfo in z_plug_host.h)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Plugin metadata returned by &#96;zph_get_plugin_info&#96;.\\\\\\\\n/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphPluginInfo {\\\\\\\\n    pub id: *const c_char,\\\\\\\\n    pub name: *const c_char,\\\\\\\\n    pub vendor: *const c_char,\\\\\\\\n    pub version: *const c_char,\\\\\\\\n    pub description: *const c_char,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Default for ZphPluginInfo {\\\\\\\\n    fn default() -&gt; Self {\\\\\\\\n        Self {\\\\\\\\n            id: std::ptr::null(),\\\\\\\\n            name: std::ptr::null(),\\\\\\\\n            vendor: std::ptr::null(),\\\\\\\\n            version: std::ptr::null(),\\\\\\\\n            description: std::ptr::null(),\\\\\\\\n            input_channels: 0,\\\\\\\\n            output_channels: 0,\\\\\\\\n            latency_samples: 0,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Parameter info struct (matches ZphParamInfo in z_plug_host.h)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Parameter metadata returned by &#96;zph_get_param_info&#96;.\\\\\\\\n/// &#96;name&#96; and &#96;module&#96; are null-terminated strings stored inline.\\\\\\\\n#[repr(C)]\\\\\\\\npub struct ZphParamInfo {\\\\\\\\n    pub id: u32,\\\\\\\\n    pub name: [u8; 256],\\\\\\\\n    pub module: [u8; 1024],\\\\\\\\n    pub min_value: f64,\\\\\\\\n    pub max_value: f64,\\\\\\\\n    pub default_value: f64,\\\\\\\\n    pub flags: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Default for ZphParamInfo {\\\\\\\\n    fn default() -&gt; Self {\\\\\\\\n        Self {\\\\\\\\n            id: 0,\\\\\\\\n            name: [0u8; 256],\\\\\\\\n            module: [0u8; 1024],\\\\\\\\n            min_value: 0.0,\\\\\\\\n            max_value: 1.0,\\\\\\\\n            default_value: 0.0,\\\\\\\\n            flags: 0,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_host extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\\n\\\\\\\\n    /// Destroy a plugin handle and free all resources.\\\\\\\\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start the audio processing state (call from audio thread after activate).\\\\\\\\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Process one block of audio through the plugin.\\\\\\\\n    pub fn zph_process(\\\\\\\\n        plugin: *mut ZphPlugin,\\\\\\\\n        inputs: *const *const f32,\\\\\\\\n        outputs: *const *mut f32,\\\\\\\\n        channel_count: u32,\\\\\\\\n        frame_count: u32,\\\\\\\\n    ) -&gt; ZphProcessStatus;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\\n    pub fn zph_get_param_info(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        index: u32,\\\\\\\\n        out: *mut ZphParamInfo,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn zph_get_param_value(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        param_id: u32,\\\\\\\\n        out: *mut f64,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\\n\\\\\\\\n    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\\n\\\\\\\\n    /// Destroy the engine and free all resources.\\\\\\\\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Pause playback (position preserved).\\\\\\\\n    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn zpe_set_looping(engine: *mut ZpeEngine, enable: bool);\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":217}\\\"},\\\"capabilityType\\\":15}\",\"d31d7a78-e844-480a-b2fe-9a07ba263fe1\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"1eae4c67-27b6-40a2-a555-a2748b64d5f4\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_1762059e-59c6-4055-8c00-af9704e52dc\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_1762059e-59c6-4055-8c00-af9704e52dc\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/build.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/build.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader/build.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\\nuse std::process::Command;\\\\\\\\n\\\\\\\\nfn main() {\\\\\\\\n    let repo_root = PathBuf::from(env!(\\\\\\\\\\\\\\\"CARGO_MANIFEST_DIR\\\\\\\\\\\\\\\"))\\\\\\\\n        .parent()\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"zloader must be inside the z-plug repo\\\\\\\\\\\\\\\")\\\\\\\\n        .to_path_buf();\\\\\\\\n\\\\\\\\n    // Tell cargo to re-run this script if Zig sources change.\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_host\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"lib/z_plug_engine\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n    println!(\\\\\\\\n        \\\\\\\\\\\\\\\"cargo:rerun-if-changed={}\\\\\\\\\\\\\\\",\\\\\\\\n        repo_root.join(\\\\\\\\\\\\\\\"build.zig\\\\\\\\\\\\\\\").display()\\\\\\\\n    );\\\\\\\\n\\\\\\\\n    // Build the Zig static libraries. We need to activate the Nix/direnv\\\\\\\\n    // environment to get Zig 0.15.2 on PATH. We do this by running direnv\\\\\\\\n    // export bash and sourcing its output before invoking zig.\\\\\\\\n    //\\\\\\\\n    // If direnv is not available (e.g. CI without Nix), fall back to\\\\\\\\n    // expecting &#96;zig&#96; to already be on PATH.\\\\\\\\n    let zig_path = find_zig(&amp;repo_root);\\\\\\\\n\\\\\\\\n    let status = Command::new(&amp;zig_path)\\\\\\\\n        .args([\\\\\\\\\\\\\\\"build\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"host\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"engine\\\\\\\\\\\\\\\"])\\\\\\\\n        .current_dir(&amp;repo_root)\\\\\\\\n        .status()\\\\\\\\n        .unwrap_or_else(|e| panic!(\\\\\\\\\\\\\\\"failed to run zig build: {e}\\\\\\\\\\\\\\\"));\\\\\\\\n\\\\\\\\n    if !status.success() {\\\\\\\\n        panic!(\\\\\\\\\\\\\\\"zig build host engine failed with status: {status}\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Link the produced static libraries.\\\\\\\\n    let lib_dir = repo_root.join(\\\\\\\\\\\\\\\"zig-out/lib\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-search=native={}\\\\\\\\\\\\\\\", lib_dir.display());\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_host\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=static=z_plug_engine\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // macOS frameworks required by z_plug_engine (CoreAudio via AudioQueue).\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=AudioToolbox\\\\\\\\\\\\\\\");\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=framework=CoreAudio\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // libc is needed because the Zig libraries call into it.\\\\\\\\n    println!(\\\\\\\\\\\\\\\"cargo:rustc-link-lib=c\\\\\\\\\\\\\\\");\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Locate the &#96;zig&#96; binary. Tries:\\\\\\\\n///   1. &#96;&lt;repo_root&gt;/.direnv&#96; paths (Nix devShell via direnv)\\\\\\\\n///   2. The &#96;ZIG&#96; environment variable\\\\\\\\n///   3. Plain &#96;zig&#96; on PATH\\\\\\\\nfn find_zig(repo_root: &amp;PathBuf) -&gt; String {\\\\\\\\n    // Try to get the zig path from the direnv environment.\\\\\\\\n    // direnv stores activated paths in NIX_PROFILES or we can just run\\\\\\\\n    // &#96;direnv exec . which zig&#96; if direnv is available.\\\\\\\\n    if let Ok(output) = Command::new(\\\\\\\\\\\\\\\"direnv\\\\\\\\\\\\\\\")\\\\\\\\n        .args([\\\\\\\\\\\\\\\"exec\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"which\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"zig\\\\\\\\\\\\\\\"])\\\\\\\\n        .current_dir(repo_root)\\\\\\\\n        .output()\\\\\\\\n    {\\\\\\\\n        if output.status.success() {\\\\\\\\n            let path = String::from_utf8_lossy(&amp;output.stdout).trim().to_string();\\\\\\\\n            if !path.is_empty() {\\\\\\\\n                return path;\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Fall back to ZIG env var or plain &#96;zig&#96;.\\\\\\\\n    std::env::var(\\\\\\\\\\\\\\\"ZIG\\\\\\\\\\\\\\\").unwrap_or_else(|_| \\\\\\\\\\\\\\\"zig\\\\\\\\\\\\\\\".to_string())\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":80}\\\"},\\\"capabilityType\\\":15}\",\"64ccfd4a-ead3-4caf-8d09-5fd504b162f6\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"765721e8-4909-46e8-9e7d-128788fe4e38\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nSearching for mouse/input handling code:\\\\n\\\"}\",\"22543eed-635f-4e18-acfe-31fda0e8186d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d4bd9ad5-d8a1-46bb-a0ab-d109a2c645f9\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_0cac942b-8eae-44f0-b6a1-ac35e52168f\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_0cac942b-8eae-44f0-b6a1-ac35e52168f\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"mouse|click|on_click|MouseEvent|pointer|input|interaction\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_0cac942b-8eae-44f0-b6a1-ac35e52168f\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"mouse|click|on_click|MouseEvent|pointer|input|interaction\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"mouse|click|on_click|MouseEvent|pointer|input|interaction\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/zloader\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{\\\\\\\"matches\\\\\\\":[{\\\\\\\"file\\\\\\\":\\\\\\\"zloader/src/app.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":220,\\\\\\\"content\\\\\\\":\\\\\\\"                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":229,\\\\\\\"content\\\\\\\":\\\\\\\"                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"zloader/src/host.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":39,\\\\\\\"content\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":51,\\\\\\\"content\\\\\\\":\\\\\\\"/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":130,\\\\\\\"content\\\\\\\":\\\\\\\"            input_channels: raw.input_channels,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":180,\\\\\\\"content\\\\\\\":\\\\\\\"    /// Return the raw pointer for passing to the engine.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"zloader/src/engine.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":21,\\\\\\\"content\\\\\\\":\\\\\\\"/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"zloader/src/ffi.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":45,\\\\\\\"content\\\\\\\":\\\\\\\"/// String pointers are owned by the plugin and valid for the plugin lifetime.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":53,\\\\\\\"content\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":66,\\\\\\\"content\\\\\\\":\\\\\\\"            input_channels: 0,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":131,\\\\\\\"content\\\\\\\":\\\\\\\"        inputs: *const *const f32,\\\\\\\"}]}],\\\\\\\"totalLines\\\\\\\":11,\\\\\\\"totalMatchedLines\\\\\\\":11}}}}}\\\"},\\\"capabilityType\\\":15}\",\"77ca8476-1767-47ec-ac80-35803b8f9a3f\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"a61505ef-e9cb-49c1-89f7-088673439673\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.581Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_114740d9-604c-4b1a-8547-4887177661e\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_114740d9-604c-4b1a-8547-4887177661e\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How are mouse clicks or pointer events handled in the waveform view?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"zloader\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How are mouse clicks or pointer events handled in the waveform view?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"zloader\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":38,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":93,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\\n        peaks: WaveformPeaks,\\\\\\\\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\\n    ) -&gt; Self {\\\\\\\\n        let plugin_name: SharedString = state\\\\\\\\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\\n            .into();\\\\\\\\n\\\\\\\\n        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\\n\\\\\\\\n        // Build the waveform view.\\\\\\\\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\\n\\\\\\\\n        // Build the params view.\\\\\\\\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\\n\\\\\\\\n        // Subscribe to slider changes and forward to the plugin host.\\\\\\\\n        // This runs on the main thread with full access to cx.\\\\\\\\n        let state_for_params = state.clone();\\\\\\\\n        params_view\\\\\\\\n            .read_with(cx, |pv, _| {\\\\\\\\n                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\\n                pv.sliders\\\\\\\\n                    .iter()\\\\\\\\n                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\\n            })\\\\\\\\n            .into_iter()\\\\\\\\n            .for_each(|(param_id, slider_entity)| {\\\\\\\\n                let state_weak = state_for_params.downgrade();\\\\\\\\n                cx.subscribe(\\\\\\\\n                    &amp;slider_entity,\\\\\\\\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\\n                        let SliderEvent::Change(value) = event;\\\\\\\\n                        let v = value.start() as f64;\\\\\\\\n                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\\n                            state_entity.read_with(cx, |s, _| {\\\\\\\\n                                s.host.set_param_value(param_id, v);\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .detach();\\\\\\\\n            });\\\\\\\\n\\\\\\\\n        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\\n        let state_weak = state.downgrade();\\\\\\\\n        let waveform_weak = waveform.downgrade();\\\\\\\\n        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx: &amp;mut gpui::Context&lt;Self&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name: SharedString = state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |s, _| s.plugin_info.name.clone())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params = state.read_with(cx, |s, _| s.params.clone());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the waveform view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = cx.new(|_cx| WaveformView::new(peaks));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Build the params view.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Subscribe to slider changes and forward to the plugin host.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This runs on the main thread with full access to cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_for_params = state.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        params_view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"            .read_with(cx, |pv, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Collect slider entities to subscribe to them from the parent cx.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                pv.sliders\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .map(|s| (s.info.id, s.slider.clone()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .collect::&lt;Vec&lt;_&gt;&gt;()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into_iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            .for_each(|(param_id, slider_entity)| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"                let state_weak = state_for_params.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.subscribe(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;slider_entity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_this, _slider, event: &amp;SliderEvent, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let SliderEvent::Change(value) = event;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let v = value.start() as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if let Some(state_entity) = state_weak.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                            state_entity.read_with(cx, |s, _| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                                s.host.set_param_value(param_id, v);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Spawn a repeating timer to poll playback position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state_weak = state.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform_weak = waveform.downgrade();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94}]},\\\\\\\"score\\\\\\\":0.2714520990848541},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":84},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":143,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\\n    pub position: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformView {\\\\\\\\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\\n        Self { peaks, position: 0 }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for WaveformView {\\\\\\\\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let peaks = self.peaks.clone();\\\\\\\\n        let position = self.position;\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .w_full()\\\\\\\\n            .h(px(120.0))\\\\\\\\n            .bg(rgb(0x1a1a2e))\\\\\\\\n            .rounded(px(6.0))\\\\\\\\n            .overflow_hidden()\\\\\\\\n            .child(\\\\\\\\n                canvas(\\\\\\\\n                    move |_bounds, _window, _cx| {},\\\\\\\\n                    move |bounds, _prepaint, window, _cx| {\\\\\\\\n                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\\n                    },\\\\\\\\n                )\\\\\\\\n                .w_full()\\\\\\\\n                .h_full(),\\\\\\\\n            )\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Drawing helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\\n    window.paint_quad(PaintQuad {\\\\\\\\n        bounds: Bounds {\\\\\\\\n            origin: Point { x: px(x), y: px(y) },\\\\\\\\n            size: Size {\\\\\\\\n                width: px(w),\\\\\\\\n                height: px(h),\\\\\\\\n            },\\\\\\\\n        },\\\\\\\\n        corner_radii: Corners::all(px(0.0)),\\\\\\\\n        background: Background::from(color),\\\\\\\\n        border_widths: Edges::all(px(0.0)),\\\\\\\\n        border_color: gpui::transparent_black(),\\\\\\\\n        border_style: BorderStyle::default(),\\\\\\\\n    });\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(peaks: WaveformPeaks) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { peaks, position: 0 }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        let peaks = self.peaks.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        let position = self.position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"            .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"            .h(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x1a1a2e))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"            .rounded(px(6.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            .overflow_hidden()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                canvas(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |_bounds, _window, _cx| {},\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    move |bounds, _prepaint, window, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                        draw_waveform(window, bounds, &amp;peaks, position);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                .w_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"                .h_full(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"// Drawing helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"fn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    window.paint_quad(PaintQuad {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"        bounds: Bounds {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            origin: Point { x: px(x), y: px(y) },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            size: Size {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"                width: px(w),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"                height: px(h),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        corner_radii: Corners::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        background: Background::from(color),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_widths: Edges::all(px(0.0)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_color: gpui::transparent_black(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        border_style: BorderStyle::default(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144}]},\\\\\\\"score\\\\\\\":0.25639623403549194},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":139,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":180,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\\n    window: &amp;mut Window,\\\\\\\\n    bounds: Bounds&lt;Pixels&gt;,\\\\\\\\n    peaks: &amp;WaveformPeaks,\\\\\\\\n    position: u64,\\\\\\\\n) {\\\\\\\\n    let width = f32::from(bounds.size.width);\\\\\\\\n    let height = f32::from(bounds.size.height);\\\\\\\\n    let origin_x = f32::from(bounds.origin.x);\\\\\\\\n    let origin_y = f32::from(bounds.origin.y);\\\\\\\\n    let mid_y = origin_y + height / 2.0;\\\\\\\\n    let half_h = height / 2.0 * 0.9;\\\\\\\\n\\\\\\\\n    let num_cols = peaks.peaks.len().max(1);\\\\\\\\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\\n    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\\n    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\\n\\\\\\\\n    // Draw waveform bars.\\\\\\\\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\\n        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\\n\\\\\\\\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\\n        let bar_height = (bottom - top).max(1.0);\\\\\\\\n\\\\\\\\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Draw center line.\\\\\\\\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\\n\\\\\\\\n    // Draw playhead.\\\\\\\\n    if peaks.total_samples &gt; 0 {\\\\\\\\n        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn draw_waveform(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    bounds: Bounds&lt;Pixels&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    peaks: &amp;WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    position: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\") {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    let width = f32::from(bounds.size.width);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"    let height = f32::from(bounds.size.height);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_x = f32::from(bounds.origin.x);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    let origin_y = f32::from(bounds.origin.y);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mid_y = origin_y + height / 2.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    let half_h = height / 2.0 * 0.9;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    let num_cols = peaks.peaks.len().max(1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"    let waveform_color: Hsla = rgb(0x4a9eff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    let center_color: Hsla = rgb(0x2a4a6e).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    let playhead_color: Hsla = rgb(0xffffff).into();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw waveform bars.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        let x = origin_x + (i as f32 / num_cols as f32) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_width = (width / num_cols as f32).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"        let top = mid_y - max_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bar_height = (bottom - top).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw center line.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Draw playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    if peaks.total_samples &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        let progress = position as f32 / peaks.total_samples as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181}]},\\\\\\\"score\\\\\\\":0.24968016147613525},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\\n            loop {\\\\\\\\n                cx.background_executor()\\\\\\\\n                    .timer(Duration::from_millis(30))\\\\\\\\n                    .await;\\\\\\\\n\\\\\\\\n                let should_stop = cx.update(|cx| {\\\\\\\\n                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\\n                        return true;\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    // Poll position and call idle.\\\\\\\\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\\n                        s.host.idle();\\\\\\\\n                        (s.engine.position(), s.engine.is_playing())\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update waveform playhead.\\\\\\\\n                    waveform_entity.update(cx, |w, cx| {\\\\\\\\n                        w.position = position;\\\\\\\\n                        cx.notify();\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                    // Update root view playing state.\\\\\\\\n                    this.update(cx, |app, cx| {\\\\\\\\n                        app.is_playing = is_playing;\\\\\\\\n                        cx.notify();\\\\\\\\n                    })\\\\\\\\n                    .is_err()\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                if should_stop.unwrap_or(true) {\\\\\\\\n                    break;\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        })\\\\\\\\n        .detach();\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            state,\\\\\\\\n            waveform,\\\\\\\\n            params_view,\\\\\\\\n            is_playing: false,\\\\\\\\n            plugin_name,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            s.engine.seek(0);\\\\\\\\n        });\\\\\\\\n        self.waveform.update(cx, |w, cx| {\\\\\\\\n            w.position = 0;\\\\\\\\n            cx.notify();\\\\\\\\n        });\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.spawn(async move |this, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.background_executor()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .timer(Duration::from_millis(30))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .await;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let should_stop = cx.update(|cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(state_entity) = state_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let Some(waveform_entity) = waveform_weak.upgrade() else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Poll position and call idle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                        s.host.idle();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                        (s.engine.position(), s.engine.is_playing())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update waveform playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"                    waveform_entity.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                        w.position = position;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Update root view playing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                    this.update(cx, |app, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"                        app.is_playing = is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .is_err()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                if should_stop.unwrap_or(true) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        .detach();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"            state,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"            waveform,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"            params_view,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            is_playing: false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"            plugin_name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"            s.engine.seek(0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.waveform.update(cx, |w, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"            w.position = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"            cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152}]},\\\\\\\"score\\\\\\\":0.2392694354057312},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":99,\\\\\\\"column\\\\\\\":46},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":154,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\\n/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\\nconst WAVEFORM_COLUMNS: usize = 1200;\\\\\\\\n\\\\\\\\nfn setup(\\\\\\\\n    cx: &amp;mut App,\\\\\\\\n    plugin_path: &amp;PathBuf,\\\\\\\\n    audio_path: &amp;PathBuf,\\\\\\\\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\\n    // Load the plugin.\\\\\\\\n    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\\n    let plugin_info = host.get_info()?;\\\\\\\\n    let params = host.get_params();\\\\\\\\n\\\\\\\\n    // Create the audio engine and load the WAV file.\\\\\\\\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    engine.load_file(audio_path)?;\\\\\\\\n\\\\\\\\n    // Activate and start processing.\\\\\\\\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\\n    host.start_processing()?;\\\\\\\\n\\\\\\\\n    // Attach plugin to engine.\\\\\\\\n    engine.set_plugin(Some(&amp;mut host));\\\\\\\\n\\\\\\\\n    // Read the WAV file for waveform peak computation.\\\\\\\\n    let peaks = build_peaks(audio_path)?;\\\\\\\\n\\\\\\\\n    let state = cx.new(|_cx| AppState {\\\\\\\\n        host,\\\\\\\\n        engine,\\\\\\\\n        plugin_info,\\\\\\\\n        params,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok((state, peaks))\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read the WAV file and compute waveform peaks for display.\\\\\\\\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\\n    let data = std::fs::read(path)?;\\\\\\\\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\\n    Ok(peaks)\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\\n/// Returns (interleaved_f32_samples, channel_count).\\\\\\\\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Number of waveform display columns (pre-computed peak resolution).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"const WAVEFORM_COLUMNS: usize = 1200;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"fn setup(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    cx: &amp;mut App,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_path: &amp;PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Load the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut host = PluginHost::load(plugin_path, None)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_info = host.get_info()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    let params = host.get_params();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Create the audio engine and load the WAV file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.load_file(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Activate and start processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    host.start_processing()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Attach plugin to engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    engine.set_plugin(Some(&amp;mut host));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Read the WAV file for waveform peak computation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = build_peaks(audio_path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"    let state = cx.new(|_cx| AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        engine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        params,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((state, peaks))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Read the WAV file and compute waveform peaks for display.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"fn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    let data = std::fs::read(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"    let (samples, channels) = parse_wav_samples(&amp;data)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(peaks)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Returns (interleaved_f32_samples, channel_count).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"fn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155}]},\\\\\\\"score\\\\\\\":0.20356880128383636},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":148,\\\\\\\"column\\\\\\\":20},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":179,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\\n        self.state.update(cx, |s, _cx| {\\\\\\\\n            if is_playing {\\\\\\\\n                s.engine.stop();\\\\\\\\n            } else {\\\\\\\\n                let _ = s.engine.play();\\\\\\\\n            }\\\\\\\\n        });\\\\\\\\n        self.is_playing = !is_playing;\\\\\\\\n        cx.notify();\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ZLoaderApp {\\\\\\\\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\\n        let play_label: SharedString = if self.is_playing {\\\\\\\\n            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\\n        } else {\\\\\\\\n            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\\n        };\\\\\\\\n        let plugin_name = self.plugin_name.clone();\\\\\\\\n        let waveform = self.waveform.clone();\\\\\\\\n        let params_view = self.params_view.clone();\\\\\\\\n\\\\\\\\n        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.state.update(cx, |s, _cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"            if is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                s.engine.stop();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"                let _ = s.engine.play();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.is_playing = !is_playing;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.notify();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        let play_label: SharedString = if self.is_playing {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Stop\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Play\\\\\\\\\\\\\\\".into()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_name = self.plugin_name.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"        let waveform = self.waveform.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params_view = self.params_view.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180}]},\\\\\\\"score\\\\\\\":0.19029396772384644},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":24,\\\\\\\"column\\\\\\\":18}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\\n//!\\\\\\\\n//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\\n//! playhead line indicating the current playback position.\\\\\\\\n\\\\\\\\nuse gpui::{\\\\\\\\n    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\\n    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\\n/// One entry per display column (pixel-width bucket).\\\\\\\\n#[derive(Clone)]\\\\\\\\npub struct WaveformPeaks {\\\\\\\\n    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\\n    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\\n    /// Total number of samples in the source file (for playhead math).\\\\\\\\n    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Waveform display using GPUI's &#96;canvas()&#96; element.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Renders a pre-computed peak overview of the loaded audio file, with a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! playhead line indicating the current playback position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    IntoElement, PaintQuad, Pixels, Point, Size, Window,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Pre-computed min/max peak pairs for waveform rendering.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"/// One entry per display column (pixel-width bucket).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// (min, max) pairs in [-1.0, 1.0], one per display column.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: Vec&lt;(f32, f32)&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Total number of samples in the source file (for playhead math).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25}]},\\\\\\\"score\\\\\\\":0.18804943561553955},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/waveform.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":21},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":87}},\\\\\\\"contents\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl WaveformPeaks {\\\\\\\\n    /// Build peak data from raw interleaved f32 samples.\\\\\\\\n    ///\\\\\\\\n    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\\n    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\\n    /// bucket across all channels.\\\\\\\\n    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\\n        let total_frames = if channels &gt; 0 {\\\\\\\\n            samples.len() / channels\\\\\\\\n        } else {\\\\\\\\n            0\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let total_samples = total_frames as u64;\\\\\\\\n\\\\\\\\n        if total_frames == 0 || num_columns == 0 {\\\\\\\\n            return Self {\\\\\\\\n                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\\n                total_samples,\\\\\\\\n            };\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\\n        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\\n\\\\\\\\n        for col in 0..num_columns {\\\\\\\\n            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\\n            let end_frame = end_frame.min(total_frames);\\\\\\\\n\\\\\\\\n            let mut min = 0.0f32;\\\\\\\\n            let mut max = 0.0f32;\\\\\\\\n\\\\\\\\n            for frame in start_frame..end_frame {\\\\\\\\n                for ch in 0..channels {\\\\\\\\n                    let sample = samples[frame * channels + ch];\\\\\\\\n                    if sample &lt; min {\\\\\\\\n                        min = sample;\\\\\\\\n                    }\\\\\\\\n                    if sample &gt; max {\\\\\\\\n                        max = sample;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            peaks.push((min, max));\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        Self {\\\\\\\\n            peaks,\\\\\\\\n            total_samples,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// WaveformView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// A GPUI view that renders the waveform and a playhead.\\\\\\\\npub struct WaveformView {\\\\\\\\n    pub peaks: WaveformPeaks,\\\\\\\\n    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    pub total_samples: u64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"impl WaveformPeaks {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build peak data from raw interleaved f32 samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// divided into that many equal-sized buckets; min/max are computed per\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// bucket across all channels.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_frames = if channels &gt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            samples.len() / channels\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"            0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"        let total_samples = total_frames as u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        if total_frames == 0 || num_columns == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"            return Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                peaks: vec![(0.0, 0.0); num_columns.max(1)],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"                total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut peaks = Vec::with_capacity(num_columns);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"        for col in 0..num_columns {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"            let start_frame = (col as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"            let end_frame = end_frame.min(total_frames);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut min = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut max = 0.0f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"            for frame in start_frame..end_frame {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"                for ch in 0..channels {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let sample = samples[frame * channels + ch];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &lt; min {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        min = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if sample &gt; max {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                        max = sample;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks.push((min, max));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            peaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            total_samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"// WaveformView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A GPUI view that renders the waveform and a playhead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct WaveformView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub peaks: WaveformPeaks,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Current playback position in samples (updated by the app timer).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87}]},\\\\\\\"score\\\\\\\":0.183127298951149},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":42,\\\\\\\"column\\\\\\\":32}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\\n//!\\\\\\\\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\\n//! and drives the periodic idle/position-poll timer.\\\\\\\\n\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::button::{Button, ButtonVariants};\\\\\\\\nuse gpui_component::slider::SliderEvent;\\\\\\\\n\\\\\\\\nuse crate::engine::AudioEngine;\\\\\\\\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\\nuse crate::params::ParamsView;\\\\\\\\nuse crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AppState  owns the non-Send FFI resources\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\\npub struct AppState {\\\\\\\\n    pub host: PluginHost,\\\\\\\\n    pub engine: AudioEngine,\\\\\\\\n    pub plugin_info: PluginInfo,\\\\\\\\n    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ZLoaderApp  root view\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\npub struct ZLoaderApp {\\\\\\\\n    state: Entity&lt;AppState&gt;,\\\\\\\\n    waveform: Entity&lt;WaveformView&gt;,\\\\\\\\n    params_view: Entity&lt;ParamsView&gt;,\\\\\\\\n    is_playing: bool,\\\\\\\\n    plugin_name: SharedString,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ZLoaderApp {\\\\\\\\n    pub fn new(\\\\\\\\n        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Root GPUI view for zloader.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! and drives the periodic idle/position-poll timer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::button::{Button, ButtonVariants};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::SliderEvent;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::{ParamInfo, PluginHost, PluginInfo};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::params::ParamsView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::waveform::{WaveformPeaks, WaveformView};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// AppState  owns the non-Send FFI resources\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AppState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub host: PluginHost,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub engine: AudioEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub plugin_info: PluginInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub params: Vec&lt;ParamInfo&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"// ZLoaderApp  root view\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    waveform: Entity&lt;WaveformView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    params_view: Entity&lt;ParamsView&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    is_playing: bool,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_name: SharedString,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ZLoaderApp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        state: Entity&lt;AppState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.18025976419448853},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":41,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":103,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\\n\\\\\\\\n    if !args.plugin_path.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\\n    }\\\\\\\\n    if !args.audio_file.exists() {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let plugin_path = args.plugin_path.clone();\\\\\\\\n    let audio_path = args.audio_file.clone();\\\\\\\\n\\\\\\\\n    Application::new().run(move |cx: &amp;mut App| {\\\\\\\\n        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\\n\\\\\\\\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\\n        gpui_component::init(cx);\\\\\\\\n\\\\\\\\n        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\\n            Ok(v) =&gt; v,\\\\\\\\n            Err(e) =&gt; {\\\\\\\\n                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\\n                cx.quit();\\\\\\\\n                return;\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\\n\\\\\\\\n        cx.open_window(\\\\\\\\n            WindowOptions {\\\\\\\\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\\n                titlebar: Some(gpui::TitlebarOptions {\\\\\\\\n                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\\n                    ..Default::default()\\\\\\\\n                }),\\\\\\\\n                ..Default::default()\\\\\\\\n            },\\\\\\\\n            move |window, cx| {\\\\\\\\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\\n            },\\\\\\\\n        )\\\\\\\\n        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        cx.activate(true);\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Setup: load plugin + audio, build peak data\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nconst SAMPLE_RATE: f64 = 44100.0;\\\\\\\\nconst BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.plugin_path.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Plugin not found: {:?}\\\\\\\\\\\\\\\", args.plugin_path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    if !args.audio_file.exists() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Audio file not found: {:?}\\\\\\\\\\\\\\\", args.audio_file);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"    let plugin_path = args.plugin_path.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    let audio_path = args.audio_file.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    Application::new().run(move |cx: &amp;mut App| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load embedded Inter Variable font so text renders on all platforms.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"        // glyphs via GPUI's sprite atlas on some macOS configurations.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Initialize gpui-component theming and force dark mode to match our dark UI.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        gpui_component::init(cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Load plugin and audio on the main thread (FFI is not Send).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            Ok(v) =&gt; v,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            Err(e) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"                eprintln!(\\\\\\\\\\\\\\\"Error: {e:#}\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.quit();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"                return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.open_window(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            WindowOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                window_bounds: Some(WindowBounds::Windowed(bounds)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                titlebar: Some(gpui::TitlebarOptions {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"                    title: Some(\\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\".into()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                ..Default::default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"            move |window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        .expect(\\\\\\\\\\\\\\\"failed to open window\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        cx.activate(true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"// Setup: load plugin + audio, build peak data\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"const SAMPLE_RATE: f64 = 44100.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"const BUFFER_SIZE: u32 = 512;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104}]},\\\\\\\"score\\\\\\\":0.16375379264354706},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":28,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":94,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    ///\\\\\\\\n    /// Stops playback and resets position if a file was already loaded.\\\\\\\\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    ///\\\\\\\\n    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\\n    /// output. The plugin must be activated and processing-started before\\\\\\\\n    /// calling &#96;play()&#96;.\\\\\\\\n    ///\\\\\\\\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\\n        let plugin_ptr = host\\\\\\\\n            .map(|h| h.raw_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null_mut());\\\\\\\\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Pause playback. The current position is preserved.\\\\\\\\n    pub fn pause(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn stop(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_create returned NULL\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stops playback and resets position if a file was already loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_load_file failed for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Audio from the loaded WAV file will be routed through the plugin before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// output. The plugin must be activated and processing-started before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// calling &#96;play()&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pass &#96;None&#96; to detach and use passthrough mode.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_ptr = host\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|h| h.raw_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null_mut());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zpe_play(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zpe_play failed (no file loaded or audio init error)\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback. The current position is preserved.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn pause(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_pause(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_stop(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn seek(&amp;mut self, sample_position: u64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95}]},\\\\\\\"score\\\\\\\":0.14962780475616455},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":205,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":237,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\\n                            .flex_col()\\\\\\\\n                            .gap(px(8.0))\\\\\\\\n                            .w(px(120.0))\\\\\\\\n                            .flex_shrink_0()\\\\\\\\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\\n                            .child(\\\\\\\\n                                div()\\\\\\\\n                                    .flex()\\\\\\\\n                                    .flex_row()\\\\\\\\n                                    .gap(px(8.0))\\\\\\\\n                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\\n                                        |app, _ev, window, cx| {\\\\\\\\n                                            app.on_rewind(window, cx);\\\\\\\\n                                        },\\\\\\\\n                                    )))\\\\\\\\n                                    .child(\\\\\\\\n                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\\n                                            .primary()\\\\\\\\n                                            .label(play_label)\\\\\\\\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\\n                                                app.on_play_stop(window, cx);\\\\\\\\n                                            })),\\\\\\\\n                                    ),\\\\\\\\n                            ),\\\\\\\\n                    )\\\\\\\\n                    // Parameter panel\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .w(px(120.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex_shrink_0()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(div().text_sm().text_color(rgb(0x888888)).child(\\\\\\\\\\\\\\\"Transport\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"                                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .gap(px(8.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(Button::new(\\\\\\\\\\\\\\\"rewind\\\\\\\\\\\\\\\").label(\\\\\\\\\\\\\\\"&lt;&lt;\\\\\\\\\\\\\\\").on_click(cx.listener(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        |app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            app.on_rewind(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    )))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        Button::new(\\\\\\\\\\\\\\\"play_stop\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .primary()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .label(play_label)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            .on_click(cx.listener(|app, _ev, window, cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                app.on_play_stop(window, cx);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            })),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":231},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":232},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":233},{\\\\\\\"text\\\\\\\":\\\\\\\"                    )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":234},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Parameter panel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":235},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238}]},\\\\\\\"score\\\\\\\":0.12851929664611816},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":44,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\\n//!\\\\\\\\n//! Usage:\\\\\\\\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\\n\\\\\\\\nmod app;\\\\\\\\nmod engine;\\\\\\\\nmod ffi;\\\\\\\\nmod host;\\\\\\\\nmod params;\\\\\\\\nmod transport;\\\\\\\\nmod waveform;\\\\\\\\n\\\\\\\\nuse std::path::PathBuf;\\\\\\\\n\\\\\\\\nuse anyhow::Result;\\\\\\\\nuse clap::Parser;\\\\\\\\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\\nuse gpui_component::{theme::Theme, Root};\\\\\\\\n\\\\\\\\nuse app::{AppState, ZLoaderApp};\\\\\\\\nuse engine::AudioEngine;\\\\\\\\nuse host::PluginHost;\\\\\\\\nuse waveform::WaveformPeaks;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// CLI\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n#[derive(Parser, Debug)]\\\\\\\\n#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\\nstruct Args {\\\\\\\\n    /// Path to the .clap plugin file or bundle.\\\\\\\\n    plugin_path: PathBuf,\\\\\\\\n\\\\\\\\n    /// Path to a WAV audio file to play through the plugin.\\\\\\\\n    audio_file: PathBuf,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Entry point\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn main() -&gt; Result&lt;()&gt; {\\\\\\\\n    let args = Args::parse();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! zloader  CLAP plugin debug/test tool.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! Usage:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod app;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod engine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"mod host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod transport;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"mod waveform;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::PathBuf;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::Result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap::Parser;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::{theme::Theme, Root};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"use app::{AppState, ZLoaderApp};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use engine::AudioEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use waveform::WaveformPeaks;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// CLI\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Parser, Debug)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[command(name = \\\\\\\\\\\\\\\"zloader\\\\\\\\\\\\\\\", about = \\\\\\\\\\\\\\\"CLAP plugin debug/test tool\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"struct Args {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to the .clap plugin file or bundle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    plugin_path: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Path to a WAV audio file to play through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    audio_file: PathBuf,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"// Entry point\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"fn main() -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    let args = Args::parse();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45}]},\\\\\\\"score\\\\\\\":0.12071912735700607},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":160,\\\\\\\"column\\\\\\\":68},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":214,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nextern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\\n\\\\\\\\n    /// Destroy the engine and free all resources.\\\\\\\\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Load a WAV file for playback.\\\\\\\\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Attach a CLAP plugin to the engine.\\\\\\\\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start playback.\\\\\\\\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Pause playback (position preserved).\\\\\\\\n    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Stop playback and reset position to 0.\\\\\\\\n    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\\n\\\\\\\\n    /// Seek to a specific sample position.\\\\\\\\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn zpe_set_looping\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_idle(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"// z_plug_engine extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" declarations\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy the engine and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_destroy(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a WAV file for playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Attach a CLAP plugin to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start playback.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Pause playback (position preserved).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_pause(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop playback and reset position to 0.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_stop(engine: *mut ZpeEngine);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Seek to a specific sample position.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zpe_set_looping\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215}]},\\\\\\\"score\\\\\\\":0.12059029936790466},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/ffi.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":105,\\\\\\\"column\\\\\\\":78},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":163}},\\\\\\\"contents\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\\n\\\\\\\\n    /// Destroy a plugin handle and free all resources.\\\\\\\\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Start the audio processing state (call from audio thread after activate).\\\\\\\\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\\n\\\\\\\\n    /// Process one block of audio through the plugin.\\\\\\\\n    pub fn zph_process(\\\\\\\\n        plugin: *mut ZphPlugin,\\\\\\\\n        inputs: *const *const f32,\\\\\\\\n        outputs: *const *mut f32,\\\\\\\\n        channel_count: u32,\\\\\\\\n        frame_count: u32,\\\\\\\\n    ) -&gt; ZphProcessStatus;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Return the number of parameters the plugin exposes.\\\\\\\\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\\n\\\\\\\\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\\n    pub fn zph_get_param_info(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        index: u32,\\\\\\\\n        out: *mut ZphParamInfo,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Get the current value of a parameter by its stable ID.\\\\\\\\n    pub fn zph_get_param_value(\\\\\\\\n        plugin: *const ZphPlugin,\\\\\\\\n        param_id: u32,\\\\\\\\n        out: *mut f64,\\\\\\\\n    ) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\\n\\\\\\\\n    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\\n\\\\\\\\n    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Destroy a plugin handle and free all resources.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_destroy(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_deactivate(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state (call from audio thread after activate).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Process one block of audio through the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *mut ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"        inputs: *const *const f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        outputs: *const *mut f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        channel_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        frame_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; ZphProcessStatus;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the number of parameters the plugin exposes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_info(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"        index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut ZphParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the current value of a parameter by its stable ID.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_get_param_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        out: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Save plugin state. Pass buffer=NULL to query required size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load plugin state from buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163}]},\\\\\\\"score\\\\\\\":0.09068050235509872},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":92,\\\\\\\"column\\\\\\\":48},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":138,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the current playback position in samples.\\\\\\\\n    pub fn position(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the total length of the loaded file in samples.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn length(&amp;self) -&gt; u64 {\\\\\\\\n        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the engine's output sample rate in Hz.\\\\\\\\n    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the channel count of the loaded file.\\\\\\\\n    /// Returns 0 if no file is loaded.\\\\\\\\n    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return true if the engine is currently playing.\\\\\\\\n    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\\n        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Enable or disable looping.\\\\\\\\n    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the current playback position in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn position(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_position(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the total length of the loaded file in samples.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn length(&amp;self) -&gt; u64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_length(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the engine's output sample rate in Hz.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn sample_rate(&amp;self) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the channel count of the loaded file.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns 0 if no file is loaded.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn channels(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_get_channel_count(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return true if the engine is currently playing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn is_playing(&amp;self) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_is_playing(self.ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Enable or disable looping.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_looping(&amp;mut self, enable: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"    std::ffi::CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139}]},\\\\\\\"score\\\\\\\":0.08957183361053467},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/engine.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\nuse crate::host::PluginHost;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// AudioEngine\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\\n///\\\\\\\\n/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\\n/// CoreAudio AudioQueue on macOS.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread.\\\\\\\\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct AudioEngine {\\\\\\\\n    ptr: *mut ffi::ZpeEngine,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Drop for AudioEngine {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl AudioEngine {\\\\\\\\n    /// Create a new audio engine.\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_engine C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::PluginHost;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// AudioEngine\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around the z_plug_engine audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Manages playback of a WAV file through an optional CLAP plugin using\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// CoreAudio AudioQueue on macOS.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZpeEngine,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zpe_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"impl AudioEngine {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Create a new audio engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36}]},\\\\\\\"score\\\\\\\":0.08663029968738556},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":166,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":208,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\\n    /// Thread-safe; may be called from any thread.\\\\\\\\n    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\\n        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\\n    pub fn idle(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Return the raw pointer for passing to the engine.\\\\\\\\n    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\\n        self.ptr\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Helpers\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\\n    let s = path\\\\\\\\n        .to_str()\\\\\\\\n        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\\n    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\\n    if ptr.is_null() {\\\\\\\\n        return String::new();\\\\\\\\n    }\\\\\\\\n    unsafe { CStr::from_ptr(ptr) }\\\\\\\\n        .to_string_lossy()\\\\\\\\n        .into_owned()\\\\\\\\n}\\\\\\\\n\\\\\\\\nfn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\\n    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\\n    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter change to be applied on the next process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Thread-safe; may be called from any thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle deferred plugin callbacks. Call periodically from the main thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn idle(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_idle(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Return the raw pointer for passing to the engine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.ptr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"// Helpers\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    let s = path\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"        .ok_or_else(|| anyhow!(\\\\\\\\\\\\\\\"path is not valid UTF-8: {:?}\\\\\\\\\\\\\\\", path))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"    CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"path contains null byte: {e}\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        return String::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe { CStr::from_ptr(ptr) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"        .to_string_lossy()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        .into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"fn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209}]},\\\\\\\"score\\\\\\\":0.0850088968873024},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":61,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":119,\\\\\\\"column\\\\\\\":73}},\\\\\\\"contents\\\\\\\":\\\\\\\";\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\\n    ///\\\\\\\\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\\n        let path_cstr = path_to_cstring(path)?;\\\\\\\\n        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\\n            .transpose()?;\\\\\\\\n\\\\\\\\n        let id_ptr = id_cstr\\\\\\\\n            .as_ref()\\\\\\\\n            .map(|c| c.as_ptr())\\\\\\\\n            .unwrap_or(std::ptr::null());\\\\\\\\n\\\\\\\\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\\n        if ptr.is_null() {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\\n        }\\\\\\\\n        Ok(Self { ptr })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Activate the plugin for audio processing.\\\\\\\\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Deactivate the plugin.\\\\\\\\n    pub fn deactivate(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\\n        if !ok {\\\\\\\\n            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        Ok(())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Stop the audio processing state.\\\\\\\\n    pub fn stop_processing(&amp;mut self) {\\\\\\\\n        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Retrieve plugin metadata.\\\\\\\\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\\n        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Load a &#96;.clap&#96; file and instantiate a plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"        let path_cstr = path_to_cstring(path)?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_cstr: Option&lt;CString&gt; = plugin_id\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| CString::new(s).map_err(|e| anyhow!(\\\\\\\\\\\\\\\"invalid plugin_id: {e}\\\\\\\\\\\\\\\")))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"            .transpose()?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        let id_ptr = id_cstr\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|c| c.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"            .unwrap_or(std::ptr::null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        if ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_load_plugin returned NULL for {:?}\\\\\\\\\\\\\\\", path);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(Self { ptr })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Activate the plugin for audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_activate failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Deactivate the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn deactivate(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_deactivate(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Start the audio processing state. Must be called before &#96;process&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !ok {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"            bail!(\\\\\\\\\\\\\\\"zph_start_processing failed\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"        Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stop the audio processing state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn stop_processing(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe { ffi::zph_stop_processing(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Retrieve plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut raw = ffi::ZphPluginInfo::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"text\\\\\\\":\\\\\\\"        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":120}]},\\\\\\\"score\\\\\\\":0.08431699872016907},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/params.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":56,\\\\\\\"column\\\\\\\":13}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\\n\\\\\\\\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\\nuse gpui_component::slider::{Slider, SliderState};\\\\\\\\n\\\\\\\\nuse crate::host::ParamInfo;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Per-parameter slider entry\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Holds the GPUI entity for one parameter's slider state.\\\\\\\\npub struct ParamSlider {\\\\\\\\n    pub info: ParamInfo,\\\\\\\\n    pub slider: Entity&lt;SliderState&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// ParamsView\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Panel of parameter sliders.\\\\\\\\npub struct ParamsView {\\\\\\\\n    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ParamsView {\\\\\\\\n    /// Build the params view from a list of parameter infos.\\\\\\\\n    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\\n        let sliders = params\\\\\\\\n            .iter()\\\\\\\\n            .map(|info| {\\\\\\\\n                let min = info.min_value as f32;\\\\\\\\n                let max = info.max_value as f32;\\\\\\\\n                let default = info.default_value as f32;\\\\\\\\n\\\\\\\\n                let slider = cx.new(|_cx| {\\\\\\\\n                    SliderState::new()\\\\\\\\n                        .min(min)\\\\\\\\n                        .max(max)\\\\\\\\n                        .default_value(default)\\\\\\\\n                });\\\\\\\\n\\\\\\\\n                ParamSlider {\\\\\\\\n                    info: info.clone(),\\\\\\\\n                    slider,\\\\\\\\n                }\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n\\\\\\\\n        Self { sliders }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Render for ParamsView {\\\\\\\\n    fn render\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use gpui_component::slider::{Slider, SliderState};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::host::ParamInfo;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"// Per-parameter slider entry\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Holds the GPUI entity for one parameter's slider state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub info: ParamInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub slider: Entity&lt;SliderState&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"// ParamsView\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Panel of parameter sliders.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub sliders: Vec&lt;ParamSlider&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Build the params view from a list of parameter infos.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"        let sliders = params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|info| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"                let min = info.min_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"                let max = info.max_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"                let default = info.default_value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"                let slider = cx.new(|_cx| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"                    SliderState::new()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .min(min)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .max(max)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .default_value(default)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"                ParamSlider {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"                    info: info.clone(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"                    slider,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self { sliders }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Render for ParamsView {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn render\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57}]},\\\\\\\"score\\\\\\\":0.07614213228225708},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/app.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":174,\\\\\\\"column\\\\\\\":51},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":208,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"        div()\\\\\\\\n            .flex()\\\\\\\\n            .flex_col()\\\\\\\\n            .size_full()\\\\\\\\n            .bg(rgb(0x0f0f1a))\\\\\\\\n            .text_color(rgb(0xffffff))\\\\\\\\n            .p(px(16.0))\\\\\\\\n            .gap(px(16.0))\\\\\\\\n            // Header: plugin name\\\\\\\\n            .child(\\\\\\\\n                div().flex().flex_row().items_center().gap(px(8.0)).child(\\\\\\\\n                    div()\\\\\\\\n                        .text_size(px(20.0))\\\\\\\\n                        .size_full()\\\\\\\\n                        .bg(rgb(0x0000FF))\\\\\\\\n                        .text_color(rgb(0xffffff))\\\\\\\\n                        .child(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\".clone()),\\\\\\\\n                ),\\\\\\\\n            )\\\\\\\\n            // Waveform\\\\\\\\n            .child(waveform)\\\\\\\\n            // Bottom: transport + params\\\\\\\\n            .child(\\\\\\\\n                div()\\\\\\\\n                    .flex()\\\\\\\\n                    .flex_row()\\\\\\\\n                    .gap(px(24.0))\\\\\\\\n                    .flex_1()\\\\\\\\n                    .min_h(px(0.0))\\\\\\\\n                    // Transport controls\\\\\\\\n                    .child(\\\\\\\\n                        div()\\\\\\\\n                            .flex()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"            .flex_col()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            .bg(rgb(0x0f0f1a))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"            .text_color(rgb(0xffffff))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"            .p(px(16.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"            .gap(px(16.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Header: plugin name\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"                div().flex().flex_row().items_center().gap(px(8.0)).child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"                    div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_size(px(20.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .size_full()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .bg(rgb(0x0000FF))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .text_color(rgb(0xffffff))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .child(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\".clone()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"                ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Waveform\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(waveform)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Bottom: transport + params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"            .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"                div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex_row()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .gap(px(24.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .flex_1()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .min_h(px(0.0))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Transport controls\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .child(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"                        div()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .flex()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209}]},\\\\\\\"score\\\\\\\":0.0726109966635704},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/host.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":67,\\\\\\\"column\\\\\\\":7}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\\n#![allow(dead_code)]\\\\\\\\n\\\\\\\\nuse std::ffi::{CStr, CString};\\\\\\\\nuse std::path::Path;\\\\\\\\n\\\\\\\\nuse anyhow::{anyhow, bail, Result};\\\\\\\\n\\\\\\\\nuse crate::ffi;\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Param info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of a plugin parameter.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct ParamInfo {\\\\\\\\n    pub id: u32,\\\\\\\\n    pub name: String,\\\\\\\\n    pub module: String,\\\\\\\\n    pub min_value: f64,\\\\\\\\n    pub max_value: f64,\\\\\\\\n    pub default_value: f64,\\\\\\\\n    pub flags: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Plugin info (safe Rust representation)\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe Rust representation of plugin metadata.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub id: String,\\\\\\\\n    pub name: String,\\\\\\\\n    pub vendor: String,\\\\\\\\n    pub version: String,\\\\\\\\n    pub description: String,\\\\\\\\n    pub input_channels: u32,\\\\\\\\n    pub output_channels: u32,\\\\\\\\n    pub latency_samples: u32,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// PluginHost\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\n/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\\n///\\\\\\\\n/// All methods must be called from the main thread unless otherwise noted.\\\\\\\\n/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\\npub struct PluginHost {\\\\\\\\n    ptr: *mut ffi::ZphPlugin,\\\\\\\\n}\\\\\\\\n\\\\\\\\n// The Zig host library is designed for single-threaded main-thread use.\\\\\\\\n// We assert this by not implementing Send/Sync.\\\\\\\\n\\\\\\\\nimpl Drop for PluginHost {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if !self.ptr.is_null() {\\\\\\\\n            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginHost {\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Safe Rust wrapper around the z_plug_host C API.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"#![allow(dead_code)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::{CStr, CString};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::path::Path;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use anyhow::{anyhow, bail, Result};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::ffi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"// Param info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of a plugin parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct ParamInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub module: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub min_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub max_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub default_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub flags: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"// Plugin info (safe Rust representation)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe Rust representation of plugin metadata.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub id: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub description: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_channels: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub latency_samples: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"// PluginHost\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"// ---------------------------------------------------------------------------\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Safe wrapper around a loaded CLAP plugin instance.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"/// All methods must be called from the main thread unless otherwise noted.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    ptr: *mut ffi::ZphPlugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"// The Zig host library is designed for single-threaded main-thread use.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"// We assert this by not implementing Send/Sync.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Drop for PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"        if !self.ptr.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe { ffi::zph_destroy(self.ptr) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginHost {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68}]},\\\\\\\"score\\\\\\\":0.06432650238275528},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/transport.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":6,\\\\\\\"column\\\\\\\":74}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\\n//!\\\\\\\\n//! This module is kept for organisational clarity; the actual transport\\\\\\\\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\\n\\\\\\\\n// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Transport controls: rewind and play/stop.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! This module is kept for organisational clarity; the actual transport\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"// (No standalone view needed  transport is rendered inline in app.rs.)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7}]},\\\\\\\"score\\\\\\\":0.06164110079407692},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":151,\\\\\\\"column\\\\\\\":62},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":197,\\\\\\\"column\\\\\\\":62}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n    if data.len() &lt; 44 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let mut pos = 12usize;\\\\\\\\n    let mut fmt_channels: u16 = 0;\\\\\\\\n    let mut fmt_bits: u16 = 0;\\\\\\\\n    let mut fmt_audio_format: u16 = 0;\\\\\\\\n    let mut data_start = 0usize;\\\\\\\\n    let mut data_len = 0usize;\\\\\\\\n\\\\\\\\n    while pos + 8 &lt;= data.len() {\\\\\\\\n        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\\n        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\\n        pos += 8;\\\\\\\\n\\\\\\\\n        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\\n            if chunk_size &gt;= 16 {\\\\\\\\n                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\\n                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\\n                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\\n            }\\\\\\\\n        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\\n            data_start = pos;\\\\\\\\n            data_len = chunk_size;\\\\\\\\n            break;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        pos += chunk_size;\\\\\\\\n        if chunk_size % 2 != 0 {\\\\\\\\n            pos += 1;\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    if data_start == 0 || fmt_channels == 0 {\\\\\\\\n        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\\n    let channels = fmt_channels as usize;\\\\\\\\n\\\\\\\\n    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data.len() &lt; 44 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"WAV file too small\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    if &amp;data[0..4] != b\\\\\\\\\\\\\\\"RIFF\\\\\\\\\\\\\\\" || &amp;data[8..12] != b\\\\\\\\\\\\\\\"WAVE\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Not a valid RIFF/WAVE file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut pos = 12usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_channels: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_bits: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut fmt_audio_format: u16 = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_start = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"    let mut data_len = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"    while pos + 8 &lt;= data.len() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_id = &amp;data[pos..pos + 4];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"        let chunk_size = u32::from_le_bytes(data[pos + 4..pos + 8].try_into()?) as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_id == b\\\\\\\\\\\\\\\"fmt \\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"            if chunk_size &gt;= 16 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_audio_format = u16::from_le_bytes(data[pos..pos + 2].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_channels = u16::from_le_bytes(data[pos + 2..pos + 4].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                fmt_bits = u16::from_le_bytes(data[pos + 14..pos + 16].try_into()?);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if chunk_id == b\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_start = pos;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            data_len = chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"            break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"        pos += chunk_size;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"        if chunk_size % 2 != 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"            pos += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"    if data_start == 0 || fmt_channels == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        anyhow::bail!(\\\\\\\\\\\\\\\"Could not find fmt/data chunks in WAV file\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"    let raw = &amp;data[data_start..data_start.saturating_add(data_len).min(data.len())];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"    let channels = fmt_channels as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198}]},\\\\\\\"score\\\\\\\":0.058692339807748795},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./zloader/src/main.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":195,\\\\\\\"column\\\\\\\":41},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":229,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\\n        (3, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\\n            .collect(),\\\\\\\\n        (1, 16) =&gt; raw\\\\\\\\n            .chunks_exact(2)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 32768.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 24) =&gt; raw\\\\\\\\n            .chunks_exact(3)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\\n                s as f32 / 8388608.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        (1, 32) =&gt; raw\\\\\\\\n            .chunks_exact(4)\\\\\\\\n            .map(|b| {\\\\\\\\n                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\\n                s as f32 / 2147483648.0\\\\\\\\n            })\\\\\\\\n            .collect(),\\\\\\\\n        _ =&gt; anyhow::bail!(\\\\\\\\n            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\\n        ),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    Ok((samples, channels))\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    let samples: Vec&lt;f32&gt; = match (fmt_audio_format, fmt_bits) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"        (3, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| f32::from_le_bytes(b.try_into().unwrap()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 16) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(2)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i16::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 32768.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 24) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(3)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes([b[0], b[1], b[2], 0]) &gt;&gt; 8;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 8388608.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"        (1, 32) =&gt; raw\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"            .chunks_exact(4)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|b| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"                let s = i32::from_le_bytes(b.try_into().unwrap());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"                s as f32 / 2147483648.0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; anyhow::bail!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"            \\\\\\\\\\\\\\\"Unsupported WAV format: audio_format={fmt_audio_format}, bits={fmt_bits}\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"        ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok((samples, channels))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230}]},\\\\\\\"score\\\\\\\":0.05450329929590225}]}\\\"},\\\"capabilityType\\\":15}\",\"3e7decbb-4bbd-47bf-be32-31a1dbc54144\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8dbaeac3-dc6c-41b0-85ac-4b0db58a13ff\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-24T17:13:10.583Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\n## Directory Structure\\\\n\\\\n&#96;&#96;&#96;\\\\nzloader/\\\\n Cargo.toml          # Rust package manifest\\\\n build.rs            # Build script (links Zig libraries)\\\\n src/\\\\n     main.rs         # Entry point, CLI parsing, setup\\\\n     app.rs          # Root GPUI view (ZLoaderApp)\\\\n     waveform.rs     # Waveform rendering component\\\\n     engine.rs       # Audio engine wrapper\\\\n     host.rs         # Plugin host wrapper\\\\n     params.rs       # Parameter UI panel\\\\n     transport.rs    # Transport controls (placeholder)\\\\n     ffi.rs          # FFI bindings to C APIs\\\\n&#96;&#96;&#96;\\\\n\\\\n## Project Overview\\\\n\\\\nzloader is a Rust-based CLAP plugin debug/test tool built with GPUI. It:\\\\n- Loads a CLAP plugin from a &#96;.clap&#96; file\\\\n- Loads a WAV audio file\\\\n- Routes audio through the plugin\\\\n- Displays a waveform visualization\\\\n- Provides parameter controls\\\\n\\\\nDependencies:\\\\n- &#96;gpui&#96; (0.2.2)  UI framework\\\\n- &#96;gpui-component&#96; (0.5.1)  UI components\\\\n- &#96;clap&#96; (4.x)  CLI parsing\\\\n- &#96;anyhow&#96;  Error handling\\\\n\\\\n## Waveform Rendering Architecture\\\\n\\\\nLocation: &#96;/Users/b/code/z-plug/zloader/src/waveform.rs&#96;\\\\n\\\\n### Peak Data Structure\\\\n- &#96;WaveformPeaks&#96;: Pre-computed min/max pairs (one per display column)\\\\n  - &#96;peaks: Vec&lt;(f32, f32)&gt;&#96;  min/max pairs in [-1.0, 1.0]\\\\n  - &#96;total_samples: u64&#96;  total samples for playhead math\\\\n  - Built from raw samples via &#96;from_samples()&#96; (1200 columns default)\\\\n\\\\n### Rendering System\\\\n- &#96;WaveformView&#96;: GPUI view component\\\\n  - Uses GPUI's &#96;canvas()&#96; element for custom drawing\\\\n  - Stores &#96;peaks&#96; and current &#96;position&#96; (u64 samples)\\\\n  - Renders via &#96;draw_waveform()&#96; callback\\\\n\\\\n### Drawing Implementation\\\\n&#96;draw_waveform()&#96; (lines 142-181):\\\\n1. Waveform bars: iterates peak pairs, draws vertical bars\\\\n   - Color: &#96;rgb(0x4a9eff)&#96;\\\\n   - Bar width = &#96;width / num_cols&#96;\\\\n   - Height based on min/max values\\\\n2. Center line: horizontal line at midpoint (&#96;rgb(0x2a4a6e)&#96;)\\\\n3. Playhead: vertical white line (&#96;rgb(0xffffff)&#96;)\\\\n   - Position: &#96;(position / total_samples) * width&#96;\\\\n   - 2px wide, full height\\\\n\\\\n## Audio Playback &amp; Playhead System\\\\n\\\\n### Audio Engine (&#96;engine.rs&#96;)\\\\nWrapper around &#96;z_plug_engine&#96; C API:\\\\n- &#96;AudioEngine&#96;: manages WAV playback via CoreAudio AudioQueue (macOS)\\\\n- Methods: &#96;play()&#96;, &#96;pause()&#96;, &#96;stop()&#96;, &#96;seek(sample_position)&#96;, &#96;position()&#96;  u64 samples\\\\n- Position tracking: &#96;position()&#96; returns current sample position\\\\n\\\\n### Playhead Update Loop (&#96;app.rs&#96; lines 88-130)\\\\n- Timer: 30ms interval (&#96;Duration::from_millis(30)&#96;)\\\\n- Each tick:\\\\n  1. Calls &#96;host.idle()&#96; for plugin callbacks\\\\n  2. Polls &#96;engine.position()&#96; and &#96;engine.is_playing()&#96;\\\\n  3. Updates &#96;waveform.position&#96; and notifies UI\\\\n  4. Updates root app &#96;is_playing&#96; state\\\\n\\\\n### Position Flow\\\\n&#96;&#96;&#96;\\\\nAudio Engine (C)  engine.position()  AppState  WaveformView.position  draw_waveform()\\\\n&#96;&#96;&#96;\\\\n\\\\n## Mouse/Input Handling\\\\n\\\\nCurrent state: no mouse/input handling in the waveform view.\\\\n\\\\nExisting input handling:\\\\n- Transport buttons (&#96;app.rs&#96; lines 220-231): &#96;on_click&#96; listeners for rewind and play/stop\\\\n- Parameter sliders (&#96;params.rs&#96;): GPUI &#96;Slider&#96; components with change events\\\\n\\\\nWaveform view:\\\\n- Uses &#96;canvas()&#96; for rendering only\\\\n- No click handlers or pointer event listeners\\\\n- No interaction code in &#96;WaveformView::render()&#96; or &#96;draw_waveform()&#96;\\\\n\\\\n## Key File Paths\\\\n\\\\n- &#96;/Users/b/code/z-plug/zloader/src/waveform.rs&#96;  Waveform rendering\\\\n- &#96;/Users/b/code/z-plug/zloader/src/app.rs&#96;  Main app, playhead update loop\\\\n- &#96;/Users/b/code/z-plug/zloader/src/engine.rs&#96;  Audio engine wrapper\\\\n- &#96;/Users/b/code/z-plug/zloader/src/main.rs&#96;  Entry point, WAV parsing, peak computation\\\\n- &#96;/Users/b/code/z-plug/zloader/src/host.rs&#96;  Plugin host wrapper\\\\n- &#96;/Users/b/code/z-plug/zloader/src/params.rs&#96;  Parameter UI\\\\n- &#96;/Users/b/code/z-plug/zloader/src/ffi.rs&#96;  FFI bindings\\\\n\\\\n## Architecture Summary\\\\n\\\\n1. Setup (&#96;main.rs&#96;): Loads plugin, loads WAV, computes peaks, creates &#96;AppState&#96;\\\\n2. UI (&#96;app.rs&#96;): &#96;ZLoaderApp&#96; owns state entities, spawns update timer\\\\n3. Playback (&#96;engine.rs&#96;): C API wrapper for audio engine\\\\n4. Visualization (&#96;waveform.rs&#96;): Canvas-based rendering with pre-computed peaks\\\\n5. Update loop: 30ms timer polls position and updates waveform playhead\\\\n\\\\nThe waveform is currently display-only; adding click-to-seek would require mouse event handlers on the canvas element.\\\"}\"},\"status\":\"completed\",\"context\":{\"composers\":[],\"selectedCommits\":[],\"selectedPullRequests\":[],\"selectedImages\":[],\"folderSelections\":[],\"fileSelections\":[],\"selections\":[],\"terminalSelections\":[],\"selectedDocs\":[],\"externalLinks\":[],\"cursorRules\":[],\"cursorCommands\":[],\"gitPRDiffSelections\":[],\"subagentSelections\":[],\"browserSelections\":[],\"mentions\":{\"composers\":{},\"selectedCommits\":{},\"selectedPullRequests\":{},\"gitDiff\":[],\"gitDiffFromBranchToMain\":[],\"selectedImages\":{},\"folderSelections\":{},\"fileSelections\":{},\"terminalFiles\":{},\"selections\":{},\"terminalSelections\":{},\"selectedDocs\":{},\"externalLinks\":{},\"diffHistory\":[],\"cursorRules\":{},\"cursorCommands\":{},\"uiElementSelections\":[],\"consoleLogs\":[],\"ideEditorsState\":[],\"gitPRDiffSelections\":{},\"subagentSelections\":{},\"browserSelections\":{}}},\"generatingBubbleIds\":[],\"isReadingLongFile\":false,\"codeBlockData\":{},\"originalFileStates\":{},\"newlyCreatedFiles\":[],\"newlyCreatedFolders\":[],\"createdAt\":1771952777551,\"hasChangedContext\":false,\"activeTabsShouldBeReactive\":true,\"capabilities\":[{\"type\":30,\"data\":{}},{\"type\":15,\"data\":{\"bubbleDataMap\":\"{}\"}}],\"name\":\"Explore zloader directory structure\",\"isFileListExpanded\":false,\"browserChipManuallyDisabled\":false,\"browserChipManuallyEnabled\":false,\"unifiedMode\":\"agent\",\"forceMode\":\"edit\",\"usageData\":{},\"allAttachedFileCodeChunksUris\":[],\"modelConfig\":{\"modelName\":\"composer-1\",\"maxMode\":false},\"subComposerIds\":[],\"capabilityContexts\":[],\"todos\":[],\"isQueueExpanded\":true,\"hasUnreadMessages\":false,\"gitHubPromptDismissed\":false,\"totalLinesAdded\":0,\"totalLinesRemoved\":0,\"addedFiles\":0,\"removedFiles\":0,\"isDraft\":false,\"isCreatingWorktree\":false,\"isApplyingWorktree\":false,\"isUndoingWorktree\":false,\"applied\":false,\"pendingCreateWorktree\":false,\"isBestOfNSubcomposer\":false,\"isBestOfNParent\":false,\"bestOfNJudgeWinner\":false,\"isSpec\":false,\"isProject\":false,\"isSpecSubagentDone\":false,\"stopHookLoopCount\":0,\"speculativeSummarizationEncryptionKey\":\"PPM5bT6tyAk/7sDZT2mW3EMcspg4Xvtnwr2TCb+vHxs=\",\"isNAL\":true,\"planModeSuggestionUsed\":false,\"debugModeSuggestionUsed\":false,\"conversationState\":\"~\",\"queueItems\":[],\"isAgentic\":true}"
}
```
Result:

```json
{
  "agentId": "ca097c3d-5411-4885-920f-9131d6ef529f"
}
```
Status: **completed**


</details>
</tool-use>

---

Let me read the key files to understand the exact implementation details.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/code/z-plug/zloader/src/waveform.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/code/z-plug/zloader/src/app.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/code/z-plug/zloader/src/engine.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the codebase. Let me check how GPUI handles mouse events to understand what APIs are available for implementing scrubbing.</details></think>

---

Now let me check how GPUI handles mouse events  specifically looking at how existing click handlers work and what mouse event APIs are available.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "on_mouse_down|on_mouse_up|on_mouse_move|on_click|MouseDown|MouseUp|MouseMove",
  "path": "/Users/b/code/z-plug/zloader/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "on_mouse_down|on_mouse_up|on_mouse_move|on_click|MouseDown|MouseUp|MouseMove",
    "path": "/Users/b/code/z-plug/zloader/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "zloader/src/app.rs",
              "matches": [
                {
                  "lineNumber": 220,
                  "content": "                                    .child(Button::new(\"rewind\").label(\"&lt;&lt;\").on_click(cx.listener("
                },
                {
                  "lineNumber": 229,
                  "content": "                                            .on_click(cx.listener(|app, _ev, window, cx| {"
                }
              ]
            }
          ],
          "totalLines": 2,
          "totalMatchedLines": 2
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How does GPUI handle mouse drag events on canvas elements?",
  "includePattern": "/Users/b/code/z-plug/zloader/",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {
            "line": 38,
            "column": 1
          },
          "endPosition": {
            "line": 93,
            "column": 26
          }
        },
        "contents": "impl ZLoaderApp {\n    pub fn new(\n        state: Entity&lt;AppState&gt;,\n        peaks: WaveformPeaks,\n        cx: &amp;mut gpui::Context&lt;Self&gt;,\n    ) -&gt; Self {\n        let plugin_name: SharedString = state\n            .read_with(cx, |s, _| s.plugin_info.name.clone())\n            .into();\n\n        let params = state.read_with(cx, |s, _| s.params.clone());\n\n        // Build the waveform view.\n        let waveform = cx.new(|_cx| WaveformView::new(peaks));\n\n        // Build the params view.\n        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));\n\n        // Subscribe to slider changes and forward to the plugin host.\n        // This runs on the main thread with full access to cx.\n        let state_for_params = state.clone();\n        params_view\n            .read_with(cx, |pv, _| {\n                // Collect slider entities to subscribe to them from the parent cx.\n                pv.sliders\n                    .iter()\n                    .map(|s| (s.info.id, s.slider.clone()))\n                    .collect::&lt;Vec&lt;_&gt;&gt;()\n            })\n            .into_iter()\n            .for_each(|(param_id, slider_entity)| {\n                let state_weak = state_for_params.downgrade();\n                cx.subscribe(\n                    &amp;slider_entity,\n                    move |_this, _slider, event: &amp;SliderEvent, cx| {\n                        let SliderEvent::Change(value) = event;\n                        let v = value.start() as f64;\n                        if let Some(state_entity) = state_weak.upgrade() {\n                            state_entity.read_with(cx, |s, _| {\n                                s.host.set_param_value(param_id, v);\n                            });\n                        }\n                    },\n                )\n                .detach();\n            });\n\n        // Spawn a repeating timer to poll playback position and call idle.\n        let state_weak = state.downgrade();\n        let waveform_weak = waveform.downgrade();\n        cx.spawn(async move |this, cx| {\n            loop {\n                cx.background_executor()\n                    .timer",
        "signatures": {},
        "detailedLines": [
          {
            "text": "impl ZLoaderApp {",
            "lineNumber": 41
          },
          {
            "text": "    pub fn new(",
            "lineNumber": 42
          },
          {
            "text": "        state: Entity&lt;AppState&gt;,",
            "lineNumber": 43
          },
          {
            "text": "        peaks: WaveformPeaks,",
            "lineNumber": 44
          },
          {
            "text": "        cx: &amp;mut gpui::Context&lt;Self&gt;,",
            "lineNumber": 45
          },
          {
            "text": "    ) -&gt; Self {",
            "lineNumber": 46
          },
          {
            "text": "        let plugin_name: SharedString = state",
            "lineNumber": 47
          },
          {
            "text": "            .read_with(cx, |s, _| s.plugin_info.name.clone())",
            "lineNumber": 48
          },
          {
            "text": "            .into();",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "        let params = state.read_with(cx, |s, _| s.params.clone());",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "        // Build the waveform view.",
            "lineNumber": 53
          },
          {
            "text": "        let waveform = cx.new(|_cx| WaveformView::new(peaks));",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "        // Build the params view.",
            "lineNumber": 56
          },
          {
            "text": "        let params_view = cx.new(|cx| ParamsView::new(&amp;params, cx));",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "        // Subscribe to slider changes and forward to the plugin host.",
            "lineNumber": 59
          },
          {
            "text": "        // This runs on the main thread with full access to cx.",
            "lineNumber": 60
          },
          {
            "text": "        let state_for_params = state.clone();",
            "lineNumber": 61
          },
          {
            "text": "        params_view",
            "lineNumber": 62
          },
          {
            "text": "            .read_with(cx, |pv, _| {",
            "lineNumber": 63
          },
          {
            "text": "                // Collect slider entities to subscribe to them from the parent cx.",
            "lineNumber": 64
          },
          {
            "text": "                pv.sliders",
            "lineNumber": 65
          },
          {
            "text": "                    .iter()",
            "lineNumber": 66
          },
          {
            "text": "                    .map(|s| (s.info.id, s.slider.clone()))",
            "lineNumber": 67
          },
          {
            "text": "                    .collect::&lt;Vec&lt;_&gt;&gt;()",
            "lineNumber": 68
          },
          {
            "text": "            })",
            "lineNumber": 69
          },
          {
            "text": "            .into_iter()",
            "lineNumber": 70
          },
          {
            "text": "            .for_each(|(param_id, slider_entity)| {",
            "lineNumber": 71
          },
          {
            "text": "                let state_weak = state_for_params.downgrade();",
            "lineNumber": 72
          },
          {
            "text": "                cx.subscribe(",
            "lineNumber": 73
          },
          {
            "text": "                    &amp;slider_entity,",
            "lineNumber": 74
          },
          {
            "text": "                    move |_this, _slider, event: &amp;SliderEvent, cx| {",
            "lineNumber": 75
          },
          {
            "text": "                        let SliderEvent::Change(value) = event;",
            "lineNumber": 76
          },
          {
            "text": "                        let v = value.start() as f64;",
            "lineNumber": 77
          },
          {
            "text": "                        if let Some(state_entity) = state_weak.upgrade() {",
            "lineNumber": 78
          },
          {
            "text": "                            state_entity.read_with(cx, |s, _| {",
            "lineNumber": 79
          },
          {
            "text": "                                s.host.set_param_value(param_id, v);",
            "lineNumber": 80
          },
          {
            "text": "                            });",
            "lineNumber": 81
          },
          {
            "text": "                        }",
            "lineNumber": 82
          },
          {
            "text": "                    },",
            "lineNumber": 83
          },
          {
            "text": "                )",
            "lineNumber": 84
          },
          {
            "text": "                .detach();",
            "lineNumber": 85
          },
          {
            "text": "            });",
            "lineNumber": 86
          },
          {
            "lineNumber": 87
          },
          {
            "text": "        // Spawn a repeating timer to poll playback position and call idle.",
            "lineNumber": 88
          },
          {
            "text": "        let state_weak = state.downgrade();",
            "lineNumber": 89
          },
          {
            "text": "        let waveform_weak = waveform.downgrade();",
            "lineNumber": 90
          },
          {
            "text": "        cx.spawn(async move |this, cx| {",
            "lineNumber": 91
          },
          {
            "text": "            loop {",
            "lineNumber": 92
          },
          {
            "text": "                cx.background_executor()",
            "lineNumber": 93
          },
          {
            "text": "                    .timer",
            "lineNumber": 94
          }
        ]
      },
      "score": 0.22596250474452972
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/waveform.rs",
        "range": {
          "startPosition": {
            "line": 84
          },
          "endPosition": {
            "line": 143,
            "column": 27
          }
        },
        "contents": "pub struct WaveformView {\n    pub peaks: WaveformPeaks,\n    /// Current playback position in samples (updated by the app timer).\n    pub position: u64,\n}\n\nimpl WaveformView {\n    pub fn new(peaks: WaveformPeaks) -&gt; Self {\n        Self { peaks, position: 0 }\n    }\n}\n\nimpl Render for WaveformView {\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\n        let peaks = self.peaks.clone();\n        let position = self.position;\n\n        div()\n            .w_full()\n            .h(px(120.0))\n            .bg(rgb(0x1a1a2e))\n            .rounded(px(6.0))\n            .overflow_hidden()\n            .child(\n                canvas(\n                    move |_bounds, _window, _cx| {},\n                    move |bounds, _prepaint, window, _cx| {\n                        draw_waveform(window, bounds, &amp;peaks, position);\n                    },\n                )\n                .w_full()\n                .h_full(),\n            )\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Drawing helpers\n// ---------------------------------------------------------------------------\n\nfn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {\n    window.paint_quad(PaintQuad {\n        bounds: Bounds {\n            origin: Point { x: px(x), y: px(y) },\n            size: Size {\n                width: px(w),\n                height: px(h),\n            },\n        },\n        corner_radii: Corners::all(px(0.0)),\n        background: Background::from(color),\n        border_widths: Edges::all(px(0.0)),\n        border_color: gpui::transparent_black(),\n        border_style: BorderStyle::default(),\n    });\n}\n\nfn draw_waveform(\n    window: &amp;mut Window,\n    bounds: Bounds&lt;Pixels&gt;,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "pub struct WaveformView {",
            "lineNumber": 85
          },
          {
            "text": "    pub peaks: WaveformPeaks,",
            "lineNumber": 86
          },
          {
            "text": "    /// Current playback position in samples (updated by the app timer).",
            "lineNumber": 87
          },
          {
            "text": "    pub position: u64,",
            "lineNumber": 88
          },
          {
            "text": "}",
            "lineNumber": 89
          },
          {
            "lineNumber": 90
          },
          {
            "text": "impl WaveformView {",
            "lineNumber": 91
          },
          {
            "text": "    pub fn new(peaks: WaveformPeaks) -&gt; Self {",
            "lineNumber": 92
          },
          {
            "text": "        Self { peaks, position: 0 }",
            "lineNumber": 93
          },
          {
            "text": "    }",
            "lineNumber": 94
          },
          {
            "text": "}",
            "lineNumber": 95
          },
          {
            "lineNumber": 96
          },
          {
            "text": "impl Render for WaveformView {",
            "lineNumber": 97
          },
          {
            "text": "    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {",
            "lineNumber": 98
          },
          {
            "text": "        let peaks = self.peaks.clone();",
            "lineNumber": 99
          },
          {
            "text": "        let position = self.position;",
            "lineNumber": 100
          },
          {
            "lineNumber": 101
          },
          {
            "text": "        div()",
            "lineNumber": 102
          },
          {
            "text": "            .w_full()",
            "lineNumber": 103
          },
          {
            "text": "            .h(px(120.0))",
            "lineNumber": 104
          },
          {
            "text": "            .bg(rgb(0x1a1a2e))",
            "lineNumber": 105
          },
          {
            "text": "            .rounded(px(6.0))",
            "lineNumber": 106
          },
          {
            "text": "            .overflow_hidden()",
            "lineNumber": 107
          },
          {
            "text": "            .child(",
            "lineNumber": 108
          },
          {
            "text": "                canvas(",
            "lineNumber": 109
          },
          {
            "text": "                    move |_bounds, _window, _cx| {},",
            "lineNumber": 110
          },
          {
            "text": "                    move |bounds, _prepaint, window, _cx| {",
            "lineNumber": 111
          },
          {
            "text": "                        draw_waveform(window, bounds, &amp;peaks, position);",
            "lineNumber": 112
          },
          {
            "text": "                    },",
            "lineNumber": 113
          },
          {
            "text": "                )",
            "lineNumber": 114
          },
          {
            "text": "                .w_full()",
            "lineNumber": 115
          },
          {
            "text": "                .h_full(),",
            "lineNumber": 116
          },
          {
            "text": "            )",
            "lineNumber": 117
          },
          {
            "text": "    }",
            "lineNumber": 118
          },
          {
            "text": "}",
            "lineNumber": 119
          },
          {
            "lineNumber": 120
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 121
          },
          {
            "text": "// Drawing helpers",
            "lineNumber": 122
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 123
          },
          {
            "lineNumber": 124
          },
          {
            "text": "fn paint_rect(window: &amp;mut Window, x: f32, y: f32, w: f32, h: f32, color: Hsla) {",
            "lineNumber": 125
          },
          {
            "text": "    window.paint_quad(PaintQuad {",
            "lineNumber": 126
          },
          {
            "text": "        bounds: Bounds {",
            "lineNumber": 127
          },
          {
            "text": "            origin: Point { x: px(x), y: px(y) },",
            "lineNumber": 128
          },
          {
            "text": "            size: Size {",
            "lineNumber": 129
          },
          {
            "text": "                width: px(w),",
            "lineNumber": 130
          },
          {
            "text": "                height: px(h),",
            "lineNumber": 131
          },
          {
            "text": "            },",
            "lineNumber": 132
          },
          {
            "text": "        },",
            "lineNumber": 133
          },
          {
            "text": "        corner_radii: Corners::all(px(0.0)),",
            "lineNumber": 134
          },
          {
            "text": "        background: Background::from(color),",
            "lineNumber": 135
          },
          {
            "text": "        border_widths: Edges::all(px(0.0)),",
            "lineNumber": 136
          },
          {
            "text": "        border_color: gpui::transparent_black(),",
            "lineNumber": 137
          },
          {
            "text": "        border_style: BorderStyle::default(),",
            "lineNumber": 138
          },
          {
            "text": "    });",
            "lineNumber": 139
          },
          {
            "text": "}",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "fn draw_waveform(",
            "lineNumber": 142
          },
          {
            "text": "    window: &amp;mut Window,",
            "lineNumber": 143
          },
          {
            "text": "    bounds: Bounds&lt;Pixels&gt;,",
            "lineNumber": 144
          }
        ]
      },
      "score": 0.20689409971237183
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/params.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 56,
            "column": 13
          }
        },
        "contents": "//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.\n\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\nuse gpui_component::slider::{Slider, SliderState};\n\nuse crate::host::ParamInfo;\n\n// ---------------------------------------------------------------------------\n// Per-parameter slider entry\n// ---------------------------------------------------------------------------\n\n/// Holds the GPUI entity for one parameter's slider state.\npub struct ParamSlider {\n    pub info: ParamInfo,\n    pub slider: Entity&lt;SliderState&gt;,\n}\n\n// ---------------------------------------------------------------------------\n// ParamsView\n// ---------------------------------------------------------------------------\n\n/// Panel of parameter sliders.\npub struct ParamsView {\n    pub sliders: Vec&lt;ParamSlider&gt;,\n}\n\nimpl ParamsView {\n    /// Build the params view from a list of parameter infos.\n    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {\n        let sliders = params\n            .iter()\n            .map(|info| {\n                let min = info.min_value as f32;\n                let max = info.max_value as f32;\n                let default = info.default_value as f32;\n\n                let slider = cx.new(|_cx| {\n                    SliderState::new()\n                        .min(min)\n                        .max(max)\n                        .default_value(default)\n                });\n\n                ParamSlider {\n                    info: info.clone(),\n                    slider,\n                }\n            })\n            .collect();\n\n        Self { sliders }\n    }\n\n}\n\nimpl Render for ParamsView {\n    fn render",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Parameter panel: a scrollable list of labeled sliders for each plugin parameter.",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};",
            "lineNumber": 3
          },
          {
            "text": "use gpui_component::slider::{Slider, SliderState};",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "use crate::host::ParamInfo;",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 8
          },
          {
            "text": "// Per-parameter slider entry",
            "lineNumber": 9
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "/// Holds the GPUI entity for one parameter's slider state.",
            "lineNumber": 12
          },
          {
            "text": "pub struct ParamSlider {",
            "lineNumber": 13
          },
          {
            "text": "    pub info: ParamInfo,",
            "lineNumber": 14
          },
          {
            "text": "    pub slider: Entity&lt;SliderState&gt;,",
            "lineNumber": 15
          },
          {
            "text": "}",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 18
          },
          {
            "text": "// ParamsView",
            "lineNumber": 19
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 20
          },
          {
            "lineNumber": 21
          },
          {
            "text": "/// Panel of parameter sliders.",
            "lineNumber": 22
          },
          {
            "text": "pub struct ParamsView {",
            "lineNumber": 23
          },
          {
            "text": "    pub sliders: Vec&lt;ParamSlider&gt;,",
            "lineNumber": 24
          },
          {
            "text": "}",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "impl ParamsView {",
            "lineNumber": 27
          },
          {
            "text": "    /// Build the params view from a list of parameter infos.",
            "lineNumber": 28
          },
          {
            "text": "    pub fn new(params: &amp;[ParamInfo], cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; Self {",
            "lineNumber": 29
          },
          {
            "text": "        let sliders = params",
            "lineNumber": 30
          },
          {
            "text": "            .iter()",
            "lineNumber": 31
          },
          {
            "text": "            .map(|info| {",
            "lineNumber": 32
          },
          {
            "text": "                let min = info.min_value as f32;",
            "lineNumber": 33
          },
          {
            "text": "                let max = info.max_value as f32;",
            "lineNumber": 34
          },
          {
            "text": "                let default = info.default_value as f32;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "                let slider = cx.new(|_cx| {",
            "lineNumber": 37
          },
          {
            "text": "                    SliderState::new()",
            "lineNumber": 38
          },
          {
            "text": "                        .min(min)",
            "lineNumber": 39
          },
          {
            "text": "                        .max(max)",
            "lineNumber": 40
          },
          {
            "text": "                        .default_value(default)",
            "lineNumber": 41
          },
          {
            "text": "                });",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "                ParamSlider {",
            "lineNumber": 44
          },
          {
            "text": "                    info: info.clone(),",
            "lineNumber": 45
          },
          {
            "text": "                    slider,",
            "lineNumber": 46
          },
          {
            "text": "                }",
            "lineNumber": 47
          },
          {
            "text": "            })",
            "lineNumber": 48
          },
          {
            "text": "            .collect();",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "        Self { sliders }",
            "lineNumber": 51
          },
          {
            "text": "    }",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "}",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "impl Render for ParamsView {",
            "lineNumber": 56
          },
          {
            "text": "    fn render",
            "lineNumber": 57
          }
        ]
      },
      "score": 0.19114536046981812
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {
            "line": 148,
            "column": 20
          },
          "endPosition": {
            "line": 179,
            "column": 24
          }
        },
        "contents": "    }\n\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\n        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());\n        self.state.update(cx, |s, _cx| {\n            if is_playing {\n                s.engine.stop();\n            } else {\n                let _ = s.engine.play();\n            }\n        });\n        self.is_playing = !is_playing;\n        cx.notify();\n    }\n}\n\nimpl Render for ZLoaderApp {\n    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\n        let play_label: SharedString = if self.is_playing {\n            \"Stop\".into()\n        } else {\n            \"Play\".into()\n        };\n        let plugin_name = self.plugin_name.clone();\n        let waveform = self.waveform.clone();\n        let params_view = self.params_view.clone();\n\n        div()\n            .flex()\n            .flex_col()\n            .size_full()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    }",
            "lineNumber": 150
          },
          {
            "lineNumber": 151
          },
          {
            "text": "    fn on_play_stop(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {",
            "lineNumber": 152
          },
          {
            "text": "        let is_playing = self.state.read_with(cx, |s, _| s.engine.is_playing());",
            "lineNumber": 153
          },
          {
            "text": "        self.state.update(cx, |s, _cx| {",
            "lineNumber": 154
          },
          {
            "text": "            if is_playing {",
            "lineNumber": 155
          },
          {
            "text": "                s.engine.stop();",
            "lineNumber": 156
          },
          {
            "text": "            } else {",
            "lineNumber": 157
          },
          {
            "text": "                let _ = s.engine.play();",
            "lineNumber": 158
          },
          {
            "text": "            }",
            "lineNumber": 159
          },
          {
            "text": "        });",
            "lineNumber": 160
          },
          {
            "text": "        self.is_playing = !is_playing;",
            "lineNumber": 161
          },
          {
            "text": "        cx.notify();",
            "lineNumber": 162
          },
          {
            "text": "    }",
            "lineNumber": 163
          },
          {
            "text": "}",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "impl Render for ZLoaderApp {",
            "lineNumber": 166
          },
          {
            "text": "    fn render(&amp;mut self, window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {",
            "lineNumber": 167
          },
          {
            "text": "        let play_label: SharedString = if self.is_playing {",
            "lineNumber": 168
          },
          {
            "text": "            \"Stop\".into()",
            "lineNumber": 169
          },
          {
            "text": "        } else {",
            "lineNumber": 170
          },
          {
            "text": "            \"Play\".into()",
            "lineNumber": 171
          },
          {
            "text": "        };",
            "lineNumber": 172
          },
          {
            "text": "        let plugin_name = self.plugin_name.clone();",
            "lineNumber": 173
          },
          {
            "text": "        let waveform = self.waveform.clone();",
            "lineNumber": 174
          },
          {
            "text": "        let params_view = self.params_view.clone();",
            "lineNumber": 175
          },
          {
            "lineNumber": 176
          },
          {
            "text": "        div()",
            "lineNumber": 177
          },
          {
            "text": "            .flex()",
            "lineNumber": 178
          },
          {
            "text": "            .flex_col()",
            "lineNumber": 179
          },
          {
            "text": "            .size_full()",
            "lineNumber": 180
          }
        ]
      },
      "score": 0.18002890050411224
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 42,
            "column": 32
          }
        },
        "contents": "//! Root GPUI view for zloader.\n//!\n//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,\n//! and drives the periodic idle/position-poll timer.\n\nuse std::time::Duration;\n\nuse gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};\nuse gpui_component::button::{Button, ButtonVariants};\nuse gpui_component::slider::SliderEvent;\n\nuse crate::engine::AudioEngine;\nuse crate::host::{ParamInfo, PluginHost, PluginInfo};\nuse crate::params::ParamsView;\nuse crate::waveform::{WaveformPeaks, WaveformView};\n\n// ---------------------------------------------------------------------------\n// AppState  owns the non-Send FFI resources\n// ---------------------------------------------------------------------------\n\n/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.\npub struct AppState {\n    pub host: PluginHost,\n    pub engine: AudioEngine,\n    pub plugin_info: PluginInfo,\n    pub params: Vec&lt;ParamInfo&gt;,\n}\n\n// ---------------------------------------------------------------------------\n// ZLoaderApp  root view\n// ---------------------------------------------------------------------------\n\npub struct ZLoaderApp {\n    state: Entity&lt;AppState&gt;,\n    waveform: Entity&lt;WaveformView&gt;,\n    params_view: Entity&lt;ParamsView&gt;,\n    is_playing: bool,\n    plugin_name: SharedString,\n}\n\nimpl ZLoaderApp {\n    pub fn new(\n        state: Entity&lt;AppState&gt;,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Root GPUI view for zloader.",
            "lineNumber": 1
          },
          {
            "text": "//!",
            "lineNumber": 2
          },
          {
            "text": "//! &#96;ZLoaderApp&#96; owns the plugin host and audio engine, lays out the UI,",
            "lineNumber": 3
          },
          {
            "text": "//! and drives the periodic idle/position-poll timer.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "use std::time::Duration;",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "use gpui::{div, prelude::*, px, rgb, Entity, IntoElement, SharedString, Window};",
            "lineNumber": 8
          },
          {
            "text": "use gpui_component::button::{Button, ButtonVariants};",
            "lineNumber": 9
          },
          {
            "text": "use gpui_component::slider::SliderEvent;",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "use crate::engine::AudioEngine;",
            "lineNumber": 12
          },
          {
            "text": "use crate::host::{ParamInfo, PluginHost, PluginInfo};",
            "lineNumber": 13
          },
          {
            "text": "use crate::params::ParamsView;",
            "lineNumber": 14
          },
          {
            "text": "use crate::waveform::{WaveformPeaks, WaveformView};",
            "lineNumber": 15
          },
          {
            "lineNumber": 16
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 17
          },
          {
            "text": "// AppState  owns the non-Send FFI resources",
            "lineNumber": 18
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "/// Owns the FFI resources. Kept in a GPUI entity so it lives on the main thread.",
            "lineNumber": 21
          },
          {
            "text": "pub struct AppState {",
            "lineNumber": 22
          },
          {
            "text": "    pub host: PluginHost,",
            "lineNumber": 23
          },
          {
            "text": "    pub engine: AudioEngine,",
            "lineNumber": 24
          },
          {
            "text": "    pub plugin_info: PluginInfo,",
            "lineNumber": 25
          },
          {
            "text": "    pub params: Vec&lt;ParamInfo&gt;,",
            "lineNumber": 26
          },
          {
            "text": "}",
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 29
          },
          {
            "text": "// ZLoaderApp  root view",
            "lineNumber": 30
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "pub struct ZLoaderApp {",
            "lineNumber": 33
          },
          {
            "text": "    state: Entity&lt;AppState&gt;,",
            "lineNumber": 34
          },
          {
            "text": "    waveform: Entity&lt;WaveformView&gt;,",
            "lineNumber": 35
          },
          {
            "text": "    params_view: Entity&lt;ParamsView&gt;,",
            "lineNumber": 36
          },
          {
            "text": "    is_playing: bool,",
            "lineNumber": 37
          },
          {
            "text": "    plugin_name: SharedString,",
            "lineNumber": 38
          },
          {
            "text": "}",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "impl ZLoaderApp {",
            "lineNumber": 41
          },
          {
            "text": "    pub fn new(",
            "lineNumber": 42
          },
          {
            "text": "        state: Entity&lt;AppState&gt;,",
            "lineNumber": 43
          }
        ]
      },
      "score": 0.1747353971004486
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {
            "line": 89,
            "column": 49
          },
          "endPosition": {
            "line": 151,
            "column": 52
          }
        },
        "contents": "        cx.spawn(async move |this, cx| {\n            loop {\n                cx.background_executor()\n                    .timer(Duration::from_millis(30))\n                    .await;\n\n                let should_stop = cx.update(|cx| {\n                    let Some(state_entity) = state_weak.upgrade() else {\n                        return true;\n                    };\n                    let Some(waveform_entity) = waveform_weak.upgrade() else {\n                        return true;\n                    };\n\n                    // Poll position and call idle.\n                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {\n                        s.host.idle();\n                        (s.engine.position(), s.engine.is_playing())\n                    });\n\n                    // Update waveform playhead.\n                    waveform_entity.update(cx, |w, cx| {\n                        w.position = position;\n                        cx.notify();\n                    });\n\n                    // Update root view playing state.\n                    this.update(cx, |app, cx| {\n                        app.is_playing = is_playing;\n                        cx.notify();\n                    })\n                    .is_err()\n                });\n\n                if should_stop.unwrap_or(true) {\n                    break;\n                }\n            }\n        })\n        .detach();\n\n        Self {\n            state,\n            waveform,\n            params_view,\n            is_playing: false,\n            plugin_name,\n        }\n    }\n\n    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {\n        self.state.update(cx, |s, _cx| {\n            s.engine.seek(0);\n        });\n        self.waveform.update(cx, |w, cx| {\n            w.position = 0;\n            cx.notify();\n        });\n        cx.notify();\n    }\n\n    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        cx.spawn(async move |this, cx| {",
            "lineNumber": 91
          },
          {
            "text": "            loop {",
            "lineNumber": 92
          },
          {
            "text": "                cx.background_executor()",
            "lineNumber": 93
          },
          {
            "text": "                    .timer(Duration::from_millis(30))",
            "lineNumber": 94
          },
          {
            "text": "                    .await;",
            "lineNumber": 95
          },
          {
            "lineNumber": 96
          },
          {
            "text": "                let should_stop = cx.update(|cx| {",
            "lineNumber": 97
          },
          {
            "text": "                    let Some(state_entity) = state_weak.upgrade() else {",
            "lineNumber": 98
          },
          {
            "text": "                        return true;",
            "lineNumber": 99
          },
          {
            "text": "                    };",
            "lineNumber": 100
          },
          {
            "text": "                    let Some(waveform_entity) = waveform_weak.upgrade() else {",
            "lineNumber": 101
          },
          {
            "text": "                        return true;",
            "lineNumber": 102
          },
          {
            "text": "                    };",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "                    // Poll position and call idle.",
            "lineNumber": 105
          },
          {
            "text": "                    let (position, is_playing) = state_entity.update(cx, |s, _cx| {",
            "lineNumber": 106
          },
          {
            "text": "                        s.host.idle();",
            "lineNumber": 107
          },
          {
            "text": "                        (s.engine.position(), s.engine.is_playing())",
            "lineNumber": 108
          },
          {
            "text": "                    });",
            "lineNumber": 109
          },
          {
            "lineNumber": 110
          },
          {
            "text": "                    // Update waveform playhead.",
            "lineNumber": 111
          },
          {
            "text": "                    waveform_entity.update(cx, |w, cx| {",
            "lineNumber": 112
          },
          {
            "text": "                        w.position = position;",
            "lineNumber": 113
          },
          {
            "text": "                        cx.notify();",
            "lineNumber": 114
          },
          {
            "text": "                    });",
            "lineNumber": 115
          },
          {
            "lineNumber": 116
          },
          {
            "text": "                    // Update root view playing state.",
            "lineNumber": 117
          },
          {
            "text": "                    this.update(cx, |app, cx| {",
            "lineNumber": 118
          },
          {
            "text": "                        app.is_playing = is_playing;",
            "lineNumber": 119
          },
          {
            "text": "                        cx.notify();",
            "lineNumber": 120
          },
          {
            "text": "                    })",
            "lineNumber": 121
          },
          {
            "text": "                    .is_err()",
            "lineNumber": 122
          },
          {
            "text": "                });",
            "lineNumber": 123
          },
          {
            "lineNumber": 124
          },
          {
            "text": "                if should_stop.unwrap_or(true) {",
            "lineNumber": 125
          },
          {
            "text": "                    break;",
            "lineNumber": 126
          },
          {
            "text": "                }",
            "lineNumber": 127
          },
          {
            "text": "            }",
            "lineNumber": 128
          },
          {
            "text": "        })",
            "lineNumber": 129
          },
          {
            "text": "        .detach();",
            "lineNumber": 130
          },
          {
            "lineNumber": 131
          },
          {
            "text": "        Self {",
            "lineNumber": 132
          },
          {
            "text": "            state,",
            "lineNumber": 133
          },
          {
            "text": "            waveform,",
            "lineNumber": 134
          },
          {
            "text": "            params_view,",
            "lineNumber": 135
          },
          {
            "text": "            is_playing: false,",
            "lineNumber": 136
          },
          {
            "text": "            plugin_name,",
            "lineNumber": 137
          },
          {
            "text": "        }",
            "lineNumber": 138
          },
          {
            "text": "    }",
            "lineNumber": 139
          },
          {
            "lineNumber": 140
          },
          {
            "text": "    fn on_rewind(&amp;mut self, _window: &amp;mut Window, cx: &amp;mut gpui::Context&lt;Self&gt;) {",
            "lineNumber": 141
          },
          {
            "text": "        self.state.update(cx, |s, _cx| {",
            "lineNumber": 142
          },
          {
            "text": "            s.engine.seek(0);",
            "lineNumber": 143
          },
          {
            "text": "        });",
            "lineNumber": 144
          },
          {
            "text": "        self.waveform.update(cx, |w, cx| {",
            "lineNumber": 145
          },
          {
            "text": "            w.position = 0;",
            "lineNumber": 146
          },
          {
            "text": "            cx.notify();",
            "lineNumber": 147
          },
          {
            "text": "        });",
            "lineNumber": 148
          },
          {
            "text": "        cx.notify();",
            "lineNumber": 149
          },
          {
            "text": "    }",
            "lineNumber": 150
          },
          {
            "lineNumber": 151
          },
          {
            "text": "    fn on_play_stop(&amp;mut self, _window: &amp;mut Window,",
            "lineNumber": 152
          }
        ]
      },
      "score": 0.17401725053787231
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/waveform.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 24,
            "column": 18
          }
        },
        "contents": "//! Waveform display using GPUI's &#96;canvas()&#96; element.\n//!\n//! Renders a pre-computed peak overview of the loaded audio file, with a\n//! playhead line indicating the current playback position.\n\nuse gpui::{\n    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,\n    IntoElement, PaintQuad, Pixels, Point, Size, Window,\n};\n\n// ---------------------------------------------------------------------------\n// Peak data\n// ---------------------------------------------------------------------------\n\n/// Pre-computed min/max peak pairs for waveform rendering.\n/// One entry per display column (pixel-width bucket).\n#[derive(Clone)]\npub struct WaveformPeaks {\n    /// (min, max) pairs in [-1.0, 1.0], one per display column.\n    pub peaks: Vec&lt;(f32, f32)&gt;,\n    /// Total number of samples in the source file (for playhead math).\n    pub total_samples: u64,\n}\n\nimpl WaveformPeaks",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Waveform display using GPUI's &#96;canvas()&#96; element.",
            "lineNumber": 1
          },
          {
            "text": "//!",
            "lineNumber": 2
          },
          {
            "text": "//! Renders a pre-computed peak overview of the loaded audio file, with a",
            "lineNumber": 3
          },
          {
            "text": "//! playhead line indicating the current playback position.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "use gpui::{",
            "lineNumber": 6
          },
          {
            "text": "    canvas, div, prelude::*, px, rgb, Background, BorderStyle, Bounds, Corners, Edges, Hsla,",
            "lineNumber": 7
          },
          {
            "text": "    IntoElement, PaintQuad, Pixels, Point, Size, Window,",
            "lineNumber": 8
          },
          {
            "text": "};",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 11
          },
          {
            "text": "// Peak data",
            "lineNumber": 12
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "/// Pre-computed min/max peak pairs for waveform rendering.",
            "lineNumber": 15
          },
          {
            "text": "/// One entry per display column (pixel-width bucket).",
            "lineNumber": 16
          },
          {
            "text": "#[derive(Clone)]",
            "lineNumber": 17
          },
          {
            "text": "pub struct WaveformPeaks {",
            "lineNumber": 18
          },
          {
            "text": "    /// (min, max) pairs in [-1.0, 1.0], one per display column.",
            "lineNumber": 19
          },
          {
            "text": "    pub peaks: Vec&lt;(f32, f32)&gt;,",
            "lineNumber": 20
          },
          {
            "text": "    /// Total number of samples in the source file (for playhead math).",
            "lineNumber": 21
          },
          {
            "text": "    pub total_samples: u64,",
            "lineNumber": 22
          },
          {
            "text": "}",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "impl WaveformPeaks",
            "lineNumber": 25
          }
        ]
      },
      "score": 0.16985739767551422
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/main.rs",
        "range": {
          "startPosition": {
            "line": 41,
            "column": 78
          },
          "endPosition": {
            "line": 103,
            "column": 29
          }
        },
        "contents": "fn main() -&gt; Result&lt;()&gt; {\n    let args = Args::parse();\n\n    if !args.plugin_path.exists() {\n        anyhow::bail!(\"Plugin not found: {:?}\", args.plugin_path);\n    }\n    if !args.audio_file.exists() {\n        anyhow::bail!(\"Audio file not found: {:?}\", args.audio_file);\n    }\n\n    let plugin_path = args.plugin_path.clone();\n    let audio_path = args.audio_file.clone();\n\n    Application::new().run(move |cx: &amp;mut App| {\n        // Load embedded Inter Variable font so text renders on all platforms.\n        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize\n        // glyphs via GPUI's sprite atlas on some macOS configurations.\n\n        // Initialize gpui-component theming and force dark mode to match our dark UI.\n        gpui_component::init(cx);\n\n        // Load plugin and audio on the main thread (FFI is not Send).\n        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {\n            Ok(v) =&gt; v,\n            Err(e) =&gt; {\n                eprintln!(\"Error: {e:#}\");\n                cx.quit();\n                return;\n            }\n        };\n\n        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);\n\n        cx.open_window(\n            WindowOptions {\n                window_bounds: Some(WindowBounds::Windowed(bounds)),\n                titlebar: Some(gpui::TitlebarOptions {\n                    title: Some(\"zloader\".into()),\n                    ..Default::default()\n                }),\n                ..Default::default()\n            },\n            move |window, cx| {\n                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));\n                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))\n            },\n        )\n        .expect(\"failed to open window\");\n\n        cx.activate(true);\n    });\n\n    Ok(())\n}\n\n// ---------------------------------------------------------------------------\n// Setup: load plugin + audio, build peak data\n// ---------------------------------------------------------------------------\n\nconst SAMPLE_RATE: f64 = 44100.0;\nconst BUFFER_SIZE: u32 = 512;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "fn main() -&gt; Result&lt;()&gt; {",
            "lineNumber": 44
          },
          {
            "text": "    let args = Args::parse();",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "    if !args.plugin_path.exists() {",
            "lineNumber": 47
          },
          {
            "text": "        anyhow::bail!(\"Plugin not found: {:?}\", args.plugin_path);",
            "lineNumber": 48
          },
          {
            "text": "    }",
            "lineNumber": 49
          },
          {
            "text": "    if !args.audio_file.exists() {",
            "lineNumber": 50
          },
          {
            "text": "        anyhow::bail!(\"Audio file not found: {:?}\", args.audio_file);",
            "lineNumber": 51
          },
          {
            "text": "    }",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "    let plugin_path = args.plugin_path.clone();",
            "lineNumber": 54
          },
          {
            "text": "    let audio_path = args.audio_file.clone();",
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "    Application::new().run(move |cx: &amp;mut App| {",
            "lineNumber": 57
          },
          {
            "text": "        // Load embedded Inter Variable font so text renders on all platforms.",
            "lineNumber": 58
          },
          {
            "text": "        // The system font (.SystemUIFont / .AppleSystemUIFont) fails to rasterize",
            "lineNumber": 59
          },
          {
            "text": "        // glyphs via GPUI's sprite atlas on some macOS configurations.",
            "lineNumber": 60
          },
          {
            "lineNumber": 61
          },
          {
            "text": "        // Initialize gpui-component theming and force dark mode to match our dark UI.",
            "lineNumber": 62
          },
          {
            "text": "        gpui_component::init(cx);",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "        // Load plugin and audio on the main thread (FFI is not Send).",
            "lineNumber": 65
          },
          {
            "text": "        let (state_entity, peaks) = match setup(cx, &amp;plugin_path, &amp;audio_path) {",
            "lineNumber": 66
          },
          {
            "text": "            Ok(v) =&gt; v,",
            "lineNumber": 67
          },
          {
            "text": "            Err(e) =&gt; {",
            "lineNumber": 68
          },
          {
            "text": "                eprintln!(\"Error: {e:#}\");",
            "lineNumber": 69
          },
          {
            "text": "                cx.quit();",
            "lineNumber": 70
          },
          {
            "text": "                return;",
            "lineNumber": 71
          },
          {
            "text": "            }",
            "lineNumber": 72
          },
          {
            "text": "        };",
            "lineNumber": 73
          },
          {
            "lineNumber": 74
          },
          {
            "text": "        let bounds = Bounds::centered(None, size(px(900.0), px(600.0)), cx);",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "        cx.open_window(",
            "lineNumber": 77
          },
          {
            "text": "            WindowOptions {",
            "lineNumber": 78
          },
          {
            "text": "                window_bounds: Some(WindowBounds::Windowed(bounds)),",
            "lineNumber": 79
          },
          {
            "text": "                titlebar: Some(gpui::TitlebarOptions {",
            "lineNumber": 80
          },
          {
            "text": "                    title: Some(\"zloader\".into()),",
            "lineNumber": 81
          },
          {
            "text": "                    ..Default::default()",
            "lineNumber": 82
          },
          {
            "text": "                }),",
            "lineNumber": 83
          },
          {
            "text": "                ..Default::default()",
            "lineNumber": 84
          },
          {
            "text": "            },",
            "lineNumber": 85
          },
          {
            "text": "            move |window, cx| {",
            "lineNumber": 86
          },
          {
            "text": "                let app_view = cx.new(|cx| ZLoaderApp::new(state_entity, peaks, cx));",
            "lineNumber": 87
          },
          {
            "text": "                cx.new(|cx| Root::new(gpui::AnyView::from(app_view), window, cx))",
            "lineNumber": 88
          },
          {
            "text": "            },",
            "lineNumber": 89
          },
          {
            "text": "        )",
            "lineNumber": 90
          },
          {
            "text": "        .expect(\"failed to open window\");",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "        cx.activate(true);",
            "lineNumber": 93
          },
          {
            "text": "    });",
            "lineNumber": 94
          },
          {
            "lineNumber": 95
          },
          {
            "text": "    Ok(())",
            "lineNumber": 96
          },
          {
            "text": "}",
            "lineNumber": 97
          },
          {
            "lineNumber": 98
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 99
          },
          {
            "text": "// Setup: load plugin + audio, build peak data",
            "lineNumber": 100
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "const SAMPLE_RATE: f64 = 44100.0;",
            "lineNumber": 103
          },
          {
            "text": "const BUFFER_SIZE: u32 = 512;",
            "lineNumber": 104
          }
        ]
      },
      "score": 0.16074010729789734
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/params.rs",
        "range": {
          "startPosition": {
            "line": 50,
            "column": 24
          },
          "endPosition": {
            "line": 86,
            "column": 1
          }
        },
        "contents": "    }\n\n}\n\nimpl Render for ParamsView {\n    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {\n        let mut rows = div()\n            .flex()\n            .flex_col()\n            .gap(px(12.0))\n            .w_full()\n            .overflow_hidden();\n\n        for entry in &amp;self.sliders {\n            let name: SharedString = entry.info.name.clone().into();\n            let slider_entity = entry.slider.clone();\n\n            let row = div()\n                .flex()\n                .flex_col()\n                .gap(px(4.0))\n                .w_full()\n                .child(\n                    div()\n                        .text_sm()\n                        .text_color(rgb(0xcccccc))\n                        .child(name),\n                )\n                .child(Slider::new(&amp;slider_entity));\n\n            rows = rows.child(row);\n        }\n\n        rows\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    }",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "}",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "impl Render for ParamsView {",
            "lineNumber": 56
          },
          {
            "text": "    fn render(&amp;mut self, _window: &amp;mut Window, _cx: &amp;mut gpui::Context&lt;Self&gt;) -&gt; impl IntoElement {",
            "lineNumber": 57
          },
          {
            "text": "        let mut rows = div()",
            "lineNumber": 58
          },
          {
            "text": "            .flex()",
            "lineNumber": 59
          },
          {
            "text": "            .flex_col()",
            "lineNumber": 60
          },
          {
            "text": "            .gap(px(12.0))",
            "lineNumber": 61
          },
          {
            "text": "            .w_full()",
            "lineNumber": 62
          },
          {
            "text": "            .overflow_hidden();",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "        for entry in &amp;self.sliders {",
            "lineNumber": 65
          },
          {
            "text": "            let name: SharedString = entry.info.name.clone().into();",
            "lineNumber": 66
          },
          {
            "text": "            let slider_entity = entry.slider.clone();",
            "lineNumber": 67
          },
          {
            "lineNumber": 68
          },
          {
            "text": "            let row = div()",
            "lineNumber": 69
          },
          {
            "text": "                .flex()",
            "lineNumber": 70
          },
          {
            "text": "                .flex_col()",
            "lineNumber": 71
          },
          {
            "text": "                .gap(px(4.0))",
            "lineNumber": 72
          },
          {
            "text": "                .w_full()",
            "lineNumber": 73
          },
          {
            "text": "                .child(",
            "lineNumber": 74
          },
          {
            "text": "                    div()",
            "lineNumber": 75
          },
          {
            "text": "                        .text_sm()",
            "lineNumber": 76
          },
          {
            "text": "                        .text_color(rgb(0xcccccc))",
            "lineNumber": 77
          },
          {
            "text": "                        .child(name),",
            "lineNumber": 78
          },
          {
            "text": "                )",
            "lineNumber": 79
          },
          {
            "text": "                .child(Slider::new(&amp;slider_entity));",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "            rows = rows.child(row);",
            "lineNumber": 82
          },
          {
            "text": "        }",
            "lineNumber": 83
          },
          {
            "lineNumber": 84
          },
          {
            "text": "        rows",
            "lineNumber": 85
          },
          {
            "text": "    }",
            "lineNumber": 86
          },
          {
            "text": "}",
            "lineNumber": 87
          }
        ]
      },
      "score": 0.1214185431599617
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/waveform.rs",
        "range": {
          "startPosition": {
            "line": 139,
            "column": 1
          },
          "endPosition": {
            "line": 180,
            "column": 1
          }
        },
        "contents": "fn draw_waveform(\n    window: &amp;mut Window,\n    bounds: Bounds&lt;Pixels&gt;,\n    peaks: &amp;WaveformPeaks,\n    position: u64,\n) {\n    let width = f32::from(bounds.size.width);\n    let height = f32::from(bounds.size.height);\n    let origin_x = f32::from(bounds.origin.x);\n    let origin_y = f32::from(bounds.origin.y);\n    let mid_y = origin_y + height / 2.0;\n    let half_h = height / 2.0 * 0.9;\n\n    let num_cols = peaks.peaks.len().max(1);\n    let waveform_color: Hsla = rgb(0x4a9eff).into();\n    let center_color: Hsla = rgb(0x2a4a6e).into();\n    let playhead_color: Hsla = rgb(0xffffff).into();\n\n    // Draw waveform bars.\n    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {\n        let x = origin_x + (i as f32 / num_cols as f32) * width;\n        let bar_width = (width / num_cols as f32).max(1.0);\n\n        let top = mid_y - max_val.abs().min(1.0) * half_h;\n        let bottom = mid_y + min_val.abs().min(1.0) * half_h;\n        let bar_height = (bottom - top).max(1.0);\n\n        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);\n    }\n\n    // Draw center line.\n    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);\n\n    // Draw playhead.\n    if peaks.total_samples &gt; 0 {\n        let progress = position as f32 / peaks.total_samples as f32;\n        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;\n        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);\n    }\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "fn draw_waveform(",
            "lineNumber": 142
          },
          {
            "text": "    window: &amp;mut Window,",
            "lineNumber": 143
          },
          {
            "text": "    bounds: Bounds&lt;Pixels&gt;,",
            "lineNumber": 144
          },
          {
            "text": "    peaks: &amp;WaveformPeaks,",
            "lineNumber": 145
          },
          {
            "text": "    position: u64,",
            "lineNumber": 146
          },
          {
            "text": ") {",
            "lineNumber": 147
          },
          {
            "text": "    let width = f32::from(bounds.size.width);",
            "lineNumber": 148
          },
          {
            "text": "    let height = f32::from(bounds.size.height);",
            "lineNumber": 149
          },
          {
            "text": "    let origin_x = f32::from(bounds.origin.x);",
            "lineNumber": 150
          },
          {
            "text": "    let origin_y = f32::from(bounds.origin.y);",
            "lineNumber": 151
          },
          {
            "text": "    let mid_y = origin_y + height / 2.0;",
            "lineNumber": 152
          },
          {
            "text": "    let half_h = height / 2.0 * 0.9;",
            "lineNumber": 153
          },
          {
            "lineNumber": 154
          },
          {
            "text": "    let num_cols = peaks.peaks.len().max(1);",
            "lineNumber": 155
          },
          {
            "text": "    let waveform_color: Hsla = rgb(0x4a9eff).into();",
            "lineNumber": 156
          },
          {
            "text": "    let center_color: Hsla = rgb(0x2a4a6e).into();",
            "lineNumber": 157
          },
          {
            "text": "    let playhead_color: Hsla = rgb(0xffffff).into();",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "    // Draw waveform bars.",
            "lineNumber": 160
          },
          {
            "text": "    for (i, &amp;(min_val, max_val)) in peaks.peaks.iter().enumerate() {",
            "lineNumber": 161
          },
          {
            "text": "        let x = origin_x + (i as f32 / num_cols as f32) * width;",
            "lineNumber": 162
          },
          {
            "text": "        let bar_width = (width / num_cols as f32).max(1.0);",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "        let top = mid_y - max_val.abs().min(1.0) * half_h;",
            "lineNumber": 165
          },
          {
            "text": "        let bottom = mid_y + min_val.abs().min(1.0) * half_h;",
            "lineNumber": 166
          },
          {
            "text": "        let bar_height = (bottom - top).max(1.0);",
            "lineNumber": 167
          },
          {
            "lineNumber": 168
          },
          {
            "text": "        paint_rect(window, x, top, bar_width - 0.5, bar_height, waveform_color);",
            "lineNumber": 169
          },
          {
            "text": "    }",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "    // Draw center line.",
            "lineNumber": 172
          },
          {
            "text": "    paint_rect(window, origin_x, mid_y - 0.5, width, 1.0, center_color);",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "    // Draw playhead.",
            "lineNumber": 175
          },
          {
            "text": "    if peaks.total_samples &gt; 0 {",
            "lineNumber": 176
          },
          {
            "text": "        let progress = position as f32 / peaks.total_samples as f32;",
            "lineNumber": 177
          },
          {
            "text": "        let playhead_x = origin_x + progress.clamp(0.0, 1.0) * width;",
            "lineNumber": 178
          },
          {
            "text": "        paint_rect(window, playhead_x, origin_y, 2.0, height, playhead_color);",
            "lineNumber": 179
          },
          {
            "text": "    }",
            "lineNumber": 180
          },
          {
            "text": "}",
            "lineNumber": 181
          }
        ]
      },
      "score": 0.11533720046281815
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/Cargo.toml",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 11
          }
        },
        "contents": "[package]\nname = \"zloader\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ngpui = \"0.2.2\"\ngpui-component = \"0.5.1\"\nsmallvec = \"1\"\nclap = { version = \"4\", features = [\"derive\"] }\nanyhow = \"1\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "[package]",
            "lineNumber": 1
          },
          {
            "text": "name = \"zloader\"",
            "lineNumber": 2
          },
          {
            "text": "version = \"0.1.0\"",
            "lineNumber": 3
          },
          {
            "text": "edition = \"2021\"",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "[dependencies]",
            "lineNumber": 6
          },
          {
            "text": "gpui = \"0.2.2\"",
            "lineNumber": 7
          },
          {
            "text": "gpui-component = \"0.5.1\"",
            "lineNumber": 8
          },
          {
            "text": "smallvec = \"1\"",
            "lineNumber": 9
          },
          {
            "text": "clap = { version = \"4\", features = [\"derive\"] }",
            "lineNumber": 10
          },
          {
            "text": "anyhow = \"1\"",
            "lineNumber": 11
          }
        ]
      },
      "score": 0.10901589691638947
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {
            "line": 205,
            "column": 41
          },
          "endPosition": {
            "line": 237,
            "column": 35
          }
        },
        "contents": "                    .child(\n                        div()\n                            .flex()\n                            .flex_col()\n                            .gap(px(8.0))\n                            .w(px(120.0))\n                            .flex_shrink_0()\n                            .child(div().text_sm().text_color(rgb(0x888888)).child(\"Transport\"))\n                            .child(\n                                div()\n                                    .flex()\n                                    .flex_row()\n                                    .gap(px(8.0))\n                                    .child(Button::new(\"rewind\").label(\"&lt;&lt;\").on_click(cx.listener(\n                                        |app, _ev, window, cx| {\n                                            app.on_rewind(window, cx);\n                                        },\n                                    )))\n                                    .child(\n                                        Button::new(\"play_stop\")\n                                            .primary()\n                                            .label(play_label)\n                                            .on_click(cx.listener(|app, _ev, window, cx| {\n                                                app.on_play_stop(window, cx);\n                                            })),\n                                    ),\n                            ),\n                    )\n                    // Parameter panel\n                    .child(\n                        div()\n                            .flex()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "                    .child(",
            "lineNumber": 207
          },
          {
            "text": "                        div()",
            "lineNumber": 208
          },
          {
            "text": "                            .flex()",
            "lineNumber": 209
          },
          {
            "text": "                            .flex_col()",
            "lineNumber": 210
          },
          {
            "text": "                            .gap(px(8.0))",
            "lineNumber": 211
          },
          {
            "text": "                            .w(px(120.0))",
            "lineNumber": 212
          },
          {
            "text": "                            .flex_shrink_0()",
            "lineNumber": 213
          },
          {
            "text": "                            .child(div().text_sm().text_color(rgb(0x888888)).child(\"Transport\"))",
            "lineNumber": 214
          },
          {
            "text": "                            .child(",
            "lineNumber": 215
          },
          {
            "text": "                                div()",
            "lineNumber": 216
          },
          {
            "text": "                                    .flex()",
            "lineNumber": 217
          },
          {
            "text": "                                    .flex_row()",
            "lineNumber": 218
          },
          {
            "text": "                                    .gap(px(8.0))",
            "lineNumber": 219
          },
          {
            "text": "                                    .child(Button::new(\"rewind\").label(\"&lt;&lt;\").on_click(cx.listener(",
            "lineNumber": 220
          },
          {
            "text": "                                        |app, _ev, window, cx| {",
            "lineNumber": 221
          },
          {
            "text": "                                            app.on_rewind(window, cx);",
            "lineNumber": 222
          },
          {
            "text": "                                        },",
            "lineNumber": 223
          },
          {
            "text": "                                    )))",
            "lineNumber": 224
          },
          {
            "text": "                                    .child(",
            "lineNumber": 225
          },
          {
            "text": "                                        Button::new(\"play_stop\")",
            "lineNumber": 226
          },
          {
            "text": "                                            .primary()",
            "lineNumber": 227
          },
          {
            "text": "                                            .label(play_label)",
            "lineNumber": 228
          },
          {
            "text": "                                            .on_click(cx.listener(|app, _ev, window, cx| {",
            "lineNumber": 229
          },
          {
            "text": "                                                app.on_play_stop(window, cx);",
            "lineNumber": 230
          },
          {
            "text": "                                            })),",
            "lineNumber": 231
          },
          {
            "text": "                                    ),",
            "lineNumber": 232
          },
          {
            "text": "                            ),",
            "lineNumber": 233
          },
          {
            "text": "                    )",
            "lineNumber": 234
          },
          {
            "text": "                    // Parameter panel",
            "lineNumber": 235
          },
          {
            "text": "                    .child(",
            "lineNumber": 236
          },
          {
            "text": "                        div()",
            "lineNumber": 237
          },
          {
            "text": "                            .flex()",
            "lineNumber": 238
          }
        ]
      },
      "score": 0.10323780030012131
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/main.rs",
        "range": {
          "startPosition": {
            "line": 99,
            "column": 46
          },
          "endPosition": {
            "line": 154,
            "column": 5
          }
        },
        "contents": "// ---------------------------------------------------------------------------\n\nconst SAMPLE_RATE: f64 = 44100.0;\nconst BUFFER_SIZE: u32 = 512;\n/// Number of waveform display columns (pre-computed peak resolution).\nconst WAVEFORM_COLUMNS: usize = 1200;\n\nfn setup(\n    cx: &amp;mut App,\n    plugin_path: &amp;PathBuf,\n    audio_path: &amp;PathBuf,\n) -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {\n    // Load the plugin.\n    let mut host = PluginHost::load(plugin_path, None)?;\n    let plugin_info = host.get_info()?;\n    let params = host.get_params();\n\n    // Create the audio engine and load the WAV file.\n    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;\n    engine.load_file(audio_path)?;\n\n    // Activate and start processing.\n    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;\n    host.start_processing()?;\n\n    // Attach plugin to engine.\n    engine.set_plugin(Some(&amp;mut host));\n\n    // Read the WAV file for waveform peak computation.\n    let peaks = build_peaks(audio_path)?;\n\n    let state = cx.new(|_cx| AppState {\n        host,\n        engine,\n        plugin_info,\n        params,\n    });\n\n    Ok((state, peaks))\n}\n\n/// Read the WAV file and compute waveform peaks for display.\nfn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {\n    let data = std::fs::read(path)?;\n    let (samples, channels) = parse_wav_samples(&amp;data)?;\n    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);\n    Ok(peaks)\n}\n\n/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.\n/// Returns (interleaved_f32_samples, channel_count).\nfn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {\n    if data.len() &lt; 44 {\n        anyhow::bail!(\"WAV file too small\");\n    }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "const SAMPLE_RATE: f64 = 44100.0;",
            "lineNumber": 103
          },
          {
            "text": "const BUFFER_SIZE: u32 = 512;",
            "lineNumber": 104
          },
          {
            "text": "/// Number of waveform display columns (pre-computed peak resolution).",
            "lineNumber": 105
          },
          {
            "text": "const WAVEFORM_COLUMNS: usize = 1200;",
            "lineNumber": 106
          },
          {
            "lineNumber": 107
          },
          {
            "text": "fn setup(",
            "lineNumber": 108
          },
          {
            "text": "    cx: &amp;mut App,",
            "lineNumber": 109
          },
          {
            "text": "    plugin_path: &amp;PathBuf,",
            "lineNumber": 110
          },
          {
            "text": "    audio_path: &amp;PathBuf,",
            "lineNumber": 111
          },
          {
            "text": ") -&gt; Result&lt;(gpui::Entity&lt;AppState&gt;, WaveformPeaks)&gt; {",
            "lineNumber": 112
          },
          {
            "text": "    // Load the plugin.",
            "lineNumber": 113
          },
          {
            "text": "    let mut host = PluginHost::load(plugin_path, None)?;",
            "lineNumber": 114
          },
          {
            "text": "    let plugin_info = host.get_info()?;",
            "lineNumber": 115
          },
          {
            "text": "    let params = host.get_params();",
            "lineNumber": 116
          },
          {
            "lineNumber": 117
          },
          {
            "text": "    // Create the audio engine and load the WAV file.",
            "lineNumber": 118
          },
          {
            "text": "    let mut engine = AudioEngine::new(SAMPLE_RATE, BUFFER_SIZE)?;",
            "lineNumber": 119
          },
          {
            "text": "    engine.load_file(audio_path)?;",
            "lineNumber": 120
          },
          {
            "lineNumber": 121
          },
          {
            "text": "    // Activate and start processing.",
            "lineNumber": 122
          },
          {
            "text": "    host.activate(SAMPLE_RATE, BUFFER_SIZE)?;",
            "lineNumber": 123
          },
          {
            "text": "    host.start_processing()?;",
            "lineNumber": 124
          },
          {
            "lineNumber": 125
          },
          {
            "text": "    // Attach plugin to engine.",
            "lineNumber": 126
          },
          {
            "text": "    engine.set_plugin(Some(&amp;mut host));",
            "lineNumber": 127
          },
          {
            "lineNumber": 128
          },
          {
            "text": "    // Read the WAV file for waveform peak computation.",
            "lineNumber": 129
          },
          {
            "text": "    let peaks = build_peaks(audio_path)?;",
            "lineNumber": 130
          },
          {
            "lineNumber": 131
          },
          {
            "text": "    let state = cx.new(|_cx| AppState {",
            "lineNumber": 132
          },
          {
            "text": "        host,",
            "lineNumber": 133
          },
          {
            "text": "        engine,",
            "lineNumber": 134
          },
          {
            "text": "        plugin_info,",
            "lineNumber": 135
          },
          {
            "text": "        params,",
            "lineNumber": 136
          },
          {
            "text": "    });",
            "lineNumber": 137
          },
          {
            "lineNumber": 138
          },
          {
            "text": "    Ok((state, peaks))",
            "lineNumber": 139
          },
          {
            "text": "}",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "/// Read the WAV file and compute waveform peaks for display.",
            "lineNumber": 142
          },
          {
            "text": "fn build_peaks(path: &amp;PathBuf) -&gt; Result&lt;WaveformPeaks&gt; {",
            "lineNumber": 143
          },
          {
            "text": "    let data = std::fs::read(path)?;",
            "lineNumber": 144
          },
          {
            "text": "    let (samples, channels) = parse_wav_samples(&amp;data)?;",
            "lineNumber": 145
          },
          {
            "text": "    let peaks = WaveformPeaks::from_samples(&amp;samples, channels, WAVEFORM_COLUMNS);",
            "lineNumber": 146
          },
          {
            "text": "    Ok(peaks)",
            "lineNumber": 147
          },
          {
            "text": "}",
            "lineNumber": 148
          },
          {
            "lineNumber": 149
          },
          {
            "text": "/// Minimal WAV parser that extracts f32 samples from PCM/float WAV files.",
            "lineNumber": 150
          },
          {
            "text": "/// Returns (interleaved_f32_samples, channel_count).",
            "lineNumber": 151
          },
          {
            "text": "fn parse_wav_samples(data: &amp;[u8]) -&gt; Result&lt;(Vec&lt;f32&gt;, usize)&gt; {",
            "lineNumber": 152
          },
          {
            "text": "    if data.len() &lt; 44 {",
            "lineNumber": 153
          },
          {
            "text": "        anyhow::bail!(\"WAV file too small\");",
            "lineNumber": 154
          },
          {
            "text": "    }",
            "lineNumber": 155
          }
        ]
      },
      "score": 0.09812159836292267
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/main.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 44,
            "column": 29
          }
        },
        "contents": "//! zloader  CLAP plugin debug/test tool.\n//!\n//! Usage:\n//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;\n\nmod app;\nmod engine;\nmod ffi;\nmod host;\nmod params;\nmod transport;\nmod waveform;\n\nuse std::path::PathBuf;\n\nuse anyhow::Result;\nuse clap::Parser;\nuse gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};\nuse gpui_component::{theme::Theme, Root};\n\nuse app::{AppState, ZLoaderApp};\nuse engine::AudioEngine;\nuse host::PluginHost;\nuse waveform::WaveformPeaks;\n\n// ---------------------------------------------------------------------------\n// CLI\n// ---------------------------------------------------------------------------\n\n#[derive(Parser, Debug)]\n#[command(name = \"zloader\", about = \"CLAP plugin debug/test tool\")]\nstruct Args {\n    /// Path to the .clap plugin file or bundle.\n    plugin_path: PathBuf,\n\n    /// Path to a WAV audio file to play through the plugin.\n    audio_file: PathBuf,\n}\n\n// ---------------------------------------------------------------------------\n// Entry point\n// ---------------------------------------------------------------------------\n\nfn main() -&gt; Result&lt;()&gt; {\n    let args = Args::parse();",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! zloader  CLAP plugin debug/test tool.",
            "lineNumber": 1
          },
          {
            "text": "//!",
            "lineNumber": 2
          },
          {
            "text": "//! Usage:",
            "lineNumber": 3
          },
          {
            "text": "//!   zloader &lt;plugin.clap&gt; &lt;audio.wav&gt;",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "mod app;",
            "lineNumber": 6
          },
          {
            "text": "mod engine;",
            "lineNumber": 7
          },
          {
            "text": "mod ffi;",
            "lineNumber": 8
          },
          {
            "text": "mod host;",
            "lineNumber": 9
          },
          {
            "text": "mod params;",
            "lineNumber": 10
          },
          {
            "text": "mod transport;",
            "lineNumber": 11
          },
          {
            "text": "mod waveform;",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "use std::path::PathBuf;",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "use anyhow::Result;",
            "lineNumber": 16
          },
          {
            "text": "use clap::Parser;",
            "lineNumber": 17
          },
          {
            "text": "use gpui::{prelude::*, px, size, App, Application, Bounds, WindowBounds, WindowOptions};",
            "lineNumber": 18
          },
          {
            "text": "use gpui_component::{theme::Theme, Root};",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "use app::{AppState, ZLoaderApp};",
            "lineNumber": 21
          },
          {
            "text": "use engine::AudioEngine;",
            "lineNumber": 22
          },
          {
            "text": "use host::PluginHost;",
            "lineNumber": 23
          },
          {
            "text": "use waveform::WaveformPeaks;",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 26
          },
          {
            "text": "// CLI",
            "lineNumber": 27
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "#[derive(Parser, Debug)]",
            "lineNumber": 30
          },
          {
            "text": "#[command(name = \"zloader\", about = \"CLAP plugin debug/test tool\")]",
            "lineNumber": 31
          },
          {
            "text": "struct Args {",
            "lineNumber": 32
          },
          {
            "text": "    /// Path to the .clap plugin file or bundle.",
            "lineNumber": 33
          },
          {
            "text": "    plugin_path: PathBuf,",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "    /// Path to a WAV audio file to play through the plugin.",
            "lineNumber": 36
          },
          {
            "text": "    audio_file: PathBuf,",
            "lineNumber": 37
          },
          {
            "text": "}",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 40
          },
          {
            "text": "// Entry point",
            "lineNumber": 41
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "fn main() -&gt; Result&lt;()&gt; {",
            "lineNumber": 44
          },
          {
            "text": "    let args = Args::parse();",
            "lineNumber": 45
          }
        ]
      },
      "score": 0.09168309718370438
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/ffi.rs",
        "range": {
          "startPosition": {
            "line": 105,
            "column": 78
          },
          "endPosition": {
            "line": 163
          }
        },
        "contents": "extern \"C\" {\n    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.\n    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.\n    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;\n\n    /// Destroy a plugin handle and free all resources.\n    pub fn zph_destroy(plugin: *mut ZphPlugin);\n\n    /// Activate the plugin for audio processing.\n    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;\n\n    /// Deactivate the plugin.\n    pub fn zph_deactivate(plugin: *mut ZphPlugin);\n\n    /// Start the audio processing state (call from audio thread after activate).\n    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;\n\n    /// Stop the audio processing state.\n    pub fn zph_stop_processing(plugin: *mut ZphPlugin);\n\n    /// Process one block of audio through the plugin.\n    pub fn zph_process(\n        plugin: *mut ZphPlugin,\n        inputs: *const *const f32,\n        outputs: *const *mut f32,\n        channel_count: u32,\n        frame_count: u32,\n    ) -&gt; ZphProcessStatus;\n\n    /// Fill &#96;out&#96; with plugin metadata.\n    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;\n\n    /// Return the number of parameters the plugin exposes.\n    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;\n\n    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.\n    pub fn zph_get_param_info(\n        plugin: *const ZphPlugin,\n        index: u32,\n        out: *mut ZphParamInfo,\n    ) -&gt; bool;\n\n    /// Get the current value of a parameter by its stable ID.\n    pub fn zph_get_param_value(\n        plugin: *const ZphPlugin,\n        param_id: u32,\n        out: *mut f64,\n    ) -&gt; bool;\n\n    /// Queue a parameter change to be applied on the next process call.\n    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);\n\n    /// Save plugin state. Pass buffer=NULL to query required size.\n    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;\n\n    /// Load plugin state from buffer.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "extern \"C\" {",
            "lineNumber": 108
          },
          {
            "text": "    /// Load a .clap file and instantiate a plugin. Returns NULL on failure.",
            "lineNumber": 109
          },
          {
            "text": "    /// &#96;plugin_id&#96; may be NULL to load the first available plugin.",
            "lineNumber": 110
          },
          {
            "text": "    pub fn zph_load_plugin(path: *const c_char, plugin_id: *const c_char) -&gt; *mut ZphPlugin;",
            "lineNumber": 111
          },
          {
            "lineNumber": 112
          },
          {
            "text": "    /// Destroy a plugin handle and free all resources.",
            "lineNumber": 113
          },
          {
            "text": "    pub fn zph_destroy(plugin: *mut ZphPlugin);",
            "lineNumber": 114
          },
          {
            "lineNumber": 115
          },
          {
            "text": "    /// Activate the plugin for audio processing.",
            "lineNumber": 116
          },
          {
            "text": "    pub fn zph_activate(plugin: *mut ZphPlugin, sample_rate: f64, max_frames: u32) -&gt; bool;",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "    /// Deactivate the plugin.",
            "lineNumber": 119
          },
          {
            "text": "    pub fn zph_deactivate(plugin: *mut ZphPlugin);",
            "lineNumber": 120
          },
          {
            "lineNumber": 121
          },
          {
            "text": "    /// Start the audio processing state (call from audio thread after activate).",
            "lineNumber": 122
          },
          {
            "text": "    pub fn zph_start_processing(plugin: *mut ZphPlugin) -&gt; bool;",
            "lineNumber": 123
          },
          {
            "lineNumber": 124
          },
          {
            "text": "    /// Stop the audio processing state.",
            "lineNumber": 125
          },
          {
            "text": "    pub fn zph_stop_processing(plugin: *mut ZphPlugin);",
            "lineNumber": 126
          },
          {
            "lineNumber": 127
          },
          {
            "text": "    /// Process one block of audio through the plugin.",
            "lineNumber": 128
          },
          {
            "text": "    pub fn zph_process(",
            "lineNumber": 129
          },
          {
            "text": "        plugin: *mut ZphPlugin,",
            "lineNumber": 130
          },
          {
            "text": "        inputs: *const *const f32,",
            "lineNumber": 131
          },
          {
            "text": "        outputs: *const *mut f32,",
            "lineNumber": 132
          },
          {
            "text": "        channel_count: u32,",
            "lineNumber": 133
          },
          {
            "text": "        frame_count: u32,",
            "lineNumber": 134
          },
          {
            "text": "    ) -&gt; ZphProcessStatus;",
            "lineNumber": 135
          },
          {
            "lineNumber": 136
          },
          {
            "text": "    /// Fill &#96;out&#96; with plugin metadata.",
            "lineNumber": 137
          },
          {
            "text": "    pub fn zph_get_plugin_info(plugin: *const ZphPlugin, out: *mut ZphPluginInfo) -&gt; bool;",
            "lineNumber": 138
          },
          {
            "lineNumber": 139
          },
          {
            "text": "    /// Return the number of parameters the plugin exposes.",
            "lineNumber": 140
          },
          {
            "text": "    pub fn zph_get_param_count(plugin: *const ZphPlugin) -&gt; u32;",
            "lineNumber": 141
          },
          {
            "lineNumber": 142
          },
          {
            "text": "    /// Fill &#96;out&#96; with info about the parameter at &#96;index&#96;.",
            "lineNumber": 143
          },
          {
            "text": "    pub fn zph_get_param_info(",
            "lineNumber": 144
          },
          {
            "text": "        plugin: *const ZphPlugin,",
            "lineNumber": 145
          },
          {
            "text": "        index: u32,",
            "lineNumber": 146
          },
          {
            "text": "        out: *mut ZphParamInfo,",
            "lineNumber": 147
          },
          {
            "text": "    ) -&gt; bool;",
            "lineNumber": 148
          },
          {
            "lineNumber": 149
          },
          {
            "text": "    /// Get the current value of a parameter by its stable ID.",
            "lineNumber": 150
          },
          {
            "text": "    pub fn zph_get_param_value(",
            "lineNumber": 151
          },
          {
            "text": "        plugin: *const ZphPlugin,",
            "lineNumber": 152
          },
          {
            "text": "        param_id: u32,",
            "lineNumber": 153
          },
          {
            "text": "        out: *mut f64,",
            "lineNumber": 154
          },
          {
            "text": "    ) -&gt; bool;",
            "lineNumber": 155
          },
          {
            "lineNumber": 156
          },
          {
            "text": "    /// Queue a parameter change to be applied on the next process call.",
            "lineNumber": 157
          },
          {
            "text": "    pub fn zph_set_param_value(plugin: *mut ZphPlugin, param_id: u32, value: f64);",
            "lineNumber": 158
          },
          {
            "lineNumber": 159
          },
          {
            "text": "    /// Save plugin state. Pass buffer=NULL to query required size.",
            "lineNumber": 160
          },
          {
            "text": "    pub fn zph_save_state(plugin: *const ZphPlugin, buffer: *mut u8, size: *mut u32) -&gt; bool;",
            "lineNumber": 161
          },
          {
            "lineNumber": 162
          },
          {
            "text": "    /// Load plugin state from buffer.",
            "lineNumber": 163
          }
        ]
      },
      "score": 0.07485970109701157
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/engine.rs",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 49
          },
          "endPosition": {
            "line": 94,
            "column": 5
          }
        },
        "contents": ";\n        }\n    }\n}\n\nimpl AudioEngine {\n    /// Create a new audio engine.\n    ///\n    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).\n    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).\n    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {\n        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };\n        if ptr.is_null() {\n            bail!(\"zpe_create returned NULL\");\n        }\n        Ok(Self { ptr })\n    }\n\n    /// Load a WAV file for playback.\n    ///\n    /// Stops playback and resets position if a file was already loaded.\n    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {\n        let path_cstr = path_to_cstring(path)?;\n        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };\n        if !ok {\n            bail!(\"zpe_load_file failed for {:?}\", path);\n        }\n        Ok(())\n    }\n\n    /// Attach a CLAP plugin to the engine.\n    ///\n    /// Audio from the loaded WAV file will be routed through the plugin before\n    /// output. The plugin must be activated and processing-started before\n    /// calling &#96;play()&#96;.\n    ///\n    /// Pass &#96;None&#96; to detach and use passthrough mode.\n    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {\n        let plugin_ptr = host\n            .map(|h| h.raw_ptr())\n            .unwrap_or(std::ptr::null_mut());\n        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };\n    }\n\n    /// Start playback.\n    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {\n        let ok = unsafe { ffi::zpe_play(self.ptr) };\n        if !ok {\n            bail!(\"zpe_play failed (no file loaded or audio init error)\");\n        }\n        Ok(())\n    }\n\n    /// Pause playback. The current position is preserved.\n    pub fn pause(&amp;mut self) {\n        unsafe { ffi::zpe_pause(self.ptr) };\n    }\n\n    /// Stop playback and reset position to 0.\n    pub fn stop(&amp;mut self) {\n        unsafe { ffi::zpe_stop(self.ptr) };\n    }\n\n    /// Seek to a specific sample position.\n    pub fn seek(&amp;mut self, sample_position: u64) {\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\n    }",
        "signatures": {},
        "detailedLines": [
          {
            "text": ";",
            "lineNumber": 29
          },
          {
            "text": "        }",
            "lineNumber": 30
          },
          {
            "text": "    }",
            "lineNumber": 31
          },
          {
            "text": "}",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "impl AudioEngine {",
            "lineNumber": 34
          },
          {
            "text": "    /// Create a new audio engine.",
            "lineNumber": 35
          },
          {
            "text": "    ///",
            "lineNumber": 36
          },
          {
            "text": "    /// &#96;sample_rate&#96;: output sample rate in Hz (0 defaults to 44100).",
            "lineNumber": 37
          },
          {
            "text": "    /// &#96;buffer_size&#96;: frames per audio callback (0 defaults to 512).",
            "lineNumber": 38
          },
          {
            "text": "    pub fn new(sample_rate: f64, buffer_size: u32) -&gt; Result&lt;Self&gt; {",
            "lineNumber": 39
          },
          {
            "text": "        let ptr = unsafe { ffi::zpe_create(sample_rate, buffer_size) };",
            "lineNumber": 40
          },
          {
            "text": "        if ptr.is_null() {",
            "lineNumber": 41
          },
          {
            "text": "            bail!(\"zpe_create returned NULL\");",
            "lineNumber": 42
          },
          {
            "text": "        }",
            "lineNumber": 43
          },
          {
            "text": "        Ok(Self { ptr })",
            "lineNumber": 44
          },
          {
            "text": "    }",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "    /// Load a WAV file for playback.",
            "lineNumber": 47
          },
          {
            "text": "    ///",
            "lineNumber": 48
          },
          {
            "text": "    /// Stops playback and resets position if a file was already loaded.",
            "lineNumber": 49
          },
          {
            "text": "    pub fn load_file(&amp;mut self, path: &amp;Path) -&gt; Result&lt;()&gt; {",
            "lineNumber": 50
          },
          {
            "text": "        let path_cstr = path_to_cstring(path)?;",
            "lineNumber": 51
          },
          {
            "text": "        let ok = unsafe { ffi::zpe_load_file(self.ptr, path_cstr.as_ptr()) };",
            "lineNumber": 52
          },
          {
            "text": "        if !ok {",
            "lineNumber": 53
          },
          {
            "text": "            bail!(\"zpe_load_file failed for {:?}\", path);",
            "lineNumber": 54
          },
          {
            "text": "        }",
            "lineNumber": 55
          },
          {
            "text": "        Ok(())",
            "lineNumber": 56
          },
          {
            "text": "    }",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    /// Attach a CLAP plugin to the engine.",
            "lineNumber": 59
          },
          {
            "text": "    ///",
            "lineNumber": 60
          },
          {
            "text": "    /// Audio from the loaded WAV file will be routed through the plugin before",
            "lineNumber": 61
          },
          {
            "text": "    /// output. The plugin must be activated and processing-started before",
            "lineNumber": 62
          },
          {
            "text": "    /// calling &#96;play()&#96;.",
            "lineNumber": 63
          },
          {
            "text": "    ///",
            "lineNumber": 64
          },
          {
            "text": "    /// Pass &#96;None&#96; to detach and use passthrough mode.",
            "lineNumber": 65
          },
          {
            "text": "    pub fn set_plugin(&amp;mut self, host: Option&lt;&amp;mut PluginHost&gt;) {",
            "lineNumber": 66
          },
          {
            "text": "        let plugin_ptr = host",
            "lineNumber": 67
          },
          {
            "text": "            .map(|h| h.raw_ptr())",
            "lineNumber": 68
          },
          {
            "text": "            .unwrap_or(std::ptr::null_mut());",
            "lineNumber": 69
          },
          {
            "text": "        unsafe { ffi::zpe_set_plugin(self.ptr, plugin_ptr) };",
            "lineNumber": 70
          },
          {
            "text": "    }",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "    /// Start playback.",
            "lineNumber": 73
          },
          {
            "text": "    pub fn play(&amp;mut self) -&gt; Result&lt;()&gt; {",
            "lineNumber": 74
          },
          {
            "text": "        let ok = unsafe { ffi::zpe_play(self.ptr) };",
            "lineNumber": 75
          },
          {
            "text": "        if !ok {",
            "lineNumber": 76
          },
          {
            "text": "            bail!(\"zpe_play failed (no file loaded or audio init error)\");",
            "lineNumber": 77
          },
          {
            "text": "        }",
            "lineNumber": 78
          },
          {
            "text": "        Ok(())",
            "lineNumber": 79
          },
          {
            "text": "    }",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "    /// Pause playback. The current position is preserved.",
            "lineNumber": 82
          },
          {
            "text": "    pub fn pause(&amp;mut self) {",
            "lineNumber": 83
          },
          {
            "text": "        unsafe { ffi::zpe_pause(self.ptr) };",
            "lineNumber": 84
          },
          {
            "text": "    }",
            "lineNumber": 85
          },
          {
            "lineNumber": 86
          },
          {
            "text": "    /// Stop playback and reset position to 0.",
            "lineNumber": 87
          },
          {
            "text": "    pub fn stop(&amp;mut self) {",
            "lineNumber": 88
          },
          {
            "text": "        unsafe { ffi::zpe_stop(self.ptr) };",
            "lineNumber": 89
          },
          {
            "text": "    }",
            "lineNumber": 90
          },
          {
            "lineNumber": 91
          },
          {
            "text": "    /// Seek to a specific sample position.",
            "lineNumber": 92
          },
          {
            "text": "    pub fn seek(&amp;mut self, sample_position: u64) {",
            "lineNumber": 93
          },
          {
            "text": "        unsafe { ffi::zpe_seek(self.ptr, sample_position) };",
            "lineNumber": 94
          },
          {
            "text": "    }",
            "lineNumber": 95
          }
        ]
      },
      "score": 0.0650065466761589
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/host.rs",
        "range": {
          "startPosition": {
            "line": 166,
            "column": 5
          },
          "endPosition": {
            "line": 208,
            "column": 1
          }
        },
        "contents": "    /// Queue a parameter change to be applied on the next process call.\n    /// Thread-safe; may be called from any thread.\n    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {\n        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };\n    }\n\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\n    pub fn idle(&amp;mut self) {\n        unsafe { ffi::zph_idle(self.ptr) };\n    }\n\n    /// Return the raw pointer for passing to the engine.\n    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {\n        self.ptr\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {\n    let s = path\n        .to_str()\n        .ok_or_else(|| anyhow!(\"path is not valid UTF-8: {:?}\", path))?;\n    CString::new(s).map_err(|e| anyhow!(\"path contains null byte: {e}\"))\n}\n\nfn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {\n    if ptr.is_null() {\n        return String::new();\n    }\n    unsafe { CStr::from_ptr(ptr) }\n        .to_string_lossy()\n        .into_owned()\n}\n\nfn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {\n    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());\n    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    /// Queue a parameter change to be applied on the next process call.",
            "lineNumber": 169
          },
          {
            "text": "    /// Thread-safe; may be called from any thread.",
            "lineNumber": 170
          },
          {
            "text": "    pub fn set_param_value(&amp;self, param_id: u32, value: f64) {",
            "lineNumber": 171
          },
          {
            "text": "        unsafe { ffi::zph_set_param_value(self.ptr, param_id, value) };",
            "lineNumber": 172
          },
          {
            "text": "    }",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "    /// Handle deferred plugin callbacks. Call periodically from the main thread.",
            "lineNumber": 175
          },
          {
            "text": "    pub fn idle(&amp;mut self) {",
            "lineNumber": 176
          },
          {
            "text": "        unsafe { ffi::zph_idle(self.ptr) };",
            "lineNumber": 177
          },
          {
            "text": "    }",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "    /// Return the raw pointer for passing to the engine.",
            "lineNumber": 180
          },
          {
            "text": "    pub fn raw_ptr(&amp;mut self) -&gt; *mut ffi::ZphPlugin {",
            "lineNumber": 181
          },
          {
            "text": "        self.ptr",
            "lineNumber": 182
          },
          {
            "text": "    }",
            "lineNumber": 183
          },
          {
            "text": "}",
            "lineNumber": 184
          },
          {
            "lineNumber": 185
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 186
          },
          {
            "text": "// Helpers",
            "lineNumber": 187
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 188
          },
          {
            "lineNumber": 189
          },
          {
            "text": "fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString&gt; {",
            "lineNumber": 190
          },
          {
            "text": "    let s = path",
            "lineNumber": 191
          },
          {
            "text": "        .to_str()",
            "lineNumber": 192
          },
          {
            "text": "        .ok_or_else(|| anyhow!(\"path is not valid UTF-8: {:?}\", path))?;",
            "lineNumber": 193
          },
          {
            "text": "    CString::new(s).map_err(|e| anyhow!(\"path contains null byte: {e}\"))",
            "lineNumber": 194
          },
          {
            "text": "}",
            "lineNumber": 195
          },
          {
            "lineNumber": 196
          },
          {
            "text": "fn cstr_ptr_to_string(ptr: *const std::ffi::c_char) -&gt; String {",
            "lineNumber": 197
          },
          {
            "text": "    if ptr.is_null() {",
            "lineNumber": 198
          },
          {
            "text": "        return String::new();",
            "lineNumber": 199
          },
          {
            "text": "    }",
            "lineNumber": 200
          },
          {
            "text": "    unsafe { CStr::from_ptr(ptr) }",
            "lineNumber": 201
          },
          {
            "text": "        .to_string_lossy()",
            "lineNumber": 202
          },
          {
            "text": "        .into_owned()",
            "lineNumber": 203
          },
          {
            "text": "}",
            "lineNumber": 204
          },
          {
            "lineNumber": 205
          },
          {
            "text": "fn cstr_bytes_to_string(bytes: &amp;[u8]) -&gt; String {",
            "lineNumber": 206
          },
          {
            "text": "    let end = bytes.iter().position(|&amp;b| b == 0).unwrap_or(bytes.len());",
            "lineNumber": 207
          },
          {
            "text": "    String::from_utf8_lossy(&amp;bytes[..end]).into_owned()",
            "lineNumber": 208
          },
          {
            "text": "}",
            "lineNumber": 209
          }
        ]
      },
      "score": 0.064120352268219
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/host.rs",
        "range": {
          "startPosition": {
            "line": 61,
            "column": 49
          },
          "endPosition": {
            "line": 119,
            "column": 73
          }
        },
        "contents": ";\n        }\n    }\n}\n\nimpl PluginHost {\n    /// Load a &#96;.clap&#96; file and instantiate a plugin.\n    ///\n    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.\n    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {\n        let path_cstr = path_to_cstring(path)?;\n        let id_cstr: Option&lt;CString&gt; = plugin_id\n            .map(|s| CString::new(s).map_err(|e| anyhow!(\"invalid plugin_id: {e}\")))\n            .transpose()?;\n\n        let id_ptr = id_cstr\n            .as_ref()\n            .map(|c| c.as_ptr())\n            .unwrap_or(std::ptr::null());\n\n        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };\n        if ptr.is_null() {\n            bail!(\"zph_load_plugin returned NULL for {:?}\", path);\n        }\n        Ok(Self { ptr })\n    }\n\n    /// Activate the plugin for audio processing.\n    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {\n        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };\n        if !ok {\n            bail!(\"zph_activate failed\");\n        }\n        Ok(())\n    }\n\n    /// Deactivate the plugin.\n    pub fn deactivate(&amp;mut self) {\n        unsafe { ffi::zph_deactivate(self.ptr) };\n    }\n\n    /// Start the audio processing state. Must be called before &#96;process&#96;.\n    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {\n        let ok = unsafe { ffi::zph_start_processing(self.ptr) };\n        if !ok {\n            bail!(\"zph_start_processing failed\");\n        }\n        Ok(())\n    }\n\n    /// Stop the audio processing state.\n    pub fn stop_processing(&amp;mut self) {\n        unsafe { ffi::zph_stop_processing(self.ptr) };\n    }\n\n    /// Retrieve plugin metadata.\n    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {\n        let mut raw = ffi::ZphPluginInfo::default();\n        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };",
        "signatures": {},
        "detailedLines": [
          {
            "text": ";",
            "lineNumber": 62
          },
          {
            "text": "        }",
            "lineNumber": 63
          },
          {
            "text": "    }",
            "lineNumber": 64
          },
          {
            "text": "}",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "impl PluginHost {",
            "lineNumber": 67
          },
          {
            "text": "    /// Load a &#96;.clap&#96; file and instantiate a plugin.",
            "lineNumber": 68
          },
          {
            "text": "    ///",
            "lineNumber": 69
          },
          {
            "text": "    /// &#96;plugin_id&#96; may be &#96;None&#96; to load the first available plugin.",
            "lineNumber": 70
          },
          {
            "text": "    pub fn load(path: &amp;Path, plugin_id: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self&gt; {",
            "lineNumber": 71
          },
          {
            "text": "        let path_cstr = path_to_cstring(path)?;",
            "lineNumber": 72
          },
          {
            "text": "        let id_cstr: Option&lt;CString&gt; = plugin_id",
            "lineNumber": 73
          },
          {
            "text": "            .map(|s| CString::new(s).map_err(|e| anyhow!(\"invalid plugin_id: {e}\")))",
            "lineNumber": 74
          },
          {
            "text": "            .transpose()?;",
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "        let id_ptr = id_cstr",
            "lineNumber": 77
          },
          {
            "text": "            .as_ref()",
            "lineNumber": 78
          },
          {
            "text": "            .map(|c| c.as_ptr())",
            "lineNumber": 79
          },
          {
            "text": "            .unwrap_or(std::ptr::null());",
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "        let ptr = unsafe { ffi::zph_load_plugin(path_cstr.as_ptr(), id_ptr) };",
            "lineNumber": 82
          },
          {
            "text": "        if ptr.is_null() {",
            "lineNumber": 83
          },
          {
            "text": "            bail!(\"zph_load_plugin returned NULL for {:?}\", path);",
            "lineNumber": 84
          },
          {
            "text": "        }",
            "lineNumber": 85
          },
          {
            "text": "        Ok(Self { ptr })",
            "lineNumber": 86
          },
          {
            "text": "    }",
            "lineNumber": 87
          },
          {
            "lineNumber": 88
          },
          {
            "text": "    /// Activate the plugin for audio processing.",
            "lineNumber": 89
          },
          {
            "text": "    pub fn activate(&amp;mut self, sample_rate: f64, max_frames: u32) -&gt; Result&lt;()&gt; {",
            "lineNumber": 90
          },
          {
            "text": "        let ok = unsafe { ffi::zph_activate(self.ptr, sample_rate, max_frames) };",
            "lineNumber": 91
          },
          {
            "text": "        if !ok {",
            "lineNumber": 92
          },
          {
            "text": "            bail!(\"zph_activate failed\");",
            "lineNumber": 93
          },
          {
            "text": "        }",
            "lineNumber": 94
          },
          {
            "text": "        Ok(())",
            "lineNumber": 95
          },
          {
            "text": "    }",
            "lineNumber": 96
          },
          {
            "lineNumber": 97
          },
          {
            "text": "    /// Deactivate the plugin.",
            "lineNumber": 98
          },
          {
            "text": "    pub fn deactivate(&amp;mut self) {",
            "lineNumber": 99
          },
          {
            "text": "        unsafe { ffi::zph_deactivate(self.ptr) };",
            "lineNumber": 100
          },
          {
            "text": "    }",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "    /// Start the audio processing state. Must be called before &#96;process&#96;.",
            "lineNumber": 103
          },
          {
            "text": "    pub fn start_processing(&amp;mut self) -&gt; Result&lt;()&gt; {",
            "lineNumber": 104
          },
          {
            "text": "        let ok = unsafe { ffi::zph_start_processing(self.ptr) };",
            "lineNumber": 105
          },
          {
            "text": "        if !ok {",
            "lineNumber": 106
          },
          {
            "text": "            bail!(\"zph_start_processing failed\");",
            "lineNumber": 107
          },
          {
            "text": "        }",
            "lineNumber": 108
          },
          {
            "text": "        Ok(())",
            "lineNumber": 109
          },
          {
            "text": "    }",
            "lineNumber": 110
          },
          {
            "lineNumber": 111
          },
          {
            "text": "    /// Stop the audio processing state.",
            "lineNumber": 112
          },
          {
            "text": "    pub fn stop_processing(&amp;mut self) {",
            "lineNumber": 113
          },
          {
            "text": "        unsafe { ffi::zph_stop_processing(self.ptr) };",
            "lineNumber": 114
          },
          {
            "text": "    }",
            "lineNumber": 115
          },
          {
            "lineNumber": 116
          },
          {
            "text": "    /// Retrieve plugin metadata.",
            "lineNumber": 117
          },
          {
            "text": "    pub fn get_info(&amp;self) -&gt; Result&lt;PluginInfo&gt; {",
            "lineNumber": 118
          },
          {
            "text": "        let mut raw = ffi::ZphPluginInfo::default();",
            "lineNumber": 119
          },
          {
            "text": "        let ok = unsafe { ffi::zph_get_plugin_info(self.ptr, &amp;mut raw) };",
            "lineNumber": 120
          }
        ]
      },
      "score": 0.061563801020383835
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/host.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 67,
            "column": 7
          }
        },
        "contents": "//! Safe Rust wrapper around the z_plug_host C API.\n#![allow(dead_code)]\n\nuse std::ffi::{CStr, CString};\nuse std::path::Path;\n\nuse anyhow::{anyhow, bail, Result};\n\nuse crate::ffi;\n\n// ---------------------------------------------------------------------------\n// Param info (safe Rust representation)\n// ---------------------------------------------------------------------------\n\n/// Safe Rust representation of a plugin parameter.\n#[derive(Debug, Clone)]\npub struct ParamInfo {\n    pub id: u32,\n    pub name: String,\n    pub module: String,\n    pub min_value: f64,\n    pub max_value: f64,\n    pub default_value: f64,\n    pub flags: u32,\n}\n\n// ---------------------------------------------------------------------------\n// Plugin info (safe Rust representation)\n// ---------------------------------------------------------------------------\n\n/// Safe Rust representation of plugin metadata.\n#[derive(Debug, Clone)]\npub struct PluginInfo {\n    pub id: String,\n    pub name: String,\n    pub vendor: String,\n    pub version: String,\n    pub description: String,\n    pub input_channels: u32,\n    pub output_channels: u32,\n    pub latency_samples: u32,\n}\n\n// ---------------------------------------------------------------------------\n// PluginHost\n// ---------------------------------------------------------------------------\n\n/// Safe wrapper around a loaded CLAP plugin instance.\n///\n/// All methods must be called from the main thread unless otherwise noted.\n/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.\npub struct PluginHost {\n    ptr: *mut ffi::ZphPlugin,\n}\n\n// The Zig host library is designed for single-threaded main-thread use.\n// We assert this by not implementing Send/Sync.\n\nimpl Drop for PluginHost {\n    fn drop(&amp;mut self) {\n        if !self.ptr.is_null() {\n            unsafe { ffi::zph_destroy(self.ptr) };\n        }\n    }\n}\n\nimpl PluginHost {\n    ///",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Safe Rust wrapper around the z_plug_host C API.",
            "lineNumber": 1
          },
          {
            "text": "#![allow(dead_code)]",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "use std::ffi::{CStr, CString};",
            "lineNumber": 4
          },
          {
            "text": "use std::path::Path;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "use anyhow::{anyhow, bail, Result};",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "use crate::ffi;",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 11
          },
          {
            "text": "// Param info (safe Rust representation)",
            "lineNumber": 12
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "/// Safe Rust representation of a plugin parameter.",
            "lineNumber": 15
          },
          {
            "text": "#[derive(Debug, Clone)]",
            "lineNumber": 16
          },
          {
            "text": "pub struct ParamInfo {",
            "lineNumber": 17
          },
          {
            "text": "    pub id: u32,",
            "lineNumber": 18
          },
          {
            "text": "    pub name: String,",
            "lineNumber": 19
          },
          {
            "text": "    pub module: String,",
            "lineNumber": 20
          },
          {
            "text": "    pub min_value: f64,",
            "lineNumber": 21
          },
          {
            "text": "    pub max_value: f64,",
            "lineNumber": 22
          },
          {
            "text": "    pub default_value: f64,",
            "lineNumber": 23
          },
          {
            "text": "    pub flags: u32,",
            "lineNumber": 24
          },
          {
            "text": "}",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 27
          },
          {
            "text": "// Plugin info (safe Rust representation)",
            "lineNumber": 28
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/// Safe Rust representation of plugin metadata.",
            "lineNumber": 31
          },
          {
            "text": "#[derive(Debug, Clone)]",
            "lineNumber": 32
          },
          {
            "text": "pub struct PluginInfo {",
            "lineNumber": 33
          },
          {
            "text": "    pub id: String,",
            "lineNumber": 34
          },
          {
            "text": "    pub name: String,",
            "lineNumber": 35
          },
          {
            "text": "    pub vendor: String,",
            "lineNumber": 36
          },
          {
            "text": "    pub version: String,",
            "lineNumber": 37
          },
          {
            "text": "    pub description: String,",
            "lineNumber": 38
          },
          {
            "text": "    pub input_channels: u32,",
            "lineNumber": 39
          },
          {
            "text": "    pub output_channels: u32,",
            "lineNumber": 40
          },
          {
            "text": "    pub latency_samples: u32,",
            "lineNumber": 41
          },
          {
            "text": "}",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 44
          },
          {
            "text": "// PluginHost",
            "lineNumber": 45
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "/// Safe wrapper around a loaded CLAP plugin instance.",
            "lineNumber": 48
          },
          {
            "text": "///",
            "lineNumber": 49
          },
          {
            "text": "/// All methods must be called from the main thread unless otherwise noted.",
            "lineNumber": 50
          },
          {
            "text": "/// The underlying &#96;ZphPlugin&#96; pointer is freed on &#96;Drop&#96;.",
            "lineNumber": 51
          },
          {
            "text": "pub struct PluginHost {",
            "lineNumber": 52
          },
          {
            "text": "    ptr: *mut ffi::ZphPlugin,",
            "lineNumber": 53
          },
          {
            "text": "}",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "// The Zig host library is designed for single-threaded main-thread use.",
            "lineNumber": 56
          },
          {
            "text": "// We assert this by not implementing Send/Sync.",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "impl Drop for PluginHost {",
            "lineNumber": 59
          },
          {
            "text": "    fn drop(&amp;mut self) {",
            "lineNumber": 60
          },
          {
            "text": "        if !self.ptr.is_null() {",
            "lineNumber": 61
          },
          {
            "text": "            unsafe { ffi::zph_destroy(self.ptr) };",
            "lineNumber": 62
          },
          {
            "text": "        }",
            "lineNumber": 63
          },
          {
            "text": "    }",
            "lineNumber": 64
          },
          {
            "text": "}",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "impl PluginHost {",
            "lineNumber": 67
          },
          {
            "text": "    ///",
            "lineNumber": 68
          }
        ]
      },
      "score": 0.053691741079092026
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/waveform.rs",
        "range": {
          "startPosition": {
            "line": 21
          },
          "endPosition": {
            "line": 87
          }
        },
        "contents": "    pub total_samples: u64,\n}\n\nimpl WaveformPeaks {\n    /// Build peak data from raw interleaved f32 samples.\n    ///\n    /// &#96;num_columns&#96; is the target display width in pixels. The samples are\n    /// divided into that many equal-sized buckets; min/max are computed per\n    /// bucket across all channels.\n    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {\n        let total_frames = if channels &gt; 0 {\n            samples.len() / channels\n        } else {\n            0\n        };\n\n        let total_samples = total_frames as u64;\n\n        if total_frames == 0 || num_columns == 0 {\n            return Self {\n                peaks: vec![(0.0, 0.0); num_columns.max(1)],\n                total_samples,\n            };\n        }\n\n        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);\n        let mut peaks = Vec::with_capacity(num_columns);\n\n        for col in 0..num_columns {\n            let start_frame = (col as f64 * frames_per_col) as usize;\n            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;\n            let end_frame = end_frame.min(total_frames);\n\n            let mut min = 0.0f32;\n            let mut max = 0.0f32;\n\n            for frame in start_frame..end_frame {\n                for ch in 0..channels {\n                    let sample = samples[frame * channels + ch];\n                    if sample &lt; min {\n                        min = sample;\n                    }\n                    if sample &gt; max {\n                        max = sample;\n                    }\n                }\n            }\n\n            peaks.push((min, max));\n        }\n\n        Self {\n            peaks,\n            total_samples,\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// WaveformView\n// ---------------------------------------------------------------------------\n\n/// A GPUI view that renders the waveform and a playhead.\npub struct WaveformView {\n    pub peaks: WaveformPeaks,\n    /// Current playback position in samples (updated by the app timer).",
        "signatures": {},
        "detailedLines": [
          {
            "text": "    pub total_samples: u64,",
            "lineNumber": 22
          },
          {
            "text": "}",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "impl WaveformPeaks {",
            "lineNumber": 25
          },
          {
            "text": "    /// Build peak data from raw interleaved f32 samples.",
            "lineNumber": 26
          },
          {
            "text": "    ///",
            "lineNumber": 27
          },
          {
            "text": "    /// &#96;num_columns&#96; is the target display width in pixels. The samples are",
            "lineNumber": 28
          },
          {
            "text": "    /// divided into that many equal-sized buckets; min/max are computed per",
            "lineNumber": 29
          },
          {
            "text": "    /// bucket across all channels.",
            "lineNumber": 30
          },
          {
            "text": "    pub fn from_samples(samples: &amp;[f32], channels: usize, num_columns: usize) -&gt; Self {",
            "lineNumber": 31
          },
          {
            "text": "        let total_frames = if channels &gt; 0 {",
            "lineNumber": 32
          },
          {
            "text": "            samples.len() / channels",
            "lineNumber": 33
          },
          {
            "text": "        } else {",
            "lineNumber": 34
          },
          {
            "text": "            0",
            "lineNumber": 35
          },
          {
            "text": "        };",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "        let total_samples = total_frames as u64;",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "text": "        if total_frames == 0 || num_columns == 0 {",
            "lineNumber": 40
          },
          {
            "text": "            return Self {",
            "lineNumber": 41
          },
          {
            "text": "                peaks: vec![(0.0, 0.0); num_columns.max(1)],",
            "lineNumber": 42
          },
          {
            "text": "                total_samples,",
            "lineNumber": 43
          },
          {
            "text": "            };",
            "lineNumber": 44
          },
          {
            "text": "        }",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "        let frames_per_col = (total_frames as f64 / num_columns as f64).max(1.0);",
            "lineNumber": 47
          },
          {
            "text": "        let mut peaks = Vec::with_capacity(num_columns);",
            "lineNumber": 48
          },
          {
            "lineNumber": 49
          },
          {
            "text": "        for col in 0..num_columns {",
            "lineNumber": 50
          },
          {
            "text": "            let start_frame = (col as f64 * frames_per_col) as usize;",
            "lineNumber": 51
          },
          {
            "text": "            let end_frame = ((col + 1) as f64 * frames_per_col) as usize;",
            "lineNumber": 52
          },
          {
            "text": "            let end_frame = end_frame.min(total_frames);",
            "lineNumber": 53
          },
          {
            "lineNumber": 54
          },
          {
            "text": "            let mut min = 0.0f32;",
            "lineNumber": 55
          },
          {
            "text": "            let mut max = 0.0f32;",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "            for frame in start_frame..end_frame {",
            "lineNumber": 58
          },
          {
            "text": "                for ch in 0..channels {",
            "lineNumber": 59
          },
          {
            "text": "                    let sample = samples[frame * channels + ch];",
            "lineNumber": 60
          },
          {
            "text": "                    if sample &lt; min {",
            "lineNumber": 61
          },
          {
            "text": "                        min = sample;",
            "lineNumber": 62
          },
          {
            "text": "                    }",
            "lineNumber": 63
          },
          {
            "text": "                    if sample &gt; max {",
            "lineNumber": 64
          },
          {
            "text": "                        max = sample;",
            "lineNumber": 65
          },
          {
            "text": "                    }",
            "lineNumber": 66
          },
          {
            "text": "                }",
            "lineNumber": 67
          },
          {
            "text": "            }",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "            peaks.push((min, max));",
            "lineNumber": 70
          },
          {
            "text": "        }",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "        Self {",
            "lineNumber": 73
          },
          {
            "text": "            peaks,",
            "lineNumber": 74
          },
          {
            "text": "            total_samples,",
            "lineNumber": 75
          },
          {
            "text": "        }",
            "lineNumber": 76
          },
          {
            "text": "    }",
            "lineNumber": 77
          },
          {
            "text": "}",
            "lineNumber": 78
          },
          {
            "lineNumber": 79
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 80
          },
          {
            "text": "// WaveformView",
            "lineNumber": 81
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "/// A GPUI view that renders the waveform and a playhead.",
            "lineNumber": 84
          },
          {
            "text": "pub struct WaveformView {",
            "lineNumber": 85
          },
          {
            "text": "    pub peaks: WaveformPeaks,",
            "lineNumber": 86
          },
          {
            "text": "    /// Current playback position in samples (updated by the app timer).",
            "lineNumber": 87
          }
        ]
      },
      "score": 0.04973980039358139
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/ffi.rs",
        "range": {
          "startPosition": {
            "line": 160,
            "column": 68
          },
          "endPosition": {
            "line": 214,
            "column": 26
          }
        },
        "contents": " size: *mut u32) -&gt; bool;\n\n    /// Load plugin state from buffer.\n    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;\n\n    /// Handle deferred plugin callbacks. Call periodically from the main thread.\n    pub fn zph_idle(plugin: *mut ZphPlugin);\n}\n\n// ---------------------------------------------------------------------------\n// z_plug_engine extern \"C\" declarations\n// ---------------------------------------------------------------------------\n\nextern \"C\" {\n    /// Create a new audio engine.\n    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;\n\n    /// Destroy the engine and free all resources.\n    pub fn zpe_destroy(engine: *mut ZpeEngine);\n\n    /// Load a WAV file for playback.\n    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;\n\n    /// Attach a CLAP plugin to the engine.\n    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);\n\n    /// Start playback.\n    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;\n\n    /// Pause playback (position preserved).\n    pub fn zpe_pause(engine: *mut ZpeEngine);\n\n    /// Stop playback and reset position to 0.\n    pub fn zpe_stop(engine: *mut ZpeEngine);\n\n    /// Seek to a specific sample position.\n    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);\n\n    /// Return the current playback position in samples.\n    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;\n\n    /// Return the total length of the loaded file in samples.\n    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;\n\n    /// Return the engine's output sample rate in Hz.\n    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;\n\n    /// Return the channel count of the loaded file.\n    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;\n\n    /// Return true if the engine is currently playing.\n    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;\n\n    /// Enable or disable looping.\n    pub fn zpe_set_looping",
        "signatures": {},
        "detailedLines": [
          {
            "text": " size: *mut u32) -&gt; bool;",
            "lineNumber": 161
          },
          {
            "lineNumber": 162
          },
          {
            "text": "    /// Load plugin state from buffer.",
            "lineNumber": 163
          },
          {
            "text": "    pub fn zph_load_state(plugin: *mut ZphPlugin, buffer: *const u8, size: u32) -&gt; bool;",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "    /// Handle deferred plugin callbacks. Call periodically from the main thread.",
            "lineNumber": 166
          },
          {
            "text": "    pub fn zph_idle(plugin: *mut ZphPlugin);",
            "lineNumber": 167
          },
          {
            "text": "}",
            "lineNumber": 168
          },
          {
            "lineNumber": 169
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 170
          },
          {
            "text": "// z_plug_engine extern \"C\" declarations",
            "lineNumber": 171
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 172
          },
          {
            "lineNumber": 173
          },
          {
            "text": "extern \"C\" {",
            "lineNumber": 174
          },
          {
            "text": "    /// Create a new audio engine.",
            "lineNumber": 175
          },
          {
            "text": "    pub fn zpe_create(sample_rate: f64, buffer_size: u32) -&gt; *mut ZpeEngine;",
            "lineNumber": 176
          },
          {
            "lineNumber": 177
          },
          {
            "text": "    /// Destroy the engine and free all resources.",
            "lineNumber": 178
          },
          {
            "text": "    pub fn zpe_destroy(engine: *mut ZpeEngine);",
            "lineNumber": 179
          },
          {
            "lineNumber": 180
          },
          {
            "text": "    /// Load a WAV file for playback.",
            "lineNumber": 181
          },
          {
            "text": "    pub fn zpe_load_file(engine: *mut ZpeEngine, path: *const c_char) -&gt; bool;",
            "lineNumber": 182
          },
          {
            "lineNumber": 183
          },
          {
            "text": "    /// Attach a CLAP plugin to the engine.",
            "lineNumber": 184
          },
          {
            "text": "    pub fn zpe_set_plugin(engine: *mut ZpeEngine, plugin: *mut ZphPlugin);",
            "lineNumber": 185
          },
          {
            "lineNumber": 186
          },
          {
            "text": "    /// Start playback.",
            "lineNumber": 187
          },
          {
            "text": "    pub fn zpe_play(engine: *mut ZpeEngine) -&gt; bool;",
            "lineNumber": 188
          },
          {
            "lineNumber": 189
          },
          {
            "text": "    /// Pause playback (position preserved).",
            "lineNumber": 190
          },
          {
            "text": "    pub fn zpe_pause(engine: *mut ZpeEngine);",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "    /// Stop playback and reset position to 0.",
            "lineNumber": 193
          },
          {
            "text": "    pub fn zpe_stop(engine: *mut ZpeEngine);",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "    /// Seek to a specific sample position.",
            "lineNumber": 196
          },
          {
            "text": "    pub fn zpe_seek(engine: *mut ZpeEngine, sample_position: u64);",
            "lineNumber": 197
          },
          {
            "lineNumber": 198
          },
          {
            "text": "    /// Return the current playback position in samples.",
            "lineNumber": 199
          },
          {
            "text": "    pub fn zpe_get_position(engine: *const ZpeEngine) -&gt; u64;",
            "lineNumber": 200
          },
          {
            "lineNumber": 201
          },
          {
            "text": "    /// Return the total length of the loaded file in samples.",
            "lineNumber": 202
          },
          {
            "text": "    pub fn zpe_get_length(engine: *const ZpeEngine) -&gt; u64;",
            "lineNumber": 203
          },
          {
            "lineNumber": 204
          },
          {
            "text": "    /// Return the engine's output sample rate in Hz.",
            "lineNumber": 205
          },
          {
            "text": "    pub fn zpe_get_sample_rate(engine: *const ZpeEngine) -&gt; f64;",
            "lineNumber": 206
          },
          {
            "lineNumber": 207
          },
          {
            "text": "    /// Return the channel count of the loaded file.",
            "lineNumber": 208
          },
          {
            "text": "    pub fn zpe_get_channel_count(engine: *const ZpeEngine) -&gt; u32;",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "    /// Return true if the engine is currently playing.",
            "lineNumber": 211
          },
          {
            "text": "    pub fn zpe_is_playing(engine: *const ZpeEngine) -&gt; bool;",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "    /// Enable or disable looping.",
            "lineNumber": 214
          },
          {
            "text": "    pub fn zpe_set_looping",
            "lineNumber": 215
          }
        ]
      },
      "score": 0.04588120058178902
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/engine.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 36
          }
        },
        "contents": "//! Safe Rust wrapper around the z_plug_engine C API.\n#![allow(dead_code)]\n\nuse std::path::Path;\n\nuse anyhow::{anyhow, bail, Result};\n\nuse crate::ffi;\nuse crate::host::PluginHost;\n\n// ---------------------------------------------------------------------------\n// AudioEngine\n// ---------------------------------------------------------------------------\n\n/// Safe wrapper around the z_plug_engine audio engine.\n///\n/// Manages playback of a WAV file through an optional CLAP plugin using\n/// CoreAudio AudioQueue on macOS.\n///\n/// All methods must be called from the main thread.\n/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.\npub struct AudioEngine {\n    ptr: *mut ffi::ZpeEngine,\n}\n\nimpl Drop for AudioEngine {\n    fn drop(&amp;mut self) {\n        if !self.ptr.is_null() {\n            unsafe { ffi::zpe_destroy(self.ptr) };\n        }\n    }\n}\n\nimpl AudioEngine {\n    /// Create a new audio engine.\n    ///",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Safe Rust wrapper around the z_plug_engine C API.",
            "lineNumber": 1
          },
          {
            "text": "#![allow(dead_code)]",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "use std::path::Path;",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "use anyhow::{anyhow, bail, Result};",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "use crate::ffi;",
            "lineNumber": 8
          },
          {
            "text": "use crate::host::PluginHost;",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 11
          },
          {
            "text": "// AudioEngine",
            "lineNumber": 12
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "/// Safe wrapper around the z_plug_engine audio engine.",
            "lineNumber": 15
          },
          {
            "text": "///",
            "lineNumber": 16
          },
          {
            "text": "/// Manages playback of a WAV file through an optional CLAP plugin using",
            "lineNumber": 17
          },
          {
            "text": "/// CoreAudio AudioQueue on macOS.",
            "lineNumber": 18
          },
          {
            "text": "///",
            "lineNumber": 19
          },
          {
            "text": "/// All methods must be called from the main thread.",
            "lineNumber": 20
          },
          {
            "text": "/// The underlying &#96;ZpeEngine&#96; pointer is freed on &#96;Drop&#96;.",
            "lineNumber": 21
          },
          {
            "text": "pub struct AudioEngine {",
            "lineNumber": 22
          },
          {
            "text": "    ptr: *mut ffi::ZpeEngine,",
            "lineNumber": 23
          },
          {
            "text": "}",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "impl Drop for AudioEngine {",
            "lineNumber": 26
          },
          {
            "text": "    fn drop(&amp;mut self) {",
            "lineNumber": 27
          },
          {
            "text": "        if !self.ptr.is_null() {",
            "lineNumber": 28
          },
          {
            "text": "            unsafe { ffi::zpe_destroy(self.ptr) };",
            "lineNumber": 29
          },
          {
            "text": "        }",
            "lineNumber": 30
          },
          {
            "text": "    }",
            "lineNumber": 31
          },
          {
            "text": "}",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "impl AudioEngine {",
            "lineNumber": 34
          },
          {
            "text": "    /// Create a new audio engine.",
            "lineNumber": 35
          },
          {
            "text": "    ///",
            "lineNumber": 36
          }
        ]
      },
      "score": 0.03542700037360191
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/app.rs",
        "range": {
          "startPosition": {
            "line": 174,
            "column": 51
          },
          "endPosition": {
            "line": 208,
            "column": 35
          }
        },
        "contents": "        div()\n            .flex()\n            .flex_col()\n            .size_full()\n            .bg(rgb(0x0f0f1a))\n            .text_color(rgb(0xffffff))\n            .p(px(16.0))\n            .gap(px(16.0))\n            // Header: plugin name\n            .child(\n                div().flex().flex_row().items_center().gap(px(8.0)).child(\n                    div()\n                        .text_size(px(20.0))\n                        .size_full()\n                        .bg(rgb(0x0000FF))\n                        .text_color(rgb(0xffffff))\n                        .child(\"test\".clone()),\n                ),\n            )\n            // Waveform\n            .child(waveform)\n            // Bottom: transport + params\n            .child(\n                div()\n                    .flex()\n                    .flex_row()\n                    .gap(px(24.0))\n                    .flex_1()\n                    .min_h(px(0.0))\n                    // Transport controls\n                    .child(\n                        div()\n                            .flex()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "        div()",
            "lineNumber": 177
          },
          {
            "text": "            .flex()",
            "lineNumber": 178
          },
          {
            "text": "            .flex_col()",
            "lineNumber": 179
          },
          {
            "text": "            .size_full()",
            "lineNumber": 180
          },
          {
            "text": "            .bg(rgb(0x0f0f1a))",
            "lineNumber": 181
          },
          {
            "text": "            .text_color(rgb(0xffffff))",
            "lineNumber": 182
          },
          {
            "text": "            .p(px(16.0))",
            "lineNumber": 183
          },
          {
            "text": "            .gap(px(16.0))",
            "lineNumber": 184
          },
          {
            "text": "            // Header: plugin name",
            "lineNumber": 185
          },
          {
            "text": "            .child(",
            "lineNumber": 186
          },
          {
            "text": "                div().flex().flex_row().items_center().gap(px(8.0)).child(",
            "lineNumber": 187
          },
          {
            "text": "                    div()",
            "lineNumber": 188
          },
          {
            "text": "                        .text_size(px(20.0))",
            "lineNumber": 189
          },
          {
            "text": "                        .size_full()",
            "lineNumber": 190
          },
          {
            "text": "                        .bg(rgb(0x0000FF))",
            "lineNumber": 191
          },
          {
            "text": "                        .text_color(rgb(0xffffff))",
            "lineNumber": 192
          },
          {
            "text": "                        .child(\"test\".clone()),",
            "lineNumber": 193
          },
          {
            "text": "                ),",
            "lineNumber": 194
          },
          {
            "text": "            )",
            "lineNumber": 195
          },
          {
            "text": "            // Waveform",
            "lineNumber": 196
          },
          {
            "text": "            .child(waveform)",
            "lineNumber": 197
          },
          {
            "text": "            // Bottom: transport + params",
            "lineNumber": 198
          },
          {
            "text": "            .child(",
            "lineNumber": 199
          },
          {
            "text": "                div()",
            "lineNumber": 200
          },
          {
            "text": "                    .flex()",
            "lineNumber": 201
          },
          {
            "text": "                    .flex_row()",
            "lineNumber": 202
          },
          {
            "text": "                    .gap(px(24.0))",
            "lineNumber": 203
          },
          {
            "text": "                    .flex_1()",
            "lineNumber": 204
          },
          {
            "text": "                    .min_h(px(0.0))",
            "lineNumber": 205
          },
          {
            "text": "                    // Transport controls",
            "lineNumber": 206
          },
          {
            "text": "                    .child(",
            "lineNumber": 207
          },
          {
            "text": "                        div()",
            "lineNumber": 208
          },
          {
            "text": "                            .flex()",
            "lineNumber": 209
          }
        ]
      },
      "score": 0.034045930951833725
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/engine.rs",
        "range": {
          "startPosition": {
            "line": 92,
            "column": 48
          },
          "endPosition": {
            "line": 138,
            "column": 1
          }
        },
        "contents": " {\n        unsafe { ffi::zpe_seek(self.ptr, sample_position) };\n    }\n\n    /// Return the current playback position in samples.\n    pub fn position(&amp;self) -&gt; u64 {\n        unsafe { ffi::zpe_get_position(self.ptr) }\n    }\n\n    /// Return the total length of the loaded file in samples.\n    /// Returns 0 if no file is loaded.\n    pub fn length(&amp;self) -&gt; u64 {\n        unsafe { ffi::zpe_get_length(self.ptr) }\n    }\n\n    /// Return the engine's output sample rate in Hz.\n    pub fn sample_rate(&amp;self) -&gt; f64 {\n        unsafe { ffi::zpe_get_sample_rate(self.ptr) }\n    }\n\n    /// Return the channel count of the loaded file.\n    /// Returns 0 if no file is loaded.\n    pub fn channels(&amp;self) -&gt; u32 {\n        unsafe { ffi::zpe_get_channel_count(self.ptr) }\n    }\n\n    /// Return true if the engine is currently playing.\n    pub fn is_playing(&amp;self) -&gt; bool {\n        unsafe { ffi::zpe_is_playing(self.ptr) }\n    }\n\n    /// Enable or disable looping.\n    pub fn set_looping(&amp;mut self, enable: bool) {\n        unsafe { ffi::zpe_set_looping(self.ptr, enable) };\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\nfn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {\n    let s = path\n        .to_str()\n        .ok_or_else(|| anyhow!(\"path is not valid UTF-8: {:?}\", path))?;\n    std::ffi::CString::new(s).map_err(|e| anyhow!(\"path contains null byte: {e}\"))\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": " {",
            "lineNumber": 93
          },
          {
            "text": "        unsafe { ffi::zpe_seek(self.ptr, sample_position) };",
            "lineNumber": 94
          },
          {
            "text": "    }",
            "lineNumber": 95
          },
          {
            "lineNumber": 96
          },
          {
            "text": "    /// Return the current playback position in samples.",
            "lineNumber": 97
          },
          {
            "text": "    pub fn position(&amp;self) -&gt; u64 {",
            "lineNumber": 98
          },
          {
            "text": "        unsafe { ffi::zpe_get_position(self.ptr) }",
            "lineNumber": 99
          },
          {
            "text": "    }",
            "lineNumber": 100
          },
          {
            "lineNumber": 101
          },
          {
            "text": "    /// Return the total length of the loaded file in samples.",
            "lineNumber": 102
          },
          {
            "text": "    /// Returns 0 if no file is loaded.",
            "lineNumber": 103
          },
          {
            "text": "    pub fn length(&amp;self) -&gt; u64 {",
            "lineNumber": 104
          },
          {
            "text": "        unsafe { ffi::zpe_get_length(self.ptr) }",
            "lineNumber": 105
          },
          {
            "text": "    }",
            "lineNumber": 106
          },
          {
            "lineNumber": 107
          },
          {
            "text": "    /// Return the engine's output sample rate in Hz.",
            "lineNumber": 108
          },
          {
            "text": "    pub fn sample_rate(&amp;self) -&gt; f64 {",
            "lineNumber": 109
          },
          {
            "text": "        unsafe { ffi::zpe_get_sample_rate(self.ptr) }",
            "lineNumber": 110
          },
          {
            "text": "    }",
            "lineNumber": 111
          },
          {
            "lineNumber": 112
          },
          {
            "text": "    /// Return the channel count of the loaded file.",
            "lineNumber": 113
          },
          {
            "text": "    /// Returns 0 if no file is loaded.",
            "lineNumber": 114
          },
          {
            "text": "    pub fn channels(&amp;self) -&gt; u32 {",
            "lineNumber": 115
          },
          {
            "text": "        unsafe { ffi::zpe_get_channel_count(self.ptr) }",
            "lineNumber": 116
          },
          {
            "text": "    }",
            "lineNumber": 117
          },
          {
            "lineNumber": 118
          },
          {
            "text": "    /// Return true if the engine is currently playing.",
            "lineNumber": 119
          },
          {
            "text": "    pub fn is_playing(&amp;self) -&gt; bool {",
            "lineNumber": 120
          },
          {
            "text": "        unsafe { ffi::zpe_is_playing(self.ptr) }",
            "lineNumber": 121
          },
          {
            "text": "    }",
            "lineNumber": 122
          },
          {
            "lineNumber": 123
          },
          {
            "text": "    /// Enable or disable looping.",
            "lineNumber": 124
          },
          {
            "text": "    pub fn set_looping(&amp;mut self, enable: bool) {",
            "lineNumber": 125
          },
          {
            "text": "        unsafe { ffi::zpe_set_looping(self.ptr, enable) };",
            "lineNumber": 126
          },
          {
            "text": "    }",
            "lineNumber": 127
          },
          {
            "text": "}",
            "lineNumber": 128
          },
          {
            "lineNumber": 129
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 130
          },
          {
            "text": "// Helpers",
            "lineNumber": 131
          },
          {
            "text": "// ---------------------------------------------------------------------------",
            "lineNumber": 132
          },
          {
            "lineNumber": 133
          },
          {
            "text": "fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;std::ffi::CString&gt; {",
            "lineNumber": 134
          },
          {
            "text": "    let s = path",
            "lineNumber": 135
          },
          {
            "text": "        .to_str()",
            "lineNumber": 136
          },
          {
            "text": "        .ok_or_else(|| anyhow!(\"path is not valid UTF-8: {:?}\", path))?;",
            "lineNumber": 137
          },
          {
            "text": "    std::ffi::CString::new(s).map_err(|e| anyhow!(\"path contains null byte: {e}\"))",
            "lineNumber": 138
          },
          {
            "text": "}",
            "lineNumber": 139
          }
        ]
      },
      "score": 0.03265583887696266
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./zloader/src/transport.rs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 6,
            "column": 74
          }
        },
        "contents": "//! Transport controls: rewind and play/stop.\n//!\n//! This module is kept for organisational clarity; the actual transport\n//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern\n//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.\n\n// (No standalone view needed  transport is rendered inline in app.rs.)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "//! Transport controls: rewind and play/stop.",
            "lineNumber": 1
          },
          {
            "text": "//!",
            "lineNumber": 2
          },
          {
            "text": "//! This module is kept for organisational clarity; the actual transport",
            "lineNumber": 3
          },
          {
            "text": "//! buttons are rendered inline in &#96;app.rs&#96; using the entity handle pattern",
            "lineNumber": 4
          },
          {
            "text": "//! so they can dispatch actions back to &#96;ZLoaderApp&#96;.",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "// (No standalone view needed  transport is rendered inline in app.rs.)",
            "lineNumber": 7
          }
        ]
      },
      "score": 0.025093259289860725
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I need to understand GPUI's mouse event API. Let me look at the GPUI documentation or source to understand how to handle mouse down, mouse move, and mouse up events on a div element.</details></think>

---

Let me check the GPUI API for mouse event handling.

---

<tool-use data-tool-type="unknown" data-tool-name="mcp-perplexity-user-perplexity-perplexity_ask">
<details>
<summary>Tool use: **mcp-perplexity-user-perplexity-perplexity_ask**</summary>


Parameters:

```json
{
  "tools": [
    {
      "name": "perplexity_ask",
      "parameters": "{\"messages\":[{\"role\":\"user\",\"content\":\"In GPUI (the Zed editor's UI framework for Rust), how do you handle mouse events like on_mouse_down, on_mouse_move, on_mouse_up on a div element? What is the API for drag interactions? I need the GPUI 0.2 API, not the older version.\"}],\"search_context_size\":\"high\"}",
      "serverName": "perplexity"
    }
  ]
}
```
Additional data:

```json
{
  "status": "success"
}
```
Result:

```json
{
  "result": "{\"content\":[{\"type\":\"text\",\"text\":\"In GPUI 0.2, mouse events like &#96;on_mouse_down&#96;, &#96;on_mouse_move&#96;, and &#96;on_mouse_up&#96; are **not direct methods on &#96;div()&#96; elements**. Instead, GPUI dispatches raw platform &#96;MouseEvent&#96;s (including &#96;MouseDownEvent&#96;, &#96;MouseMoveEvent&#96;, &#96;MouseUpEvent&#96;) to focused or hovered views via the &#96;View&#96; context, which you handle in your &#96;Render&#96; implementation or by implementing event traits[1][7].\\n\\n## Handling Mouse Events on a Div\\n\\n1. **Create a custom &#96;View&#96; that wraps your &#96;div&#96;** and implements event handling:\\n\\n&#96;&#96;&#96;rust\\nuse gpui::{*, prelude::*};\\n\\npub struct MyDiv {\\n    // View state\\n}\\n\\nimpl Render for MyDiv {\\n    fn render(&amp;mut self, _: &amp;mut Window, cx: &amp;mut ViewContext&lt;Self&gt;) -&gt; impl IntoElement {\\n        // Build your div with event styling if needed\\n        div()\\n            .on_mouse_down_outside(|event, cx| {\\n                // Optional: Dismiss on outside click\\n                cx.stop_propagation();\\n            })\\n            .child(\\\"Clickable div\\\")\\n    }\\n}\\n\\n// Handle raw events in the view context\\nimpl View for MyDiv {\\n    fn ui_name() -&gt; &amp;'static str { \\\"MyDiv\\\" }\\n}\\n\\nimpl MouseEventHandler for MyDiv {\\n    fn mouse_down(&amp;mut self, event: &amp;MouseDownEvent, cx: &amp;mut ViewContext&lt;Self&gt;) {\\n        println!(\\\"Mouse down at {:?}\\\", event.position);\\n        // Start drag or other logic\\n        cx.stop_propagation(); // Prevent parent handling\\n    }\\n\\n    fn mouse_move(&amp;mut self, event: &amp;MouseMoveEvent, cx: &amp;mut ViewContext&lt;Self&gt;) {\\n        println!(\\\"Mouse move at {:?}\\\", event.position);\\n    }\\n\\n    fn mouse_up(&amp;mut self, event: &amp;MouseUpEvent, cx: &amp;mut ViewContext&lt;Self&gt;) {\\n        println!(\\\"Mouse up at {:?}\\\", event.position);\\n    }\\n}\\n&#96;&#96;&#96;\\n\\n2. **Key methods available**:\\n   - &#96;div().on_mouse_down_outside()&#96; - Fires when clicking outside the element[3][8]\\n   - Raw events via &#96;MouseEventHandler&#96; trait: &#96;mouse_down()&#96;, &#96;mouse_move()&#96;, &#96;mouse_up()&#96;[1][7]\\n   - &#96;ClickEvent&#96; combines down+up for clicks, with &#96;click_count()&#96;, &#96;position()&#96;, &#96;is_right_click()&#96;[4]\\n\\n## Drag Interactions API\\n\\n**GPUI 0.2 provides &#96;AnyDrag&#96; for platform drag/drop and manual drag state**:\\n\\n&#96;&#96;&#96;rust\\nuse gpui::{AnyDrag, *};\\n\\nimpl Render for MyDraggableDiv {\\n    fn render(&amp;mut self, cx: &amp;mut ViewContext&lt;Self&gt;) -&gt; impl IntoElement {\\n        div()\\n            .draggable()  // Enables drag start\\n            .on_drag_start(|drag_state, cx| {\\n                // Return drag data\\n                drag_state.set_data(\\\"my-data\\\".to_string());\\n            })\\n            .on_drag_over(|drag_event, cx| {\\n                // Accept drop\\n                cx.dispatch_action(DragOver);\\n            })\\n            .on_drop(|drag_event, cx| {\\n                // Handle drop\\n                if let Some(data) = drag_event.data::&lt;String&gt;() {\\n                    println!(\\\"Dropped: {}\\\", data);\\n                }\\n            })\\n    }\\n}\\n&#96;&#96;&#96;\\n\\n**Manual drag state with &#96;AnyDrag&#96;**:\\n&#96;&#96;&#96;rust\\n// In mouse_down handler:\\nfn mouse_down(&amp;mut self, event: &amp;MouseDownEvent, cx: &amp;mut ViewContext&lt;Self&gt;) {\\n    let drag = AnyDrag::start(event.position, cx);\\n    // Track drag state in view\\n    cx.notify(); // Rerender to show drag preview\\n}\\n\\nfn mouse_move(&amp;mut self, event: &amp;MouseMoveEvent, cx: &amp;mut ViewContext&lt;Self&gt;) {\\n    if let Some(drag) = cx.global::&lt;AnyDrag&gt;() {\\n        // Update drag position\\n        drag.update(event.position);\\n    }\\n}\\n&#96;&#96;&#96;\\n\\n**Core drag APIs**:\\n- &#96;AnyDrag::start(position, cx)&#96; - Begin drag operation[5]\\n- &#96;drag_state.set_data(T)&#96; - Attach payload to drag[5]\\n- &#96;div().draggable()&#96; - Enable HTML5-style drag[3][8]\\n- Platform file drops via &#96;FileDropEvent&#96; (implements &#96;MouseEvent&#96;)[7]\\n\\n**Register your view**:\\n&#96;&#96;&#96;rust\\ncx.new(|_| MyDiv)  // Creates Entity handle[3]\\n&#96;&#96;&#96;\\n\\n**Note**: GPUI 0.2 lacks high-level &#96;on_drag&#96; component methods (unlike web frameworks). Use &#96;AnyDrag&#96; + manual &#96;MouseEventHandler&#96; for custom drags. For higher-level components, consider &#96;gpui-component&#96; 0.5+, which builds on GPUI 0.2 but adds utilities like &#96;Button::on_click()&#96;[3][8]. Search results lack full 0.2 drag examples; check Zed's source or &#96;docs.rs/gpui/0.2.2&#96; for ViewContext methods[5][12].\\n\\nCitations:\\n[1] https://docs.rs/gpui/latest/gpui/struct.MouseClickEvent.html\\n[2] https://github.com/zed-industries/zed/discussions/41673\\n[3] https://github.com/longbridge/gpui-component\\n[4] https://docs.rs/gpui/latest/gpui/enum.ClickEvent.html\\n[5] https://docs.rs/gpui\\n[6] https://docs.gpustack.ai/0.2/overview/\\n[7] https://docs.rs/gpui/latest/gpui/trait.MouseEvent.html\\n[8] https://longbridge.github.io/gpui-component/docs/getting-started\\n[9] https://www.gpui.rs\\n[10] https://longbridge.github.io/gpui-component/\\n[11] https://zed.dev/blog/gpui-2-on-preview\\n[12] https://crates.io/crates/gpui/0.2.0\\n[13] https://github.com/hedge-ops/gpui-tutorial\\n[14] https://github.com/Augani/adabraka-ui\\n[15] https://docs.rs/gpui_util\\n\"}]}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "on_mouse_down|on_mouse_move|on_mouse_up|MouseDownEvent|MouseMoveEvent|MouseUpEvent",
  "path": "/Users/b/code/z-plug",
  "glob": "**/*.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "on_mouse_down|on_mouse_move|on_mouse_up|MouseDownEvent|MouseMoveEvent|MouseUpEvent",
    "path": "/Users/b/code/z-plug",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The perplexity answer seems to be mixing up different versions and potentially hallucinating some APIs. Let me look at the actual GPUI crate documentation to see what mouse event methods are available on div elements.</details></think>

---

Let me check the actual GPUI API more carefully by looking at what's available in the dependency.

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2**  Run command: cd /Users/b/code/z-plug/zloader && rg "on_mouse|MouseDown|MouseUp|MouseMove|on_click|cursor_style" target/doc 2>/dev/null | head -30; echo "---"; rg "on_mouse_down\b" -l ~/.cargo/registry/src/*/gpui-*/src/ 2>/dev/null | head -10</summary>

```bash
cd /Users/b/code/z-plug/zloader && rg "on_mouse|MouseDown|MouseUp|MouseMove|on_click|cursor_style" target/doc 2>/dev/null | head -30; echo "---"; rg "on_mouse_down\b" -l ~/.cargo/registry/src/*/gpui-*/src/ 2>/dev/null | head -10
```
</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search**  Searched codebase "undefined"  **130** results in **1** directory</summary>

Directory: **/Users/b/.cargo/registry/src** (130 files)

| File |
|------|
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/tab_stop.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/taffy.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/view.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/keymap.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/action.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/gpui.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/element.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/prelude.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/shared_uri.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/assets.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/inspector.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/input.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/scene.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/geometry.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/path_builder.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/shared_string.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/test.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/util.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/svg_renderer.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/subscription.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system/line_layout.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/async_context.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/_ownership_and_data_flow.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/test_context.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system/line_wrapper.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/entity_map.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system/font_fallbacks.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/keyboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/platform.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/events.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/directx_atlas.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/keyboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/platform.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/events.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/app_menu.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system/line.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/directx_renderer.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/display.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/keystroke.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/wrapper.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/display.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/display_link.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/scap_screen_capture.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/clipboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/destination_list.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/xdg_desktop_portal.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/text_system/font_features.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/dispatcher.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/dispatcher.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/headless.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/vsync.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/system_settings.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/metal_renderer.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/metal_atlas.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/directx_devices.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/platform.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/screen_capture.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/text_system.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/util.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/attributed_string.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/direct_write.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/keyboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/keyboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/blade/blade_context.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/headless/client.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/keymap/context.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/colors.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/executor.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/asset_cache.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/blade/apple_compat.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/status_item.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/serial.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/clipboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/keymap/binding.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/arena.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/dispatcher.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/deferred.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/clipboard.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window/prompts.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/blade/blade_atlas.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/xim_handler.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/style.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/cursor.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/svg.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/event.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/blade/blade_renderer.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/image_cache.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/client.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/window_appearance.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/display.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test/platform.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/anchored.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/img.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/key_dispatch.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/animation.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test/dispatcher.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/client.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/uniform_list.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/display.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/text_system.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/list.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/surface.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test/window.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/mod.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/canvas.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test/display.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/text.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/open_type.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/blade.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/global.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/color.rs` |
| `index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/bounds_tree.rs` |

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "pub fn on_mouse_down|pub fn on_mouse_move|pub fn on_mouse_up|pub fn on_click",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "pub fn on_mouse_down|pub fn on_mouse_move|pub fn on_mouse_up|pub fn on_click",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "MouseDownEvent|MouseMoveEvent|MouseUpEvent",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/input.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "MouseDownEvent|MouseMoveEvent|MouseUpEvent",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/input.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "on_mouse|on_click|MouseDown|MouseUp|MouseMove",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "on_mouse|on_click|MouseDown|MouseUp|MouseMove",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs",
              "matches": [
                {
                  "lineNumber": 93,
                  "content": "pub struct MouseDownEvent {"
                },
                {
                  "lineNumber": 110,
                  "content": "impl Sealed for MouseDownEvent {}"
                },
                {
                  "lineNumber": 111,
                  "content": "impl InputEvent for MouseDownEvent {"
                },
                {
                  "lineNumber": 113,
                  "content": "        PlatformInput::MouseDown(self)"
                },
                {
                  "lineNumber": 116,
                  "content": "impl MouseEvent for MouseDownEvent {}"
                },
                {
                  "lineNumber": 120,
                  "content": "pub struct MouseUpEvent {"
                },
                {
                  "lineNumber": 134,
                  "content": "impl Sealed for MouseUpEvent {}"
                },
                {
                  "lineNumber": 135,
                  "content": "impl InputEvent for MouseUpEvent {"
                },
                {
                  "lineNumber": 137,
                  "content": "        PlatformInput::MouseUp(self)"
                },
                {
                  "lineNumber": 140,
                  "content": "impl MouseEvent for MouseUpEvent {}"
                },
                {
                  "lineNumber": 146,
                  "content": "    pub down: MouseDownEvent,"
                },
                {
                  "lineNumber": 149,
                  "content": "    pub up: MouseUpEvent,"
                },
                {
                  "lineNumber": 255,
                  "content": "    /// &#96;Mouse&#96;: Count of clicks from MouseUpEvent"
                },
                {
                  "lineNumber": 335,
                  "content": "pub struct MouseMoveEvent {"
                },
                {
                  "lineNumber": 346,
                  "content": "impl Sealed for MouseMoveEvent {}"
                },
                {
                  "lineNumber": 347,
                  "content": "impl InputEvent for MouseMoveEvent {"
                },
                {
                  "lineNumber": 349,
                  "content": "        PlatformInput::MouseMove(self)"
                },
                {
                  "lineNumber": 352,
                  "content": "impl MouseEvent for MouseMoveEvent {}"
                },
                {
                  "lineNumber": 354,
                  "content": "impl MouseMoveEvent {"
                },
                {
                  "lineNumber": 555,
                  "content": "    MouseDown(MouseDownEvent),"
                },
                {
                  "lineNumber": 557,
                  "content": "    MouseUp(MouseUpEvent),"
                },
                {
                  "lineNumber": 559,
                  "content": "    MouseMove(MouseMoveEvent),"
                },
                {
                  "lineNumber": 574,
                  "content": "            PlatformInput::MouseDown(event) =&gt; Some(event),"
                },
                {
                  "lineNumber": 575,
                  "content": "            PlatformInput::MouseUp(event) =&gt; Some(event),"
                },
                {
                  "lineNumber": 576,
                  "content": "            PlatformInput::MouseMove(event) =&gt; Some(event),"
                },
                {
                  "lineNumber": 588,
                  "content": "            PlatformInput::MouseDown(_) =&gt; None,"
                },
                {
                  "lineNumber": 589,
                  "content": "            PlatformInput::MouseUp(_) =&gt; None,"
                },
                {
                  "lineNumber": 590,
                  "content": "            PlatformInput::MouseMove(_) =&gt; None,"
                }
              ]
            }
          ],
          "totalLines": 28,
          "totalMatchedLines": 28
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "MouseDown|MouseUp|MouseMove",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/input.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "MouseDown|MouseUp|MouseMove",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/input.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs</summary>

</details>
</tool-use>

---

Now let me find how the element builder API exposes these events (the `on_mouse_down` etc. methods on `Div` / `Styled` elements).

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn on_mouse_down|fn on_mouse_move|fn on_mouse_up",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn on_mouse_down|fn on_mouse_move|fn on_mouse_up",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
              "matches": [
                {
                  "lineNumber": 121,
                  "content": "    pub fn on_mouse_down("
                },
                {
                  "lineNumber": 173,
                  "content": "    pub fn on_mouse_up("
                },
                {
                  "lineNumber": 226,
                  "content": "    pub fn on_mouse_down_out("
                },
                {
                  "lineNumber": 243,
                  "content": "    pub fn on_mouse_up_out("
                },
                {
                  "lineNumber": 263,
                  "content": "    pub fn on_mouse_move("
                },
                {
                  "lineNumber": 696,
                  "content": "    fn on_mouse_down("
                },
                {
                  "lineNumber": 751,
                  "content": "    fn on_mouse_up("
                },
                {
                  "lineNumber": 777,
                  "content": "    fn on_mouse_down_out("
                },
                {
                  "lineNumber": 790,
                  "content": "    fn on_mouse_up_out("
                },
                {
                  "lineNumber": 803,
                  "content": "    fn on_mouse_move("
                }
              ]
            }
          ],
          "totalLines": 10,
          "totalMatchedLines": 10
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now let me also look at the `InteractiveElement` trait to see the builder-style methods that can be chained on div elements.</details></think>

---

Now let me check the `InteractiveElement` trait methods to see the builder-style API for mouse events on elements.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn on_mouse_down|fn on_mouse_up|fn on_mouse_move|fn on_click|fn cursor_style",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/element.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn on_mouse_down|fn on_mouse_up|fn on_mouse_move|fn on_click|fn cursor_style",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/element.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "trait InteractiveElement",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "trait InteractiveElement",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
              "matches": [
                {
                  "lineNumber": 596,
                  "content": "pub trait InteractiveElement: Sized {"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a clear picture. Let me also check the `cx.listener()` pattern and the `on_drag_move`/`DragMoveEvent` to understand how drag interactions work in GPUI.

But actually, for waveform scrubbing, a simpler approach works: track a `dragging: bool` state on the `WaveformView`, use `on_mouse_down` to set it to true and seek, `on_mouse_move` to update position while dragging, and `on_mouse_up_out` + `on_mouse_up` to stop dragging. We also need the bounds to convert pixel position to sample position.
 
Looking at the API, `cx.listener()` wraps a closure that gets access to the view state (`&mut Self`), converting it into the callback signature that event handlers expect. So I can use `cx.listener(|this, event, window, cx| { ... })` on `on_mouse_down` and other handlers to access and mutate the `WaveformView` state.

The design needs a `WaveformEvent::Seek(u64)` enum that the view emits when the user scrubs, which `ZLoaderApp` subscribes to. I'll store the waveform bounds in the view state (updated during rendering) and use a helper method to convert mouse pixel positions to sample positions. The tricky part is that `on_mouse_move` only fires while the mouse is over the element, so I need to use `on_drag_move` instead, which continues firing even when dragging outside the bounds. I need to store the waveform bounds somewhere accessible to the event handlers. The cleanest approach is to keep `bounds` as a field on `WaveformView` and update it during the canvas prepaint callbackI can use `cx.update_entity` to mutate the view from within the callback by passing the entity handle through the closure.</details></think>

---

Let me look at how to get an entity handle from within the render context, which we'll need for tracking bounds.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn entity|fn handle|fn weak_entity",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn entity|fn handle|fn weak_entity",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
              "matches": [
                {
                  "lineNumber": 45,
                  "content": "    pub fn entity_id(&amp;self) -&gt; EntityId {"
                },
                {
                  "lineNumber": 50,
                  "content": "    pub fn entity(&amp;self) -&gt; Entity&lt;T&gt; {"
                },
                {
                  "lineNumber": 57,
                  "content": "    pub fn weak_entity(&amp;self) -&gt; WeakEntity&lt;T&gt; {"
                }
              ]
            }
          ],
          "totalLines": 3,
          "totalMatchedLines": 3
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I know that `cx.entity()` returns `Entity<T>` and `cx.weak_entity()` returns `WeakEntity<T>`. So we can get the entity handle from within the render method.

Now let me also check if `EventEmitter` is available and how to emit events from a view:</details></think>

---

Now let me check how `EventEmitter` works in GPUI and how subscribers work.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "trait EventEmitter|fn emit|cx\\.emit",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "trait EventEmitter|fn emit|cx\\.emit",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
              "matches": [
                {
                  "lineNumber": 723,
                  "content": "    pub fn emit&lt;Evt&gt;(&amp;mut self, event: Evt)"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "trait EventEmitter",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "trait EventEmitter",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/gpui.rs",
              "matches": [
                {
                  "lineNumber": 237,
                  "content": "pub trait EventEmitter&lt;E: Any&gt;: 'static {}"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs</summary>

</details>
</tool-use>

---

Now let me also check the `cx.listener()` signature for the `on_mouse_down` callback shape.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn listener",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn listener",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs",
              "matches": [
                {
                  "lineNumber": 252,
                  "content": "    pub fn listener&lt;E: ?Sized&gt;("
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app/context.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have all the information I need. Let me also check what `MouseMoveEvent` contains:</details></think>

---

Let me check the `MouseMoveEvent` struct and also the `cursor_style` method for setting the cursor to a pointer.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/interactive.rs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor_style|CursorStyle",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor_style|CursorStyle",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "cursor_style|CursorStyle",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "outputMode": "files_with_matches",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "cursor_style|CursorStyle",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "files_with_matches",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "files": {
          "files": [
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/app.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/style.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/text.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/platform.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/mac/platform.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/windows/util.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/platform.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/test/platform.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/headless/client.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland/client.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/wayland.rs",
            "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform/linux/x11/client.rs"
          ],
          "totalFiles": 16
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor_style",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor_style",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "cursor_style|set_cursor",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "cursor_style|set_cursor",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
              "matches": [
                {
                  "lineNumber": 680,
                  "content": "    pub(crate) cursor_styles: Vec&lt;CursorStyleRequest&gt;,"
                },
                {
                  "lineNumber": 705,
                  "content": "    cursor_styles_index: usize,"
                },
                {
                  "lineNumber": 726,
                  "content": "            cursor_styles: Vec::new(),"
                },
                {
                  "lineNumber": 748,
                  "content": "        self.cursor_styles.clear();"
                },
                {
                  "lineNumber": 762,
                  "content": "    pub(crate) fn cursor_style(&amp;self, window: &amp;Window) -&gt; Option&lt;CursorStyle&gt; {"
                }
              ]
            }
          ],
          "totalLines": 21,
          "totalMatchedLines": 21,
          "clientTruncated": true
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor\\b",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor\\b",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "CursorStyle\"",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "CursorStyle\"",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "enum CursorStyle",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "enum CursorStyle",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs",
              "matches": [
                {
                  "lineNumber": 1408,
                  "content": "pub enum CursorStyle {"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/platform.rs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have everything I need to create the plan. Let me also check if there's a `cursor` or `cursor_style` method on the `Styled` trait for setting hover cursor:</details></think>

---

Now let me check how to set cursor style on a div element.

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor|CursorStyle",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/style.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor|CursorStyle",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/style.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/style.rs",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "    CornersRefinement, CursorStyle, DefiniteLength, DevicePixels, Edges, EdgesRefinement, Font,"
                },
                {
                  "lineNumber": 258,
                  "content": "    pub mouse_cursor: Option&lt;CursorStyle&gt;,"
                }
              ]
            }
          ],
          "totalLines": 2,
          "totalMatchedLines": 2
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "mouse_cursor|cursor_pointer|fn cursor",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "mouse_cursor|cursor_pointer|fn cursor",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "mouse_cursor\"",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "mouse_cursor\"",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "mouse_cursor",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "mouse_cursor",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/elements/div.rs",
              "matches": [
                {
                  "lineNumber": 1696,
                  "content": "            || style.mouse_cursor.is_some()"
                },
                {
                  "lineNumber": 1835,
                  "content": "                                                if let Some(mouse_cursor) = drag.cursor_style {"
                },
                {
                  "lineNumber": 1836,
                  "content": "                                                    window.set_window_cursor_style(mouse_cursor);"
                },
                {
                  "lineNumber": 1839,
                  "content": "                                                if let Some(mouse_cursor) = style.mouse_cursor {"
                },
                {
                  "lineNumber": 1840,
                  "content": "                                                    window.set_cursor_style(mouse_cursor, hitbox);"
                },
                {
                  "lineNumber": 2069,
                  "content": "            || self.base_style.mouse_cursor.is_some()"
                },
                {
                  "lineNumber": 2082,
                  "content": "        let drag_cursor_style = self.base_style.as_ref().mouse_cursor;"
                },
                {
                  "lineNumber": 2538,
                  "content": "                style.mouse_cursor = drag.cursor_style;"
                }
              ]
            }
          ],
          "totalLines": 8,
          "totalMatchedLines": 8
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor\"",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor\"",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "mouse_cursor\"",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "mouse_cursor\"",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "Cursor",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "Cursor",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "    self as gpui, AbsoluteLength, AlignContent, AlignItems, BorderStyle, CursorStyle,"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fn cursor\"",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fn cursor\"",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2**  Run command: rg "fn cursor" /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs</summary>

```bash
rg "fn cursor" /Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs
```
</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "CursorStyle",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
  "context": 3,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "CursorStyle",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/styled.rs",
              "matches": [
                {
                  "lineNumber": 1,
                  "content": "use crate::{",
                  "isContextLine": true
                },
                {
                  "lineNumber": 2,
                  "content": "    self as gpui, AbsoluteLength, AlignContent, AlignItems, BorderStyle, CursorStyle,"
                },
                {
                  "lineNumber": 3,
                  "content": "    DefiniteLength, Display, Fill, FlexDirection, FlexWrap, Font, FontStyle, FontWeight,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 4,
                  "content": "    GridPlacement, Hsla, JustifyContent, Length, SharedString, StrikethroughStyle, StyleRefinement,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 5,
                  "content": "    TextAlign, TextOverflow, TextStyleRefinement, UnderlineStyle, WhiteSpace, px, relative, rems,",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 5,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
It seems like `CursorStyle` is imported in `styled.rs` but there's no helper method to set it on elements. Let me check how the cursor style is actually set on elements  maybe it's through the `hover` style or directly through the `Interactivity` struct.

Let me search for how cursor is used in existing GPUI code:</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "set_cursor_style|set_window_cursor",
  "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "set_cursor_style|set_window_cursor",
    "path": "/Users/b/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/b/code/z-plug": {
        "content": {
          "matches": [
            {
              "file": "../../.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gpui-0.2.2/src/window.rs",
              "matches": [
                {
                  "lineNumber": 1975,
                  "content": "        self.reset_cursor_style(cx);"
                },
                {
                  "lineNumber": 2351,
                  "content": "    pub fn set_cursor_style(&amp;mut self, style: CursorStyle, hitbox: &amp;Hitbox) {"
                },
                {
                  "lineNumber": 2361,
                  "content": "    /// &#96;set_cursor_style&#96;. This method should only be called during the prepaint"
                },
                {
                  "lineNumber": 2363,
                  "content": "    pub fn set_window_cursor_style(&amp;mut self, style: CursorStyle) {"
                },
                {
                  "lineNumber": 3527,
                  "content": "    fn reset_cursor_style(&amp;self, cx: &amp;mut App) {"
                }
              ]
            }
          ],
          "totalLines": 7,
          "totalMatchedLines": 7,
          "clientTruncated": true
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
OK, cursor style is set via `window.set_cursor_style(style, &hitbox)` or `window.set_window_cursor_style(style)`. It's not a simple `.cursor_pointer()` method on a div. For our purposes, we could set cursor style by hooking into the `hover` state or by doing it manually in the paint callback. But honestly for an MVP this isn't critical  the main feature is the scrub interaction.

Now I have all the information I need to create a comprehensive plan. Let me summarize:

## Plan

### Architecture
- `WaveformView` needs to handle mouse events for click-to-seek and drag-to-scrub


- Communication: emit a `WaveformEvent::Seek(u64)` event, which `ZLoaderApp` subscribes to (same pattern as `ParamsView` / `SliderEvent`)
- Bounds tracking: store `bounds` on `WaveformView`, updated from the canvas prepaint callback via the entity handle

### Changes to `waveform.rs`:
1. Add `WaveformEvent` enum with a `Seek(u64)` variant
2. Implement `EventEmitter<WaveformEvent>` for `WaveformView`
3. Add `dragging: bool` and `bounds: Bounds<Pixels>` fields to `WaveformView`
4. In `render()`:
   - Use `cx.weak_entity()` to get a handle, move it into the canvas prepaint callback to update `self.bounds`
   - Add mouse event listeners for down, move, and up to track dragging state and compute sample positions
   - Add `.capture_any_mouse_up()` to catch releases outside the element
   - Helper method `sample_position_from_mouse(&self, mouse_x: Pixels) -> u64`

### Changes to `app.rs`:
1. Subscribe to `WaveformEvent::Seek` on the waveform entity in `ZLoaderApp::new()`
2. In the handler: call `engine.seek(position)` and update `waveform.position`

### Bounds tracking detail:
I'm using the canvas prepaint callback to capture bounds and update the view via the entity handle. This approach means bounds are one frame behind, but that's imperceptible. On the very first frame before any paint, we'd use a default zero bounds which we handle by returning sample position 0.</details></think>

---

I now have a thorough understanding of the codebase and the GPUI 0.2.2 API. Let me create the plan.

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Waveform Scrub Interaction\n\n## Current State\n\nThe waveform in [&#96;zloader/src/waveform.rs&#96;](zloader/src/waveform.rs) is display-only: a &#96;canvas()&#96; element inside a &#96;div()&#96; that paints pre-computed peaks and a playhead line. There are no mouse event handlers. The audio engine in [&#96;zloader/src/engine.rs&#96;](zloader/src/engine.rs) already has a &#96;seek(sample_position: u64)&#96; method.\n\n## Design\n\nUse the same event-emitter pattern already established by &#96;ParamsView&#96;/&#96;SliderEvent&#96;: &#96;WaveformView&#96; emits a &#96;WaveformEvent::Seek(u64)&#96; event, and &#96;ZLoaderApp&#96; subscribes to it and calls &#96;engine.seek()&#96;.\n\nFor converting mouse pixel position to sample position, store the canvas bounds on &#96;WaveformView&#96; (updated each frame from the canvas prepaint callback via the entity handle).\n\n## Changes\n\n### 1. &#96;waveform.rs&#96; -- Add event type and mouse handlers\n\n**New event type:**\n&#96;&#96;&#96;rust\npub enum WaveformEvent {\n    Seek(u64),\n}\nimpl EventEmitter&lt;WaveformEvent&gt; for WaveformView {}\n&#96;&#96;&#96;\n\n**New fields on &#96;WaveformView&#96;:**\n- &#96;dragging: bool&#96; -- true while the left mouse button is held on the waveform\n- &#96;bounds: Bounds&lt;Pixels&gt;&#96; -- last-known canvas bounds (updated from prepaint callback each frame)\n\n**New imports:** &#96;EventEmitter&#96;, &#96;MouseButton&#96;, &#96;MouseDownEvent&#96;, &#96;MouseMoveEvent&#96;, &#96;MouseUpEvent&#96;\n\n**Helper method** on &#96;WaveformView&#96;:\n&#96;&#96;&#96;rust\nfn sample_from_mouse(&amp;self, mouse_position: Point&lt;Pixels&gt;) -&gt; u64 {\n    let x = f32::from(mouse_position.x) - f32::from(self.bounds.origin.x);\n    let width = f32::from(self.bounds.size.width);\n    if width &lt;= 0.0 || self.peaks.total_samples == 0 {\n        return 0;\n    }\n    let progress = (x / width).clamp(0.0, 1.0);\n    (progress as f64 * self.peaks.total_samples as f64) as u64\n}\n&#96;&#96;&#96;\n\n**Bounds tracking** -- In the canvas prepaint callback, update &#96;self.bounds&#96; via the entity handle:\n&#96;&#96;&#96;rust\nlet weak = cx.weak_entity();\ncanvas(\n    move |bounds, _window, cx| {\n        if let Some(entity) = weak.upgrade() {\n            entity.update(cx, |view, _cx| { view.bounds = bounds; });\n        }\n    },\n    // ... paint callback unchanged ...\n)\n&#96;&#96;&#96;\n\n**Mouse event handlers on the outer &#96;div()&#96;:**\n\n- &#96;.on_mouse_down(MouseButton::Left, cx.listener(|this, event, _window, cx| { ... }))&#96; -- Set &#96;this.dragging = true&#96;, compute sample position, update &#96;this.position&#96;, emit &#96;WaveformEvent::Seek&#96;, &#96;cx.notify()&#96;\n- &#96;.on_mouse_move(cx.listener(|this, event, _window, cx| { ... }))&#96; -- Only act if &#96;event.dragging()&#96; (left button held); compute sample position, update &#96;this.position&#96;, emit &#96;WaveformEvent::Seek&#96;, &#96;cx.notify()&#96;\n- &#96;.capture_any_mouse_up(cx.listener(|this, _event, _window, _cx| { this.dragging = false; }))&#96; -- Catches mouse-up anywhere (including outside the element) to end the drag\n\nThe &#96;on_mouse_move&#96; handler uses &#96;MouseMoveEvent::dragging()&#96; (returns true when left button is held) as an additional guard, so even if GPUI dispatches a move without a prior mouse-down on this element, nothing happens.\n\n### 2. &#96;app.rs&#96; -- Subscribe to seek events\n\nIn &#96;ZLoaderApp::new()&#96;, after creating the waveform entity, subscribe to &#96;WaveformEvent&#96;:\n\n&#96;&#96;&#96;rust\nlet state_for_seek = state.clone();\ncx.subscribe(&amp;waveform, move |_this, _waveform, event: &amp;WaveformEvent, cx| {\n    let WaveformEvent::Seek(position) = event;\n    if let Some(state_entity) = state_for_seek.upgrade() {\n        state_entity.update(cx, |s, _cx| {\n            s.engine.seek(*position);\n        });\n    }\n}).detach();\n&#96;&#96;&#96;\n\nUse a &#96;WeakEntity&#96; (via &#96;state.downgrade()&#96;) to avoid reference cycles, matching the existing pattern for param subscriptions.\n\n### 3. Avoid position timer overwrite during drag\n\nThe 30ms timer in &#96;app.rs&#96; (lines 88-130) polls &#96;engine.position()&#96; and writes it to &#96;waveform.position&#96;. During a drag, this would fight with the user's mouse-driven position. Fix: skip the waveform position update while &#96;dragging&#96; is true:\n\n&#96;&#96;&#96;rust\nwaveform_entity.update(cx, |w, cx| {\n    if !w.dragging {\n        w.position = position;\n        cx.notify();\n    }\n});\n&#96;&#96;&#96;\n\nThis requires &#96;dragging&#96; to be &#96;pub&#96; (or add a getter). Since the existing &#96;position&#96; field is already &#96;pub&#96;, keeping &#96;dragging&#96; pub is consistent.\n\n## Files Changed\n\n- [&#96;zloader/src/waveform.rs&#96;](zloader/src/waveform.rs) -- Event type, mouse handlers, bounds tracking, scrub logic\n- [&#96;zloader/src/app.rs&#96;](zloader/src/app.rs) -- Subscribe to seek events, guard timer update during drag\n",
  "name": "Waveform scrub interaction",
  "todos": [
    {
      "content": "Add WaveformEvent enum and EventEmitter impl in waveform.rs",
      "status": "pending",
      "id": "waveform-event"
    },
    {
      "content": "Add dragging/bounds fields and sample_from_mouse helper to WaveformView",
      "status": "pending",
      "id": "waveform-state"
    },
    {
      "content": "Add mouse down/move/up handlers and bounds tracking in WaveformView::render()",
      "status": "pending",
      "id": "waveform-handlers"
    },
    {
      "content": "Subscribe to WaveformEvent::Seek in ZLoaderApp::new() and call engine.seek()",
      "status": "pending",
      "id": "app-subscribe"
    },
    {
      "content": "Skip waveform position update in the 30ms timer while dragging",
      "status": "pending",
      "id": "app-timer-guard"
    },
    {
      "content": "cargo build to verify compilation",
      "status": "pending",
      "id": "build-verify"
    }
  ],
  "overview": "Add mouse interaction to the waveform display in zloader so that clicking or dragging on the waveform seeks the audio playhead to the corresponding position."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///Users/b/.cursor/plans/waveform_scrub_interaction_b88c96ea.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

_**User**_

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

_**Agent (model claude-4.6-sonnet-medium, mode Agent)**_

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [-] Add WaveformEvent enum and EventEmitter impl in waveform.rs
- [ ] Add dragging/bounds fields and sample_from_mouse helper to WaveformView
- [ ] Add mouse down/move/up handlers and bounds tracking in WaveformView::render()
- [ ] Subscribe to WaveformEvent::Seek in ZLoaderApp::new() and call engine.seek()
- [ ] Skip waveform position update in the 30ms timer while dragging
- [ ] cargo build to verify compilation

</details>
</tool-use>

---

Now I'll implement all the waveform changes in one go, then update `app.rs`.

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/b/code/z-plug/zloader/src/waveform.rs</summary>

Status: **loading**

</details>

</tool-use>

---

