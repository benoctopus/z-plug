<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session d952b9d0-53da-445e-8277-ceec3dd0ea5b (2026-02-16 20:51Z) -->

# Format wrappers execution plan (2026-02-16 20:51Z)

_**User**_

Please create a plan to execute on 2.3 Format Wrappers from @zig-plug-design.md 

---

_**Agent (model claude-4.5-sonnet, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user wants me to create a plan for implementing section 2.3 Format Wrappers from the design document. Let me first read that document to understand what needs to be done, and also explore the current state of the codebase to understand what already exists.</details></think>

---

Let me start by reading the design document and exploring the current codebase state in parallel.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/zig-plug-design.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="task_v2">
<details>
<summary>Tool use: **task_v2**</summary>


Parameters:

```json
{
  "description": "Explore current codebase state",
  "prompt": "Thoroughly explore the z-plug codebase at /Users/b/code/z-plug. I need to understand:\n\n1. The complete directory structure (all files and folders)\n2. What has already been implemented in src/core/ (read all files there)\n3. What exists in src/wrappers/ (if anything)\n4. What exists in src/bindings/ (especially clap and vst3 bindings - read key files)\n5. The current build.zig\n6. The current src/root.zig\n7. Any existing tests\n\nBe very thorough - read all source files. Return a comprehensive summary of what exists and what's implemented.",
  "subagentType": "explore",
  "model": "composer-1",
  "name": "explore"
}
```
Additional data:

```json
{
  "status": "success",
  "composerData": "{\"_v\":13,\"composerId\":\"task-toolu_01K9TBoc3GWwND7c973n1no5\",\"richText\":\"\",\"hasLoaded\":true,\"text\":\"\",\"fullConversationHeadersOnly\":[{\"bubbleId\":\"174b6f53-e7bc-4d3d-8fc9-32f9fcc8498a\",\"type\":2},{\"bubbleId\":\"d85f933a-7215-4eb7-aa27-f7ec63b691e7\",\"type\":2},{\"bubbleId\":\"95107c12-7f02-4848-aaf3-db33637a0838\",\"type\":2},{\"bubbleId\":\"1c039d6c-b286-40af-b467-b64478a96096\",\"type\":2},{\"bubbleId\":\"57dc49d0-9f4d-4c25-81ad-f62abd80bd04\",\"type\":2},{\"bubbleId\":\"be4e1b12-3314-4477-894a-4fac9b130563\",\"type\":2},{\"bubbleId\":\"b715ee57-dbae-42fe-b21f-dc9b22f6d3e4\",\"type\":2},{\"bubbleId\":\"c17583f1-a8bb-421b-8c6d-ac13991aeb40\",\"type\":2},{\"bubbleId\":\"a87b48ee-546b-42a9-86db-7845e9c5f175\",\"type\":2},{\"bubbleId\":\"5101dc25-eefd-44c5-9482-12c0850b1fa6\",\"type\":2},{\"bubbleId\":\"5ff3d7b7-4574-4521-ba7a-e0382781b571\",\"type\":2},{\"bubbleId\":\"198e956e-9526-4443-b927-2a0cdf9e3702\",\"type\":2},{\"bubbleId\":\"c5e2e168-41d9-4cd0-9d29-0fc086042408\",\"type\":2},{\"bubbleId\":\"378ade35-db85-46d1-989e-9f68330ab62c\",\"type\":2},{\"bubbleId\":\"63543b79-4d41-45b9-af42-a6793132f425\",\"type\":2},{\"bubbleId\":\"ca37a5a8-4701-4da1-ac6e-854481f43556\",\"type\":2},{\"bubbleId\":\"7da9ef2c-7bd6-43ff-9e41-3a4d2b864f30\",\"type\":2},{\"bubbleId\":\"80e55d13-1b58-4dbc-9ce8-af68f19fbe2d\",\"type\":2},{\"bubbleId\":\"8849348b-172d-4ab7-8a33-d01aad79c693\",\"type\":2},{\"bubbleId\":\"827f80c3-6a0c-4a18-a8b0-052083f27043\",\"type\":2},{\"bubbleId\":\"ee9baf04-a1d1-44c8-b4d5-72a574ea0c41\",\"type\":2},{\"bubbleId\":\"a8d30db3-8831-49f3-bd0c-dad4e2e9d27d\",\"type\":2},{\"bubbleId\":\"146585dd-0299-44cc-9271-a7213ea75937\",\"type\":2},{\"bubbleId\":\"f9497ad8-9db3-4cd6-a0ad-db008241caaf\",\"type\":2},{\"bubbleId\":\"a30006d2-08e8-4c50-847f-83e34b9489fc\",\"type\":2},{\"bubbleId\":\"28043d82-0e11-4179-95a7-8a178127d780\",\"type\":2},{\"bubbleId\":\"d95a5364-9cc3-4e12-9535-e7c974faeb96\",\"type\":2},{\"bubbleId\":\"8422e63a-6009-4a5a-821e-3c4ad7b7b50b\",\"type\":2},{\"bubbleId\":\"83cf5af5-6225-4c37-9342-1f368aeeb37e\",\"type\":2},{\"bubbleId\":\"1b434a9e-d4dd-48d4-a66e-6c45d0f04634\",\"type\":2},{\"bubbleId\":\"b220aa81-d944-4353-9a85-d8895eac88e0\",\"type\":2},{\"bubbleId\":\"4191c99d-0c2b-421b-a5b2-400620a583ff\",\"type\":2},{\"bubbleId\":\"3cf46475-daea-4c22-b2e1-c8edc6974541\",\"type\":2},{\"bubbleId\":\"a2175461-e781-4b45-9251-730f37868d4c\",\"type\":2},{\"bubbleId\":\"726dfa41-3bd7-4a92-b6e4-4c1ae438aec1\",\"type\":2},{\"bubbleId\":\"55d240b4-e8f8-4ce4-8450-ecccf70d110b\",\"type\":2},{\"bubbleId\":\"7a95b419-01e1-4844-a321-1648339759d7\",\"type\":2},{\"bubbleId\":\"14f849d8-e830-487b-9e0b-555d2591d0a0\",\"type\":2},{\"bubbleId\":\"48a54e61-ab30-4d39-ada7-2e571b6986b2\",\"type\":2},{\"bubbleId\":\"d4919d13-2256-4a84-aeb4-43b0913a488a\",\"type\":2},{\"bubbleId\":\"4b0d6a75-4a62-4d33-b9d3-10d909ba0c65\",\"type\":2},{\"bubbleId\":\"0b4cf422-6c1a-4f73-bc78-becc429a29f0\",\"type\":2}],\"conversationMap\":{\"174b6f53-e7bc-4d3d-8fc9-32f9fcc8498a\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f3c4ce7e-f134-40a2-a8e2-95ea0b4bd310\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nExploring the codebase. Gathering the directory structure and reading key files.\\\\n\\\"}\",\"d85f933a-7215-4eb7-aa27-f7ec63b691e7\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"1d3ecf21-ee06-439f-8188-67521c077337\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"tool\\\":15,\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"\\\",\\\"toolCallId\\\":\\\"tool_223045fa-6ceb-40e7-9c45-a2766a5d80a\\\",\\\"status\\\":\\\"error\\\",\\\"rawArgs\\\":\\\"\\\",\\\"name\\\":\\\"run_terminal_command_v2\\\",\\\"additionalData\\\":{\\\"status\\\":\\\"error\\\"},\\\"params\\\":\\\"{\\\\\\\"command\\\\\\\":\\\\\\\"find /Users/b/code/z-plug -type f -name \\\\\\\\\\\\\\\"*.zig\\\\\\\\\\\\\\\" | head -50\\\\\\\",\\\\\\\"cwd\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"options\\\\\\\":{\\\\\\\"timeout\\\\\\\":300000},\\\\\\\"parsingResult\\\\\\\":{\\\\\\\"executableCommands\\\\\\\":[{\\\\\\\"name\\\\\\\":\\\\\\\"find\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-type\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"f\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-name\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"*.zig\\\\\\\\\\\\\\\"\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"find /Users/b/code/z-plug -type f -name \\\\\\\\\\\\\\\"*.zig\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"head\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"number\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-50\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"head -50\\\\\\\"}]},\\\\\\\"requestedSandboxPolicy\\\\\\\":{\\\\\\\"type\\\\\\\":\\\\\\\"TYPE_WORKSPACE_READONLY\\\\\\\",\\\\\\\"networkAccess\\\\\\\":false,\\\\\\\"enableSharedBuildCache\\\\\\\":true}}\\\",\\\"error\\\":\\\"{\\\\\\\"clientVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"modelVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"actualErrorMessageOnlySendFromClientToServerNeverTheOtherWayAroundBecauseThatMayBeASecurityRisk\\\\\\\":\\\\\\\"This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\"}\\\"},\\\"capabilityType\\\":15}\",\"95107c12-7f02-4848-aaf3-db33637a0838\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"5f13259a-e024-40cc-902b-7312edd2119f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"tool\\\":15,\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"\\\",\\\"toolCallId\\\":\\\"tool_61944302-291c-4bf2-905f-48f25c4e951\\\",\\\"status\\\":\\\"error\\\",\\\"rawArgs\\\":\\\"\\\",\\\"name\\\":\\\"run_terminal_command_v2\\\",\\\"additionalData\\\":{\\\"status\\\":\\\"error\\\"},\\\"params\\\":\\\"{\\\\\\\"command\\\\\\\":\\\\\\\"find /Users/b/code/z-plug -type f | grep -E \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\.(zig|md|txt|json|toml|yaml|yml)$\\\\\\\\\\\\\\\" | sort\\\\\\\",\\\\\\\"cwd\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"options\\\\\\\":{\\\\\\\"timeout\\\\\\\":300000},\\\\\\\"parsingResult\\\\\\\":{\\\\\\\"executableCommands\\\\\\\":[{\\\\\\\"name\\\\\\\":\\\\\\\"find\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-type\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"f\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"find /Users/b/code/z-plug -type f\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"grep\\\\\\\",\\\\\\\"args\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"word\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"-E\\\\\\\"},{\\\\\\\"type\\\\\\\":\\\\\\\"string\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\.(zig|md|txt|json|toml|yaml|yml)$\\\\\\\\\\\\\\\"\\\\\\\"}],\\\\\\\"fullText\\\\\\\":\\\\\\\"grep -E \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\.(zig|md|txt|json|toml|yaml|yml)$\\\\\\\\\\\\\\\"\\\\\\\"},{\\\\\\\"name\\\\\\\":\\\\\\\"sort\\\\\\\",\\\\\\\"fullText\\\\\\\":\\\\\\\"sort\\\\\\\"}]},\\\\\\\"requestedSandboxPolicy\\\\\\\":{\\\\\\\"type\\\\\\\":\\\\\\\"TYPE_WORKSPACE_READONLY\\\\\\\",\\\\\\\"networkAccess\\\\\\\":false,\\\\\\\"enableSharedBuildCache\\\\\\\":true}}\\\",\\\"error\\\":\\\"{\\\\\\\"clientVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"modelVisibleErrorMessage\\\\\\\":\\\\\\\"Permission denied: This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\",\\\\\\\"actualErrorMessageOnlySendFromClientToServerNeverTheOtherWayAroundBecauseThatMayBeASecurityRisk\\\\\\\":\\\\\\\"This operation is not allowed in readonly mode. The subagent was launched with readonly: true, which restricts write operations.\\\\\\\"}\\\"},\\\"capabilityType\\\":15}\",\"1c039d6c-b286-40af-b467-b64478a96096\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"2a7ec2a8-e191-4f0c-b31f-cf89d1c5fe32\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_8f54d139-0063-4084-995c-17c89a62200\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_8f54d139-0063-4084-995c-17c89a62200\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*.zig\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/plugin.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/root.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/state.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/buffer.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/params.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/events.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/audio_layout.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/layout_tests.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/root.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"build.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/main.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/version.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/stream.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/process.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/plugin.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/host.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/factory/plugin.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/factory/preset_discovery.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/audio_ports_activation.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/event_registry.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/posix_fd_support.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/thread_pool.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/log.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/audio_ports_config_info.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/tail.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/voice_info.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/configurable_audio_ports.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/render.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/state_context.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/state.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/ambisonic.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/track_info.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/timer_support.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/thread_check.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/audio_ports.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/surround.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/note_ports.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/params.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/preset_load.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/context_menu.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/latency.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/remote_controls.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/gui.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/param_indication.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/note_name.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/ext/audio_ports_config.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/events.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/entry.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/audio_buffer.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/guid.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/view.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/types.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/stream.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/processor.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/param_changes.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/funknown.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/factory.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/events.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/controller.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/connection.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/component.zig\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/main.zig\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":63}]}\\\"},\\\"capabilityType\\\":15}\",\"57dc49d0-9f4d-4c25-81ad-f62abd80bd04\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"ddcc9755-6f3a-4ab7-95bb-5697502d0080\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_cd3e18e4-90e1-4442-b0eb-14ea3165215\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_cd3e18e4-90e1-4442-b0eb-14ea3165215\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/build.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/build.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/build.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n// Although this function looks imperative, it does not perform the build\\\\\\\\n// directly and instead it mutates the build graph (&#96;b&#96;) that will be then\\\\\\\\n// executed by an external runner. The functions in &#96;std.Build&#96; implement a DSL\\\\\\\\n// for defining build steps and express dependencies between them, allowing the\\\\\\\\n// build runner to parallelize the build automatically (and the cache system to\\\\\\\\n// know when a step doesn't need to be re-run).\\\\\\\\npub fn build(b: *std.Build) void {\\\\\\\\n    // Standard target options allow the person running &#96;zig build&#96; to choose\\\\\\\\n    // what target to build for. Here we do not override the defaults, which\\\\\\\\n    // means any target is allowed, and the default is native. Other options\\\\\\\\n    // for restricting supported target set are available.\\\\\\\\n    const target = b.standardTargetOptions(.{});\\\\\\\\n    // Standard optimization options allow the person running &#96;zig build&#96; to select\\\\\\\\n    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall. Here we do not\\\\\\\\n    // set a preferred release mode, allowing the user to decide how to optimize.\\\\\\\\n    const optimize = b.standardOptimizeOption(.{});\\\\\\\\n    // It's also possible to define more custom flags to toggle optional features\\\\\\\\n    // of this build script using &#96;b.option()&#96;. All defined flags (including\\\\\\\\n    // target and optimize options) will be listed when running &#96;zig build --help&#96;\\\\\\\\n    // in this directory.\\\\\\\\n\\\\\\\\n    // Low-level bindings modules for CLAP and VST3\\\\\\\\n    const clap_bindings = b.addModule(\\\\\\\\\\\\\\\"clap-bindings\\\\\\\\\\\\\\\", .{\\\\\\\\n        .root_source_file = b.path(\\\\\\\\\\\\\\\"src/bindings/clap/main.zig\\\\\\\\\\\\\\\"),\\\\\\\\n        .target = target,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    const vst3_bindings = b.addModule(\\\\\\\\\\\\\\\"vst3-bindings\\\\\\\\\\\\\\\", .{\\\\\\\\n        .root_source_file = b.path(\\\\\\\\\\\\\\\"src/bindings/vst3/root.zig\\\\\\\\\\\\\\\"),\\\\\\\\n        .target = target,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // Main framework module\\\\\\\\n    const mod = b.addModule(\\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\", .{\\\\\\\\n        .root_source_file = b.path(\\\\\\\\\\\\\\\"src/root.zig\\\\\\\\\\\\\\\"),\\\\\\\\n        .target = target,\\\\\\\\n        .imports = &amp;.{\\\\\\\\n            .{ .name = \\\\\\\\\\\\\\\"clap-bindings\\\\\\\\\\\\\\\", .module = clap_bindings },\\\\\\\\n            .{ .name = \\\\\\\\\\\\\\\"vst3-bindings\\\\\\\\\\\\\\\", .module = vst3_bindings },\\\\\\\\n        },\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // Here we define an executable. An executable needs to have a root module\\\\\\\\n    // which needs to expose a &#96;main&#96; function. While we could add a main function\\\\\\\\n    // to the module defined above, it's sometimes preferable to split business\\\\\\\\n    // logic and the CLI into two separate modules.\\\\\\\\n    //\\\\\\\\n    // If your goal is to create a Zig library for others to use, consider if\\\\\\\\n    // it might benefit from also exposing a CLI tool. A parser library for a\\\\\\\\n    // data serialization format could also bundle a CLI syntax checker, for example.\\\\\\\\n    //\\\\\\\\n    // If instead your goal is to create an executable, consider if users might\\\\\\\\n    // be interested in also being able to embed the core functionality of your\\\\\\\\n    // program in their own executable in order to avoid the overhead involved in\\\\\\\\n    // subprocessing your CLI tool.\\\\\\\\n    //\\\\\\\\n    // If neither case applies to you, feel free to delete the declaration you\\\\\\\\n    // don't need and to put everything under a single module.\\\\\\\\n    const exe = b.addExecutable(.{\\\\\\\\n        .name = \\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\",\\\\\\\\n        .root_module = b.createModule(.{\\\\\\\\n            // b.createModule defines a new module just like b.addModule but,\\\\\\\\n            // unlike b.addModule, it does not expose the module to consumers of\\\\\\\\n            // this package, which is why in this case we don't have to give it a name.\\\\\\\\n            .root_source_file = b.path(\\\\\\\\\\\\\\\"src/main.zig\\\\\\\\\\\\\\\"),\\\\\\\\n            // Target and optimization levels must be explicitly wired in when\\\\\\\\n            // defining an executable or library (in the root module), and you\\\\\\\\n            // can also hardcode a specific target for an executable or library\\\\\\\\n            // definition if desireable (e.g. firmware for embedded devices).\\\\\\\\n            .target = target,\\\\\\\\n            .optimize = optimize,\\\\\\\\n            // List of modules available for import in source files part of the\\\\\\\\n            // root module.\\\\\\\\n            .imports = &amp;.{\\\\\\\\n                // Here \\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\" is the name you will use in your source code to\\\\\\\\n                // import this module (e.g. &#96;@import(\\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\")&#96;). The name is\\\\\\\\n                // repeated because you are allowed to rename your imports, which\\\\\\\\n                // can be extremely useful in case of collisions (which can happen\\\\\\\\n                // importing modules from different packages).\\\\\\\\n                .{ .name = \\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\", .module = mod },\\\\\\\\n            },\\\\\\\\n        }),\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // This declares intent for the executable to be installed into the\\\\\\\\n    // install prefix when running &#96;zig build&#96; (i.e. when executing the default\\\\\\\\n    // step). By default the install prefix is &#96;zig-out/&#96; but can be overridden\\\\\\\\n    // by passing &#96;--prefix&#96; or &#96;-p&#96;.\\\\\\\\n    b.installArtifact(exe);\\\\\\\\n\\\\\\\\n    // This creates a top level step. Top level steps have a name and can be\\\\\\\\n    // invoked by name when running &#96;zig build&#96; (e.g. &#96;zig build run&#96;).\\\\\\\\n    // This will evaluate the &#96;run&#96; step rather than the default step.\\\\\\\\n    // For a top level step to actually do something, it must depend on other\\\\\\\\n    // steps (e.g. a Run step, as we will see in a moment).\\\\\\\\n    const run_step = b.step(\\\\\\\\\\\\\\\"run\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Run the app\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // This creates a RunArtifact step in the build graph. A RunArtifact step\\\\\\\\n    // invokes an executable compiled by Zig. Steps will only be executed by the\\\\\\\\n    // runner if invoked directly by the user (in the case of top level steps)\\\\\\\\n    // or if another step depends on it, so it's up to you to define when and\\\\\\\\n    // how this Run step will be executed. In our case we want to run it when\\\\\\\\n    // the user runs &#96;zig build run&#96;, so we create a dependency link.\\\\\\\\n    const run_cmd = b.addRunArtifact(exe);\\\\\\\\n    run_step.dependOn(&amp;run_cmd.step);\\\\\\\\n\\\\\\\\n    // By making the run step depend on the default step, it will be run from the\\\\\\\\n    // installation directory rather than directly from within the cache directory.\\\\\\\\n    run_cmd.step.dependOn(b.getInstallStep());\\\\\\\\n\\\\\\\\n    // This allows the user to pass arguments to the application in the build\\\\\\\\n    // command itself, like this: &#96;zig build run -- arg1 arg2 etc&#96;\\\\\\\\n    if (b.args) |args| {\\\\\\\\n        run_cmd.addArgs(args);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Creates an executable that will run &#96;test&#96; blocks from the provided module.\\\\\\\\n    // Here &#96;mod&#96; needs to define a target, which is why earlier we made sure to\\\\\\\\n    // set the releative field.\\\\\\\\n    const mod_tests = b.addTest(.{\\\\\\\\n        .root_module = mod,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // Test the CLAP bindings\\\\\\\\n    const clap_tests = b.addTest(.{\\\\\\\\n        .root_module = clap_bindings,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // Test the VST3 bindings\\\\\\\\n    const vst3_tests = b.addTest(.{\\\\\\\\n        .root_module = vst3_bindings,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // A run step that will run the test executable.\\\\\\\\n    const run_mod_tests = b.addRunArtifact(mod_tests);\\\\\\\\n    const run_clap_tests = b.addRunArtifact(clap_tests);\\\\\\\\n    const run_vst3_tests = b.addRunArtifact(vst3_tests);\\\\\\\\n\\\\\\\\n    // Creates an executable that will run &#96;test&#96; blocks from the executable's\\\\\\\\n    // root module. Note that test executables only test one module at a time,\\\\\\\\n    // hence why we have to create two separate ones.\\\\\\\\n    const exe_tests = b.addTest(.{\\\\\\\\n        .root_module = exe.root_module,\\\\\\\\n    });\\\\\\\\n\\\\\\\\n    // A run step that will run the second test executable.\\\\\\\\n    const run_exe_tests = b.addRunArtifact(exe_tests);\\\\\\\\n\\\\\\\\n    // A top level step for running all tests. dependOn can be called multiple\\\\\\\\n    // times and since the two run steps do not depend on one another, this will\\\\\\\\n    // make the two of them run in parallel.\\\\\\\\n    const test_step = b.step(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Run tests\\\\\\\\\\\\\\\");\\\\\\\\n    test_step.dependOn(&amp;run_mod_tests.step);\\\\\\\\n    test_step.dependOn(&amp;run_clap_tests.step);\\\\\\\\n    test_step.dependOn(&amp;run_vst3_tests.step);\\\\\\\\n    test_step.dependOn(&amp;run_exe_tests.step);\\\\\\\\n\\\\\\\\n    // Just like flags, top level steps are also listed in the &#96;--help&#96; menu.\\\\\\\\n    //\\\\\\\\n    // The Zig build system is entirely implemented in userland, which means\\\\\\\\n    // that it cannot hook into private compiler APIs. All compilation work\\\\\\\\n    // orchestrated by the build system will result in other Zig compiler\\\\\\\\n    // subcommands being invoked with the right flags defined. You can observe\\\\\\\\n    // these invocations when one fails (or you pass a flag to increase\\\\\\\\n    // verbosity) to validate assumptions and diagnose problems.\\\\\\\\n    //\\\\\\\\n    // Lastly, the Zig build system is relatively simple and self-contained,\\\\\\\\n    // and reading its source code will allow you to master it.\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":172}\\\"},\\\"capabilityType\\\":15}\",\"be4e1b12-3314-4477-894a-4fac9b130563\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f5d934e9-8f9a-4753-85b8-602fe578a9f9\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_ac884f4b-d799-41ef-a5ba-8b2e994633e\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_ac884f4b-d799-41ef-a5ba-8b2e994633e\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/root.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/root.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/root.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"/// Public API for plugin authors.\\\\\\\\n///\\\\\\\\n/// This module re-exports all core framework types that plugin authors need\\\\\\\\n/// to implement audio plugins for both CLAP and VST3.\\\\\\\\nconst std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n// Core plugin interface\\\\\\\\npub const Plugin = @import(\\\\\\\\\\\\\\\"core/plugin.zig\\\\\\\\\\\\\\\").Plugin;\\\\\\\\npub const ProcessStatus = @import(\\\\\\\\\\\\\\\"core/plugin.zig\\\\\\\\\\\\\\\").ProcessStatus;\\\\\\\\npub const ProcessContext = @import(\\\\\\\\\\\\\\\"core/plugin.zig\\\\\\\\\\\\\\\").ProcessContext;\\\\\\\\npub const EventOutputList = @import(\\\\\\\\\\\\\\\"core/plugin.zig\\\\\\\\\\\\\\\").EventOutputList;\\\\\\\\n\\\\\\\\n// Audio buffer types\\\\\\\\npub const Buffer = @import(\\\\\\\\\\\\\\\"core/buffer.zig\\\\\\\\\\\\\\\").Buffer;\\\\\\\\npub const AuxBuffers = @import(\\\\\\\\\\\\\\\"core/buffer.zig\\\\\\\\\\\\\\\").AuxBuffers;\\\\\\\\n\\\\\\\\n// Note and MIDI events\\\\\\\\npub const NoteEvent = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").NoteEvent;\\\\\\\\npub const NoteData = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").NoteData;\\\\\\\\npub const PolyValueData = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").PolyValueData;\\\\\\\\npub const MidiCCData = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").MidiCCData;\\\\\\\\npub const MidiChannelData = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").MidiChannelData;\\\\\\\\npub const MidiProgramData = @import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\").MidiProgramData;\\\\\\\\n\\\\\\\\n// Parameter system\\\\\\\\npub const Param = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").Param;\\\\\\\\npub const FloatParam = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").FloatParam;\\\\\\\\npub const IntParam = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").IntParam;\\\\\\\\npub const BoolParam = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").BoolParam;\\\\\\\\npub const ChoiceParam = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").ChoiceParam;\\\\\\\\npub const FloatRange = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").FloatRange;\\\\\\\\npub const IntRange = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").IntRange;\\\\\\\\npub const ParamFlags = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").ParamFlags;\\\\\\\\npub const ParamValues = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").ParamValues;\\\\\\\\npub const idHash = @import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\").idHash;\\\\\\\\n\\\\\\\\n// Audio I/O layout and configuration\\\\\\\\npub const AudioIOLayout = @import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\").AudioIOLayout;\\\\\\\\npub const BufferConfig = @import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\").BufferConfig;\\\\\\\\npub const ProcessMode = @import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\").ProcessMode;\\\\\\\\npub const MidiConfig = @import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\").MidiConfig;\\\\\\\\npub const Transport = @import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\").Transport;\\\\\\\\n\\\\\\\\n// State persistence\\\\\\\\npub const SaveContext = @import(\\\\\\\\\\\\\\\"core/state.zig\\\\\\\\\\\\\\\").SaveContext;\\\\\\\\npub const LoadContext = @import(\\\\\\\\\\\\\\\"core/state.zig\\\\\\\\\\\\\\\").LoadContext;\\\\\\\\npub const StateVersion = @import(\\\\\\\\\\\\\\\"core/state.zig\\\\\\\\\\\\\\\").StateVersion;\\\\\\\\n\\\\\\\\ntest {\\\\\\\\n    // Ensure all core module tests are run.\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/audio_layout.zig\\\\\\\\\\\\\\\"));\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/buffer.zig\\\\\\\\\\\\\\\"));\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/events.zig\\\\\\\\\\\\\\\"));\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/params.zig\\\\\\\\\\\\\\\"));\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/state.zig\\\\\\\\\\\\\\\"));\\\\\\\\n    std.testing.refAllDecls(@import(\\\\\\\\\\\\\\\"core/plugin.zig\\\\\\\\\\\\\\\"));\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":58}\\\"},\\\"capabilityType\\\":15}\",\"b715ee57-dbae-42fe-b21f-dc9b22f6d3e4\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"0b3fbb9e-8702-426f-9a83-f62a4648faed\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nReading core files and checking wrappers and bindings:\\\\n\\\"}\",\"c17583f1-a8bb-421b-8c6d-ac13991aeb40\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"0751fc74-b677-4619-93ff-8fa330842570\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_cc034697-a48c-49f1-b5dd-b340389590c\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_cc034697-a48c-49f1-b5dd-b340389590c\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/plugin.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/plugin.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/plugin.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":411}\\\"},\\\"capabilityType\\\":15}\",\"a87b48ee-546b-42a9-86db-7845e9c5f175\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"45960817-d1dd-4235-9abf-a60d79d10db0\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_bc6ef66b-066e-410c-9116-982c867e5b2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_bc6ef66b-066e-410c-9116-982c867e5b2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/buffer.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/buffer.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/buffer.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":344}\\\"},\\\"capabilityType\\\":15}\",\"5101dc25-eefd-44c5-9482-12c0850b1fa6\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"3c5201b3-be8d-4e5e-b43f-9fce6e6800ed\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_4e2d8591-072e-46c3-99fb-d89cb558268\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_4e2d8591-072e-46c3-99fb-d89cb558268\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/params.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/params.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/params.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":403}\\\"},\\\"capabilityType\\\":15}\",\"5ff3d7b7-4574-4521-ba7a-e0382781b571\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"7bf4066b-c9e6-41fb-b29a-3a764beadc21\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_2bef2004-dfab-4184-9e68-9d39e650247\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_2bef2004-dfab-4184-9e68-9d39e650247\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/events.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/events.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/events.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"/// Unified note and MIDI event types.\\\\\\\\n///\\\\\\\\n/// Both CLAP and VST3 wrappers translate their format-specific events into\\\\\\\\n/// this single tagged union. All events carry a sample-accurate &#96;timing&#96;\\\\\\\\n/// offset within the current process buffer.\\\\\\\\nconst std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n/// Common data for note on, note off, choke, and voice-terminated events.\\\\\\\\npub const NoteData = struct {\\\\\\\\n    /// Sample offset within the current process buffer.\\\\\\\\n    timing: u32,\\\\\\\\n    /// Host-assigned voice identifier, or &#96;null&#96; if not provided.\\\\\\\\n    voice_id: ?i32 = null,\\\\\\\\n    /// MIDI channel (0â€“15).\\\\\\\\n    channel: u8,\\\\\\\\n    /// MIDI note number (0â€“127).\\\\\\\\n    note: u8,\\\\\\\\n    /// Velocity in the range 0.0â€“1.0.\\\\\\\\n    velocity: f32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Common data for per-note (polyphonic) value events such as\\\\\\\\n/// poly pressure, tuning, vibrato, expression, brightness, volume, and pan.\\\\\\\\npub const PolyValueData = struct {\\\\\\\\n    /// Sample offset within the current process buffer.\\\\\\\\n    timing: u32,\\\\\\\\n    /// Host-assigned voice identifier, or &#96;null&#96; if not provided.\\\\\\\\n    voice_id: ?i32 = null,\\\\\\\\n    /// MIDI channel (0â€“15).\\\\\\\\n    channel: u8,\\\\\\\\n    /// MIDI note number (0â€“127).\\\\\\\\n    note: u8,\\\\\\\\n    /// The value for this event. The range depends on the event kind\\\\\\\\n    /// (typically 0.0â€“1.0 for pressure, or semitones for tuning).\\\\\\\\n    value: f32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Data for MIDI CC (control change) events.\\\\\\\\npub const MidiCCData = struct {\\\\\\\\n    /// Sample offset within the current process buffer.\\\\\\\\n    timing: u32,\\\\\\\\n    /// MIDI channel (0â€“15).\\\\\\\\n    channel: u8,\\\\\\\\n    /// MIDI CC number (0â€“127).\\\\\\\\n    cc: u8,\\\\\\\\n    /// CC value normalized to 0.0â€“1.0.\\\\\\\\n    value: f32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Data for channel-wide MIDI events that carry a single value\\\\\\\\n/// (channel pressure, pitch bend).\\\\\\\\npub const MidiChannelData = struct {\\\\\\\\n    /// Sample offset within the current process buffer.\\\\\\\\n    timing: u32,\\\\\\\\n    /// MIDI channel (0â€“15).\\\\\\\\n    channel: u8,\\\\\\\\n    /// The value for this event (0.0â€“1.0 for pressure,\\\\\\\\n    /// -1.0â€“1.0 for pitch bend).\\\\\\\\n    value: f32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Data for MIDI program change events.\\\\\\\\npub const MidiProgramData = struct {\\\\\\\\n    /// Sample offset within the current process buffer.\\\\\\\\n    timing: u32,\\\\\\\\n    /// MIDI channel (0â€“15).\\\\\\\\n    channel: u8,\\\\\\\\n    /// Program number (0â€“127).\\\\\\\\n    program: u8,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// A single note or MIDI event, unified across CLAP and VST3.\\\\\\\\n///\\\\\\\\n/// The wrappers translate format-specific events into this tagged union\\\\\\\\n/// before passing them to the plugin's &#96;process&#96; function.\\\\\\\\npub const NoteEvent = union(enum) {\\\\\\\\n    // -- Note events --\\\\\\\\n    /// A note-on event with velocity.\\\\\\\\n    note_on: NoteData,\\\\\\\\n    /// A note-off event with release velocity.\\\\\\\\n    note_off: NoteData,\\\\\\\\n    /// Abruptly stop a voice (no release phase).\\\\\\\\n    choke: NoteData,\\\\\\\\n    /// Sent by the plugin when a voice finishes naturally (output only).\\\\\\\\n    voice_terminated: NoteData,\\\\\\\\n\\\\\\\\n    // -- Per-note (polyphonic) expression events --\\\\\\\\n    /// Per-note aftertouch / poly pressure (0.0â€“1.0).\\\\\\\\n    poly_pressure: PolyValueData,\\\\\\\\n    /// Per-note tuning offset in semitones.\\\\\\\\n    poly_tuning: PolyValueData,\\\\\\\\n    /// Per-note vibrato amount (0.0â€“1.0).\\\\\\\\n    poly_vibrato: PolyValueData,\\\\\\\\n    /// Per-note expression amount (0.0â€“1.0).\\\\\\\\n    poly_expression: PolyValueData,\\\\\\\\n    /// Per-note brightness (0.0â€“1.0).\\\\\\\\n    poly_brightness: PolyValueData,\\\\\\\\n    /// Per-note volume/gain (0.0â€“1.0, linear).\\\\\\\\n    poly_volume: PolyValueData,\\\\\\\\n    /// Per-note pan (-1.0 left .. 1.0 right).\\\\\\\\n    poly_pan: PolyValueData,\\\\\\\\n\\\\\\\\n    // -- Channel-wide MIDI events --\\\\\\\\n    /// MIDI Control Change.\\\\\\\\n    midi_cc: MidiCCData,\\\\\\\\n    /// MIDI Channel Pressure (aftertouch).\\\\\\\\n    midi_channel_pressure: MidiChannelData,\\\\\\\\n    /// MIDI Pitch Bend (-1.0â€“1.0).\\\\\\\\n    midi_pitch_bend: MidiChannelData,\\\\\\\\n    /// MIDI Program Change.\\\\\\\\n    midi_program_change: MidiProgramData,\\\\\\\\n\\\\\\\\n    /// Returns the sample offset (timing) of this event within the buffer.\\\\\\\\n    pub fn timing(self: NoteEvent) u32 {\\\\\\\\n        return switch (self) {\\\\\\\\n            inline else =&gt; |data| data.timing,\\\\\\\\n        };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Returns the MIDI channel of this event, or &#96;null&#96; if not applicable.\\\\\\\\n    pub fn channel(self: NoteEvent) ?u8 {\\\\\\\\n        return switch (self) {\\\\\\\\n            .note_on, .note_off, .choke, .voice_terminated =&gt; |d| d.channel,\\\\\\\\n            .poly_pressure, .poly_tuning, .poly_vibrato, .poly_expression, .poly_brightness, .poly_volume, .poly_pan =&gt; |d| d.channel,\\\\\\\\n            .midi_cc =&gt; |d| d.channel,\\\\\\\\n            .midi_channel_pressure, .midi_pitch_bend =&gt; |d| d.channel,\\\\\\\\n            .midi_program_change =&gt; |d| d.channel,\\\\\\\\n        };\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Returns the voice ID of this event, or &#96;null&#96; if not applicable.\\\\\\\\n    pub fn voiceId(self: NoteEvent) ?i32 {\\\\\\\\n        return switch (self) {\\\\\\\\n            .note_on, .note_off, .choke, .voice_terminated =&gt; |d| d.voice_id,\\\\\\\\n            .poly_pressure, .poly_tuning, .poly_vibrato, .poly_expression, .poly_brightness, .poly_volume, .poly_pan =&gt; |d| d.voice_id,\\\\\\\\n            .midi_cc, .midi_channel_pressure, .midi_pitch_bend, .midi_program_change =&gt; null,\\\\\\\\n        };\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Tests\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"NoteEvent timing extraction\\\\\\\\\\\\\\\" {\\\\\\\\n    const on = NoteEvent{ .note_on = .{\\\\\\\\n        .timing = 42,\\\\\\\\n        .channel = 0,\\\\\\\\n        .note = 60,\\\\\\\\n        .velocity = 0.8,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(u32, 42), on.timing());\\\\\\\\n\\\\\\\\n    const cc = NoteEvent{ .midi_cc = .{\\\\\\\\n        .timing = 100,\\\\\\\\n        .channel = 3,\\\\\\\\n        .cc = 74,\\\\\\\\n        .value = 0.5,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(u32, 100), cc.timing());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"NoteEvent channel extraction\\\\\\\\\\\\\\\" {\\\\\\\\n    const off = NoteEvent{ .note_off = .{\\\\\\\\n        .timing = 0,\\\\\\\\n        .channel = 7,\\\\\\\\n        .note = 64,\\\\\\\\n        .velocity = 0.0,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(?u8, 7), off.channel());\\\\\\\\n\\\\\\\\n    const pb = NoteEvent{ .midi_pitch_bend = .{\\\\\\\\n        .timing = 10,\\\\\\\\n        .channel = 2,\\\\\\\\n        .value = 0.25,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(?u8, 2), pb.channel());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"NoteEvent voiceId extraction\\\\\\\\\\\\\\\" {\\\\\\\\n    const on = NoteEvent{ .note_on = .{\\\\\\\\n        .timing = 0,\\\\\\\\n        .voice_id = 42,\\\\\\\\n        .channel = 0,\\\\\\\\n        .note = 60,\\\\\\\\n        .velocity = 1.0,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(?i32, 42), on.voiceId());\\\\\\\\n\\\\\\\\n    const cc = NoteEvent{ .midi_cc = .{\\\\\\\\n        .timing = 0,\\\\\\\\n        .channel = 0,\\\\\\\\n        .cc = 1,\\\\\\\\n        .value = 0.0,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(?i32, null), cc.voiceId());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"NoteEvent voiceId defaults to null\\\\\\\\\\\\\\\" {\\\\\\\\n    const on = NoteEvent{ .note_on = .{\\\\\\\\n        .timing = 0,\\\\\\\\n        .channel = 0,\\\\\\\\n        .note = 60,\\\\\\\\n        .velocity = 0.5,\\\\\\\\n    } };\\\\\\\\n    try std.testing.expectEqual(@as(?i32, null), on.voiceId());\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":208}\\\"},\\\"capabilityType\\\":15}\",\"198e956e-9526-4443-b927-2a0cdf9e3702\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"5f31fee9-bf8f-4251-9eae-2751c2e67b26\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.035Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_63a908e5-1f63-4069-8892-80aa326f8fd\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_63a908e5-1f63-4069-8892-80aa326f8fd\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/state.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/state.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/state.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"/// State persistence interface for plugin presets.\\\\\\\\n///\\\\\\\\n/// The framework calls &#96;save&#96; and &#96;load&#96; callbacks provided by the plugin.\\\\\\\\n/// It wraps format-specific stream types (CLAP &#96;clap_ostream_t&#96;/&#96;clap_istream_t&#96;,\\\\\\\\n/// VST3 &#96;IBStream&#96;) into a simple reader/writer interface that plugins can use\\\\\\\\n/// to serialize their parameters and internal state.\\\\\\\\n///\\\\\\\\n/// Uses Zig 0.15.2's &#96;std.io.AnyReader&#96; and &#96;std.io.AnyWriter&#96; for type erasure.\\\\\\\\nconst std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n/// Version number type for state serialization versioning and migration.\\\\\\\\npub const StateVersion = u32;\\\\\\\\n\\\\\\\\n/// Context passed to the plugin's &#96;save&#96; function.\\\\\\\\npub const SaveContext = struct {\\\\\\\\n    /// Type-erased writer for writing binary data to the host's stream.\\\\\\\\n    writer: std.io.AnyWriter,\\\\\\\\n\\\\\\\\n    /// Write a single value of type &#96;T&#96; in native byte order.\\\\\\\\n    pub fn write(self: SaveContext, comptime T: type, value: T) !void {\\\\\\\\n        const bytes = std.mem.asBytes(&amp;value);\\\\\\\\n        try self.writer.writeAll(bytes);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Write a slice of bytes.\\\\\\\\n    pub fn writeBytes(self: SaveContext, bytes: []const u8) !void {\\\\\\\\n        try self.writer.writeAll(bytes);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Write a length-prefixed string (u32 length + UTF-8 bytes).\\\\\\\\n    pub fn writeString(self: SaveContext, str: []const u8) !void {\\\\\\\\n        const len: u32 = @intCast(str.len);\\\\\\\\n        try self.write(u32, len);\\\\\\\\n        try self.writer.writeAll(str);\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Context passed to the plugin's &#96;load&#96; function.\\\\\\\\npub const LoadContext = struct {\\\\\\\\n    /// Type-erased reader for reading binary data from the host's stream.\\\\\\\\n    reader: std.io.AnyReader,\\\\\\\\n    /// The version number of the saved state, for migration.\\\\\\\\n    version: StateVersion,\\\\\\\\n\\\\\\\\n    /// Read a single value of type &#96;T&#96; in native byte order.\\\\\\\\n    pub fn read(self: LoadContext, comptime T: type) !T {\\\\\\\\n        var value: T = undefined;\\\\\\\\n        const bytes = std.mem.asBytes(&amp;value);\\\\\\\\n        try self.reader.readNoEof(bytes);\\\\\\\\n        return value;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Read a fixed number of bytes into a buffer.\\\\\\\\n    pub fn readBytes(self: LoadContext, buffer: []u8) !void {\\\\\\\\n        try self.reader.readNoEof(buffer);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Read a length-prefixed string into an allocator-owned buffer.\\\\\\\\n    /// Caller owns the returned slice.\\\\\\\\n    pub fn readString(self: LoadContext, allocator: std.mem.Allocator) ![]u8 {\\\\\\\\n        const len = try self.read(u32);\\\\\\\\n        const buffer = try allocator.alloc(u8, len);\\\\\\\\n        errdefer allocator.free(buffer);\\\\\\\\n        try self.reader.readNoEof(buffer);\\\\\\\\n        return buffer;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Read a length-prefixed string into a provided fixed buffer.\\\\\\\\n    /// Returns the slice of &#96;buffer&#96; that was written to.\\\\\\\\n    pub fn readStringBounded(self: LoadContext, buffer: []u8) ![]u8 {\\\\\\\\n        const len = try self.read(u32);\\\\\\\\n        if (len &gt; buffer.len) return error.BufferTooSmall;\\\\\\\\n        const slice = buffer[0..len];\\\\\\\\n        try self.reader.readNoEof(slice);\\\\\\\\n        return slice;\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Magic bytes at the start of every saved state (\\\\\\\\\\\\\\\"ZPLG\\\\\\\\\\\\\\\" in ASCII).\\\\\\\\npub const MAGIC: u32 = 0x5A504C47;\\\\\\\\n\\\\\\\\n/// Write the standard state header (magic bytes + version).\\\\\\\\n///\\\\\\\\n/// Wrappers call this before delegating to the plugin's &#96;save&#96; callback.\\\\\\\\npub fn writeHeader(writer: std.io.AnyWriter, version: StateVersion) !void {\\\\\\\\n    try writer.writeInt(u32, MAGIC, .little);\\\\\\\\n    try writer.writeInt(u32, version, .little);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read and validate the standard state header, returning the version number.\\\\\\\\n///\\\\\\\\n/// Wrappers call this before delegating to the plugin's &#96;load&#96; callback.\\\\\\\\npub fn readHeader(reader: std.io.AnyReader) !StateVersion {\\\\\\\\n    const magic = try reader.readInt(u32, .little);\\\\\\\\n    if (magic != MAGIC) return error.InvalidStateMagic;\\\\\\\\n    const version = try reader.readInt(u32, .little);\\\\\\\\n    return version;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Tests\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"SaveContext write and read roundtrip\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Save\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    const save_ctx = SaveContext{ .writer = writer };\\\\\\\\n    try save_ctx.write(f32, 0.5);\\\\\\\\n    try save_ctx.write(u32, 42);\\\\\\\\n\\\\\\\\n    // Load\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const load_ctx = LoadContext{ .reader = reader, .version = 1 };\\\\\\\\n    const f = try load_ctx.read(f32);\\\\\\\\n    const u = try load_ctx.read(u32);\\\\\\\\n\\\\\\\\n    try std.testing.expectApproxEqAbs(@as(f32, 0.5), f, 1e-6);\\\\\\\\n    try std.testing.expectEqual(@as(u32, 42), u);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"SaveContext writeString and LoadContext readString\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Save\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    const save_ctx = SaveContext{ .writer = writer };\\\\\\\\n    try save_ctx.writeString(\\\\\\\\\\\\\\\"hello\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // Load (allocator-based)\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const load_ctx = LoadContext{ .reader = reader, .version = 1 };\\\\\\\\n    const allocator = std.testing.allocator;\\\\\\\\n    const str = try load_ctx.readString(allocator);\\\\\\\\n    defer allocator.free(str);\\\\\\\\n\\\\\\\\n    try std.testing.expectEqualStrings(\\\\\\\\\\\\\\\"hello\\\\\\\\\\\\\\\", str);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"LoadContext readStringBounded\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Save\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    const save_ctx = SaveContext{ .writer = writer };\\\\\\\\n    try save_ctx.writeString(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // Load (bounded)\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const load_ctx = LoadContext{ .reader = reader, .version = 1 };\\\\\\\\n    var read_buf: [64]u8 = undefined;\\\\\\\\n    const str = try load_ctx.readStringBounded(&amp;read_buf);\\\\\\\\n\\\\\\\\n    try std.testing.expectEqualStrings(\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\", str);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"LoadContext readStringBounded buffer too small\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Save\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    const save_ctx = SaveContext{ .writer = writer };\\\\\\\\n    try save_ctx.writeString(\\\\\\\\\\\\\\\"this is a long string\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    // Load (bounded with small buffer)\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const load_ctx = LoadContext{ .reader = reader, .version = 1 };\\\\\\\\n    var read_buf: [10]u8 = undefined;\\\\\\\\n    const result = load_ctx.readStringBounded(&amp;read_buf);\\\\\\\\n\\\\\\\\n    try std.testing.expectError(error.BufferTooSmall, result);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"writeHeader and readHeader roundtrip\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Write header\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    try writeHeader(writer, 42);\\\\\\\\n\\\\\\\\n    // Read header\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const version = try readHeader(reader);\\\\\\\\n\\\\\\\\n    try std.testing.expectEqual(@as(StateVersion, 42), version);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"readHeader detects invalid magic\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Write wrong magic\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    try writer.writeInt(u32, 0xDEADBEEF, .little);\\\\\\\\n    try writer.writeInt(u32, 1, .little);\\\\\\\\n\\\\\\\\n    // Read header\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const result = readHeader(reader);\\\\\\\\n\\\\\\\\n    try std.testing.expectError(error.InvalidStateMagic, result);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"writeBytes and readBytes\\\\\\\\\\\\\\\" {\\\\\\\\n    var buffer: [128]u8 = undefined;\\\\\\\\n    var stream = std.io.fixedBufferStream(&amp;buffer);\\\\\\\\n\\\\\\\\n    // Save\\\\\\\\n    const writer = stream.writer().any();\\\\\\\\n    const save_ctx = SaveContext{ .writer = writer };\\\\\\\\n    const data = [_]u8{ 1, 2, 3, 4, 5 };\\\\\\\\n    try save_ctx.writeBytes(&amp;data);\\\\\\\\n\\\\\\\\n    // Load\\\\\\\\n    stream.pos = 0;\\\\\\\\n    const reader = stream.reader().any();\\\\\\\\n    const load_ctx = LoadContext{ .reader = reader, .version = 1 };\\\\\\\\n    var read_data: [5]u8 = undefined;\\\\\\\\n    try load_ctx.readBytes(&amp;read_data);\\\\\\\\n\\\\\\\\n    try std.testing.expectEqualSlices(u8, &amp;data, &amp;read_data);\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":235}\\\"},\\\"capabilityType\\\":15}\",\"c5e2e168-41d9-4cd0-9d29-0fc086042408\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"ceaf4834-2c12-4fa3-83d5-d763fab37650\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_9d05e3ce-a4a2-4c1f-bc30-5c1eea243b2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_9d05e3ce-a4a2-4c1f-bc30-5c1eea243b2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/audio_layout.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/audio_layout.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/audio_layout.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"/// Audio I/O layout, buffer configuration, and transport types.\\\\\\\\n///\\\\\\\\n/// These are the foundational types that describe how a plugin connects to\\\\\\\\n/// the host's audio graph and what runtime processing parameters are in effect.\\\\\\\\nconst std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n/// Declares a supported channel configuration for a plugin.\\\\\\\\n///\\\\\\\\n/// A plugin provides one or more of these at comptime. The host picks\\\\\\\\n/// the first layout it can satisfy, so order them from most preferred\\\\\\\\n/// to least preferred.\\\\\\\\npub const AudioIOLayout = struct {\\\\\\\\n    /// Number of channels on the main input bus, or &#96;null&#96; for no main input\\\\\\\\n    /// (e.g. a synthesizer).\\\\\\\\n    main_input_channels: ?u32 = null,\\\\\\\\n    /// Number of channels on the main output bus, or &#96;null&#96; for no main output\\\\\\\\n    /// (e.g. an analyzer).\\\\\\\\n    main_output_channels: ?u32 = null,\\\\\\\\n    /// Channel counts for each auxiliary input bus.\\\\\\\\n    aux_input_ports: []const u32 = &amp;.{},\\\\\\\\n    /// Channel counts for each auxiliary output bus.\\\\\\\\n    aux_output_ports: []const u32 = &amp;.{},\\\\\\\\n    /// Optional human-readable name for this layout (e.g. \\\\\\\\\\\\\\\"Stereo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"5.1\\\\\\\\\\\\\\\").\\\\\\\\n    name: ?[:0]const u8 = null,\\\\\\\\n\\\\\\\\n    /// Mono in, mono out.\\\\\\\\n    pub const MONO: AudioIOLayout = .{\\\\\\\\n        .main_input_channels = 1,\\\\\\\\n        .main_output_channels = 1,\\\\\\\\n        .name = \\\\\\\\\\\\\\\"Mono\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /// Stereo in, stereo out.\\\\\\\\n    pub const STEREO: AudioIOLayout = .{\\\\\\\\n        .main_input_channels = 2,\\\\\\\\n        .main_output_channels = 2,\\\\\\\\n        .name = \\\\\\\\\\\\\\\"Stereo\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /// No input (instrument/synth), stereo out.\\\\\\\\n    pub const STEREO_OUT: AudioIOLayout = .{\\\\\\\\n        .main_input_channels = null,\\\\\\\\n        .main_output_channels = 2,\\\\\\\\n        .name = \\\\\\\\\\\\\\\"Stereo Out\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /// Returns the total number of input channels across all buses.\\\\\\\\n    pub fn totalInputChannels(self: AudioIOLayout) u32 {\\\\\\\\n        var total: u32 = self.main_input_channels orelse 0;\\\\\\\\n        for (self.aux_input_ports) |ch| {\\\\\\\\n            total += ch;\\\\\\\\n        }\\\\\\\\n        return total;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Returns the total number of output channels across all buses.\\\\\\\\n    pub fn totalOutputChannels(self: AudioIOLayout) u32 {\\\\\\\\n        var total: u32 = self.main_output_channels orelse 0;\\\\\\\\n        for (self.aux_output_ports) |ch| {\\\\\\\\n            total += ch;\\\\\\\\n        }\\\\\\\\n        return total;\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Runtime audio configuration provided by the host when the plugin is activated.\\\\\\\\npub const BufferConfig = struct {\\\\\\\\n    /// The host's current sample rate in Hz.\\\\\\\\n    sample_rate: f32,\\\\\\\\n    /// Minimum buffer size the host may pass to &#96;process&#96;, or &#96;null&#96; if unknown.\\\\\\\\n    min_buffer_size: ?u32 = null,\\\\\\\\n    /// Maximum buffer size the host may pass to &#96;process&#96;.\\\\\\\\n    max_buffer_size: u32,\\\\\\\\n    /// Whether processing is real-time, buffered, or offline.\\\\\\\\n    process_mode: ProcessMode = .realtime,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// How the host drives the plugin's processing.\\\\\\\\npub const ProcessMode = enum {\\\\\\\\n    /// Real-time processing at a fixed rate (normal playback).\\\\\\\\n    realtime,\\\\\\\\n    /// Real-time-like but at irregular intervals (VST3 \\\\\\\\\\\\\\\"prefetch\\\\\\\\\\\\\\\" mode).\\\\\\\\n    buffered,\\\\\\\\n    /// Offline rendering â€” the host may call &#96;process&#96; faster than real-time.\\\\\\\\n    offline,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Describes what kind of note/MIDI events a plugin wants to receive or send.\\\\\\\\npub const MidiConfig = enum {\\\\\\\\n    /// No MIDI I/O.\\\\\\\\n    none,\\\\\\\\n    /// Note on/off, poly pressure, and note expression events.\\\\\\\\n    basic,\\\\\\\\n    /// Everything in &#96;basic&#96; plus MIDI CC, pitch bend, channel pressure,\\\\\\\\n    /// and program change events.\\\\\\\\n    midi_cc,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Unified transport and timeline information, abstracted from both CLAP\\\\\\\\n/// (&#96;clap_event_transport_t&#96;) and VST3 (&#96;ProcessContext&#96;).\\\\\\\\n///\\\\\\\\n/// All optional fields are &#96;null&#96; when the host does not provide that\\\\\\\\n/// information.\\\\\\\\npub const Transport = struct {\\\\\\\\n    /// Whether the host transport is currently playing.\\\\\\\\n    playing: bool = false,\\\\\\\\n    /// Whether the host is recording.\\\\\\\\n    recording: bool = false,\\\\\\\\n    /// Whether loop/cycle mode is active.\\\\\\\\n    looping: bool = false,\\\\\\\\n\\\\\\\\n    /// Tempo in beats per minute, or &#96;null&#96; if unavailable.\\\\\\\\n    tempo: ?f64 = null,\\\\\\\\n\\\\\\\\n    /// Time signature numerator (e.g. 4 for 4/4), or &#96;null&#96; if unavailable.\\\\\\\\n    time_sig_numerator: ?i32 = null,\\\\\\\\n    /// Time signature denominator (e.g. 4 for 4/4), or &#96;null&#96; if unavailable.\\\\\\\\n    time_sig_denominator: ?i32 = null,\\\\\\\\n\\\\\\\\n    /// Current playback position in samples from the project start, or &#96;null&#96;.\\\\\\\\n    pos_samples: ?i64 = null,\\\\\\\\n    /// Current playback position in quarter-note beats, or &#96;null&#96;.\\\\\\\\n    pos_beats: ?f64 = null,\\\\\\\\n    /// Position of the current bar start in quarter-note beats, or &#96;null&#96;.\\\\\\\\n    bar_start_beats: ?f64 = null,\\\\\\\\n\\\\\\\\n    /// Loop start position in quarter-note beats, or &#96;null&#96;.\\\\\\\\n    loop_start_beats: ?f64 = null,\\\\\\\\n    /// Loop end position in quarter-note beats, or &#96;null&#96;.\\\\\\\\n    loop_end_beats: ?f64 = null,\\\\\\\\n\\\\\\\\n    /// A default transport with nothing playing and no timeline info.\\\\\\\\n    pub const EMPTY: Transport = .{};\\\\\\\\n};\\\\\\\\n\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n// Tests\\\\\\\\n// ---------------------------------------------------------------------------\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"AudioIOLayout MONO constant\\\\\\\\\\\\\\\" {\\\\\\\\n    const mono = AudioIOLayout.MONO;\\\\\\\\n    try std.testing.expectEqual(@as(?u32, 1), mono.main_input_channels);\\\\\\\\n    try std.testing.expectEqual(@as(?u32, 1), mono.main_output_channels);\\\\\\\\n    try std.testing.expectEqual(@as(usize, 0), mono.aux_input_ports.len);\\\\\\\\n    try std.testing.expectEqual(@as(usize, 0), mono.aux_output_ports.len);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"AudioIOLayout STEREO constant\\\\\\\\\\\\\\\" {\\\\\\\\n    const stereo = AudioIOLayout.STEREO;\\\\\\\\n    try std.testing.expectEqual(@as(?u32, 2), stereo.main_input_channels);\\\\\\\\n    try std.testing.expectEqual(@as(?u32, 2), stereo.main_output_channels);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"AudioIOLayout STEREO_OUT constant\\\\\\\\\\\\\\\" {\\\\\\\\n    const layout = AudioIOLayout.STEREO_OUT;\\\\\\\\n    try std.testing.expectEqual(@as(?u32, null), layout.main_input_channels);\\\\\\\\n    try std.testing.expectEqual(@as(?u32, 2), layout.main_output_channels);\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"AudioIOLayout totalInputChannels with aux ports\\\\\\\\\\\\\\\" {\\\\\\\\n    const layout = AudioIOLayout{\\\\\\\\n        .main_input_channels = 2,\\\\\\\\n        .main_output_channels = 2,\\\\\\\\n        .aux_input_ports = &amp;.{ 2, 1 },\\\\\\\\n    };\\\\\\\\n    try std.testing.expectEqual(@as(u32, 5), layout.totalInputChannels());\\\\\\\\n    try std.testing.expectEqual(@as(u32, 2), layout.totalOutputChannels());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"AudioIOLayout totalInputChannels with null main\\\\\\\\\\\\\\\" {\\\\\\\\n    const layout = AudioIOLayout{\\\\\\\\n        .main_input_channels = null,\\\\\\\\n        .main_output_channels = 2,\\\\\\\\n    };\\\\\\\\n    try std.testing.expectEqual(@as(u32, 0), layout.totalInputChannels());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"Transport EMPTY default\\\\\\\\\\\\\\\" {\\\\\\\\n    const t = Transport.EMPTY;\\\\\\\\n    try std.testing.expect(!t.playing);\\\\\\\\n    try std.testing.expect(!t.recording);\\\\\\\\n    try std.testing.expect(!t.looping);\\\\\\\\n    try std.testing.expectEqual(@as(?f64, null), t.tempo);\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":185}\\\"},\\\"capabilityType\\\":15}\",\"378ade35-db85-46d1-989e-9f68330ab62c\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"eab3adf7-cb73-487c-8ff0-46481be77fd9\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_f4467e24-bf52-4f93-a504-821720f775a\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_f4467e24-bf52-4f93-a504-821720f775a\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/wrappers/**/*.zig\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/wrappers/**/*.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\"}]}\\\"},\\\"capabilityType\\\":15}\",\"63543b79-4d41-45b9-af42-a6793132f425\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"6dd9cdb3-1778-48b7-a1eb-b1817f9955c0\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_1cd58662-2862-4986-bc0c-2ec938bf580\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_1cd58662-2862-4986-bc0c-2ec938bf580\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/main.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/main.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/main.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// CLAP Zig Bindings\\\\\\\\n// Derived from: https://git.sr.ht/~interpunct/clap-zig-bindings\\\\\\\\n// Licensed under GNU LGPL v3.0 or later (see LICENSE file in this directory)\\\\\\\\n// Modified for Zig 0.15.2 compatibility\\\\\\\\n\\\\\\\\npub const Version = @import(\\\\\\\\\\\\\\\"version.zig\\\\\\\\\\\\\\\").Version;\\\\\\\\npub const Entry = @import(\\\\\\\\\\\\\\\"entry.zig\\\\\\\\\\\\\\\").Entry;\\\\\\\\npub extern const clap_entry: Entry;\\\\\\\\n\\\\\\\\npub const PluginFactory = @import(\\\\\\\\\\\\\\\"factory/plugin.zig\\\\\\\\\\\\\\\").Factory;\\\\\\\\npub const preset_discovery = @import(\\\\\\\\\\\\\\\"factory/preset_discovery.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\npub const Host = @import(\\\\\\\\\\\\\\\"host.zig\\\\\\\\\\\\\\\").Host;\\\\\\\\npub const Plugin = @import(\\\\\\\\\\\\\\\"plugin.zig\\\\\\\\\\\\\\\").Plugin;\\\\\\\\npub const Process = @import(\\\\\\\\\\\\\\\"process.zig\\\\\\\\\\\\\\\").Process;\\\\\\\\npub const AudioBuffer = @import(\\\\\\\\\\\\\\\"audio_buffer.zig\\\\\\\\\\\\\\\").AudioBuffer;\\\\\\\\npub const events = @import(\\\\\\\\\\\\\\\"events.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\npub const IStream = @import(\\\\\\\\\\\\\\\"stream.zig\\\\\\\\\\\\\\\").IStream;\\\\\\\\npub const OStream = @import(\\\\\\\\\\\\\\\"stream.zig\\\\\\\\\\\\\\\").OStream;\\\\\\\\n\\\\\\\\npub const ext = @import(\\\\\\\\\\\\\\\"ext.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n/// the clap ABI version\\\\\\\\npub const version = Version{ .major = 1, .minor = 2, .revision = 2 };\\\\\\\\n/// string capacity for names that can be displayed to the user\\\\\\\\npub const name_capacity = 256;\\\\\\\\n/// string capacity for describing a path, like a parameter in a module\\\\\\\\n/// heirachy or path within a set of nested track groups. this is not\\\\\\\\n/// a capcity for describing a file path on the disk.\\\\\\\\npub const path_capacity = 1024;\\\\\\\\n\\\\\\\\n/// generic ID type\\\\\\\\npub const Id = enum(u32) { invalid_id = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\").math.maxInt(u32), _ };\\\\\\\\n\\\\\\\\n/// fixed point representation of beat time\\\\\\\\npub const BeatTime = enum(i64) {\\\\\\\\n    _,\\\\\\\\n\\\\\\\\n    pub fn fromBeats(beats: f64) BeatTime {\\\\\\\\n        return @enumFromInt(@as(i64, @intFromFloat(@round(beats * (1 &lt;&lt; 31)))));\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// fixed point representation of seconds time\\\\\\\\npub const SecTime = enum(i64) {\\\\\\\\n    _,\\\\\\\\n\\\\\\\\n    pub fn fromSecs(seconds: f64) SecTime {\\\\\\\\n        return @enumFromInt(@as(i64, @intFromFloat(@round(seconds * (1 &lt;&lt; 31)))));\\\\\\\\n    }\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const Timestamp = enum(u64) { unknown = 0, _ };\\\\\\\\n\\\\\\\\npub const Color = extern struct {\\\\\\\\n    alpha: u8,\\\\\\\\n    red: u8,\\\\\\\\n    green: u8,\\\\\\\\n    blue: u8,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// a pair of plugin ABI and plugin identifier.\\\\\\\\npub const UniversalPluginId = extern struct {\\\\\\\\n    /// plugin ABI name, in lowercase\\\\\\\\n    /// eg: \\\\\\\\\\\\\\\"clap\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"vst2\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"au\\\\\\\\\\\\\\\", ...\\\\\\\\n    abi: [*:0]const u8,\\\\\\\\n    /// plugin ID, formatted as follows:\\\\\\\\n    ///\\\\\\\\n    /// clap: use the plugin id\\\\\\\\n    ///   eg: \\\\\\\\\\\\\\\"com.u-he.diva\\\\\\\\\\\\\\\"\\\\\\\\n    ///\\\\\\\\n    /// au: format the string like \\\\\\\\\\\\\\\"type:subt:manu\\\\\\\\\\\\\\\"\\\\\\\\n    ///   eg: \\\\\\\\\\\\\\\"aumu:SgXT:VmbA\\\\\\\\\\\\\\\"\\\\\\\\n    ///\\\\\\\\n    /// vst2: print the id as a signed 32-bits integer\\\\\\\\n    ///   eg: \\\\\\\\\\\\\\\"-4382976\\\\\\\\\\\\\\\"\\\\\\\\n    ///\\\\\\\\n    /// vst3: pring the id as a standard UUID\\\\\\\\n    ///   eg: \\\\\\\\\\\\\\\"123e4567-e89b-12d3-a456-426614174000\\\\\\\\\\\\\\\"\\\\\\\\n    id: [*:0]const u8,\\\\\\\\n};\\\\\\\\n\\\\\\\\ntest {\\\\\\\\n    @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\").testing.refAllDeclsRecursive(@This());\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":87}\\\"},\\\"capabilityType\\\":15}\",\"ca37a5a8-4701-4da1-ac6e-854481f43556\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"b3e276f8-4566-425f-aa84-b26eea12ffc1\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_797d8458-fbb4-40f8-a722-90857548d44\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_797d8458-fbb4-40f8-a722-90857548d44\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/root.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/root.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/root.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API bindings root module\\\\\\\\n// Re-exports all VST3 binding submodules\\\\\\\\n\\\\\\\\npub const types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const funknown = @import(\\\\\\\\\\\\\\\"funknown.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const factory = @import(\\\\\\\\\\\\\\\"factory.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const component = @import(\\\\\\\\\\\\\\\"component.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const processor = @import(\\\\\\\\\\\\\\\"processor.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const controller = @import(\\\\\\\\\\\\\\\"controller.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const stream = @import(\\\\\\\\\\\\\\\"stream.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const events = @import(\\\\\\\\\\\\\\\"events.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const param_changes = @import(\\\\\\\\\\\\\\\"param_changes.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const connection = @import(\\\\\\\\\\\\\\\"connection.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const view = @import(\\\\\\\\\\\\\\\"view.zig\\\\\\\\\\\\\\\");\\\\\\\\npub const layout_tests = @import(\\\\\\\\\\\\\\\"layout_tests.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n// Commonly used types\\\\\\\\npub const TUID = types.TUID;\\\\\\\\npub const tresult = types.tresult;\\\\\\\\npub const kResultOk = types.kResultOk;\\\\\\\\npub const kResultFalse = types.kResultFalse;\\\\\\\\npub const kNoInterface = types.kNoInterface;\\\\\\\\n\\\\\\\\n// Commonly used GUIDs\\\\\\\\npub const IID_FUnknown = guid.IID_FUnknown;\\\\\\\\npub const IID_IPluginBase = guid.IID_IPluginBase;\\\\\\\\npub const IID_IPluginFactory = guid.IID_IPluginFactory;\\\\\\\\npub const IID_IComponent = guid.IID_IComponent;\\\\\\\\npub const IID_IAudioProcessor = guid.IID_IAudioProcessor;\\\\\\\\npub const IID_IEditController = guid.IID_IEditController;\\\\\\\\n\\\\\\\\ntest {\\\\\\\\n    @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\").testing.refAllDeclsRecursive(@This());\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":36}\\\"},\\\"capabilityType\\\":15}\",\"7da9ef2c-7bd6-43ff-9e41-3a4d2b864f30\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"32f2ceea-3e68-4857-91f9-52debe27c7f2\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nChecking wrappers, reading key binding files, and searching for tests and other important files:\\\\n\\\"}\",\"80e55d13-1b58-4dbc-9ce8-af68f19fbe2d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8540d086-bbb6-4c5d-b106-7dcad41728a1\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_413af562-79cc-4d34-8e40-ba9e216aa39\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_413af562-79cc-4d34-8e40-ba9e216aa39\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/entry.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/entry.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/entry.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const Version = @import(\\\\\\\\\\\\\\\"version.zig\\\\\\\\\\\\\\\").Version;\\\\\\\\npub const Entry = extern struct {\\\\\\\\n    version: Version,\\\\\\\\n    init: *const fn (plugin_path: [*:0]const u8) callconv(.c) bool,\\\\\\\\n    deinit: *const fn () callconv(.c) void,\\\\\\\\n    /// get the pointer to a factory. returns null if the factory is not provided. the\\\\\\\\n    /// returned pointer must not be freed by the caller. this function must be thread safe.\\\\\\\\n    getFactory: *const fn (factory_id: [*:0]const u8) callconv(.c) ?*const anyopaque,\\\\\\\\n};\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":10}\\\"},\\\"capabilityType\\\":15}\",\"8849348b-172d-4ab7-8a33-d01aad79c693\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"eb4bddd9-8bcd-4ffc-849a-24a67c372713\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_7bbf1a35-afd6-4aac-bca8-5dfd9b305b6\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_7bbf1a35-afd6-4aac-bca8-5dfd9b305b6\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/plugin.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/plugin.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/plugin.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const Version = @import(\\\\\\\\\\\\\\\"version.zig\\\\\\\\\\\\\\\").Version;\\\\\\\\nconst Process = @import(\\\\\\\\\\\\\\\"process.zig\\\\\\\\\\\\\\\").Process;\\\\\\\\n\\\\\\\\npub const Plugin = extern struct {\\\\\\\\n    pub const Descriptor = extern struct {\\\\\\\\n        clap_version: Version,\\\\\\\\n        /// arbitrary string, should be unique to plugin.\\\\\\\\n        /// encouraged to use reverse URI, eg: \\\\\\\\\\\\\\\"com.u-he.diva\\\\\\\\\\\\\\\"\\\\\\\\n        id: [*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"Diva\\\\\\\\\\\\\\\"\\\\\\\\n        name: [*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"u-he\\\\\\\\\\\\\\\"\\\\\\\\n        vendor: ?[*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"https://u-he.com/products/diva/\\\\\\\\\\\\\\\"\\\\\\\\n        url: ?[*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"https://dl.u-he.com/manuals/plugins/diva/Diva-user-guide.pdf\\\\\\\\\\\\\\\"\\\\\\\\n        manual_url: ?[*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"https://u-he.com/support/\\\\\\\\\\\\\\\"\\\\\\\\n        support_url: ?[*:0]const u8,\\\\\\\\n        /// arbitrary string, useful for hosts to be able\\\\\\\\n        /// to understand and compare to version strings.\\\\\\\\n        /// a regex-like expression which is likely to be\\\\\\\\n        /// understood by most hosts:\\\\\\\\n        /// MAJOR(.MINOR(.REVISION)?)?( (Alpha|Beta) XREV)?\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"1.4.4\\\\\\\\\\\\\\\"\\\\\\\\n        version: ?[*:0]const u8,\\\\\\\\n        /// eg: \\\\\\\\\\\\\\\"The spirit of analogue\\\\\\\\\\\\\\\"\\\\\\\\n        description: ?[*:0]const u8,\\\\\\\\n        /// arbitrary list of keywords. they can be used by the host indexer\\\\\\\\n        /// to classify the plugin. for standard features see &#96;Plugin.features&#96;.\\\\\\\\n        features: [*:null]const ?[*:0]const u8,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    pub const features = struct {\\\\\\\\n        // categories\\\\\\\\n        pub const instrument = \\\\\\\\\\\\\\\"instrument\\\\\\\\\\\\\\\";\\\\\\\\n        pub const audio_effect = \\\\\\\\\\\\\\\"audio-effect\\\\\\\\\\\\\\\";\\\\\\\\n        pub const note_effect = \\\\\\\\\\\\\\\"note-effect\\\\\\\\\\\\\\\";\\\\\\\\n        pub const note_detector = \\\\\\\\\\\\\\\"note-detector\\\\\\\\\\\\\\\";\\\\\\\\n        pub const analyzer = \\\\\\\\\\\\\\\"analyzer\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        // sub-categories\\\\\\\\n        pub const synthesizer = \\\\\\\\\\\\\\\"synthesizer\\\\\\\\\\\\\\\";\\\\\\\\n        pub const sampler = \\\\\\\\\\\\\\\"sampler\\\\\\\\\\\\\\\";\\\\\\\\n        pub const drum = \\\\\\\\\\\\\\\"drum\\\\\\\\\\\\\\\";\\\\\\\\n        pub const drum_machine = \\\\\\\\\\\\\\\"drum-machine\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const filter = \\\\\\\\\\\\\\\"filter\\\\\\\\\\\\\\\";\\\\\\\\n        pub const phaser = \\\\\\\\\\\\\\\"phaser\\\\\\\\\\\\\\\";\\\\\\\\n        pub const equalizer = \\\\\\\\\\\\\\\"equalizer\\\\\\\\\\\\\\\";\\\\\\\\n        pub const deesser = \\\\\\\\\\\\\\\"de-esser\\\\\\\\\\\\\\\";\\\\\\\\n        pub const phase_vocoder = \\\\\\\\\\\\\\\"phase-vocoder\\\\\\\\\\\\\\\";\\\\\\\\n        pub const granular = \\\\\\\\\\\\\\\"granular\\\\\\\\\\\\\\\";\\\\\\\\n        pub const frequency_shifter = \\\\\\\\\\\\\\\"frequency-shifter\\\\\\\\\\\\\\\";\\\\\\\\n        pub const pitch_shifter = \\\\\\\\\\\\\\\"pitch-shifter\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const distortion = \\\\\\\\\\\\\\\"distortion\\\\\\\\\\\\\\\";\\\\\\\\n        pub const transient_shaper = \\\\\\\\\\\\\\\"transient-shaper\\\\\\\\\\\\\\\";\\\\\\\\n        pub const compressor = \\\\\\\\\\\\\\\"compressor\\\\\\\\\\\\\\\";\\\\\\\\n        pub const expander = \\\\\\\\\\\\\\\"expander\\\\\\\\\\\\\\\";\\\\\\\\n        pub const gate = \\\\\\\\\\\\\\\"gate\\\\\\\\\\\\\\\";\\\\\\\\n        pub const limiter = \\\\\\\\\\\\\\\"limiter\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const flanger = \\\\\\\\\\\\\\\"flanger\\\\\\\\\\\\\\\";\\\\\\\\n        pub const chorus = \\\\\\\\\\\\\\\"chorus\\\\\\\\\\\\\\\";\\\\\\\\n        pub const delay = \\\\\\\\\\\\\\\"delay\\\\\\\\\\\\\\\";\\\\\\\\n        pub const reverb = \\\\\\\\\\\\\\\"reverb\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const tremolo = \\\\\\\\\\\\\\\"tremolo\\\\\\\\\\\\\\\";\\\\\\\\n        pub const glitch = \\\\\\\\\\\\\\\"glitch\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const utility = \\\\\\\\\\\\\\\"utility\\\\\\\\\\\\\\\";\\\\\\\\n        pub const pitch_correction = \\\\\\\\\\\\\\\"pitch-correction\\\\\\\\\\\\\\\";\\\\\\\\n        pub const restoration = \\\\\\\\\\\\\\\"restoration\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const multi_effects = \\\\\\\\\\\\\\\"multi-effects\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        pub const mixing = \\\\\\\\\\\\\\\"mixing\\\\\\\\\\\\\\\";\\\\\\\\n        pub const mastering = \\\\\\\\\\\\\\\"mastering\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n        // audio capabilities\\\\\\\\n        pub const mono = \\\\\\\\\\\\\\\"mono\\\\\\\\\\\\\\\";\\\\\\\\n        pub const stereo = \\\\\\\\\\\\\\\"stereo\\\\\\\\\\\\\\\";\\\\\\\\n        pub const surround = \\\\\\\\\\\\\\\"surround\\\\\\\\\\\\\\\";\\\\\\\\n        pub const ambisonic = \\\\\\\\\\\\\\\"ambisonic\\\\\\\\\\\\\\\";\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    descriptor: *const Descriptor,\\\\\\\\n    plugin_data: *anyopaque,\\\\\\\\n    /// must be called after creating the plugin. if init returns\\\\\\\\n    /// false the host must destroy the plugin instance. if init\\\\\\\\n    /// returns true the plugin is initialized and in the deactivated\\\\\\\\n    /// sate. unlike in &#96;Factory.createPlugin&#96;, in init you have\\\\\\\\n    /// complete access to the host and host extensions, so clap\\\\\\\\n    /// related setup activities should be done here rather than\\\\\\\\n    /// in &#96;Factory.createPlugin&#96;. must be run on main thread\\\\\\\\n    init: *const fn (plugin: *const Plugin) callconv(.c) bool,\\\\\\\\n    /// free the plugin and it's resources. it is required to\\\\\\\\n    /// call &#96;Plugin.deactivate&#96; before this. must be run on\\\\\\\\n    /// main thread.\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":118}\\\"},\\\"capabilityType\\\":15}\",\"827f80c3-6a0c-4a18-a8b0-052083f27043\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e88cf4e0-1d08-465c-ac40-2e9cd8d3b86e\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_4bf528d6-ea8a-45ab-8277-9f2a89dbf18\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_4bf528d6-ea8a-45ab-8277-9f2a89dbf18\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/factory.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/factory.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/factory.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API Bindings - Plugin Factory Interfaces\\\\\\\\n// Based on steinbergmedia/vst3_c_api\\\\\\\\n\\\\\\\\nconst types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst funknown = @import(\\\\\\\\\\\\\\\"funknown.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\nconst TUID = types.TUID;\\\\\\\\nconst tresult = types.tresult;\\\\\\\\nconst FIDString = types.FIDString;\\\\\\\\nconst vst3_callconv = types.vst3_callconv;\\\\\\\\nconst char16 = types.char16;\\\\\\\\n\\\\\\\\n// Factory info string capacity\\\\\\\\npub const kNameSize = 64;\\\\\\\\npub const kURLSize = 256;\\\\\\\\npub const kEmailSize = 128;\\\\\\\\n\\\\\\\\n/// Factory information\\\\\\\\npub const PFactoryInfo = extern struct {\\\\\\\\n    vendor: [kNameSize]u8,\\\\\\\\n    url: [kURLSize]u8,\\\\\\\\n    email: [kEmailSize]u8,\\\\\\\\n    flags: i32,\\\\\\\\n    \\\\\\\\n    pub const FactoryFlags = enum(i32) {\\\\\\\\n        kNoFlags = 0,\\\\\\\\n        kClassesDiscardable = 1 &lt;&lt; 0,\\\\\\\\n        kLicenseCheck = 1 &lt;&lt; 1,\\\\\\\\n        kComponentNonDiscardable = 1 &lt;&lt; 3,\\\\\\\\n        kUnicode = 1 &lt;&lt; 4,\\\\\\\\n    };\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Class information (version 1)\\\\\\\\npub const PClassInfo = extern struct {\\\\\\\\n    cid: TUID,\\\\\\\\n    cardinality: i32,\\\\\\\\n    category: [32]u8,\\\\\\\\n    name: [64]u8,\\\\\\\\n    \\\\\\\\n    pub const ClassCardinality = enum(i32) {\\\\\\\\n        kManyInstances = 0x7FFFFFFF,\\\\\\\\n    };\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Class information (version 2) - extends PClassInfo\\\\\\\\npub const PClassInfo2 = extern struct {\\\\\\\\n    cid: TUID,\\\\\\\\n    cardinality: i32,\\\\\\\\n    category: [32]u8,\\\\\\\\n    name: [64]u8,\\\\\\\\n    class_flags: u32,\\\\\\\\n    subcategories: [128]u8,\\\\\\\\n    vendor: [64]u8,\\\\\\\\n    version: [64]u8,\\\\\\\\n    sdk_version: [64]u8,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Class information (Unicode version)\\\\\\\\npub const PClassInfoW = extern struct {\\\\\\\\n    cid: TUID,\\\\\\\\n    cardinality: i32,\\\\\\\\n    category: [32]u8,\\\\\\\\n    name: [128]char16,\\\\\\\\n    class_flags: u32,\\\\\\\\n    subcategories: [128]u8,\\\\\\\\n    vendor: [128]char16,\\\\\\\\n    version: [64]char16,\\\\\\\\n    sdk_version: [64]char16,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// IPluginFactory interface\\\\\\\\npub const IPluginFactoryVtbl = extern struct {\\\\\\\\n    // FUnknown methods\\\\\\\\n    queryInterface: *const fn (*anyopaque, *const TUID, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n    addRef: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    release: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    \\\\\\\\n    // IPluginFactory methods\\\\\\\\n    getFactoryInfo: *const fn (*anyopaque, *PFactoryInfo) callconv(.c) tresult,\\\\\\\\n    countClasses: *const fn (*anyopaque) callconv(.c) i32,\\\\\\\\n    getClassInfo: *const fn (*anyopaque, i32, *PClassInfo) callconv(.c) tresult,\\\\\\\\n    createInstance: *const fn (*anyopaque, FIDString, FIDString, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IPluginFactory = extern struct {\\\\\\\\n    lpVtbl: *const IPluginFactoryVtbl,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IID_IPluginFactory = guid.IID_IPluginFactory;\\\\\\\\n\\\\\\\\n/// IPluginFactory2 interface (adds getClassInfo2)\\\\\\\\npub const IPluginFactory2Vtbl = extern struct {\\\\\\\\n    // FUnknown methods\\\\\\\\n    queryInterface: *const fn (*anyopaque, *const TUID, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n    addRef: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    release: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    \\\\\\\\n    // IPluginFactory methods\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":149}\\\"},\\\"capabilityType\\\":15}\",\"ee9baf04-a1d1-44c8-b4d5-72a574ea0c41\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"a5a53194-63da-4d9a-a570-1962faaadcd4\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_63c6cf4a-cb6a-4f4f-9543-05d525c438a\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_63c6cf4a-cb6a-4f4f-9543-05d525c438a\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/component.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/component.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":100,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/component.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API Bindings - IComponent Interface\\\\\\\\n// Based on steinbergmedia/vst3_c_api\\\\\\\\n\\\\\\\\nconst types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst funknown = @import(\\\\\\\\\\\\\\\"funknown.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\nconst TUID = types.TUID;\\\\\\\\nconst tresult = types.tresult;\\\\\\\\nconst vst3_callconv = types.vst3_callconv;\\\\\\\\nconst TBool = types.TBool;\\\\\\\\nconst MediaType = types.MediaType;\\\\\\\\nconst BusDirection = types.BusDirection;\\\\\\\\nconst BusType = types.BusType;\\\\\\\\nconst String128 = types.String128;\\\\\\\\n\\\\\\\\n/// Bus information\\\\\\\\npub const BusInfo = extern struct {\\\\\\\\n    media_type: MediaType,\\\\\\\\n    direction: BusDirection,\\\\\\\\n    channel_count: i32,\\\\\\\\n    name: String128,\\\\\\\\n    bus_type: BusType,\\\\\\\\n    flags: u32,\\\\\\\\n    \\\\\\\\n    pub const BusFlags = enum(u32) {\\\\\\\\n        kDefaultActive = 1 &lt;&lt; 0,\\\\\\\\n        kIsControlVoltage = 1 &lt;&lt; 1,\\\\\\\\n    };\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Routing information\\\\\\\\npub const RoutingInfo = extern struct {\\\\\\\\n    media_type: MediaType,\\\\\\\\n    bus_index: i32,\\\\\\\\n    channel: i32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// IPluginBase interface (base for IComponent)\\\\\\\\npub const IPluginBaseVtbl = extern struct {\\\\\\\\n    // FUnknown methods\\\\\\\\n    queryInterface: *const fn (*anyopaque, *const TUID, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n    addRef: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    release: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    \\\\\\\\n    // IPluginBase methods\\\\\\\\n    initialize: *const fn (*anyopaque, *anyopaque) callconv(.c) tresult,\\\\\\\\n    terminate: *const fn (*anyopaque) callconv(.c) tresult,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IPluginBase = extern struct {\\\\\\\\n    lpVtbl: *const IPluginBaseVtbl,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IID_IPluginBase = guid.IID_IPluginBase;\\\\\\\\n\\\\\\\\n// Forward declarations for IBStream\\\\\\\\npub const IBStream = extern struct {\\\\\\\\n    lpVtbl: *anyopaque,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// IComponent interface\\\\\\\\npub const IComponentVtbl = extern struct {\\\\\\\\n    // FUnknown methods\\\\\\\\n    queryInterface: *const fn (*anyopaque, *const TUID, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n    addRef: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    release: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    \\\\\\\\n    // IPluginBase methods\\\\\\\\n    initialize: *const fn (*anyopaque, *anyopaque) callconv(.c) tresult,\\\\\\\\n    terminate: *const fn (*anyopaque) callconv(.c) tresult,\\\\\\\\n    \\\\\\\\n    // IComponent methods\\\\\\\\n    getControllerClassId: *const fn (*anyopaque, *TUID) callconv(.c) tresult,\\\\\\\\n    setIoMode: *const fn (*anyopaque, types.IoMode) callconv(.c) tresult,\\\\\\\\n    getBusCount: *const fn (*anyopaque, MediaType, BusDirection) callconv(.c) i32,\\\\\\\\n    getBusInfo: *const fn (*anyopaque, MediaType, BusDirection, i32, *BusInfo) callconv(.c) tresult,\\\\\\\\n    getRoutingInfo: *const fn (*anyopaque, *RoutingInfo, *RoutingInfo) callconv(.c) tresult,\\\\\\\\n    activateBus: *const fn (*anyopaque, MediaType, BusDirection, i32, TBool) callconv(.c) tresult,\\\\\\\\n    setActive: *const fn (*anyopaque, TBool) callconv(.c) tresult,\\\\\\\\n    setState: *const fn (*anyopaque, *IBStream) callconv(.c) tresult,\\\\\\\\n    getState: *const fn (*anyopaque, *IBStream) callconv(.c) tresult,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IComponent = extern struct {\\\\\\\\n    lpVtbl: *const IComponentVtbl,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IID_IComponent = guid.IID_IComponent;\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"BusInfo size\\\\\\\\\\\\\\\" {\\\\\\\\n    const testing = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\").testing;\\\\\\\\n    // Verify the struct has the expected fields\\\\\\\\n    try testing.expectEqual(@as(usize, @offsetOf(BusInfo, \\\\\\\\\\\\\\\"media_type\\\\\\\\\\\\\\\")), 0);\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":96}\\\"},\\\"capabilityType\\\":15}\",\"a8d30db3-8831-49f3-bd0c-dad4e2e9d27d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"49fa171a-06b3-4c0c-a6d6-6f0f771f1533\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b3ab0dfc-3be0-45fc-93cd-429b8aaac66\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b3ab0dfc-3be0-45fc-93cd-429b8aaac66\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/main.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/main.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/main.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const std = @import(\\\\\\\\\\\\\\\"std\\\\\\\\\\\\\\\");\\\\\\\\nconst z_plug = @import(\\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\npub fn main() !void {\\\\\\\\n    // Prints to stderr, ignoring potential errors.\\\\\\\\n    std.debug.print(\\\\\\\\\\\\\\\"All your {s} are belong to us.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\", .{\\\\\\\\\\\\\\\"codebase\\\\\\\\\\\\\\\"});\\\\\\\\n    try z_plug.bufferedPrint();\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"simple test\\\\\\\\\\\\\\\" {\\\\\\\\n    const gpa = std.testing.allocator;\\\\\\\\n    var list: std.ArrayList(i32) = .empty;\\\\\\\\n    defer list.deinit(gpa); // Try commenting this out and see if zig detects the memory leak!\\\\\\\\n    try list.append(gpa, 42);\\\\\\\\n    try std.testing.expectEqual(@as(i32, 42), list.pop());\\\\\\\\n}\\\\\\\\n\\\\\\\\ntest \\\\\\\\\\\\\\\"fuzz example\\\\\\\\\\\\\\\" {\\\\\\\\n    const Context = struct {\\\\\\\\n        fn testOne(context: @This(), input: []const u8) anyerror!void {\\\\\\\\n            _ = context;\\\\\\\\n            // Try passing &#96;--fuzz&#96; to &#96;zig build test&#96; and see if it manages to fail this test case!\\\\\\\\n            try std.testing.expect(!std.mem.eql(u8, \\\\\\\\\\\\\\\"canyoufindme\\\\\\\\\\\\\\\", input));\\\\\\\\n        }\\\\\\\\n    };\\\\\\\\n    try std.testing.fuzz(Context{}, Context.testOne, .{});\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":28}\\\"},\\\"capabilityType\\\":15}\",\"146585dd-0299-44cc-9271-a7213ea75937\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"bfd27a8f-1d2b-4dbc-96f8-5b7958f4f1ae\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_f7627cba-f039-4a71-83d8-1092f610950\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_f7627cba-f039-4a71-83d8-1092f610950\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*test*.zig\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*test*.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/layout_tests.zig\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":1}]}\\\"},\\\"capabilityType\\\":15}\",\"f9497ad8-9db3-4cd6-a0ad-db008241caaf\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"bbadff1b-9cfa-4b91-9e30-a30eaa03088c\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b85e1343-d5f3-448b-9203-a0eeeeea881\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b85e1343-d5f3-448b-9203-a0eeeeea881\\\",\\\"status\\\":\\\"error\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/*.md\\\\\\\"}\\\",\\\"result\\\":\\\"{}\\\",\\\"error\\\":\\\"{\\\\\\\"clientVisibleErrorMessage\\\\\\\":\\\\\\\"Path does not exist: /Users/code/z-plug\\\\\\\",\\\\\\\"modelVisibleErrorMessage\\\\\\\":\\\\\\\"Path does not exist: /Users/code/z-plug\\\\\\\"}\\\"},\\\"capabilityType\\\":15}\",\"a30006d2-08e8-4c50-847f-83e34b9489fc\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"03f15aa2-7573-45e8-b1f8-f0f660fa3a90\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nChecking directory structure and reading more files:\\\\n\\\"}\",\"28043d82-0e11-4179-95a7-8a178127d780\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"7c4d6909-5eaa-4125-9817-cf41779cd6e5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_48a1a869-d5f5-459e-8f13-6098854b9e8\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_48a1a869-d5f5-459e-8f13-6098854b9e8\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/layout_tests.zig\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/layout_tests.zig\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/layout_tests.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":360}\\\"},\\\"capabilityType\\\":15}\",\"d95a5364-9cc3-4e12-9535-e7c974faeb96\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e84d4077-f410-449b-9a40-99331370c918\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_bb28b307-57ab-4f01-88f2-132b430f281\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_bb28b307-57ab-4f01-88f2-132b430f281\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_bb28b307-57ab-4f01-88f2-132b430f281\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{\\\\\\\"matches\\\\\\\":[{\\\\\\\"file\\\\\\\":\\\\\\\"./.specstory/history/2026-02-16_20-46Z-format-wrappers-execution-plan.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"# Format wrappers execution plan (2026-02-16 20:46Z)\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":44,\\\\\\\"content\\\\\\\":\\\\\\\"Now I need to understand the current state of the codebase. Let me explore the existing code to understand what's already been implemented and what needs to be done for the format wrappers.&lt;/details&gt;&lt;/think&gt;\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":48,\\\\\\\"content\\\\\\\":\\\\\\\"Let me explore the existing codebase to understand what's already implemented before planning the format wrappers.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":73,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"composerData\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":13,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"composerId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-toolu_011Wg5bw5Bh9JxYNXAzdS6sS\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"richText\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hasLoaded\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":true,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"fullConversationHeadersOnly\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a7b9f6b0-2b19-4535-bac0-adedf3865f59\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"84a2bb42-06de-4478-a993-5d7bf1c6129a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"079c9905-315d-49c5-810f-10da33d56faa\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0ed51878-0aac-446a-9e8e-7d7a540c93f1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c07451d5-d937-4b5f-b777-40ff10543b06\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"189140ac-3d3a-4da5-a8bc-522575daf34d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"393fa7e7-b85d-4939-8274-b2744fed3a63\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ad34f797-5ea9-41fb-85b2-0bdc3ddc9f47\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aebcca83-abb2-46da-8917-1b6dfd29dab8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c6d767e2-8261-4df6-9519-0b17305e16fe\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dfe65f8a-9739-4c74-b983-88d2e760a59c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e9f1834b-3b99-4f7f-aa80-d1a18200aec4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"f6e5e47c-2c [... omitted end of long line]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":92,\\\\\\\"content\\\\\\\":\\\\\\\"Now I have a comprehensive understanding of the codebase. Let me read the key files that will be most relevant for the format wrappers - the plugin interface, the bindings entry points, and the build system.&lt;/details&gt;&lt;/think&gt;\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":96,\\\\\\\"content\\\\\\\":\\\\\\\"Now let me read the key files that the wrappers will need to interface with.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":145,\\\\\\\"content\\\\\\\":\\\\\\\"Let me read the key binding files that the wrappers will need to directly interface with.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":315,\\\\\\\"content\\\\\\\":\\\\\\\"Now I have a thorough understanding of the codebase. Let me also read the audio_layout and buffer files quickly, and then I'll be able to formulate a comprehensive plan for implementing the format wrappers (section 2.3).&lt;/details&gt;&lt;/think&gt;\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":392,\\\\\\\"content\\\\\\\":\\\\\\\"For the implementation approach, I need to use comptime-generic wrappers parameterized by the plugin type &#96;T&#96; so the wrapper code gets generated specifically for each plugin. The CLAP wrapper will be a struct holding the CLAP plugin with its function pointers, the descriptor, and a pointer to the user's plugin instance.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":398,\\\\\\\"content\\\\\\\":\\\\\\\"The build system needs updating to compile shared libraries for both plugin formats, and I'm scoping this work around getting functional CLAP and VST3 wrappers that handle the core lifecycle, process calls with proper event and buffer translation, and the essential extensions like parameters and audio ports.&lt;/details&gt;&lt;/think&gt;\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./README.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":60,\\\\\\\"content\\\\\\\":\\\\\\\"  wrappers/        # Format-specific wrappers (planned)\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./AGENTS.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"zig-plug is an audio plugin framework for Zig 0.15.2 that lets a plugin author write one Zig module and produce both **VST3** and **CLAP** binaries from the same source. The architecture is inspired by **nih-plug** (Rust): an API-agnostic &#96;PluginInterface&#96; with thin format-specific wrappers that translate between the internal interface and the external ABI.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":141,\\\\\\\"content\\\\\\\":\\\\\\\"  wrappers/\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":196,\\\\\\\"content\\\\\\\":\\\\\\\"- **&#96;docs/architecture.md&#96;** â€” How the four layers (plugin code â†’ core â†’ wrappers â†’ bindings) fit together, data flow, key design decisions\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":236,\\\\\\\"content\\\\\\\":\\\\\\\"- When modifying the plugin interface, update both CLAP and VST3 wrappers to maintain parity.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./src/bindings/vst3/README.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":150,\\\\\\\"content\\\\\\\":\\\\\\\"The VST3 wrapper (&#96;src/wrappers/vst3/&#96;) uses these bindings to implement the COM ABI:\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./src/bindings/clap/README.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":10,\\\\\\\"content\\\\\\\":\\\\\\\"- **No framework logic** â€” Pure ABI translation; wrappers in &#96;src/wrappers/clap/&#96; add framework integration\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":101,\\\\\\\"content\\\\\\\":\\\\\\\"The CLAP wrapper (&#96;src/wrappers/clap/&#96;) uses these bindings to implement the CLAP ABI:\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./docs/getting-started.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":109,\\\\\\\"content\\\\\\\":\\\\\\\"â”‚   â””â”€â”€ wrappers/                  # Format-specific wrappers (planned)\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":156,\\\\\\\"content\\\\\\\":\\\\\\\"When adding a new directory under &#96;src/&#96; (e.g., &#96;src/wrappers/clap/&#96;):\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./.specstory/history/2026-02-16_20-27Z-2-2-framework-core-execution-plan.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":49,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"composerData\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":13,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"composerId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-toolu_012uCoexszbg9o9nTsZhGPR3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"richText\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hasLoaded\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":true,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"fullConversationHeadersOnly\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"7aa7909a-714f-4770-a4f3-fa4e17b77702\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"10cdc19b-ccc8-4401-a353-268581cd714e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"8a8f544b-5866-4151-ba2c-f3b4cee8e1f3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"d5a1e6f5-a773-40b0-afaf-7d96894eb1c7\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"62fba475-6ecf-4fdb-ba18-6e47d435807f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ef020aee-5e76-470e-9061-24c902ff9a4d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"07f11c2f-63a1-4ae9-8ea8-848b57d76f2c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"d5d696ca-be03-44f7-9ebc-ceb7f473feda\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aaf489c8-4f4b-4104-a488-3ad4d00165d8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0b2ced59-b3ce-4484-abe8-4da73bc3e44d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2da79beb-9f2b-4388-906d-cbb78df4d417\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e1962c04-f834-4e1d-9943-6fcdd7d12d2f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e7f8d894-fb [... omitted end of long line]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":136,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"composerData\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":13,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"composerId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-toolu_01QE9UujgTJBATVgtUevjCzF\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"richText\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hasLoaded\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":true,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"fullConversationHeadersOnly\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"daeeff04-393c-4f49-8363-5e06583a845c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b0d6f0aa-4458-40dc-8cec-1588c67bf063\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"5f35ea46-93aa-4575-8254-96f9ff1c7f28\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e44b032f-8c47-4934-8af8-b55c89edfd02\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"5d7eec0c-6ec8-45f7-ba34-978f0734ab46\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a30f84f2-97f3-436d-a8b2-6eadc820bb96\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"af0e91f2-9c22-4851-85d8-7b7c95367a11\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bca980f3-a98b-4871-87b4-df16fb2c54a6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"f5ffdb4a-ac65-4942-8da8-7dcf49b1e4b0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"50d20684-0dd0-48bb-9aeb-7c2180f6a4bd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2}],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"conversationMap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"daeeff04-393c-4f49-8363-5e06583a845c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":3,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"approximateLintErrors\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lints\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"codebaseConte [... omitted end of long line]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":228,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"plan\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"# Framework Core Implementation (Section 2.2)\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Context\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThe bindings layer is complete (&amp;#96;src/bindings/clap/&amp;#96; and &amp;#96;src/bindings/vst3/&amp;#96;). The next step is to build &amp;#96;src/core/&amp;#96; -- the API-agnostic framework layer that plugin authors code against. No format-specific types should leak into this layer.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nAll code targets **Zig 0.15.2**: use &amp;#96;callconv(.c)&amp;#96;, no &amp;#96;usingnamespace&amp;#96;, new &amp;#96;std.io.Reader&amp;#96;/&amp;#96;std.io.Writer&amp;#96; interfaces.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Files to Create\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nAll new files go under &amp;#96;src/core/&amp;#96;. Each file is one concern, targeting under ~500 lines.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n---\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n### 1. &amp;#96;src/core/audio_layout.zig&amp;#96; -- Audio I/O and Process Configuration\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nFoundational types used by everything else.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **&amp;#96;AudioIOLayout&amp;#96;** -- declares supported channel configurations (modeled after nih-plug &amp;#96;AudioIOLayout&amp;#96;):\\\\\\\\\\\\\\\\n  - &amp;#96;main_input_channels: ?u32&amp;#96; -- null means no main input\\\\\\\\\\\\\\\\n  - &amp;#96;main_output_channels: ?u32&amp;#96;\\\\\\\\\\\\\\\\n  [... omitted end of long line]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":586,\\\\\\\"content\\\\\\\":\\\\\\\"The installed Zig is 0.13.0 but the project targets 0.15.2. I'll write the state module using a self-contained type-erased reader/writer pattern (like &#96;std.mem.Allocator&#96;) that the wrappers can easily bridge from CLAP/VST3 stream types. This avoids tight coupling to &#96;std.io&#96; internals that changed significantly between versions.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":936,\\\\\\\"content\\\\\\\":\\\\\\\"- **Wrappers** (Section 2.3) - CLAP and VST3 format wrappers that translate between the core and bindings\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1006,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"prompt\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Explore the codebase at /Users/b/code/z-plug. I need a complete picture of:\\\\\\\\\\\\\\\\n1. The full directory tree (all directories and files)\\\\\\\\\\\\\\\\n2. Whether any docs/ directory or README.md files already exist\\\\\\\\\\\\\\\\n3. The distinct \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"packages/modules\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" - i.e. each subdirectory under src/ that represents a logical module (src/core/, src/bindings/clap/, src/bindings/vst3/, src/wrappers/ if it exists, etc.)\\\\\\\\\\\\\\\\n4. The contents of AGENTS.md (particularly any existing documentation-related instructions)\\\\\\\\\\\\\\\\n5. Whether there's a top-level README.md\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nReport back the full tree and findings.\\\\\\\\\\\\\\\",\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1017,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"composerData\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":13,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"composerId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-toolu_015pQR1xi2oK3a6Q4Y12MJRo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"richText\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hasLoaded\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":true,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"fullConversationHeadersOnly\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2709f35f-5c5b-4588-9931-1c503819eee5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"7a9aa100-6ea7-4a0c-821f-8a2708e59f51\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"d314ff53-5c81-43aa-843b-f5d0ff783432\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"22c6811a-aaf8-410a-a9b4-4891dd2f6a5a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"4f2e398d-023a-4ba8-91a8-e585a6f87607\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"56dad756-001f-40f1-a1ab-070600202dba\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"5b8474cd-fae5-4884-a1ca-7161279cdbc7\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"56ebca67-c425-4ecf-90d3-3c937d9c9c31\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"8b0d0476-9c40-451f-a993-557b76f553d2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"813076d3-251f-41ca-a88c-fb59f362ef77\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b0cc11fe-eb88-47df-8623-b71e9d37e193\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c7652e04-e1ec-455b-aa53-9fc7998a337a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":2},{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bubbleId\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"736b0766-79 [... omitted end of long line]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1056,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"plan\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"# Bootstrap Documentation Pattern\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Structure\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTwo tiers of documentation:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n1. **&amp;#96;docs/&amp;#96;** -- High-level topic guides (architecture overview, getting started, how subsystems connect, design decisions). Audience: new contributors and plugin authors.\\\\\\\\\\\\\\\\n2. **Per-module &amp;#96;README.md&amp;#96;** -- Lower-level docs colocated with the code they describe (what the module does, public API surface, key types, usage notes). Audience: developers working in that module.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n&amp;#96;&amp;#96;&amp;#96;\\\\\\\\\\\\\\\\ndocs/\\\\\\\\\\\\\\\\n  architecture.md       # Layers, data flow, how core/wrappers/bindings connect\\\\\\\\\\\\\\\\n  getting-started.md    # Dev environment setup, building, running tests\\\\\\\\\\\\\\\\n  plugin-authors.md     # How to write a plugin using z-plug (public API guide)\\\\\\\\\\\\\\\\nsrc/\\\\\\\\\\\\\\\\n  core/README.md        # Framework core module overview\\\\\\\\\\\\\\\\n  bindings/clap/README.md   # CLAP bindings module overview\\\\\\\\\\\\\\\\n  bindings/vst3/README.md   # VST3 bindings module overview\\\\\\\\\\\\\\\\n&amp;#96;&amp;#96;&amp;#96;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Files to Create\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n### 1. &amp;#96;docs/archite [... omitted end of long line]\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./docs/architecture.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":36,\\\\\\\"content\\\\\\\":\\\\\\\"- Zero-copy buffer wrappers, lock-free parameter storage\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":39,\\\\\\\"content\\\\\\\":\\\\\\\"**3. Format Wrappers** (&#96;src/wrappers/clap/&#96;, &#96;src/wrappers/vst3/&#96;)\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":114,\\\\\\\"content\\\\\\\":\\\\\\\"The wrappers populate &#96;channel_data&#96; with pointers from the format-specific structures (&#96;clap_audio_buffer_t&#96;, &#96;AudioBusBuffers&#96;).\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":133,\\\\\\\"content\\\\\\\":\\\\\\\"Both CLAP and VST3 have different event representations. The wrappers translate these to a unified &#96;NoteEvent&#96; tagged union before passing to the plugin:\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":144,\\\\\\\"content\\\\\\\":\\\\\\\"- &#96;src/wrappers/&#96; imports both &#96;src/core/&#96; and &#96;src/bindings/&#96;\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./src/core/plugin.zig\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"/// wrappers. Plugin authors define a struct with well-known declarations\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":122,\\\\\\\"content\\\\\\\":\\\\\\\"/// namespace with metadata and helper functions for the wrappers.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./src/core/buffer.zig\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":16,\\\\\\\"content\\\\\\\":\\\\\\\"/// The wrappers populate &#96;channel_data&#96; with pointers directly into the\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./src/core/events.zig\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":3,\\\\\\\"content\\\\\\\":\\\\\\\"/// Both CLAP and VST3 wrappers translate their format-specific events into\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":74,\\\\\\\"content\\\\\\\":\\\\\\\"/// The wrappers translate format-specific events into this tagged union\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./.specstory/history/2026-02-16_19-48Z-agents-documentation-guidelines.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":129,\\\\\\\"content\\\\\\\":\\\\\\\"- **File and module organization** â€” Full project structure with &#96;core/&#96;, &#96;wrappers/clap/&#96;, &#96;wrappers/vst3/&#96;, &#96;bindings/&#96;\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":985,\\\\\\\"content\\\\\\\":\\\\\\\"  \\\\\\\\\\\\\\\"plan\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"# Implement Low-Level Bindings Layer (Design Doc Section 2.1)\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Current State\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- The project has a &amp;#96;clap-zig-bindings&amp;#96; submodule (~1700 lines across 45 files) containing complete, idiomatic Zig bindings for CLAP 1.2.2.\\\\\\\\\\\\\\\\n- There are no VST3 bindings yet. The reference is &amp;#96;steinbergmedia/vst3_c_api&amp;#96; â€” a single auto-generated C header (&amp;#96;vst3_c_api.h&amp;#96;, ~5500 lines).\\\\\\\\\\\\\\\\n- The project has no &amp;#96;build.zig&amp;#96; or &amp;#96;src/&amp;#96; directory yet.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n## Part 1: Project Scaffolding\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCreate the initial &amp;#96;build.zig&amp;#96; and source directory structure. The build file should declare two modules that the framework (and later, format wrappers) will depend on:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- &amp;#96;clap-bindings&amp;#96; â€” sourced from the adapted submodule\\\\\\\\\\\\\\\\n- &amp;#96;vst3-bindings&amp;#96; â€” sourced from new hand-written code in &amp;#96;src/bindings/vst3/&amp;#96;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n&amp;#96;&amp;#96;&amp;#96;\\\\\\\\\\\\\\\\nbuild.zig\\\\\\\\\\\\\\\\nbuild.zig.zon\\\\\\\\\\\\\\\\nsrc/\\\\\\\\\\\\\\\\n  bindings/\\\\\\\\\\\\\\\\n    vst3/\\\\\\\\\\\\\\\\n      root.zig          # Public re-exports\\\\\\\\\\\\\\\\n      types.zig        [... omitted end of long line]\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/view.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":450,\\\\\\\"content\\\\\\\":\\\\\\\"        //       on macOS and both the editor implementation and the wrappers would know about the\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/state.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":55,\\\\\\\"content\\\\\\\":\\\\\\\"/// Create a parameters iterator from the hashtables stored in the plugin wrappers. This avoids\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":84,\\\\\\\"content\\\\\\\":\\\\\\\"/// plugin wrappers will already have a list of parameters handy. See [&#96;make_params_iter()&#96;].\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/standalone/wrapper.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":614,\\\\\\\"content\\\\\\\":\\\\\\\"    /// wrappers state is set from a couple places, so this function is here to be consistent and to\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/wrapper.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":13,\\\\\\\"content\\\\\\\":\\\\\\\"// This is used by the wrappers.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/plugin.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":22,\\\\\\\"content\\\\\\\":\\\\\\\"/// before the plugin can be exported to that format. The wrappers will use this to expose the\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":29,\\\\\\\"content\\\\\\\":\\\\\\\"/// - &#96;Plugin&#96; objects are stateful. During their lifetime the plugin API wrappers will call the\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":159,\\\\\\\"content\\\\\\\":\\\\\\\"    /// after the editor GUI has been created. NIH-plug comes with wrappers for several common GUI\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/params/internals.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"/// Internal pointers to parameters. This is an implementation detail used by the wrappers for type\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":18,\\\\\\\"content\\\\\\\":\\\\\\\"// always needs to make sure that dereferencing them is safe. To do that the plugin wrappers will\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":140,\\\\\\\"content\\\\\\\":\\\\\\\"    /// wrappers.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":156,\\\\\\\"content\\\\\\\":\\\\\\\"    /// wrappers.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/src/params.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":162,\\\\\\\"content\\\\\\\":\\\\\\\"    /// Get the string representation for a normalized value. Used as part of the wrappers. Most\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":167,\\\\\\\"content\\\\\\\":\\\\\\\"    /// Get the string representation for a normalized value. Used as part of the wrappers.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":171,\\\\\\\"content\\\\\\\":\\\\\\\"    /// wrappers.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":175,\\\\\\\"content\\\\\\\":\\\\\\\"    /// wrappers. This **does** snap to step sizes for continuous parameters (i.e. [&#96;FloatParam&#96;]).\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/nih_plug_vizia/src/vizia_assets.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":6,\\\\\\\"content\\\\\\\":\\\\\\\"// This module provides a re-export and simple font wrappers around the re-exported fonts.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/nih_plug_vizia/src/assets.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":6,\\\\\\\"content\\\\\\\":\\\\\\\"// This module provides a re-export and simple font wrappers around the re-exported fonts.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/nih_plug_iced/src/assets.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"// This module provides a re-export and simple font wrappers around the re-exported fonts.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./nih-plug/CHANGELOG.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":305,\\\\\\\"content\\\\\\\":\\\\\\\"  logic in all of its wrappers.\\\\\\\"}]},{\\\\\\\"file\\\\\\\":\\\\\\\"./zig-plug-design.md\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"The framework should let a plugin author write one Zig module â€” defining parameters, audio I/O layout, a &#96;process&#96; function, and optionally a GUI â€” and produce both VST3 and CLAP binaries from the same source. The design takes heavy inspiration from **nih-plug** (Rust), which achieves exactly this by defining an API-agnostic &#96;Plugin&#96; trait and thin format-specific wrappers that translate between the internal trait and the external ABI.[^1][^2]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":146,\\\\\\\"content\\\\\\\":\\\\\\\"CLAP provides events via &#96;clap_input_events_t&#96; / &#96;clap_output_events_t&#96; with sample-accurate timestamps. VST3 uses &#96;IEventList&#96; with similar sample offsets. The wrappers translate between format-specific event types and this unified enum.[^12][^20][^16]\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":166,\\\\\\\"content\\\\\\\":\\\\\\\"- Platform-native (Core Graphics / Direct2D) via thin wrappers\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":267,\\\\\\\"content\\\\\\\":\\\\\\\"| nih-plug wrappers | https://nih-plug.robbertvanderhelm.nl/nih_plug/wrapper/index.html | CLAP/VST3/standalone wrapper modules[^29] |\\\\\\\"}]}],\\\\\\\"totalLines\\\\\\\":64,\\\\\\\"totalMatchedLines\\\\\\\":64}}}}}\\\"},\\\"capabilityType\\\":15}\",\"8422e63a-6009-4a5a-821e-3c4ad7b7b50b\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d53e69ad-c089-4fe2-81bf-ecca76333c00\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_788d4faf-f608-4f91-a5e1-c54c408e706\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_788d4faf-f608-4f91-a5e1-c54c408e706\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/events.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/events.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/events.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const clap = @import(\\\\\\\\\\\\\\\"main.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst BeatTime = clap.BeatTime;\\\\\\\\nconst SecTime = clap.SecTime;\\\\\\\\n\\\\\\\\npub const SpaceId = enum(u16) { _ };\\\\\\\\npub const NoteId = enum(i32) { unspecified = -1, _ };\\\\\\\\npub const PortIndex = enum(i16) { unspecified = -1, _ };\\\\\\\\npub const Channel = enum(i16) { unspecified = -1, _ };\\\\\\\\npub const Key = enum(i16) { unspecified = -1, _ };\\\\\\\\n\\\\\\\\npub const core_space_id: SpaceId = @enumFromInt(0);\\\\\\\\n\\\\\\\\npub const Header = extern struct {\\\\\\\\n    pub const Type = enum(u16) {\\\\\\\\n        /// uses &#96;Note&#96;\\\\\\\\n        note_on = 0,\\\\\\\\n        /// uses &#96;Note&#96;\\\\\\\\n        note_off = 1,\\\\\\\\n        /// uses &#96;Note&#96;\\\\\\\\n        note_choke = 2,\\\\\\\\n        /// uses &#96;Note&#96;\\\\\\\\n        note_end = 3,\\\\\\\\n        /// uses &#96;NoteExpression&#96;\\\\\\\\n        note_expression = 4,\\\\\\\\n        /// uses &#96;ParamValue&#96;\\\\\\\\n        param_value = 5,\\\\\\\\n        /// uses &#96;ParamMod&#96;\\\\\\\\n        param_mod = 6,\\\\\\\\n        /// uses &#96;ParamGesture&#96;\\\\\\\\n        param_gesture_begin = 7,\\\\\\\\n        /// uses &#96;ParamGesture&#96;\\\\\\\\n        param_gesture_end = 8,\\\\\\\\n        /// uses &#96;Transport&#96;\\\\\\\\n        transport = 9,\\\\\\\\n        /// uses &#96;Midi&#96;\\\\\\\\n        midi = 10,\\\\\\\\n        /// uses &#96;MidiSysex&#96;\\\\\\\\n        midi_sysex = 11,\\\\\\\\n        /// uses &#96;Midi2&#96;\\\\\\\\n        midi2 = 12,\\\\\\\\n        _,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    pub const Flags = packed struct(u32) {\\\\\\\\n        /// a live user event, ie a user turning\\\\\\\\n        /// a knob or playing a key.\\\\\\\\n        is_live: bool = false,\\\\\\\\n        /// indicate that the event should not be recorded. ie\\\\\\\\n        /// parameter is changing due to midi cc, because the\\\\\\\\n        /// if the host records the automation and the midi cc\\\\\\\\n        /// there will be a conflict.\\\\\\\\n        dont_record: bool = false,\\\\\\\\n        _: u30 = 0,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /// event size, including the header, eg: &#96;@sizeOf(Note)&#96;\\\\\\\\n    size: u32,\\\\\\\\n    /// sample offset within the buffer of this event.\\\\\\\\n    sample_offset: u32,\\\\\\\\n    /// event space, see the event_registry extension\\\\\\\\n    space_id: SpaceId,\\\\\\\\n    type: Type,\\\\\\\\n    flags: Flags,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const Note = extern struct {\\\\\\\\n    header: Header,\\\\\\\\n    note_id: NoteId,\\\\\\\\n    port_index: PortIndex,\\\\\\\\n    channel: Channel,\\\\\\\\n    key: Key,\\\\\\\\n    velocity: f64,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const NoteExpression = extern struct {\\\\\\\\n    pub const Id = enum(i32) {\\\\\\\\n        volume = 0,\\\\\\\\n        pan = 1,\\\\\\\\n        tuning = 2,\\\\\\\\n        vibrato = 3,\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":187}\\\"},\\\"capabilityType\\\":15}\",\"83cf5af5-6225-4c37-9342-1f368aeeb37e\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"7bbefdba-413c-4c4f-ae8b-0ea910e7988a\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_c23e4e4a-96fe-4225-b289-095002639cd\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_c23e4e4a-96fe-4225-b289-095002639cd\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/events.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/events.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/events.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API Bindings - IEventList Interface\\\\\\\\n// Based on steinbergmedia/vst3_c_api\\\\\\\\n\\\\\\\\nconst types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\nconst TUID = types.TUID;\\\\\\\\nconst tresult = types.tresult;\\\\\\\\nconst vst3_callconv = types.vst3_callconv;\\\\\\\\nconst ParamID = types.ParamID;\\\\\\\\nconst ParamValue = types.ParamValue;\\\\\\\\n\\\\\\\\n/// Event types\\\\\\\\npub const EventTypes = enum(u16) {\\\\\\\\n    kNoteOnEvent = 0,\\\\\\\\n    kNoteOffEvent = 1,\\\\\\\\n    kDataEvent = 2,\\\\\\\\n    kPolyPressureEvent = 3,\\\\\\\\n    kNoteExpressionValueEvent = 4,\\\\\\\\n    kNoteExpressionTextEvent = 5,\\\\\\\\n    kChordEvent = 6,\\\\\\\\n    kScaleEvent = 7,\\\\\\\\n    kLegacyMIDICCOutEvent = 65535,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Event flags\\\\\\\\npub const EventFlags = enum(u16) {\\\\\\\\n    kIsLive = 1 &lt;&lt; 0,\\\\\\\\n    kUserReserved1 = 1 &lt;&lt; 14,\\\\\\\\n    kUserReserved2 = 1 &lt;&lt; 15,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Note on event\\\\\\\\npub const NoteOnEvent = extern struct {\\\\\\\\n    channel: i16,\\\\\\\\n    pitch: i16,\\\\\\\\n    tuning: f32,\\\\\\\\n    velocity: f32,\\\\\\\\n    length: i32,\\\\\\\\n    note_id: i32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Note off event\\\\\\\\npub const NoteOffEvent = extern struct {\\\\\\\\n    channel: i16,\\\\\\\\n    pitch: i16,\\\\\\\\n    velocity: f32,\\\\\\\\n    note_id: i32,\\\\\\\\n    tuning: f32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Data event\\\\\\\\npub const DataEvent = extern struct {\\\\\\\\n    size: u32,\\\\\\\\n    type: u32,\\\\\\\\n    bytes: [*]const u8,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Poly pressure event\\\\\\\\npub const PolyPressureEvent = extern struct {\\\\\\\\n    channel: i16,\\\\\\\\n    pitch: i16,\\\\\\\\n    pressure: f32,\\\\\\\\n    note_id: i32,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Generic event structure\\\\\\\\npub const Event = extern struct {\\\\\\\\n    bus_index: i32,\\\\\\\\n    sample_offset: i32,\\\\\\\\n    ppq_position: f64,\\\\\\\\n    flags: u16,\\\\\\\\n    type: u16,\\\\\\\\n    data: extern union {\\\\\\\\n        note_on: NoteOnEvent,\\\\\\\\n        note_off: NoteOffEvent,\\\\\\\\n        data: DataEvent,\\\\\\\\n        poly_pressure: PolyPressureEvent,\\\\\\\\n    },\\\\\\\\n};\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":100}\\\"},\\\"capabilityType\\\":15}\",\"1b434a9e-d4dd-48d4-a66e-6c45d0f04634\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"39446ce5-ae39-4c8c-9d5d-2a0dacf9fbea\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_355a903c-e0cb-4c98-b882-cccdefd8fdb\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_355a903c-e0cb-4c98-b882-cccdefd8fdb\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/README.md\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/README.md\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/vst3/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/core/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/spectral_compressor/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/soft_vacuum/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/safety_limiter/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/puberty_simulator/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/loudness_war_winner/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/diopser/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/crossover/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/crisp/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/plugins/buffr_glitch/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/nih_plug_xtask/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/nih_plug_vizia/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/nih_plug_iced/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/nih_plug_egui/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/cargo_nih_plug/README.md\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/README.md\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":19}]}\\\"},\\\"capabilityType\\\":15}\",\"b220aa81-d944-4353-9a85-d8895eac88e0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"56071f4b-f3a7-4577-8af9-1144a556dae5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_65e95d0c-d369-43ab-bbea-80ee93cf623\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_65e95d0c-d369-43ab-bbea-80ee93cf623\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/LICENSE*\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"**/LICENSE*\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"absPath\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"src/bindings/clap/LICENSE\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"nih-plug/LICENSE\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":2}]}\\\"},\\\"capabilityType\\\":15}\",\"4191c99d-0c2b-421b-a5b2-400620a583ff\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"94a0b461-64ef-40b9-83a3-9ca4be363e33\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_7130c6df-f4d7-4d52-bc53-3f46d2e99a1\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_7130c6df-f4d7-4d52-bc53-3f46d2e99a1\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/ext/params.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":60}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/ext/params.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":60,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/ext/params.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"const clap = @import(\\\\\\\\\\\\\\\"../main.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\npub const id = \\\\\\\\\\\\\\\"clap.params\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\npub const Info = extern struct {\\\\\\\\n    pub const Flags = packed struct(u32) {\\\\\\\\n        is_stepped: bool = false,\\\\\\\\n        is_periodic: bool = false,\\\\\\\\n        is_hidden: bool = false,\\\\\\\\n        is_read_only: bool = false,\\\\\\\\n        is_bypass: bool = false,\\\\\\\\n        is_automatable: bool = false,\\\\\\\\n        is_automatable_per_note_id: bool = false,\\\\\\\\n        is_automatable_per_key: bool = false,\\\\\\\\n        is_automatable_per_channel: bool = false,\\\\\\\\n        is_automatable_per_port: bool = false,\\\\\\\\n        is_modulatable: bool = false,\\\\\\\\n        is_modulatable_per_note_id: bool = false,\\\\\\\\n        is_modulatable_per_key: bool = false,\\\\\\\\n        is_modulatable_per_channel: bool = false,\\\\\\\\n        is_modulatable_per_port: bool = false,\\\\\\\\n        requires_process: bool = false,\\\\\\\\n        is_enum: bool = false,\\\\\\\\n        _: u15 = 0,\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    /// stable parameter identifier. it must never change.\\\\\\\\n    id: clap.Id,\\\\\\\\n    flags: Flags,\\\\\\\\n    /// value is optional and set by the plugin. its purpose is to provide fast\\\\\\\\n    /// access to the plugin parameter object by caching its pointer.\\\\\\\\n    /// important:\\\\\\\\n    ///  - the cookie is invalidated by a full parameter rescan or when the\\\\\\\\n    ///    plugin is destroyed.\\\\\\\\n    ///  - the host will either provide the cookie as issued or null in events\\\\\\\\n    ///    addressing parameters.\\\\\\\\n    ///  - the plugin must gracefully handle the case of a cookie which is null\\\\\\\\n    ///  - many plugins will process the parameter events more quickly if the\\\\\\\\n    ///    host can provide the cookie in a faster time than a hashmap lookup\\\\\\\\n    ///    per param per event.\\\\\\\\n    cookie: ?*anyopaque,\\\\\\\\n    /// the display name. eg: \\\\\\\\\\\\\\\"Volume\\\\\\\\\\\\\\\". this does not need to be unique. do not\\\\\\\\n    /// include the module text in this. the host should concatenate/format the\\\\\\\\n    /// module + name in the case where showing the name alone would be too vague\\\\\\\\n    name: [clap.name_capacity]u8,\\\\\\\\n    /// the module path containing the parameter, eg: \\\\\\\\\\\\\\\"Oscillators/Wavetable 1\\\\\\\\\\\\\\\".\\\\\\\\n    /// '/' will be used as a separator to show a tree-like structure.\\\\\\\\n    module: [clap.path_capacity]u8,\\\\\\\\n    /// minimum plain value\\\\\\\\n    min_value: f64,\\\\\\\\n    /// maximum plain value\\\\\\\\n    max_value: f64,\\\\\\\\n    /// default plain value\\\\\\\\n    default_value: f64,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const Plugin = extern struct {\\\\\\\\n    count: *const fn (plugin: *const clap.Plugin) callconv(.c) u32,\\\\\\\\n    getInfo: *const fn (plugin: *const clap.Plugin, index: u32, info: *Info) callconv(.c) bool,\\\\\\\\n    getValue: *const fn (plugin: *const clap.Plugin, id: clap.Id, out_value: *f64) callconv(.c) bool,\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":101}\\\"},\\\"capabilityType\\\":15}\",\"3cf46475-daea-4c22-b2e1-c8edc6974541\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"6e3ce1ac-72e4-46a2-b379-b3f52f9c96bf\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_be23be60-1dfb-4fa4-a41b-da94a117636\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_be23be60-1dfb-4fa4-a41b-da94a117636\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/processor.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/processor.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":80,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/processor.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API Bindings - IAudioProcessor Interface\\\\\\\\n// Based on steinbergmedia/vst3_c_api\\\\\\\\n\\\\\\\\nconst types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\nconst TUID = types.TUID;\\\\\\\\nconst tresult = types.tresult;\\\\\\\\nconst vst3_callconv = types.vst3_callconv;\\\\\\\\nconst TBool = types.TBool;\\\\\\\\nconst Sample32 = types.Sample32;\\\\\\\\nconst Sample64 = types.Sample64;\\\\\\\\nconst SampleRate = types.SampleRate;\\\\\\\\nconst TSamples = types.TSamples;\\\\\\\\nconst TQuarterNotes = types.TQuarterNotes;\\\\\\\\nconst SpeakerArrangement = types.SpeakerArrangement;\\\\\\\\n\\\\\\\\n/// Process setup\\\\\\\\npub const ProcessSetup = extern struct {\\\\\\\\n    process_mode: i32,\\\\\\\\n    symbolic_sample_size: i32,\\\\\\\\n    max_samples_per_block: i32,\\\\\\\\n    sample_rate: SampleRate,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Audio bus buffers\\\\\\\\npub const AudioBusBuffers = extern struct {\\\\\\\\n    num_channels: i32,\\\\\\\\n    silence_flags: u64,\\\\\\\\n    channel_buffers_32: ?[*][*]Sample32,\\\\\\\\n    channel_buffers_64: ?[*][*]Sample64,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Frame rate\\\\\\\\npub const FrameRate = extern struct {\\\\\\\\n    frames_per_second: u32,\\\\\\\\n    flags: u32,\\\\\\\\n    \\\\\\\\n    pub const FrameRateFlags = enum(u32) {\\\\\\\\n        kPullDownRate = 1 &lt;&lt; 0,\\\\\\\\n        kDropRate = 1 &lt;&lt; 1,\\\\\\\\n    };\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Chord\\\\\\\\npub const Chord = extern struct {\\\\\\\\n    key_note: u8,\\\\\\\\n    root_note: u8,\\\\\\\\n    chord_mask: i16,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// Process context\\\\\\\\npub const ProcessContext = extern struct {\\\\\\\\n    state: u32,\\\\\\\\n    sample_rate: f64,\\\\\\\\n    project_time_samples: TSamples,\\\\\\\\n    system_time: i64,\\\\\\\\n    continuous_time_samples: TSamples,\\\\\\\\n    project_time_music: TQuarterNotes,\\\\\\\\n    bar_position_music: TQuarterNotes,\\\\\\\\n    cycle_start_music: TQuarterNotes,\\\\\\\\n    cycle_end_music: TQuarterNotes,\\\\\\\\n    tempo: f64,\\\\\\\\n    time_sig_numerator: i32,\\\\\\\\n    time_sig_denominator: i32,\\\\\\\\n    chord: Chord,\\\\\\\\n    smpte_offset_subframes: i32,\\\\\\\\n    frame_rate: FrameRate,\\\\\\\\n    samples_to_next_clock: i32,\\\\\\\\n    \\\\\\\\n    pub const StatesAndFlags = enum(u32) {\\\\\\\\n        kPlaying = 1 &lt;&lt; 1,\\\\\\\\n        kCycleActive = 1 &lt;&lt; 2,\\\\\\\\n        kRecording = 1 &lt;&lt; 3,\\\\\\\\n        kSystemTimeValid = 1 &lt;&lt; 8,\\\\\\\\n        kContTimeValid = 1 &lt;&lt; 17,\\\\\\\\n        kProjectTimeMusicValid = 1 &lt;&lt; 9,\\\\\\\\n        kBarPositionValid = 1 &lt;&lt; 11,\\\\\\\\n        kCycleValid = 1 &lt;&lt; 12,\\\\\\\\n        kTempoValid = 1 &lt;&lt; 10,\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":149}\\\"},\\\"capabilityType\\\":15}\",\"a2175461-e781-4b45-9251-730f37868d4c\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"b98a8d43-a10d-45ba-b823-76619f3d26e7\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nChecking for a wrappers directory and reading a few more files:\\\\n\\\"}\",\"726dfa41-3bd7-4a92-b6e4-4c1ae438aec1\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"a167e5c8-65b1-4f0f-b496-e8e1d8d441d8\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.036Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_be17e934-08ac-4ab3-b1ce-a5b0e78a587\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_be17e934-08ac-4ab3-b1ce-a5b0e78a587\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/README.md\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/README.md\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/README.md\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"# z-plug\\\\\\\\n\\\\\\\\nAn audio plugin framework for Zig 0.15.2 that allows you to write one plugin module and produce both VST3 and CLAP binaries from the same source.\\\\\\\\n\\\\\\\\n## Design Philosophy\\\\\\\\n\\\\\\\\nInspired by [nih-plug](https://github.com/robbert-vdh/nih-plug) (Rust), z-plug provides:\\\\\\\\n- **API-agnostic plugin interface** â€” Write plugin code once, target both formats\\\\\\\\n- **Comptime-driven metadata** â€” Leverage Zig's comptime for vtables, parameters, GUIDs\\\\\\\\n- **Real-time safety** â€” No allocations on the audio thread by design\\\\\\\\n- **Minimal magic** â€” Explicit over implicit, minimal ceremony\\\\\\\\n\\\\\\\\nSee [zig-plug-design.md](zig-plug-design.md) for the complete design document.\\\\\\\\n\\\\\\\\n## Project Status\\\\\\\\n\\\\\\\\nâœ… **Phase 1: Foundations** â€” Complete\\\\\\\\n- CLAP bindings (Zig 0.15.2 compatible, LGPL v3)\\\\\\\\n- VST3 C API bindings (hand-written, ~12 core interfaces, MIT)\\\\\\\\n- Build system configured with module support\\\\\\\\n\\\\\\\\nâœ… **Phase 2: Framework Core** â€” Complete\\\\\\\\n- API-agnostic plugin interface with comptime validation\\\\\\\\n- Zero-copy buffer abstraction with three iteration strategies\\\\\\\\n- Unified note/MIDI event system\\\\\\\\n- Parameter system with atomic runtime storage\\\\\\\\n- State persistence interface (save/load)\\\\\\\\n- Audio I/O configuration and transport abstraction\\\\\\\\n\\\\\\\\nðŸ”² **Phase 3: Format Wrappers** â€” Planned\\\\\\\\n- CLAP wrapper (C struct ABI)\\\\\\\\n- VST3 wrapper (COM vtable ABI)\\\\\\\\n- Build system &#96;addPlugin()&#96; helper\\\\\\\\n\\\\\\\\nðŸ”² **Phase 4: Examples and Polish** â€” Planned\\\\\\\\n- Example plugins (gain, synth)\\\\\\\\n- Documentation and tutorial expansion\\\\\\\\n- CI/CD integration\\\\\\\\n\\\\\\\\n## Building\\\\\\\\n\\\\\\\\nThis project requires Zig 0.15.2. The provided &#96;flake.nix&#96; sets up a development environment with zvm.\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;bash\\\\\\\\n# Run tests\\\\\\\\nzig build test\\\\\\\\n\\\\\\\\n# Future: Build a plugin (not yet implemented)\\\\\\\\n# zig build -Dplugin=examples/gain\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\n## Project Structure\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;\\\\\\\\nsrc/\\\\\\\\n  core/            # Framework core (API-agnostic) âœ…\\\\\\\\n  bindings/\\\\\\\\n    clap/          # CLAP C API bindings (LGPL v3) âœ…\\\\\\\\n    vst3/          # VST3 C API bindings (MIT) âœ…\\\\\\\\n  wrappers/        # Format-specific wrappers (planned)\\\\\\\\n  root.zig         # Public API âœ…\\\\\\\\ndocs/              # High-level documentation âœ…\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\n## License and Attribution\\\\\\\\n\\\\\\\\nThis project's framework code is licensed under [TBD].\\\\\\\\n\\\\\\\\n### Third-Party Components\\\\\\\\n\\\\\\\\n**CLAP Bindings** (&#96;src/bindings/clap/&#96;):\\\\\\\\n- Derived from: [clap-zig-bindings](https://git.sr.ht/~interpunct/clap-zig-bindings)\\\\\\\\n- License: GNU LGPL v3.0 or later\\\\\\\\n- Modifications: Adapted for Zig 0.15.2 compatibility\\\\\\\\n- See: &#96;src/bindings/clap/LICENSE&#96; and &#96;src/bindings/clap/NOTICE&#96;\\\\\\\\n\\\\\\\\n**VST3 Bindings** (&#96;src/bindings/vst3/&#96;):\\\\\\\\n- Based on: [Steinberg vst3_c_api](https://github.com/steinbergmedia/vst3_c_api)\\\\\\\\n- License: MIT (as of October 2025)\\\\\\\\n- Implementation: Hand-written idiomatic Zig bindings\\\\\\\\n\\\\\\\\n## Documentation\\\\\\\\n\\\\\\\\n### For Plugin Authors\\\\\\\\n- **[docs/plugin-authors.md](docs/plugin-authors.md)** â€” Public API guide with examples\\\\\\\\n- **[docs/getting-started.md](docs/getting-started.md)** â€” Development environment setup\\\\\\\\n\\\\\\\\n### For Contributors\\\\\\\\n- **[docs/architecture.md](docs/architecture.md)** â€” How the layers fit together\\\\\\\\n- **[AGENTS.md](AGENTS.md)** â€” Coding standards and architecture rules\\\\\\\\n- **[zig-plug-design.md](zig-plug-design.md)** â€” Complete design document with rationale\\\\\\\\n- **Module READMEs** â€” See &#96;src/*/README.md&#96; for module-specific docs\\\\\\\\n\\\\\\\\n## Contributing\\\\\\\\n\\\\\\\\nSee [AGENTS.md](AGENTS.md) for coding standards and architecture guidelines.\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":97}\\\"},\\\"capabilityType\\\":15}\",\"55d240b4-e8f8-4ce4-8450-ecccf70d110b\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8a2c186c-c17c-42ad-830a-e1a24d8e658f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_031499aa-fbe6-49ff-98d7-c4c04ffce94\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_031499aa-fbe6-49ff-98d7-c4c04ffce94\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/README.md\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/README.md\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/core/README.md\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"# Framework Core Module\\\\\\\\n\\\\\\\\nThe framework core provides API-agnostic types that plugin authors interact with. No format-specific code (CLAP or VST3) belongs in this layer.\\\\\\\\n\\\\\\\\n## Purpose\\\\\\\\n\\\\\\\\nThis module defines the plugin interface and all core abstractions:\\\\\\\\n- Comptime plugin validation (&#96;Plugin(T)&#96;)\\\\\\\\n- Audio buffer wrapper (&#96;Buffer&#96;)\\\\\\\\n- Unified note/MIDI events (&#96;NoteEvent&#96;)\\\\\\\\n- Parameter system (&#96;Param&#96;, &#96;ParamValues&#96;)\\\\\\\\n- State persistence (&#96;SaveContext&#96;, &#96;LoadContext&#96;)\\\\\\\\n- Audio I/O configuration (&#96;AudioIOLayout&#96;, &#96;BufferConfig&#96;, &#96;Transport&#96;)\\\\\\\\n\\\\\\\\nPlugin authors import these types via &#96;@import(\\\\\\\\\\\\\\\"z_plug\\\\\\\\\\\\\\\")&#96;, which re-exports from this module.\\\\\\\\n\\\\\\\\n## Files\\\\\\\\n\\\\\\\\n| File | Purpose |\\\\\\\\n|------|---------|\\\\\\\\n| &#96;plugin.zig&#96; | Plugin interface, comptime validation, &#96;ProcessContext&#96;, &#96;ProcessStatus&#96;, &#96;EventOutputList&#96; |\\\\\\\\n| &#96;params.zig&#96; | Parameter declarations (&#96;Param&#96;, &#96;FloatParam&#96;, &#96;IntParam&#96;, &#96;BoolParam&#96;, &#96;ChoiceParam&#96;), ranges, flags, atomic parameter storage |\\\\\\\\n| &#96;buffer.zig&#96; | Zero-copy audio buffer abstraction with three iteration strategies |\\\\\\\\n| &#96;events.zig&#96; | Unified &#96;NoteEvent&#96; tagged union (note on/off, poly expression, MIDI CC, etc.) |\\\\\\\\n| &#96;state.zig&#96; | State save/load interface (&#96;SaveContext&#96;, &#96;LoadContext&#96;) using Zig 0.15.2 I/O |\\\\\\\\n| &#96;audio_layout.zig&#96; | Audio I/O layouts, buffer config, process modes, MIDI config, transport info |\\\\\\\\n\\\\\\\\n## Key Types\\\\\\\\n\\\\\\\\n### Plugin Interface\\\\\\\\n\\\\\\\\n- **&#96;Plugin(comptime T)&#96;** â€” Comptime function that validates a plugin struct &#96;T&#96; at compile time using duck-typing (similar to &#96;std.mem.Allocator&#96; pattern). Emits clear &#96;@compileError&#96; messages for missing or wrong-typed declarations.\\\\\\\\n- **&#96;ProcessContext&#96;** â€” Passed to &#96;process&#96;, contains transport info, input events, output event list, sample rate.\\\\\\\\n- **&#96;ProcessStatus&#96;** â€” Return type from &#96;process&#96;: &#96;normal&#96;, &#96;silence&#96;, &#96;tail&#96;, &#96;keep_alive&#96;, &#96;err&#96;.\\\\\\\\n- **&#96;EventOutputList&#96;** â€” Bounded push-only list for output events.\\\\\\\\n\\\\\\\\n### Buffer and Audio I/O\\\\\\\\n\\\\\\\\n- **&#96;Buffer&#96;** â€” Zero-copy wrapper over host audio data (&#96;[][]f32&#96;). Provides raw slice access, per-sample iteration, and per-block iteration.\\\\\\\\n- **&#96;AuxBuffers&#96;** â€” Auxiliary I/O buses (sidechain inputs, aux outputs).\\\\\\\\n- **&#96;AudioIOLayout&#96;** â€” Declares supported channel configurations (main input/output, aux buses).\\\\\\\\n- **&#96;BufferConfig&#96;** â€” Runtime config from host (sample rate, buffer size, process mode).\\\\\\\\n- **&#96;Transport&#96;** â€” Unified transport/timeline info (playing, tempo, time signature, position).\\\\\\\\n\\\\\\\\n### Events\\\\\\\\n\\\\\\\\n- **&#96;NoteEvent&#96;** â€” Tagged union unifying CLAP and VST3 events:\\\\\\\\n  - Note events: &#96;note_on&#96;, &#96;note_off&#96;, &#96;choke&#96;, &#96;voice_terminated&#96;\\\\\\\\n  - Poly expression: &#96;poly_pressure&#96;, &#96;poly_tuning&#96;, &#96;poly_vibrato&#96;, &#96;poly_expression&#96;, &#96;poly_brightness&#96;, &#96;poly_volume&#96;, &#96;poly_pan&#96;\\\\\\\\n  - MIDI: &#96;midi_cc&#96;, &#96;midi_channel_pressure&#96;, &#96;midi_pitch_bend&#96;, &#96;midi_program_change&#96;\\\\\\\\n- All events carry sample-accurate &#96;timing&#96; (offset within buffer).\\\\\\\\n\\\\\\\\n### Parameters\\\\\\\\n\\\\\\\\n- **&#96;Param&#96;** â€” Tagged union for parameter declarations: &#96;float&#96;, &#96;int&#96;, &#96;boolean&#96;, &#96;choice&#96;.\\\\\\\\n- **&#96;FloatRange&#96; / &#96;IntRange&#96;** â€” Value ranges with normalize/unnormalize/clamp methods.\\\\\\\\n- **&#96;ParamFlags&#96;** â€” Packed struct controlling automation, modulation, visibility, bypass.\\\\\\\\n- **&#96;ParamValues(comptime N)&#96;** â€” Lock-free atomic storage for runtime parameter values. Uses &#96;std.atomic.Value(f32)&#96; for thread-safe access between main and audio threads.\\\\\\\\n- **&#96;idHash(comptime id)&#96;** â€” Stable FNV-1a hash for generating VST3 &#96;ParamID&#96; from string IDs.\\\\\\\\n\\\\\\\\n### State Persistence\\\\\\\\n\\\\\\\\n- **&#96;SaveContext&#96;** â€” Type-erased writer (&#96;std.io.AnyWriter&#96;) with helper methods (&#96;write&#96;, &#96;writeString&#96;, &#96;writeBytes&#96;).\\\\\\\\n- **&#96;LoadContext&#96;** â€” Type-erased reader (&#96;std.io.AnyReader&#96;) with helper methods (&#96;read&#96;, &#96;readString&#96;, &#96;readStringBounded&#96;). Includes &#96;version&#96; field for migration.\\\\\\\\n- The framework writes a header (magic bytes + version) before calling the plugin's &#96;save&#96; function.\\\\\\\\n\\\\\\\\n## Design Notes\\\\\\\\n\\\\\\\\n### Comptime Validation\\\\\\\\n\\\\\\\\nThe &#96;Plugin(comptime T)&#96; function uses &#96;@hasDecl&#96; and &#96;@TypeOf&#96; to validate plugin structs at compile time:\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;zig\\\\\\\\nif (!@hasDecl(T, \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\")) {\\\\\\\\n    @compileError(\\\\\\\\\\\\\\\"Plugin '\\\\\\\\\\\\\\\" ++ @typeName(T) ++ \\\\\\\\\\\\\\\"' must declare 'pub const name: [:0]const u8'\\\\\\\\\\\\\\\");\\\\\\\\n}\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\nThis provides:\\\\\\\\n- Zero runtime overhead (monomorphization, no vtables)\\\\\\\\n- Clear compile-time error messages\\\\\\\\n- No dynamic dispatch on the audio thread\\\\\\\\n\\\\\\\\n### Atomic Parameters\\\\\\\\n\\\\\\\\n&#96;ParamValues(N)&#96; uses &#96;std.atomic.Value(f32)&#96; for lock-free thread safety:\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;zig\\\\\\\\npub fn get(self: *const Self, index: usize) f32 {\\\\\\\\n    return self.values[index].load(.monotonic);\\\\\\\\n}\\\\\\\\n\\\\\\\\npub fn set(self: *Self, index: usize, normalized: f32) void {\\\\\\\\n    self.values[index].store(normalized, .monotonic);\\\\\\\\n}\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\nMain thread writes with &#96;.store()&#96;, audio thread reads with &#96;.load()&#96;. No locks are ever acquired.\\\\\\\\n\\\\\\\\n### Zero-Copy Buffers\\\\\\\\n\\\\\\\\n&#96;Buffer&#96; wraps pointers into the host's audio memory:\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;zig\\\\\\\\npub const Buffer = struct {\\\\\\\\n    channel_data: [][]f32,  // Points into host memory, never copies\\\\\\\\n    num_samples: usize,\\\\\\\\n    // ...\\\\\\\\n};\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\nWrappers populate &#96;channel_data&#96; with pointers from format-specific structures (&#96;clap_audio_buffer_t&#96;, &#96;AudioBusBuffers&#96;). Audio samples are never copied.\\\\\\\\n\\\\\\\\n### Three Buffer Iteration Strategies\\\\\\\\n\\\\\\\\n1. **Raw slice access** â€” Direct &#96;[]f32&#96; per channel for maximum control.\\\\\\\\n2. **Per-sample** â€” &#96;iterSamples()&#96; yields &#96;ChannelSamples&#96; for each sample index (convenient for per-sample SIMD or branching).\\\\\\\\n3. **Per-block** â€” &#96;iterBlocks(max_block_size)&#96; yields &#96;Block&#96; sub-buffers (useful for FFT, convolution, or algorithms that operate on fixed-size blocks).\\\\\\\\n\\\\\\\\n## Testing\\\\\\\\n\\\\\\\\nEach file includes test blocks at the bottom covering:\\\\\\\\n- &#96;audio_layout.zig&#96;: Layout constants, total channel calculations\\\\\\\\n- &#96;events.zig&#96;: Helper methods (timing, channel, voiceId extraction)\\\\\\\\n- &#96;params.zig&#96;: Range normalize/unnormalize roundtrips, idHash stability, ParamValues atomic access\\\\\\\\n- &#96;buffer.zig&#96;: Iteration strategies, zero-copy pointer identity\\\\\\\\n- &#96;state.zig&#96;: SaveContext/LoadContext roundtrips, header validation\\\\\\\\n- &#96;plugin.zig&#96;: Comptime validation with valid and invalid plugin structs\\\\\\\\n\\\\\\\\nRun tests with:\\\\\\\\n&#96;&#96;&#96;bash\\\\\\\\nzig build test\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\n## See Also\\\\\\\\n\\\\\\\\n- [docs/architecture.md](../../docs/architecture.md) â€” How core fits into the overall architecture\\\\\\\\n- [docs/plugin-authors.md](../../docs/plugin-authors.md) â€” Public API guide for writing plugins\\\\\\\\n- [src/root.zig](../root.zig) â€” Public API re-exports\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":140}\\\"},\\\"capabilityType\\\":15}\",\"7a95b419-01e1-4844-a321-1648339759d7\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f032d48d-6161-4dc0-837b-b28667802c3b\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_5b830e98-7fef-47ac-9557-99cf1f8e185\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_5b830e98-7fef-47ac-9557-99cf1f8e185\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/README.md\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/README.md\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/README.md\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"# CLAP Bindings Module\\\\\\\\n\\\\\\\\nLow-level idiomatic Zig translation of the CLAP 1.2.2 C API.\\\\\\\\n\\\\\\\\n## Purpose\\\\\\\\n\\\\\\\\nThis module provides direct Zig bindings for the [CLAP (CLever Audio Plug-in)](https://github.com/free-audio/clap) C API. The bindings are:\\\\\\\\n- **Thin and mechanical** â€” Direct translation of C structs and function pointers to Zig &#96;extern struct&#96; types\\\\\\\\n- **Idiomatic Zig** â€” Uses Zig naming conventions, &#96;callconv(.c)&#96; for function pointers, proper null safety\\\\\\\\n- **No framework logic** â€” Pure ABI translation; wrappers in &#96;src/wrappers/clap/&#96; add framework integration\\\\\\\\n\\\\\\\\n## Origin and License\\\\\\\\n\\\\\\\\n- **Derived from:** [clap-zig-bindings](https://git.sr.ht/~interpunct/clap-zig-bindings) by interpunct\\\\\\\\n- **Modifications:** Adapted for Zig 0.15.2 compatibility (explicit &#96;callconv(.c)&#96;, no &#96;usingnamespace&#96;)\\\\\\\\n- **License:** GNU LGPL v3.0 or later\\\\\\\\n- See [LICENSE](LICENSE) and [NOTICE](NOTICE) for full attribution\\\\\\\\n\\\\\\\\n### LGPL Compliance\\\\\\\\n\\\\\\\\nWhen distributing binaries or using this framework, you must comply with LGPL v3 requirements. Users must be able to replace the LGPL-licensed library. This is satisfied by:\\\\\\\\n1. **Distributing source code** (recommended for open source projects), or\\\\\\\\n2. **Using dynamic linking** for the CLAP bindings portion\\\\\\\\n\\\\\\\\n## Structure\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;\\\\\\\\nsrc/bindings/clap/\\\\\\\\nâ”œâ”€â”€ main.zig              # Root module, re-exports all types\\\\\\\\nâ”œâ”€â”€ LICENSE               # GNU LGPL v3.0 license text\\\\\\\\nâ”œâ”€â”€ NOTICE                # Attribution to original authors\\\\\\\\nâ”‚\\\\\\\\nâ”œâ”€â”€ version.zig           # CLAP version struct\\\\\\\\nâ”œâ”€â”€ entry.zig             # clap_entry (plugin entry point)\\\\\\\\nâ”œâ”€â”€ plugin.zig            # clap_plugin (plugin descriptor + vtable)\\\\\\\\nâ”œâ”€â”€ host.zig              # clap_host (host callbacks)\\\\\\\\nâ”œâ”€â”€ process.zig           # clap_process_t (audio processing context)\\\\\\\\nâ”œâ”€â”€ stream.zig            # clap_istream_t, clap_ostream_t (state I/O)\\\\\\\\nâ”œâ”€â”€ events.zig            # Event types (note, param, transport, MIDI)\\\\\\\\nâ”œâ”€â”€ audio_buffer.zig      # clap_audio_buffer_t (32/64-bit audio data)\\\\\\\\nâ”‚\\\\\\\\nâ”œâ”€â”€ factory/\\\\\\\\nâ”‚   â”œâ”€â”€ plugin.zig        # clap_plugin_factory_t\\\\\\\\nâ”‚   â””â”€â”€ preset_discovery.zig  # clap_preset_discovery_factory_t\\\\\\\\nâ”‚\\\\\\\\nâ””â”€â”€ ext/                  # CLAP extensions (30+ files)\\\\\\\\n    â”œâ”€â”€ params.zig        # clap_plugin_params extension\\\\\\\\n    â”œâ”€â”€ state.zig         # clap_plugin_state extension\\\\\\\\n    â”œâ”€â”€ audio_ports.zig   # clap_plugin_audio_ports extension\\\\\\\\n    â”œâ”€â”€ note_ports.zig    # clap_plugin_note_ports extension\\\\\\\\n    â”œâ”€â”€ gui.zig           # clap_plugin_gui extension\\\\\\\\n    â”œâ”€â”€ latency.zig       # clap_plugin_latency extension\\\\\\\\n    â”œâ”€â”€ tail.zig          # clap_plugin_tail extension\\\\\\\\n    â””â”€â”€ ... (25+ more extension files)\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\n## Key Types\\\\\\\\n\\\\\\\\n### Core Plugin Types\\\\\\\\n\\\\\\\\n- **&#96;clap_entry&#96;** (&#96;entry.zig&#96;) â€” Plugin entry point struct with &#96;init&#96;, &#96;deinit&#96;, &#96;get_factory&#96;.\\\\\\\\n- **&#96;clap_plugin&#96;** (&#96;plugin.zig&#96;) â€” Plugin descriptor with metadata and vtable (function pointers for &#96;activate&#96;, &#96;deactivate&#96;, &#96;start_processing&#96;, &#96;stop_processing&#96;, &#96;process&#96;, etc.).\\\\\\\\n- **&#96;clap_host&#96;** (&#96;host.zig&#96;) â€” Host callbacks provided to the plugin.\\\\\\\\n- **&#96;clap_plugin_factory&#96;** (&#96;factory/plugin.zig&#96;) â€” Factory for creating plugin instances.\\\\\\\\n\\\\\\\\n### Process and Audio\\\\\\\\n\\\\\\\\n- **&#96;clap_process_t&#96;** (&#96;process.zig&#96;) â€” Audio processing context containing:\\\\\\\\n  - &#96;frames_count&#96; â€” Number of samples to process\\\\\\\\n  - &#96;audio_inputs&#96;, &#96;audio_outputs&#96; â€” Audio buffer arrays\\\\\\\\n  - &#96;in_events&#96;, &#96;out_events&#96; â€” Event lists (input/output)\\\\\\\\n  - &#96;transport&#96; â€” Transport info (optional)\\\\\\\\n- **&#96;clap_audio_buffer_t&#96;** (&#96;audio_buffer.zig&#96;) â€” Non-interleaved audio buffer (32-bit or 64-bit float).\\\\\\\\n- **Status enum:** &#96;CLAP_PROCESS_ERROR&#96;, &#96;CLAP_PROCESS_CONTINUE&#96;, &#96;CLAP_PROCESS_CONTINUE_IF_NOT_QUIET&#96;, &#96;CLAP_PROCESS_TAIL&#96;, &#96;CLAP_PROCESS_SLEEP&#96;.\\\\\\\\n\\\\\\\\n### Events\\\\\\\\n\\\\\\\\nAll in &#96;events.zig&#96;:\\\\\\\\n- **&#96;clap_event_header_t&#96;** â€” Common header for all events (size, time, space_id, type, flags).\\\\\\\\n- **Note events:** &#96;clap_event_note_t&#96; (note on/off/choke/end).\\\\\\\\n- **Note expression:** &#96;clap_event_note_expression_t&#96; (volume, pan, tuning, vibrato, etc.).\\\\\\\\n- **Parameters:** &#96;clap_event_param_value_t&#96;, &#96;clap_event_param_mod_t&#96;, &#96;clap_event_param_gesture_begin/end_t&#96;.\\\\\\\\n- **Transport:** &#96;clap_event_transport_t&#96; (tempo, time signature, position, loop points).\\\\\\\\n- **MIDI:** &#96;clap_event_midi_t&#96;, &#96;clap_event_midi_sysex_t&#96;, &#96;clap_event_midi2_t&#96;.\\\\\\\\n\\\\\\\\n### Extensions\\\\\\\\n\\\\\\\\nCLAP uses an extension-based architecture. Common extensions include:\\\\\\\\n- **&#96;clap_plugin_params&#96;** (&#96;ext/params.zig&#96;) â€” Parameter info, value queries, text conversion.\\\\\\\\n- **&#96;clap_plugin_state&#96;** (&#96;ext/state.zig&#96;) â€” State save/load via streams.\\\\\\\\n- **&#96;clap_plugin_audio_ports&#96;** (&#96;ext/audio_ports.zig&#96;) â€” Audio bus info (channel counts, names).\\\\\\\\n- **&#96;clap_plugin_note_ports&#96;** (&#96;ext/note_ports.zig&#96;) â€” Note input/output port info.\\\\\\\\n- **&#96;clap_plugin_gui&#96;** (&#96;ext/gui.zig&#96;) â€” GUI creation, embedding, resizing.\\\\\\\\n- **&#96;clap_plugin_latency&#96;** (&#96;ext/latency.zig&#96;) â€” Report processing latency.\\\\\\\\n- **&#96;clap_plugin_tail&#96;** (&#96;ext/tail.zig&#96;) â€” Report tail length (e.g., reverb decay).\\\\\\\\n\\\\\\\\nAll extensions follow the pattern: plugin exposes an extension struct with function pointers, host queries via &#96;clap_plugin::get_extension&#96;.\\\\\\\\n\\\\\\\\n## Usage by Wrappers\\\\\\\\n\\\\\\\\nThe CLAP wrapper (&#96;src/wrappers/clap/&#96;) uses these bindings to implement the CLAP ABI:\\\\\\\\n\\\\\\\\n1. **Export &#96;clap_entry&#96;** with &#96;init&#96;, &#96;deinit&#96;, &#96;get_factory&#96;.\\\\\\\\n2. **Implement &#96;clap_plugin_factory&#96;** to create plugin instances.\\\\\\\\n3. **Implement &#96;clap_plugin&#96;** with vtable functions that delegate to the framework core.\\\\\\\\n4. **Translate events** from &#96;clap_event_*&#96; to framework &#96;NoteEvent&#96;.\\\\\\\\n5. **Map audio buffers** from &#96;clap_audio_buffer_t&#96; to framework &#96;Buffer&#96; (zero-copy).\\\\\\\\n6. **Implement extensions** to expose parameters, state, ports, etc.\\\\\\\\n\\\\\\\\n## Zig 0.15.2 Compatibility\\\\\\\\n\\\\\\\\nThese bindings have been updated for Zig 0.15.2:\\\\\\\\n- All &#96;extern struct&#96; function pointer fields use explicit &#96;callconv(.c)&#96;.\\\\\\\\n- No &#96;usingnamespace&#96; (was removed from Zig).\\\\\\\\n- Explicit type annotations where required by 0.15.2 type inference changes.\\\\\\\\n\\\\\\\\n## Testing\\\\\\\\n\\\\\\\\nThe bindings include basic tests verifying struct layouts and function pointer types. Run with:\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;bash\\\\\\\\nzig build test\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\nCLAP bindings tests are part of the main test suite (43 tests from this module).\\\\\\\\n\\\\\\\\n## See Also\\\\\\\\n\\\\\\\\n- **[CLAP specification](https://github.com/free-audio/clap)** â€” Official CLAP headers and documentation\\\\\\\\n- **[Nakst CLAP tutorials](https://nakst.gitlab.io/tutorial/clap-part-1.html)** â€” Step-by-step C implementation\\\\\\\\n- **[docs/architecture.md](../../docs/architecture.md)** â€” How bindings fit into the overall architecture\\\\\\\\n- **Original bindings:** [clap-zig-bindings](https://git.sr.ht/~interpunct/clap-zig-bindings)\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":133}\\\"},\\\"capabilityType\\\":15}\",\"14f849d8-e830-487b-9e0b-555d2591d0a0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"16adf85b-9b01-4538-896c-29590bb6bc28\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_da65e2dd-3ea0-40c1-bc4a-994dbcf3ea2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_da65e2dd-3ea0-40c1-bc4a-994dbcf3ea2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/README.md\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/README.md\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/README.md\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"# VST3 Bindings Module\\\\\\\\n\\\\\\\\nHand-written idiomatic Zig bindings for Steinberg's VST3 C API.\\\\\\\\n\\\\\\\\n## Purpose\\\\\\\\n\\\\\\\\nThis module provides Zig bindings for the [VST3 C API](https://github.com/steinbergmedia/vst3_c_api). The bindings are:\\\\\\\\n- **Hand-written** â€” Idiomatic Zig translations of ~15 core VST3 interfaces\\\\\\\\n- **Comptime-driven** â€” GUID parsing and vtable generation via comptime metaprogramming\\\\\\\\n- **Thin and mechanical** â€” No framework logic; pure ABI translation\\\\\\\\n- **COM-compatible** â€” Implements &#96;FUnknown&#96; pattern with &#96;queryInterface&#96; and reference counting\\\\\\\\n\\\\\\\\n## License\\\\\\\\n\\\\\\\\n- **Based on:** [Steinberg vst3_c_api](https://github.com/steinbergmedia/vst3_c_api)\\\\\\\\n- **License:** MIT (as of October 2025, VST3 moved to MIT licensing)\\\\\\\\n- Implementation is hand-written based on the upstream C API structure\\\\\\\\n\\\\\\\\n## Structure\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;\\\\\\\\nsrc/bindings/vst3/\\\\\\\\nâ”œâ”€â”€ root.zig              # Root module, re-exports all types\\\\\\\\nâ”œâ”€â”€ types.zig             # Fundamental types (tresult, TUID, ParamID, Sample32/64, etc.)\\\\\\\\nâ”œâ”€â”€ guid.zig              # GUID parsing, TUID constants\\\\\\\\nâ”‚\\\\\\\\nâ”œâ”€â”€ funknown.zig          # FUnknown base interface (IID, queryInterface, addRef, release)\\\\\\\\nâ”œâ”€â”€ factory.zig           # IPluginFactory, IPluginFactory2, IPluginFactory3\\\\\\\\nâ”œâ”€â”€ component.zig         # IComponent (plugin lifecycle, bus info, routing)\\\\\\\\nâ”œâ”€â”€ processor.zig         # IAudioProcessor (setupProcessing, process, getTailSamples)\\\\\\\\nâ”œâ”€â”€ controller.zig        # IEditController (parameters, UI state)\\\\\\\\nâ”‚\\\\\\\\nâ”œâ”€â”€ events.zig            # IEventList, Event (note on/off, data, poly pressure)\\\\\\\\nâ”œâ”€â”€ param_changes.zig     # IParameterChanges, IParamValueQueue\\\\\\\\nâ”œâ”€â”€ stream.zig            # IBStream (state I/O)\\\\\\\\nâ”œâ”€â”€ connection.zig        # IConnectionPoint (processor â†” controller messages)\\\\\\\\nâ”œâ”€â”€ view.zig              # IPlugView (GUI embedding)\\\\\\\\nâ”‚\\\\\\\\nâ””â”€â”€ layout_tests.zig      # Test struct layouts match upstream\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\n## Key Types\\\\\\\\n\\\\\\\\n### Fundamental Types (types.zig)\\\\\\\\n\\\\\\\\n- **&#96;tresult&#96;** â€” &#96;i32&#96; result code. Constants: &#96;kResultOk&#96;, &#96;kResultFalse&#96;, &#96;kNoInterface&#96;, &#96;kInvalidArgument&#96;, etc.\\\\\\\\n- **&#96;TUID&#96;** â€” &#96;[16]u8&#96; â€” UUID/GUID for interface identification.\\\\\\\\n- **&#96;ParamID&#96;** â€” &#96;u32&#96; â€” Parameter identifier.\\\\\\\\n- **&#96;ParamValue&#96;** â€” &#96;f64&#96; â€” Normalized parameter value (0.0â€“1.0).\\\\\\\\n- **&#96;Sample32&#96;, &#96;Sample64&#96;** â€” &#96;f32&#96;, &#96;f64&#96; â€” Audio sample types.\\\\\\\\n- **&#96;SampleRate&#96;** â€” &#96;f64&#96; â€” Sample rate in Hz.\\\\\\\\n- **&#96;TSamples&#96;** â€” &#96;i64&#96; â€” Sample count.\\\\\\\\n- **&#96;TQuarterNotes&#96;** â€” &#96;f64&#96; â€” Musical time in quarter notes.\\\\\\\\n- **Enums:** &#96;MediaTypes&#96;, &#96;BusDirections&#96;, &#96;BusTypes&#96;, &#96;IoModes&#96;, &#96;SymbolicSampleSizes&#96;, &#96;ProcessModes&#96;.\\\\\\\\n\\\\\\\\n### COM Base (funknown.zig)\\\\\\\\n\\\\\\\\n- **&#96;FUnknown&#96;** â€” Base interface with vtable:\\\\\\\\n  - &#96;queryInterface(iid: *const TUID, obj: **anyopaque) tresult&#96;\\\\\\\\n  - &#96;addRef() u32&#96;\\\\\\\\n  - &#96;release() u32&#96;\\\\\\\\n- All VST3 interfaces inherit from &#96;FUnknown&#96;.\\\\\\\\n- Use &#96;guid.zig&#96; for comptime GUID generation from string IDs.\\\\\\\\n\\\\\\\\n### Factory Interfaces (factory.zig)\\\\\\\\n\\\\\\\\n- **&#96;IPluginFactory&#96;** â€” Basic plugin factory (get plugin count, info, create instance).\\\\\\\\n- **&#96;IPluginFactory2&#96;** â€” Extended with &#96;getClassInfo2&#96; (subcategories, SDK version).\\\\\\\\n- **&#96;IPluginFactory3&#96;** â€” Extended with &#96;getClassInfoUnicode&#96; (Unicode metadata).\\\\\\\\n- **&#96;GetPluginFactory()&#96;** â€” Exported function that returns &#96;*IPluginFactory&#96;.\\\\\\\\n\\\\\\\\n### Core Plugin Interfaces\\\\\\\\n\\\\\\\\n**IComponent** (&#96;component.zig&#96;)\\\\\\\\n- Plugin lifecycle: &#96;initialize&#96;, &#96;terminate&#96;\\\\\\\\n- Bus management: &#96;getBusCount&#96;, &#96;getBusInfo&#96;, &#96;activateBus&#96;\\\\\\\\n- Routing: &#96;getRoutingInfo&#96;, &#96;setIoMode&#96;, &#96;setActive&#96;\\\\\\\\n- State: &#96;getState&#96;, &#96;setState&#96;\\\\\\\\n\\\\\\\\n**IAudioProcessor** (&#96;processor.zig&#96;)\\\\\\\\n- Processing setup: &#96;setBusArrangements&#96;, &#96;getBusArrangement&#96;, &#96;setupProcessing&#96;\\\\\\\\n- Process control: &#96;setProcessing&#96;, &#96;process&#96;\\\\\\\\n- Latency/tail: &#96;getLatencySamples&#96;, &#96;getTailSamples&#96;\\\\\\\\n\\\\\\\\n**IEditController** (&#96;controller.zig&#96;)\\\\\\\\n- Parameter management: &#96;getParameterCount&#96;, &#96;getParameterInfo&#96;, &#96;setParamNormalized&#96;, &#96;getParamNormalized&#96;\\\\\\\\n- Value conversion: &#96;normalizedParamToPlain&#96;, &#96;plainParamToNormalized&#96;, &#96;getParamStringByValue&#96;\\\\\\\\n- UI state: &#96;setComponentState&#96;, &#96;setState&#96;, &#96;getState&#96;\\\\\\\\n\\\\\\\\n### Process Data (processor.zig)\\\\\\\\n\\\\\\\\n**&#96;ProcessData&#96;** â€” Passed to &#96;IAudioProcessor::process&#96;:\\\\\\\\n- &#96;process_mode&#96; â€” Realtime, offline, prefetch\\\\\\\\n- &#96;symbolic_sample_size&#96; â€” 32-bit or 64-bit samples\\\\\\\\n- &#96;num_samples&#96; â€” Number of samples to process\\\\\\\\n- &#96;num_inputs&#96;, &#96;num_outputs&#96; â€” Bus counts\\\\\\\\n- &#96;inputs&#96;, &#96;outputs&#96; â€” &#96;AudioBusBuffers&#96; arrays\\\\\\\\n- &#96;input_parameter_changes&#96;, &#96;output_parameter_changes&#96; â€” &#96;IParameterChanges&#96;\\\\\\\\n- &#96;input_events&#96;, &#96;output_events&#96; â€” &#96;IEventList&#96;\\\\\\\\n- &#96;process_context&#96; â€” Transport, tempo, time signature, position\\\\\\\\n\\\\\\\\n**&#96;AudioBusBuffers&#96;** â€” Non-interleaved audio buffer:\\\\\\\\n- &#96;num_channels&#96; â€” Channel count\\\\\\\\n- &#96;silence_flags&#96; â€” Bitmask indicating silent channels\\\\\\\\n- &#96;channel_buffers_32&#96;, &#96;channel_buffers_64&#96; â€” Audio data pointers\\\\\\\\n\\\\\\\\n**&#96;ProcessContext&#96;** â€” Transport and timeline info:\\\\\\\\n- State flags: &#96;kPlaying&#96;, &#96;kCycleActive&#96;, &#96;kRecording&#96;, etc.\\\\\\\\n- Time: &#96;project_time_samples&#96;, &#96;continuous_time_samples&#96;, &#96;project_time_music&#96;\\\\\\\\n- Tempo: &#96;tempo&#96; (BPM), &#96;tempo_increment&#96;\\\\\\\\n- Time signature: &#96;time_sig_numerator&#96;, &#96;time_sig_denominator&#96;\\\\\\\\n- Loop: &#96;cycle_start_music&#96;, &#96;cycle_end_music&#96;\\\\\\\\n\\\\\\\\n### Events (events.zig)\\\\\\\\n\\\\\\\\n**&#96;Event&#96;** â€” Generic event structure with union containing:\\\\\\\\n- &#96;NoteOnEvent&#96; â€” Note on with velocity, tuning, length, note ID\\\\\\\\n- &#96;NoteOffEvent&#96; â€” Note off with velocity, tuning, note ID\\\\\\\\n- &#96;DataEvent&#96; â€” Sysex or other data events\\\\\\\\n- &#96;PolyPressureEvent&#96; â€” Per-note aftertouch\\\\\\\\n\\\\\\\\n**&#96;IEventList&#96;** â€” Event list interface:\\\\\\\\n- &#96;getEventCount() i32&#96;\\\\\\\\n- &#96;getEvent(index: i32, e: *Event) tresult&#96;\\\\\\\\n- &#96;addEvent(e: *const Event) tresult&#96;\\\\\\\\n\\\\\\\\n### Parameters (param_changes.zig)\\\\\\\\n\\\\\\\\n**&#96;IParameterChanges&#96;** â€” Container for parameter change queues:\\\\\\\\n- &#96;getParameterCount() i32&#96;\\\\\\\\n- &#96;getParameterData(index: i32) ?*IParamValueQueue&#96;\\\\\\\\n- &#96;addParameterData(id: *ParamID, index: *i32) ?*IParamValueQueue&#96;\\\\\\\\n\\\\\\\\n**&#96;IParamValueQueue&#96;** â€” Sample-accurate parameter automation:\\\\\\\\n- &#96;getParameterId() ParamID&#96;\\\\\\\\n- &#96;getPointCount() i32&#96;\\\\\\\\n- &#96;getPoint(index: i32, sample_offset: *i32, value: *ParamValue) tresult&#96;\\\\\\\\n- &#96;addPoint(sample_offset: i32, value: ParamValue, index: *i32) tresult&#96;\\\\\\\\n\\\\\\\\n### State (stream.zig)\\\\\\\\n\\\\\\\\n**&#96;IBStream&#96;** â€” Stream interface for state save/load:\\\\\\\\n- &#96;read(buffer: *anyopaque, num_bytes: i32, num_bytes_read: *i32) tresult&#96;\\\\\\\\n- &#96;write(buffer: *const anyopaque, num_bytes: i32, num_bytes_written: *i32) tresult&#96;\\\\\\\\n- &#96;seek(pos: i64, mode: i32, result: *i64) tresult&#96;\\\\\\\\n- &#96;tell(pos: *i64) tresult&#96;\\\\\\\\n\\\\\\\\n## Usage by Wrappers\\\\\\\\n\\\\\\\\nThe VST3 wrapper (&#96;src/wrappers/vst3/&#96;) uses these bindings to implement the COM ABI:\\\\\\\\n\\\\\\\\n1. **Export &#96;GetPluginFactory()&#96;** returning &#96;*IPluginFactory&#96;.\\\\\\\\n2. **Implement factory** to create plugin component instances.\\\\\\\\n3. **Implement &#96;IComponent&#96;** with bus management, activation, state.\\\\\\\\n4. **Implement &#96;IAudioProcessor&#96;** with &#96;process&#96; delegating to framework core.\\\\\\\\n5. **Implement &#96;IEditController&#96;** for parameter management and UI state.\\\\\\\\n6. **Translate events** from &#96;IEventList&#96; to framework &#96;NoteEvent&#96;.\\\\\\\\n7. **Map audio buffers** from &#96;AudioBusBuffers&#96; to framework &#96;Buffer&#96; (zero-copy).\\\\\\\\n8. **Handle COM reference counting** using &#96;FUnknown&#96; pattern.\\\\\\\\n\\\\\\\\n## Zig 0.15.2 Compatibility\\\\\\\\n\\\\\\\\nThese bindings are written for Zig 0.15.2:\\\\\\\\n- All &#96;extern struct&#96; function pointer fields use explicit &#96;callconv(.c)&#96;.\\\\\\\\n- GUID parsing is done at comptime using &#96;guid.zig&#96;.\\\\\\\\n- No &#96;usingnamespace&#96; (removed from Zig).\\\\\\\\n\\\\\\\\n## Testing\\\\\\\\n\\\\\\\\nThe bindings include layout tests verifying struct sizes and offsets match the upstream C API. Run with:\\\\\\\\n\\\\\\\\n&#96;&#96;&#96;bash\\\\\\\\nzig build test\\\\\\\\n&#96;&#96;&#96;\\\\\\\\n\\\\\\\\nVST3 bindings tests are part of the main test suite (2 tests from this module).\\\\\\\\n\\\\\\\\n## See Also\\\\\\\\n\\\\\\\\n- **[VST3 C API](https://github.com/steinbergmedia/vst3_c_api)** â€” Official C API headers\\\\\\\\n- **[VST3 SDK](https://github.com/steinbergmedia/vst3sdk)** â€” Full SDK with C++ implementation and examples\\\\\\\\n- **[VST3 Developer Portal](https://steinbergmedia.github.io/vst3_dev_portal/)** â€” Official documentation\\\\\\\\n- **[SuperElectric blog](https://superelectric.dev/post/post1.html)** â€” VST3 COM vtables in Zig with comptime\\\\\\\\n- **[docs/architecture.md](../../docs/architecture.md)** â€” How bindings fit into the overall architecture\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":185}\\\"},\\\"capabilityType\\\":15}\",\"48a54e61-ab30-4d39-ada7-2e571b6986b2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"09ac7bd9-2143-4eef-b189-e1a7d60dd48a\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_82ff2168-29e0-49f1-988e-802bd1ef807\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_82ff2168-29e0-49f1-988e-802bd1ef807\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"^src/wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_82ff2168-29e0-49f1-988e-802bd1ef807\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"^src/wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"^src/wrappers\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{}}}}}\\\"},\\\"capabilityType\\\":15}\",\"d4919d13-2256-4a84-aeb4-43b0913a488a\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"4a1970a8-bf7a-4d5b-8cc9-381e3b22cec6\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_9cce7507-ce67-43cf-bed7-53980e37f2f\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_9cce7507-ce67-43cf-bed7-53980e37f2f\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/stream.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":50}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/stream.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":50,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/clap/stream.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"pub const IStream = extern struct {\\\\\\\\n    /// number of bytes read, end of file, or an unknown error.\\\\\\\\n    pub const Result = enum(i64) { read_error = -1, end_of_file = 0, _ };\\\\\\\\n\\\\\\\\n    context: *anyopaque,\\\\\\\\n    read: *const fn (\\\\\\\\n        stream: *const IStream,\\\\\\\\n        buffer: *anyopaque,\\\\\\\\n        size: u64,\\\\\\\\n    ) callconv(.c) Result,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const OStream = extern struct {\\\\\\\\n    /// number of bytes written or an unknown error.\\\\\\\\n    pub const Result = enum(i64) { write_error = -1, _ };\\\\\\\\n\\\\\\\\n    context: *anyopaque,\\\\\\\\n    write: *const fn (\\\\\\\\n        stream: *const OStream,\\\\\\\\n        bufer: *const anyopaque,\\\\\\\\n        size: u64,\\\\\\\\n    ) callconv(.c) Result,\\\\\\\\n};\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":24}\\\"},\\\"capabilityType\\\":15}\",\"4b0d6a75-4a62-4d33-b9d3-10d909ba0c65\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"1e554777-de70-4d66-ac4d-87506e99f577\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_20dd0a47-7815-48f7-97fa-01314ca237b\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_20dd0a47-7815-48f7-97fa-01314ca237b\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/stream.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":50}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/stream.zig\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":50,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/src/bindings/vst3/stream.zig\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"// VST3 C API Bindings - IBStream Interface\\\\\\\\n// Based on steinbergmedia/vst3_c_api\\\\\\\\n\\\\\\\\nconst types = @import(\\\\\\\\\\\\\\\"types.zig\\\\\\\\\\\\\\\");\\\\\\\\nconst guid = @import(\\\\\\\\\\\\\\\"guid.zig\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\nconst TUID = types.TUID;\\\\\\\\nconst tresult = types.tresult;\\\\\\\\nconst vst3_callconv = types.vst3_callconv;\\\\\\\\nconst TSize = types.TSize;\\\\\\\\n\\\\\\\\n/// Seek modes for IBStream\\\\\\\\npub const IStreamSeekMode = enum(i32) {\\\\\\\\n    kIBSeekSet = 0,\\\\\\\\n    kIBSeekCur = 1,\\\\\\\\n    kIBSeekEnd = 2,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// IBStream interface vtable\\\\\\\\npub const IBStreamVtbl = extern struct {\\\\\\\\n    // FUnknown methods\\\\\\\\n    queryInterface: *const fn (*anyopaque, *const TUID, *?*anyopaque) callconv(.c) tresult,\\\\\\\\n    addRef: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    release: *const fn (*anyopaque) callconv(.c) u32,\\\\\\\\n    \\\\\\\\n    // IBStream methods\\\\\\\\n    read: *const fn (*anyopaque, *anyopaque, i32, *i32) callconv(.c) tresult,\\\\\\\\n    write: *const fn (*anyopaque, *anyopaque, i32, *i32) callconv(.c) tresult,\\\\\\\\n    seek: *const fn (*anyopaque, i64, i32, *i64) callconv(.c) tresult,\\\\\\\\n    tell: *const fn (*anyopaque, *i64) callconv(.c) tresult,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IBStream = extern struct {\\\\\\\\n    lpVtbl: *const IBStreamVtbl,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub const IID_IBStream = guid.parseGuid(\\\\\\\\\\\\\\\"C3BF6EA2-3099-4752-9B6B-F9901EE33E9B\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":38}\\\"},\\\"capabilityType\\\":15}\",\"0b4cf422-6c1a-4f73-bc78-becc429a29f0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"bd529d99-6287-4994-b23a-4a9faaa9502f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.037Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\n## Complete Codebase Exploration Summary\\\\n\\\\n### 1. Directory Structure\\\\n\\\\n**Root Level:**\\\\n- &#96;build.zig&#96; - Build system with module definitions\\\\n- &#96;src/&#96; - Main source directory\\\\n- &#96;docs/&#96; - High-level documentation\\\\n- &#96;README.md&#96; - Project overview\\\\n- &#96;AGENTS.md&#96; - Coding standards and architecture rules\\\\n- &#96;zig-plug-design.md&#96; - Design document\\\\n- &#96;nih-plug/&#96; - Reference implementation (submodule)\\\\n\\\\n**Source Structure (&#96;src/&#96;):**\\\\n&#96;&#96;&#96;\\\\nsrc/\\\\nâ”œâ”€â”€ root.zig              # Public API re-exports âœ…\\\\nâ”œâ”€â”€ main.zig              # Example executable (placeholder)\\\\nâ”œâ”€â”€ core/                 # Framework core (API-agnostic) âœ…\\\\nâ”‚   â”œâ”€â”€ plugin.zig       # Plugin interface, comptime validation\\\\nâ”‚   â”œâ”€â”€ buffer.zig        # Zero-copy buffer abstraction\\\\nâ”‚   â”œâ”€â”€ params.zig        # Parameter system\\\\nâ”‚   â”œâ”€â”€ events.zig        # Unified note/MIDI events\\\\nâ”‚   â”œâ”€â”€ state.zig         # State persistence\\\\nâ”‚   â”œâ”€â”€ audio_layout.zig  # Audio I/O config, transport\\\\nâ”‚   â””â”€â”€ README.md         # Module documentation\\\\nâ”œâ”€â”€ bindings/\\\\nâ”‚   â”œâ”€â”€ clap/            # CLAP C API bindings âœ…\\\\nâ”‚   â”‚   â”œâ”€â”€ main.zig      # Root module\\\\nâ”‚   â”‚   â”œâ”€â”€ entry.zig     # clap_entry\\\\nâ”‚   â”‚   â”œâ”€â”€ plugin.zig    # clap_plugin\\\\nâ”‚   â”‚   â”œâ”€â”€ process.zig   # clap_process_t\\\\nâ”‚   â”‚   â”œâ”€â”€ events.zig    # Event types\\\\nâ”‚   â”‚   â”œâ”€â”€ stream.zig    # IStream/OStream\\\\nâ”‚   â”‚   â”œâ”€â”€ factory/      # Factory interfaces\\\\nâ”‚   â”‚   â”œâ”€â”€ ext/          # 30+ extension files\\\\nâ”‚   â”‚   â”œâ”€â”€ LICENSE       # LGPL v3.0\\\\nâ”‚   â”‚   â””â”€â”€ README.md     # Module documentation\\\\nâ”‚   â””â”€â”€ vst3/            # VST3 C API bindings âœ…\\\\nâ”‚       â”œâ”€â”€ root.zig      # Root module\\\\nâ”‚       â”œâ”€â”€ types.zig     # Fundamental types\\\\nâ”‚       â”œâ”€â”€ guid.zig      # GUID parsing\\\\nâ”‚       â”œâ”€â”€ funknown.zig  # FUnknown base\\\\nâ”‚       â”œâ”€â”€ factory.zig   # IPluginFactory\\\\nâ”‚       â”œâ”€â”€ component.zig # IComponent\\\\nâ”‚       â”œâ”€â”€ processor.zig # IAudioProcessor\\\\nâ”‚       â”œâ”€â”€ controller.zig # IEditController\\\\nâ”‚       â”œâ”€â”€ events.zig    # IEventList\\\\nâ”‚       â”œâ”€â”€ stream.zig    # IBStream\\\\nâ”‚       â”œâ”€â”€ layout_tests.zig # Layout validation tests\\\\nâ”‚       â””â”€â”€ README.md     # Module documentation\\\\nâ””â”€â”€ wrappers/            # Format wrappers âŒ NOT YET CREATED\\\\n&#96;&#96;&#96;\\\\n\\\\n### 2. What's Implemented in &#96;src/core/&#96;\\\\n\\\\nAll 6 core modules are implemented:\\\\n\\\\n#### &#96;plugin.zig&#96; (411 lines)\\\\n- &#96;Plugin(comptime T)&#96; - Comptime validation function\\\\n- &#96;ProcessStatus&#96; - Return type from process function\\\\n- &#96;ProcessContext&#96; - Context passed to process\\\\n- &#96;EventOutputList&#96; - Bounded output event list\\\\n- Comptime validation with clear error messages\\\\n- Tests for validation and EventOutputList\\\\n\\\\n#### &#96;buffer.zig&#96; (344 lines)\\\\n- &#96;Buffer&#96; - Zero-copy wrapper (&#96;[][]f32&#96;)\\\\n- &#96;AuxBuffers&#96; - Auxiliary I/O buses\\\\n- Three iteration strategies:\\\\n  - Raw slice access (&#96;getChannel&#96;, &#96;getSample&#96;, &#96;setSample&#96;)\\\\n  - Per-sample iteration (&#96;iterSamples()&#96;)\\\\n  - Per-block iteration (&#96;iterBlocks(max_block_size)&#96;)\\\\n- Tests for all access patterns and zero-copy guarantees\\\\n\\\\n#### &#96;params.zig&#96; (403 lines)\\\\n- &#96;Param&#96; - Tagged union (float, int, boolean, choice)\\\\n- &#96;FloatRange&#96; / &#96;IntRange&#96; - Value ranges with normalize/unnormalize\\\\n- &#96;ParamFlags&#96; - Packed struct for automation/visibility flags\\\\n- &#96;ParamValues(N)&#96; - Lock-free atomic storage using &#96;std.atomic.Value(f32)&#96;\\\\n- &#96;idHash(comptime str)&#96; - FNV-1a hash for VST3 ParamID generation\\\\n- Tests for ranges, hashing, and atomic access\\\\n\\\\n#### &#96;events.zig&#96; (208 lines)\\\\n- &#96;NoteEvent&#96; - Tagged union unifying CLAP and VST3 events:\\\\n  - Note events: &#96;note_on&#96;, &#96;note_off&#96;, &#96;choke&#96;, &#96;voice_terminated&#96;\\\\n  - Poly expression: &#96;poly_pressure&#96;, &#96;poly_tuning&#96;, &#96;poly_vibrato&#96;, &#96;poly_expression&#96;, &#96;poly_brightness&#96;, &#96;poly_volume&#96;, &#96;poly_pan&#96;\\\\n  - MIDI: &#96;midi_cc&#96;, &#96;midi_channel_pressure&#96;, &#96;midi_pitch_bend&#96;, &#96;midi_program_change&#96;\\\\n- Helper methods: &#96;timing()&#96;, &#96;channel()&#96;, &#96;voiceId()&#96;\\\\n- Tests for event extraction\\\\n\\\\n#### &#96;state.zig&#96; (235 lines)\\\\n- &#96;SaveContext&#96; - Type-erased writer (&#96;std.io.AnyWriter&#96;)\\\\n- &#96;LoadContext&#96; - Type-erased reader (&#96;std.io.AnyReader&#96;) with version\\\\n- Helper methods: &#96;write()&#96;, &#96;read()&#96;, &#96;writeString()&#96;, &#96;readString()&#96;, etc.\\\\n- &#96;writeHeader()&#96; / &#96;readHeader()&#96; - Magic bytes + version\\\\n- Uses Zig 0.15.2 &#96;std.io.AnyReader&#96; / &#96;AnyWriter&#96;\\\\n- Tests for roundtrips and error handling\\\\n\\\\n#### &#96;audio_layout.zig&#96; (185 lines)\\\\n- &#96;AudioIOLayout&#96; - Channel configuration declarations\\\\n- &#96;BufferConfig&#96; - Runtime config (sample rate, buffer size, process mode)\\\\n- &#96;ProcessMode&#96; - realtime, buffered, offline\\\\n- &#96;MidiConfig&#96; - none, basic, midi_cc\\\\n- &#96;Transport&#96; - Unified transport/timeline info\\\\n- Predefined layouts: &#96;MONO&#96;, &#96;STEREO&#96;, &#96;STEREO_OUT&#96;\\\\n- Tests for layout calculations\\\\n\\\\n### 3. What Exists in &#96;src/wrappers/&#96;\\\\n\\\\n**Nothing yet** - The directory doesn't exist. This is Phase 3 (planned).\\\\n\\\\nAccording to &#96;AGENTS.md&#96; and &#96;docs/architecture.md&#96;, the wrappers should:\\\\n- &#96;src/wrappers/clap/&#96; - CLAP wrapper (C struct ABI)\\\\n- &#96;src/wrappers/vst3/&#96; - VST3 wrapper (COM vtable ABI)\\\\n\\\\n### 4. What Exists in &#96;src/bindings/&#96;\\\\n\\\\n#### CLAP Bindings (&#96;src/bindings/clap/&#96;) - Complete\\\\n- 45+ files covering CLAP 1.2.2 API\\\\n- Core: &#96;entry.zig&#96;, &#96;plugin.zig&#96;, &#96;host.zig&#96;, &#96;process.zig&#96;, &#96;events.zig&#96;, &#96;audio_buffer.zig&#96;, &#96;stream.zig&#96;\\\\n- Factory: &#96;factory/plugin.zig&#96;, &#96;factory/preset_discovery.zig&#96;\\\\n- Extensions (&#96;ext/&#96;): 30+ files including:\\\\n  - &#96;params.zig&#96;, &#96;state.zig&#96;, &#96;audio_ports.zig&#96;, &#96;note_ports.zig&#96;\\\\n  - &#96;gui.zig&#96;, &#96;latency.zig&#96;, &#96;tail.zig&#96;, &#96;render.zig&#96;\\\\n  - And many more\\\\n- License: LGPL v3.0 (from clap-zig-bindings)\\\\n- Zig 0.15.2 compatible (explicit &#96;callconv(.c)&#96;, no &#96;usingnamespace&#96;)\\\\n\\\\n#### VST3 Bindings (&#96;src/bindings/vst3/&#96;) - Complete\\\\n- 12+ core interface files\\\\n- &#96;types.zig&#96; - Fundamental types (tresult, TUID, ParamID, etc.)\\\\n- &#96;guid.zig&#96; - Comptime GUID parsing\\\\n- &#96;funknown.zig&#96; - FUnknown base interface\\\\n- &#96;factory.zig&#96; - IPluginFactory interfaces\\\\n- &#96;component.zig&#96; - IComponent\\\\n- &#96;processor.zig&#96; - IAudioProcessor with ProcessData\\\\n- &#96;controller.zig&#96; - IEditController\\\\n- &#96;events.zig&#96; - IEventList and Event types\\\\n- &#96;param_changes.zig&#96; - IParameterChanges\\\\n- &#96;stream.zig&#96; - IBStream\\\\n- &#96;connection.zig&#96; - IConnectionPoint\\\\n- &#96;view.zig&#96; - IPlugView\\\\n- &#96;layout_tests.zig&#96; - Comprehensive layout validation (360+ lines)\\\\n- License: MIT\\\\n- Zig 0.15.2 compatible\\\\n\\\\n### 5. Current &#96;build.zig&#96;\\\\n\\\\n- Defines three modules:\\\\n  - &#96;clap-bindings&#96; - Points to &#96;src/bindings/clap/main.zig&#96;\\\\n  - &#96;vst3-bindings&#96; - Points to &#96;src/bindings/vst3/root.zig&#96;\\\\n  - &#96;z_plug&#96; - Main framework module pointing to &#96;src/root.zig&#96;\\\\n- Creates test executables for all modules\\\\n- Has a &#96;test&#96; step that runs all tests\\\\n- No &#96;addPlugin()&#96; helper yet (planned for Phase 3)\\\\n\\\\n### 6. Current &#96;src/root.zig&#96;\\\\n\\\\nPublic API re-exports:\\\\n- Plugin interface: &#96;Plugin&#96;, &#96;ProcessStatus&#96;, &#96;ProcessContext&#96;, &#96;EventOutputList&#96;\\\\n- Buffer types: &#96;Buffer&#96;, &#96;AuxBuffers&#96;\\\\n- Events: &#96;NoteEvent&#96;, &#96;NoteData&#96;, &#96;PolyValueData&#96;, &#96;MidiCCData&#96;, etc.\\\\n- Parameters: &#96;Param&#96;, &#96;FloatParam&#96;, &#96;IntParam&#96;, &#96;BoolParam&#96;, &#96;ChoiceParam&#96;, &#96;ParamFlags&#96;, &#96;ParamValues&#96;, &#96;idHash&#96;\\\\n- Audio I/O: &#96;AudioIOLayout&#96;, &#96;BufferConfig&#96;, &#96;ProcessMode&#96;, &#96;MidiConfig&#96;, &#96;Transport&#96;\\\\n- State: &#96;SaveContext&#96;, &#96;LoadContext&#96;, &#96;StateVersion&#96;\\\\n- Test block that references all core modules\\\\n\\\\n### 7. Existing Tests\\\\n\\\\n**Core Module Tests:**\\\\n- &#96;plugin.zig&#96;: 4 tests (ProcessStatus, EventOutputList, validation)\\\\n- &#96;buffer.zig&#96;: 7 tests (access patterns, iteration, zero-copy)\\\\n- &#96;params.zig&#96;: 10 tests (ranges, hashing, ParamValues)\\\\n- &#96;events.zig&#96;: 4 tests (timing, channel, voiceId extraction)\\\\n- &#96;state.zig&#96;: 6 tests (roundtrips, header validation)\\\\n- &#96;audio_layout.zig&#96;: 5 tests (layout constants, calculations)\\\\n\\\\n**Binding Tests:**\\\\n- &#96;vst3/layout_tests.zig&#96;: 30+ tests validating struct layouts, GUIDs, vtable field counts\\\\n- CLAP bindings: Basic tests via &#96;refAllDeclsRecursive&#96;\\\\n\\\\n**Test Execution:**\\\\n- &#96;zig build test&#96; runs all tests\\\\n- Tests are integrated into the build system\\\\n\\\\n### Summary\\\\n\\\\n**Completed:**\\\\n- Phase 1: Bindings layer (CLAP and VST3)\\\\n- Phase 2: Framework core (all 6 modules)\\\\n\\\\n**Not Yet Implemented:**\\\\n- Phase 3: Format wrappers (&#96;src/wrappers/clap/&#96; and &#96;src/wrappers/vst3/&#96;)\\\\n- Phase 4: Examples and polish\\\\n\\\\n**Code Quality:**\\\\n- Well-documented with &#96;///&#96; comments\\\\n- Comprehensive tests\\\\n- Module READMEs\\\\n- Follows Zig 0.15.2 patterns\\\\n- Clear separation of concerns\\\\n\\\\nThe codebase is ready for wrapper implementation. The core provides the abstractions, and the bindings provide the low-level ABI interfaces. The wrappers will bridge between them.\\\"}\"},\"status\":\"completed\",\"context\":{\"composers\":[],\"selectedCommits\":[],\"selectedPullRequests\":[],\"selectedImages\":[],\"folderSelections\":[],\"fileSelections\":[],\"selections\":[],\"terminalSelections\":[],\"selectedDocs\":[],\"externalLinks\":[],\"cursorRules\":[],\"cursorCommands\":[],\"gitPRDiffSelections\":[],\"subagentSelections\":[],\"browserSelections\":[],\"mentions\":{\"composers\":{},\"selectedCommits\":{},\"selectedPullRequests\":{},\"gitDiff\":[],\"gitDiffFromBranchToMain\":[],\"selectedImages\":{},\"folderSelections\":{},\"fileSelections\":{},\"terminalFiles\":{},\"selections\":{},\"terminalSelections\":{},\"selectedDocs\":{},\"externalLinks\":{},\"diffHistory\":[],\"cursorRules\":{},\"cursorCommands\":{},\"uiElementSelections\":[],\"consoleLogs\":[],\"ideEditorsState\":[],\"gitPRDiffSelections\":{},\"subagentSelections\":{},\"browserSelections\":{}}},\"generatingBubbleIds\":[],\"isReadingLongFile\":false,\"codeBlockData\":{},\"originalFileStates\":{},\"newlyCreatedFiles\":[],\"newlyCreatedFolders\":[],\"createdAt\":1771275097133,\"hasChangedContext\":false,\"activeTabsShouldBeReactive\":true,\"capabilities\":[{\"type\":30,\"data\":{}},{\"type\":15,\"data\":{\"bubbleDataMap\":\"{}\"}}],\"name\":\"Explore current codebase state\",\"isFileListExpanded\":false,\"browserChipManuallyDisabled\":false,\"browserChipManuallyEnabled\":false,\"unifiedMode\":\"agent\",\"forceMode\":\"edit\",\"usageData\":{},\"allAttachedFileCodeChunksUris\":[],\"modelConfig\":{\"modelName\":\"composer-1\",\"maxMode\":false},\"subComposerIds\":[],\"capabilityContexts\":[],\"todos\":[],\"isQueueExpanded\":true,\"hasUnreadMessages\":false,\"gitHubPromptDismissed\":false,\"totalLinesAdded\":0,\"totalLinesRemoved\":0,\"addedFiles\":0,\"removedFiles\":0,\"isDraft\":false,\"isCreatingWorktree\":false,\"isApplyingWorktree\":false,\"isUndoingWorktree\":false,\"applied\":false,\"pendingCreateWorktree\":false,\"isBestOfNSubcomposer\":false,\"isBestOfNParent\":false,\"bestOfNJudgeWinner\":false,\"isSpec\":false,\"isProject\":false,\"isSpecSubagentDone\":false,\"stopHookLoopCount\":0,\"speculativeSummarizationEncryptionKey\":\"Lpj+o+AzT0WIBK8LczcwP3qAeV3pZOMGyfKhvdtRAco=\",\"isNAL\":true,\"planModeSuggestionUsed\":false,\"debugModeSuggestionUsed\":false,\"conversationState\":\"~\",\"queueItems\":[],\"isAgentic\":true}"
}
```
Result:

```json
{
  "agentId": "059ea131-bb00-49b8-846d-5cc08a1fb739"
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a thorough understanding of both the design document and the current codebase state. Let me also look at the nih-plug reference wrappers and some key files to understand the specific patterns I'll need to implement. Let me read some key files that will inform the wrapper implementation.</details></think>

---

Now let me look at key reference files to understand the interfaces the wrappers need to bridge.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/core/plugin.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/root.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/build.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a comprehensive understanding. Let me also look at the key binding files to understand the ABI structures the wrappers need to implement, and reference nih-plug's wrapper structure.</details></think>

---

Let me now read the key binding entry points and the nih-plug wrapper references for both formats.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/entry.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/plugin.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/process.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/factory.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now let me look at some more critical binding files and the nih-plug reference wrappers.</details></think>

---

Let me read a few more key files to fully understand the interfaces.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/component.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/processor.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/funknown.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/factory/plugin.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now let me check what nih-plug's CLAP and VST3 wrappers look like for reference.</details></think>

---

Now let me examine the nih-plug reference wrappers for architecture guidance, and also check the CLAP bindings events and extensions.

---

<tool-use data-tool-type="unknown" data-tool-name="task_v2">
<details>
<summary>Tool use: **task_v2**</summary>


Parameters:

```json
{
  "description": "Explore nih-plug wrapper structure",
  "prompt": "Explore the nih-plug CLAP and VST3 wrapper source code at /Users/b/code/z-plug/nih-plug/. I need to understand:\n\n1. The file structure of the CLAP wrapper (src/wrapper/clap/)\n2. The file structure of the VST3 wrapper (src/wrapper/vst3/)\n3. How the CLAP wrapper exports clap_entry and creates the plugin factory\n4. How the VST3 wrapper exports GetPluginFactory\n5. How each wrapper translates process calls to the framework's process function\n6. How parameters are translated in both wrappers\n7. How events are translated\n8. How state save/load works in both wrappers\n\nRead the key files (entry points, process translation, parameter handling). Be thorough. Return a comprehensive summary of the wrapper architecture patterns used.",
  "subagentType": "explore",
  "model": "composer-1",
  "name": "explore"
}
```
Additional data:

```json
{
  "status": "success",
  "composerData": "{\"_v\":13,\"composerId\":\"task-toolu_01TKTJV7DQqJ1D2MMUVRfLyn\",\"richText\":\"\",\"hasLoaded\":true,\"text\":\"\",\"fullConversationHeadersOnly\":[{\"bubbleId\":\"415494ed-2d60-47b3-bc89-694d2e7d8fcd\",\"type\":2},{\"bubbleId\":\"35a8adf1-8839-4fcd-b9ff-12077275e0d8\",\"type\":2},{\"bubbleId\":\"c8ef227c-2776-485b-a93e-77743f5bd401\",\"type\":2},{\"bubbleId\":\"6ada09c0-c34c-496a-855e-c737adf2fc60\",\"type\":2},{\"bubbleId\":\"c1f4f871-d0b1-4bf1-a169-a3d054d28ee0\",\"type\":2},{\"bubbleId\":\"a5d9b250-35dc-4493-85d7-f7fb46d12e59\",\"type\":2},{\"bubbleId\":\"82a3755c-907a-4796-bd98-82abe5ebb372\",\"type\":2},{\"bubbleId\":\"9bfcd6b9-1ab8-4c85-b13d-e13ac276344e\",\"type\":2},{\"bubbleId\":\"9ea32ff9-b961-4002-a77c-e12a5935b08c\",\"type\":2},{\"bubbleId\":\"a42ebac0-34ba-4f92-82e2-9f707dc504b1\",\"type\":2},{\"bubbleId\":\"bad34363-a97e-4d80-b1ca-898aef3414e0\",\"type\":2},{\"bubbleId\":\"1e0458ec-c0b1-4134-a1f2-7afe35e6603e\",\"type\":2},{\"bubbleId\":\"63f32d2c-70dd-4c80-8fb7-dfaa66db4189\",\"type\":2},{\"bubbleId\":\"69f8bb74-09a8-4a11-ac24-9543befc2d60\",\"type\":2},{\"bubbleId\":\"f0bed69f-20ce-4f9b-a9e5-939124b2c482\",\"type\":2},{\"bubbleId\":\"858b4a70-3176-42e4-9f45-7ce8732b0482\",\"type\":2},{\"bubbleId\":\"be40e02d-3793-4447-bd69-b057419ffed1\",\"type\":2},{\"bubbleId\":\"e022594a-a3bc-49b5-b824-d103e501f4a0\",\"type\":2},{\"bubbleId\":\"401e3443-3eb5-4386-8a13-b4215d483776\",\"type\":2},{\"bubbleId\":\"02f0051c-c1b8-4bac-8e7d-c75267370a2d\",\"type\":2},{\"bubbleId\":\"65c0da92-bee8-48a8-879c-a6f8c9003210\",\"type\":2},{\"bubbleId\":\"8949dace-b7d5-4133-8408-14b038069709\",\"type\":2},{\"bubbleId\":\"2fb527c2-cc71-4d2e-b5bb-9d3bc8acc3c2\",\"type\":2},{\"bubbleId\":\"743d70c2-ba23-49ee-a0f5-c21f98e8c686\",\"type\":2},{\"bubbleId\":\"b4f0e9e1-26ed-485d-9fb3-fc0142152dba\",\"type\":2},{\"bubbleId\":\"00fdbacc-c0c4-49df-a6c5-4bb5b56093e7\",\"type\":2},{\"bubbleId\":\"d21bdb00-e31f-4866-bbb3-fcfc5cf73920\",\"type\":2},{\"bubbleId\":\"44679531-09e9-4229-bb3e-c09420b18fb2\",\"type\":2},{\"bubbleId\":\"e9ec6a27-6c91-458a-aa0a-2084bf70750a\",\"type\":2}],\"conversationMap\":{\"415494ed-2d60-47b3-bc89-694d2e7d8fcd\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"bf71c978-6e4c-4ff0-9b53-40d212f0a53b\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nExploring the nih-plug wrapper structure and key files. Starting with directory structure, then reading entry points, process translation, parameter handling, event translation, and state save/load.\\\\n\\\"}\",\"35a8adf1-8839-4fcd-b9ff-12077275e0d8\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"1801ded3-dc41-4342-93d3-f4d196bb4904\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_540c1cfb-8658-450a-aa00-b2fb7cfa0a9\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_540c1cfb-8658-450a-aa00-b2fb7cfa0a9\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"globPattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/clap/**/*\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\".\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/clap/**/*\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/util.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/features.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/context.rs\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":5}]}\\\"},\\\"capabilityType\\\":15}\",\"c8ef227c-2776-485b-a93e-77743f5bd401\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"f742eb7b-94ed-4ed9-b041-bc4778790f7d\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_89daed38-ff8e-411e-b878-a6067596afb\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_89daed38-ff8e-411e-b878-a6067596afb\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"glob_file_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"globPattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/vst3/**/*\\\\\\\"}\\\",\\\"tool\\\":42,\\\"params\\\":\\\"{\\\\\\\"targetDirectory\\\\\\\":\\\\\\\".\\\\\\\",\\\\\\\"globPattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/vst3/**/*\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"directories\\\\\\\":[{\\\\\\\"files\\\\\\\":[{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/view.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/util.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/subcategories.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/param_units.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/note_expressions.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/factory.rs\\\\\\\"},{\\\\\\\"relPath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/context.rs\\\\\\\"}],\\\\\\\"totalFiles\\\\\\\":9}]}\\\"},\\\"capabilityType\\\":15}\",\"6ada09c0-c34c-496a-855e-c737adf2fc60\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"c3e8846b-ef1a-4626-a8fc-d34f8c7c4677\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nReading key files to understand the wrapper architecture:\\\\n\\\"}\",\"c1f4f871-d0b1-4bf1-a169-a3d054d28ee0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e57f2cc4-778d-410e-88d8-25085c8b80e5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_6641f97d-b49e-438f-ae8b-8d19c2df0f4\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_6641f97d-b49e-438f-ae8b-8d19c2df0f4\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":3232}\\\"},\\\"capabilityType\\\":15}\",\"a5d9b250-35dc-4493-85d7-f7fb46d12e59\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"52aab881-9a5c-4446-93ac-6296fd4f3fa3\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.051Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_5d757a44-1ba2-422c-b5ad-3c2d8dc7f99\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_5d757a44-1ba2-422c-b5ad-3c2d8dc7f99\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use clap_sys::plugin::clap_plugin_descriptor;\\\\\\\\nuse clap_sys::version::CLAP_VERSION;\\\\\\\\nuse std::ffi::{CStr, CString};\\\\\\\\nuse std::os::raw::c_char;\\\\\\\\n\\\\\\\\nuse crate::prelude::ClapPlugin;\\\\\\\\n\\\\\\\\n/// A static descriptor for a plugin. This is used in both the descriptor and on the plugin object\\\\\\\\n/// itself.\\\\\\\\n///\\\\\\\\n/// This cannot be cloned as [&#96;Self::clap_features_ptrs&#96;] contains pointers to\\\\\\\\n/// [&#96;Self::clap_features&#96;].\\\\\\\\npub struct PluginDescriptor {\\\\\\\\n    // We need [CString]s for all of &#96;ClapPlugin&#96;'s &#96;&amp;str&#96; fields\\\\\\\\n    clap_id: CString,\\\\\\\\n    name: CString,\\\\\\\\n    vendor: CString,\\\\\\\\n    url: CString,\\\\\\\\n    version: CString,\\\\\\\\n    clap_manual_url: Option&lt;CString&gt;,\\\\\\\\n    clap_support_url: Option&lt;CString&gt;,\\\\\\\\n    clap_description: Option&lt;CString&gt;,\\\\\\\\n    clap_features: Vec&lt;CString&gt;,\\\\\\\\n\\\\\\\\n    /// The contains pointers to the strings in &#96;clap_features&#96;.\\\\\\\\n    clap_features_ptrs: Vec&lt;*const c_char&gt;,\\\\\\\\n    /// We only support a single plugin per descriptor right now, so we'll fill in the plugin\\\\\\\\n    /// descriptor upfront. We also need to initialize the &#96;CString&#96; fields above first before we\\\\\\\\n    /// can initialize this plugin descriptor.\\\\\\\\n    plugin_descriptor: Option&lt;clap_plugin_descriptor&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nunsafe impl Send for PluginDescriptor {}\\\\\\\\nunsafe impl Sync for PluginDescriptor {}\\\\\\\\n\\\\\\\\nimpl PluginDescriptor {\\\\\\\\n    /// Construct the plugin descriptor for a specific CLAP plugin.\\\\\\\\n    pub fn for_plugin&lt;P: ClapPlugin&gt;() -&gt; Self {\\\\\\\\n        let mut descriptor = Self {\\\\\\\\n            clap_id: CString::new(P::CLAP_ID).expect(\\\\\\\\\\\\\\\"&#96;CLAP_ID&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            name: CString::new(P::NAME).expect(\\\\\\\\\\\\\\\"&#96;NAME&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            vendor: CString::new(P::VENDOR).expect(\\\\\\\\\\\\\\\"&#96;VENDOR&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            url: CString::new(P::URL).expect(\\\\\\\\\\\\\\\"&#96;URL&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            version: CString::new(P::VERSION).expect(\\\\\\\\\\\\\\\"&#96;VERSION&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            clap_manual_url: P::CLAP_MANUAL_URL\\\\\\\\n                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_MANUAL_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\\n            clap_support_url: P::CLAP_SUPPORT_URL\\\\\\\\n                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_SUPPORT_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\\n            clap_description: P::CLAP_DESCRIPTION.map(|description| {\\\\\\\\n                CString::new(description).expect(\\\\\\\\\\\\\\\"&#96;CLAP_DESCRIPTION&#96; contained null bytes\\\\\\\\\\\\\\\")\\\\\\\\n            }),\\\\\\\\n            clap_features: P::CLAP_FEATURES\\\\\\\\n                .iter()\\\\\\\\n                .map(|feat| feat.as_str())\\\\\\\\n                .map(|s| CString::new(s).expect(\\\\\\\\\\\\\\\"&#96;CLAP_FEATURES&#96; contained null bytes\\\\\\\\\\\\\\\"))\\\\\\\\n                .collect(),\\\\\\\\n\\\\\\\\n            // These need to be initialized later as they contain pointers to the fields in this\\\\\\\\n            // descriptor\\\\\\\\n            clap_features_ptrs: Vec::new(),\\\\\\\\n            plugin_descriptor: None,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // The keyword list is an environ-like list of char pointers terminated by a null pointer.\\\\\\\\n        descriptor.clap_features_ptrs = descriptor\\\\\\\\n            .clap_features\\\\\\\\n            .iter()\\\\\\\\n            .map(|feature| feature.as_ptr())\\\\\\\\n            .collect();\\\\\\\\n        descriptor.clap_features_ptrs.push(std::ptr::null());\\\\\\\\n\\\\\\\\n        // We couldn't initialize this directly because of all the CStrings\\\\\\\\n        // NOTE: This is safe without pinning this struct because all of the data is already stored\\\\\\\\n        //       on the heap\\\\\\\\n        descriptor.plugin_descriptor = Some(clap_plugin_descriptor {\\\\\\\\n            clap_version: CLAP_VERSION,\\\\\\\\n            id: descriptor.clap_id.as_ptr(),\\\\\\\\n            name: descriptor.name.as_ptr(),\\\\\\\\n            vendor: descriptor.vendor.as_ptr(),\\\\\\\\n            url: descriptor.url.as_ptr(),\\\\\\\\n            version: descriptor.version.as_ptr(),\\\\\\\\n            manual_url: descriptor\\\\\\\\n                .clap_manual_url\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|url| url.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            support_url: descriptor\\\\\\\\n                .clap_support_url\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|url| url.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            description: descriptor\\\\\\\\n                .clap_description\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|description| description.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            features: descriptor.clap_features_ptrs.as_ptr(),\\\\\\\\n        });\\\\\\\\n\\\\\\\\n        descriptor\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn clap_plugin_descriptor(&amp;self) -&gt; &amp;clap_plugin_descriptor {\\\\\\\\n        self.plugin_descriptor.as_ref().unwrap()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn clap_id(&amp;self) -&gt; &amp;CStr {\\\\\\\\n        self.clap_id.as_c_str()\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":111}\\\"},\\\"capabilityType\\\":15}\",\"82a3755c-907a-4796-bd98-82abe5ebb372\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e8aef45b-825a-45e6-8e41-e86ae311295d\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_7ef735fa-612a-49e7-8e30-ba729cb73da\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_7ef735fa-612a-49e7-8e30-ba729cb73da\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/factory.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/factory.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/factory.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"//! Utilities for building a VST3 factory.\\\\\\\\n//!\\\\\\\\n//! In order to support exporting multiple VST3 plugins from a single library a lot of functionality\\\\\\\\n//! had to be moved to the &#96;nih_export_vst3!()&#96; macro. Because working in macro-land can be both\\\\\\\\n//! frustrating and error prone, most code that does not specifically depend on all of the exposed\\\\\\\\n//! plugin types was moved back to this module so it can be compiled and type checked as normal.\\\\\\\\n\\\\\\\\nuse vst3_sys::base::{\\\\\\\\n    ClassCardinality, FactoryFlags, PClassInfo, PClassInfo2, PClassInfoW, PFactoryInfo,\\\\\\\\n};\\\\\\\\n\\\\\\\\nuse super::subcategories::Vst3SubCategory;\\\\\\\\nuse crate::prelude::Vst3Plugin;\\\\\\\\nuse crate::wrapper::util::strlcpy;\\\\\\\\nuse crate::wrapper::vst3::util::u16strlcpy;\\\\\\\\n\\\\\\\\n/// The VST3 SDK version this is roughly based on. The bindings include some VST 3.7 things but not\\\\\\\\n/// everything, so we'll play it safe.\\\\\\\\npub const VST3_SDK_VERSION: &amp;str = \\\\\\\\\\\\\\\"VST 3.6.14\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n/// The information queried about a plugin through the &#96;IPluginFactory*&#96; methods. Stored in a\\\\\\\\n/// separate struct so it can be type erased and stored in an array.\\\\\\\\n#[derive(Debug)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub cid: &amp;'static [u8; 16],\\\\\\\\n    pub name: &amp;'static str,\\\\\\\\n    pub subcategories: String,\\\\\\\\n    pub vendor: &amp;'static str,\\\\\\\\n    pub version: &amp;'static str,\\\\\\\\n\\\\\\\\n    // These are used for the factory's own info struct\\\\\\\\n    pub url: &amp;'static str,\\\\\\\\n    pub email: &amp;'static str,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginInfo {\\\\\\\\n    pub fn for_plugin&lt;P: Vst3Plugin&gt;() -&gt; PluginInfo {\\\\\\\\n        PluginInfo {\\\\\\\\n            cid: &amp;P::PLATFORM_VST3_CLASS_ID,\\\\\\\\n            name: P::NAME,\\\\\\\\n            subcategories: make_subcategories_string::&lt;P&gt;(),\\\\\\\\n            vendor: P::VENDOR,\\\\\\\\n            version: P::VERSION,\\\\\\\\n            url: P::URL,\\\\\\\\n            email: P::EMAIL,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PFactoryInfo&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory&#96;.\\\\\\\\n    pub fn create_factory_info(&amp;self) -&gt; PFactoryInfo {\\\\\\\\n        let mut info: PFactoryInfo = unsafe { std::mem::zeroed() };\\\\\\\\n        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        strlcpy(&amp;mut info.url, self.url);\\\\\\\\n        strlcpy(&amp;mut info.email, self.email);\\\\\\\\n        info.flags = FactoryFlags::kUnicode as i32;\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfo&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory&#96;.\\\\\\\\n    pub fn create_class_info(&amp;self) -&gt; PClassInfo {\\\\\\\\n        let mut info: PClassInfo = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        strlcpy(&amp;mut info.name, self.name);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfo2&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory2&#96;.\\\\\\\\n    pub fn create_class_info_2(&amp;self) -&gt; PClassInfo2 {\\\\\\\\n        let mut info: PClassInfo2 = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        strlcpy(&amp;mut info.name, self.name);\\\\\\\\n        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\\n        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\\n        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        strlcpy(&amp;mut info.version, self.version);\\\\\\\\n        strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfoW&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory3&#96;.\\\\\\\\n    pub fn create_class_info_unicode(&amp;self) -&gt; PClassInfoW {\\\\\\\\n        let mut info: PClassInfoW = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        u16strlcpy(&amp;mut info.name, self.name);\\\\\\\\n        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\\n        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\\n        u16strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        u16strlcpy(&amp;mut info.version, self.version);\\\\\\\\n        u16strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Build a pipe separated subcategories string for a VST3 plugin.\\\\\\\\nfn make_subcategories_string&lt;P: Vst3Plugin&gt;() -&gt; String {\\\\\\\\n    // No idea if any hosts do something with OnlyRT, but it's part of VST3's example categories\\\\\\\\n    // list. Plugins should not be adding this feature manually\\\\\\\\n    nih_debug_assert!(!P::VST3_SUBCATEGORIES.contains(&amp;Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"OnlyRT\\\\\\\\\\\\\\\")));\\\\\\\\n    let subcategory_string = P::VST3_SUBCATEGORIES\\\\\\\\n        .iter()\\\\\\\\n        .map(Vst3SubCategory::as_str)\\\\\\\\n        .collect::&lt;Vec&lt;&amp;str&gt;&gt;()\\\\\\\\n        .join(\\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n    let subcategory_string = if P::HARD_REALTIME_ONLY {\\\\\\\\n        format!(\\\\\\\\\\\\\\\"{subcategory_string}|OnlyRT\\\\\\\\\\\\\\\")\\\\\\\\n    } else {\\\\\\\\n        subcategory_string\\\\\\\\n    };\\\\\\\\n    nih_debug_assert!(subcategory_string.len() &lt;= 127);\\\\\\\\n\\\\\\\\n    subcategory_string\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":128}\\\"},\\\"capabilityType\\\":15}\",\"9bfcd6b9-1ab8-4c85-b13d-e13ac276344e\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8dfb6aea-4d1b-4bd9-b0df-2b1bc95862d2\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_d8c2cd80-c58c-4abe-b0a3-2a8f5b66c25\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_d8c2cd80-c58c-4abe-b0a3-2a8f5b66c25\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":1896}\\\"},\\\"capabilityType\\\":15}\",\"9ea32ff9-b961-4002-a77c-e12a5935b08c\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"880d8e61-57fc-4ff2-b9d3-4dab299b75a6\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_98661c9a-f8eb-42a7-9943-d4186e06649\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_98661c9a-f8eb-42a7-9943-d4186e06649\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/context.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/context.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/context.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":379}\\\"},\\\"capabilityType\\\":15}\",\"a42ebac0-34ba-4f92-82e2-9f707dc504b1\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"574e009b-3e94-43b5-83c3-be8231f95de5\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_03407763-06be-44d7-b2fb-93dac144a9c\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_03407763-06be-44d7-b2fb-93dac144a9c\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/context.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/context.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/context.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use atomic_refcell::AtomicRefMut;\\\\\\\\nuse std::cell::Cell;\\\\\\\\nuse std::collections::VecDeque;\\\\\\\\nuse std::sync::atomic::Ordering;\\\\\\\\nuse std::sync::Arc;\\\\\\\\nuse vst3_sys::vst::IComponentHandler;\\\\\\\\n\\\\\\\\nuse crate::prelude::{\\\\\\\\n    GuiContext, InitContext, ParamPtr, PluginApi, PluginNoteEvent, PluginState, ProcessContext,\\\\\\\\n    Transport, Vst3Plugin,\\\\\\\\n};\\\\\\\\n\\\\\\\\nuse super::inner::{Task, WrapperInner};\\\\\\\\n\\\\\\\\n/// An [&#96;InitContext&#96;] implementation for the wrapper.\\\\\\\\n///\\\\\\\\n/// # Note\\\\\\\\n///\\\\\\\\n/// Requests to change the latency are only sent when this object is dropped. Otherwise there's the\\\\\\\\n/// risk that the host will immediately deactivate/reactivate the plugin while still in the init\\\\\\\\n/// call. Reentrannt function calls are difficult to handle in Rust without forcing everything to\\\\\\\\n/// use interior mutability, so this will have to do for now. This does mean that &#96;Plugin&#96; mutex\\\\\\\\n/// lock has to be dropped before this object.\\\\\\\\npub(crate) struct WrapperInitContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\\n    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\\n    pub(super) pending_requests: PendingInitContextRequests,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Any requests that should be sent out when the [&#96;WrapperInitContext&#96;] is dropped. See that\\\\\\\\n/// struct's docstring for mroe information.\\\\\\\\n#[derive(Debug, Default)]\\\\\\\\npub(crate) struct PendingInitContextRequests {\\\\\\\\n    /// The value of the last &#96;.set_latency_samples()&#96; call.\\\\\\\\n    latency_changed: Cell&lt;Option&lt;u32&gt;&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A [&#96;ProcessContext&#96;] implementation for the wrapper. This is a separate object so it can hold on\\\\\\\\n/// to lock guards for event queues. Otherwise reading these events would require constant\\\\\\\\n/// unnecessary atomic operations to lock the uncontested locks.\\\\\\\\npub(crate) struct WrapperProcessContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\\n    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\\n    pub(super) input_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    pub(super) output_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    pub(super) transport: Transport,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A [&#96;GuiContext&#96;] implementation for the wrapper. This is passed to the plugin in\\\\\\\\n/// [&#96;Editor::spawn()&#96;][crate::prelude::Editor::spawn()] so it can interact with the rest of the plugin and\\\\\\\\n/// with the host for things like setting parameters.\\\\\\\\npub(crate) struct WrapperGuiContext&lt;P: Vst3Plugin&gt; {\\\\\\\\n    pub(super) inner: Arc&lt;WrapperInner&lt;P&gt;&gt;,\\\\\\\\n    #[cfg(debug_assertions)]\\\\\\\\n    pub(super) param_gesture_checker:\\\\\\\\n        atomic_refcell::AtomicRefCell&lt;crate::wrapper::util::context_checks::ParamGestureChecker&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; Drop for WrapperInitContext&lt;'_, P&gt; {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        if let Some(samples) = self.pending_requests.latency_changed.take() {\\\\\\\\n            self.inner.set_latency_samples(samples)\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; InitContext&lt;P&gt; for WrapperInitContext&lt;'_, P&gt; {\\\\\\\\n    fn plugin_api(&amp;self) -&gt; PluginApi {\\\\\\\\n        PluginApi::Vst3\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn execute(&amp;self, task: P::BackgroundTask) {\\\\\\\\n        (self.inner.task_executor.lock())(task);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_latency_samples(&amp;self, samples: u32) {\\\\\\\\n        // See this struct's docstring\\\\\\\\n        self.pending_requests.latency_changed.set(Some(samples));\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_current_voice_capacity(&amp;self, _capacity: u32) {\\\\\\\\n        // This is only supported by CLAP\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; ProcessContext&lt;P&gt; for WrapperProcessContext&lt;'_, P&gt; {\\\\\\\\n    fn plugin_api(&amp;self) -&gt; PluginApi {\\\\\\\\n        PluginApi::Vst3\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn execute_background(&amp;self, task: P::BackgroundTask) {\\\\\\\\n        let task_posted = self.inner.schedule_background(Task::PluginTask(task));\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn execute_gui(&amp;self, task: P::BackgroundTask) {\\\\\\\\n        let task_posted = self.inner.schedule_gui(Task::PluginTask(task));\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    #[inline]\\\\\\\\n    fn transport(&amp;self) -&gt; &amp;Transport {\\\\\\\\n        &amp;self.transport\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn next_event(&amp;mut self) -&gt; Option&lt;PluginNoteEvent&lt;P&gt;&gt; {\\\\\\\\n        self.input_events_guard.pop_front()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn send_event(&amp;mut self, event: PluginNoteEvent&lt;P&gt;) {\\\\\\\\n        self.output_events_guard.push_back(event);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_latency_samples(&amp;self, samples: u32) {\\\\\\\\n        self.inner.set_latency_samples(samples)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_current_voice_capacity(&amp;self, _capacity: u32) {\\\\\\\\n        // This is only supported by CLAP\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; GuiContext for WrapperGuiContext&lt;P&gt; {\\\\\\\\n    fn plugin_api(&amp;self) -&gt; PluginApi {\\\\\\\\n        PluginApi::Vst3\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn request_resize(&amp;self) -&gt; bool {\\\\\\\\n        let task_posted = self.inner.schedule_gui(Task::RequestResize);\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        // TODO: We don't handle resize request failures right now. In practice this should however\\\\\\\\n        //       not happen.\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // All of these functions are supposed to be called from the main thread, so we'll put some\\\\\\\\n    // trust in the caller and assume that this is indeed the case\\\\\\\\n    unsafe fn raw_begin_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\\n        match &amp;*self.inner.component_handler.borrow() {\\\\\\\\n            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n                Some(hash) =&gt; {\\\\\\\\n                    handler.begin_edit(*hash);\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n            },\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .begin_set_parameter(param_id),\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\n                \\\\\\\\\\\\\\\"raw_begin_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\"\\\\\\\\n            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_set_parameter_normalized(&amp;self, param: ParamPtr, normalized: f32) {\\\\\\\\n        match &amp;*self.inner.component_handler.borrow() {\\\\\\\\n            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n                Some(hash) =&gt; {\\\\\\\\n                    // Only update the parameters manually if the host is not processing audio. If\\\\\\\\n                    // the plugin is currently processing audio, the host will pass this change back\\\\\\\\n                    // to the plugin in the audio callback. This also prevents the values from\\\\\\\\n                    // changing in the middle of the process callback, which would be unsound.\\\\\\\\n                    // FIXME: So this doesn't work for REAPER, because they just silently stop\\\\\\\\n                    //        processing audio when you bypass the plugin. Great. We can add a time\\\\\\\\n                    //        based heuristic to work around this in the meantime.\\\\\\\\n                    if !self.inner.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                        self.inner.set_normalized_value_by_hash(\\\\\\\\n                            *hash,\\\\\\\\n                            normalized,\\\\\\\\n                            self.inner\\\\\\\\n                                .current_buffer_config\\\\\\\\n                                .load()\\\\\\\\n                                .map(|c| c.sample_rate),\\\\\\\\n                        );\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    handler.perform_edit(*hash, normalized as f64);\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n            },\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .set_parameter(param_id),\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_end_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\\n        match &amp;*self.inner.component_handler.borrow() {\\\\\\\\n            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n                Some(hash) =&gt; {\\\\\\\\n                    handler.end_edit(*hash);\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n            },\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .end_set_parameter(param_id),\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_end_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn get_state(&amp;self) -&gt; PluginState {\\\\\\\\n        self.inner.get_state_object()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_state(&amp;self, state: PluginState) {\\\\\\\\n        self.inner.set_state_object_from_gui(state)\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":232}\\\"},\\\"capabilityType\\\":15}\",\"bad34363-a97e-4d80-b1ca-898aef3414e0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d90db405-2ca1-4754-9d00-90381561c69f\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nReading the CLAP wrapper entry point and key sections:\\\\n\\\"}\",\"1e0458ec-c0b1-4134-a1f2-7afe35e6603e\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"493d2537-1789-47ab-a7b3-eeac55a5e6a8\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_1bcdd260-85e5-4533-9518-bb816f856f4\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_1bcdd260-85e5-4533-9518-bb816f856f4\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"clap_entry|CLAP_ENTRY|clap_plugin_factory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_1bcdd260-85e5-4533-9518-bb816f856f4\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"clap_entry|CLAP_ENTRY|clap_plugin_factory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"clap_entry|CLAP_ENTRY|clap_plugin_factory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{}}}}}\\\"},\\\"capabilityType\\\":15}\",\"63f32d2c-70dd-4c80-8fb7-dfaa66db4189\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"0d2fa18b-20d6-4cc1-84f1-f384d4942518\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_444a6617-046b-4609-9784-79532390abc\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_444a6617-046b-4609-9784-79532390abc\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":500}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":1,\\\\\\\"limit\\\\\\\":500,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use atomic_float::AtomicF32;\\\\\\\\nuse atomic_refcell::{AtomicRefCell, AtomicRefMut};\\\\\\\\nuse clap_sys::events::{\\\\\\\\n    clap_event_header, clap_event_midi, clap_event_midi_sysex, clap_event_note,\\\\\\\\n    clap_event_note_expression, clap_event_param_gesture, clap_event_param_mod,\\\\\\\\n    clap_event_param_value, clap_event_transport, clap_input_events, clap_output_events,\\\\\\\\n    CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_IS_LIVE, CLAP_EVENT_MIDI, CLAP_EVENT_MIDI_SYSEX,\\\\\\\\n    CLAP_EVENT_NOTE_CHOKE, CLAP_EVENT_NOTE_END, CLAP_EVENT_NOTE_EXPRESSION, CLAP_EVENT_NOTE_OFF,\\\\\\\\n    CLAP_EVENT_NOTE_ON, CLAP_EVENT_PARAM_GESTURE_BEGIN, CLAP_EVENT_PARAM_GESTURE_END,\\\\\\\\n    CLAP_EVENT_PARAM_MOD, CLAP_EVENT_PARAM_VALUE, CLAP_EVENT_TRANSPORT,\\\\\\\\n    CLAP_NOTE_EXPRESSION_BRIGHTNESS, CLAP_NOTE_EXPRESSION_EXPRESSION, CLAP_NOTE_EXPRESSION_PAN,\\\\\\\\n    CLAP_NOTE_EXPRESSION_PRESSURE, CLAP_NOTE_EXPRESSION_TUNING, CLAP_NOTE_EXPRESSION_VIBRATO,\\\\\\\\n    CLAP_NOTE_EXPRESSION_VOLUME, CLAP_TRANSPORT_HAS_BEATS_TIMELINE,\\\\\\\\n    CLAP_TRANSPORT_HAS_SECONDS_TIMELINE, CLAP_TRANSPORT_HAS_TEMPO,\\\\\\\\n    CLAP_TRANSPORT_HAS_TIME_SIGNATURE, CLAP_TRANSPORT_IS_LOOP_ACTIVE, CLAP_TRANSPORT_IS_PLAYING,\\\\\\\\n    CLAP_TRANSPORT_IS_RECORDING, CLAP_TRANSPORT_IS_WITHIN_PRE_ROLL,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::audio_ports::{\\\\\\\\n    clap_audio_port_info, clap_plugin_audio_ports, CLAP_AUDIO_PORT_IS_MAIN, CLAP_EXT_AUDIO_PORTS,\\\\\\\\n    CLAP_PORT_MONO, CLAP_PORT_STEREO,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::audio_ports_config::{\\\\\\\\n    clap_audio_ports_config, clap_plugin_audio_ports_config, CLAP_EXT_AUDIO_PORTS_CONFIG,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::remote_controls::{\\\\\\\\n    clap_plugin_remote_controls, clap_remote_controls_page, CLAP_EXT_REMOTE_CONTROLS,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::gui::{\\\\\\\\n    clap_gui_resize_hints, clap_host_gui, clap_plugin_gui, clap_window, CLAP_EXT_GUI,\\\\\\\\n    CLAP_WINDOW_API_COCOA, CLAP_WINDOW_API_WIN32, CLAP_WINDOW_API_X11,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::latency::{clap_host_latency, clap_plugin_latency, CLAP_EXT_LATENCY};\\\\\\\\nuse clap_sys::ext::note_ports::{\\\\\\\\n    clap_note_port_info, clap_plugin_note_ports, CLAP_EXT_NOTE_PORTS, CLAP_NOTE_DIALECT_CLAP,\\\\\\\\n    CLAP_NOTE_DIALECT_MIDI,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::params::{\\\\\\\\n    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\\n    CLAP_PARAM_IS_AUTOMATABLE, CLAP_PARAM_IS_BYPASS, CLAP_PARAM_IS_HIDDEN,\\\\\\\\n    CLAP_PARAM_IS_MODULATABLE, CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID, CLAP_PARAM_IS_READONLY,\\\\\\\\n    CLAP_PARAM_IS_STEPPED, CLAP_PARAM_RESCAN_VALUES,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::render::{\\\\\\\\n    clap_plugin_render, clap_plugin_render_mode, CLAP_EXT_RENDER, CLAP_RENDER_OFFLINE,\\\\\\\\n    CLAP_RENDER_REALTIME,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::state::{clap_plugin_state, CLAP_EXT_STATE};\\\\\\\\nuse clap_sys::ext::tail::{clap_plugin_tail, CLAP_EXT_TAIL};\\\\\\\\nuse clap_sys::ext::thread_check::{clap_host_thread_check, CLAP_EXT_THREAD_CHECK};\\\\\\\\nuse clap_sys::ext::voice_info::{\\\\\\\\n    clap_host_voice_info, clap_plugin_voice_info, clap_voice_info, CLAP_EXT_VOICE_INFO,\\\\\\\\n    CLAP_VOICE_INFO_SUPPORTS_OVERLAPPING_NOTES,\\\\\\\\n};\\\\\\\\nuse clap_sys::fixedpoint::{CLAP_BEATTIME_FACTOR, CLAP_SECTIME_FACTOR};\\\\\\\\nuse clap_sys::host::clap_host;\\\\\\\\nuse clap_sys::id::{clap_id, CLAP_INVALID_ID};\\\\\\\\nuse clap_sys::plugin::clap_plugin;\\\\\\\\nuse clap_sys::process::{\\\\\\\\n    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\\n    CLAP_PROCESS_ERROR,\\\\\\\\n};\\\\\\\\nuse clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\\nuse crossbeam::atomic::AtomicCell;\\\\\\\\nuse crossbeam::channel::{self, SendTimeoutError};\\\\\\\\nuse crossbeam::queue::ArrayQueue;\\\\\\\\nuse parking_lot::Mutex;\\\\\\\\nuse std::any::Any;\\\\\\\\nuse std::borrow::Borrow;\\\\\\\\nuse std::collections::{HashMap, HashSet, VecDeque};\\\\\\\\nuse std::ffi::{c_void, CStr};\\\\\\\\nuse std::mem;\\\\\\\\nuse std::num::NonZeroU32;\\\\\\\\nuse std::os::raw::c_char;\\\\\\\\nuse std::ptr::NonNull;\\\\\\\\nuse std::sync::atomic::{AtomicBool, AtomicU32, Ordering};\\\\\\\\nuse std::sync::{Arc, Weak};\\\\\\\\nuse std::thread::{self, ThreadId};\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse super::context::{WrapperGuiContext, WrapperInitContext, WrapperProcessContext};\\\\\\\\nuse super::descriptor::PluginDescriptor;\\\\\\\\nuse super::util::ClapPtr;\\\\\\\\nuse crate::event_loop::{BackgroundThread, EventLoop, MainThreadExecutor, TASK_QUEUE_CAPACITY};\\\\\\\\nuse crate::midi::MidiResult;\\\\\\\\nuse crate::prelude::{\\\\\\\\n    AsyncExecutor, AudioIOLayout, AuxiliaryBuffers, BufferConfig, ClapPlugin, Editor, MidiConfig,\\\\\\\\n    NoteEvent, ParamFlags, ParamPtr, Params, ParentWindowHandle, Plugin, PluginNoteEvent,\\\\\\\\n    ProcessMode, ProcessStatus, SysExMessage, TaskExecutor, Transport,\\\\\\\\n};\\\\\\\\nuse crate::util::permit_alloc;\\\\\\\\nuse crate::wrapper::clap::context::RemoteControlPages;\\\\\\\\nuse crate::wrapper::clap::util::{read_stream, write_stream};\\\\\\\\nuse crate::wrapper::state::{self, PluginState};\\\\\\\\nuse crate::wrapper::util::buffer_management::{BufferManager, ChannelPointers};\\\\\\\\nuse crate::wrapper::util::{\\\\\\\\n    clamp_input_event_timing, clamp_output_event_timing, hash_param_id, process_wrapper, strlcpy,\\\\\\\\n};\\\\\\\\n\\\\\\\\n/// How many output parameter changes we can store in our output parameter change queue. Storing\\\\\\\\n/// more than this many parameters at a time will cause changes to get lost.\\\\\\\\nconst OUTPUT_EVENT_QUEUE_CAPACITY: usize = 2048;\\\\\\\\n\\\\\\\\npub struct Wrapper&lt;P: ClapPlugin&gt; {\\\\\\\\n    /// A reference to this object, upgraded to an &#96;Arc&lt;Self&gt;&#96; for the GUI context.\\\\\\\\n    this: AtomicRefCell&lt;Weak&lt;Self&gt;&gt;,\\\\\\\\n\\\\\\\\n    /// The wrapped plugin instance.\\\\\\\\n    plugin: Mutex&lt;P&gt;,\\\\\\\\n    /// The plugin's background task executor closure.\\\\\\\\n    pub task_executor: Mutex&lt;TaskExecutor&lt;P&gt;&gt;,\\\\\\\\n    /// The plugin's parameters. These are fetched once during initialization. That way the\\\\\\\\n    /// &#96;ParamPtr&#96;s are guaranteed to live at least as long as this object and we can interact with\\\\\\\\n    /// the &#96;Params&#96; object without having to acquire a lock on &#96;plugin&#96;.\\\\\\\\n    params: Arc&lt;dyn Params&gt;,\\\\\\\\n    /// The plugin's editor, if it has one. This object does not do anything on its own, but we need\\\\\\\\n    /// to instantiate this in advance so we don't need to lock the entire [&#96;Plugin&#96;] object when\\\\\\\\n    /// creating an editor. Wrapped in an &#96;AtomicRefCell&#96; because it needs to be initialized late.\\\\\\\\n    editor: AtomicRefCell&lt;Option&lt;Mutex&lt;Box&lt;dyn Editor&gt;&gt;&gt;&gt;,\\\\\\\\n    /// A handle for the currently active editor instance. The plugin should implement &#96;Drop&#96; on\\\\\\\\n    /// this handle for its closing behavior.\\\\\\\\n    editor_handle: Mutex&lt;Option&lt;Box&lt;dyn Any + Send&gt;&gt;&gt;,\\\\\\\\n    /// The DPI scaling factor as passed to the [IPlugViewContentScaleSupport::set_scale_factor()]\\\\\\\\n    /// function. Defaults to 1.0, and will be kept there on macOS. When reporting and handling size\\\\\\\\n    /// the sizes communicated to and from the DAW should be scaled by this factor since NIH-plug's\\\\\\\\n    /// APIs only deal in logical pixels.\\\\\\\\n    editor_scaling_factor: AtomicF32,\\\\\\\\n\\\\\\\\n    is_processing: AtomicBool,\\\\\\\\n    /// The current IO configuration, modified through the &#96;clap_plugin_audio_ports_config&#96;\\\\\\\\n    /// extension. Initialized to the plugin's first audio IO configuration.\\\\\\\\n    current_audio_io_layout: AtomicCell&lt;AudioIOLayout&gt;,\\\\\\\\n    /// The current buffer configuration, containing the sample rate and the maximum block size.\\\\\\\\n    /// Will be set in &#96;clap_plugin::activate()&#96;.\\\\\\\\n    current_buffer_config: AtomicCell&lt;Option&lt;BufferConfig&gt;&gt;,\\\\\\\\n    /// The current audio processing mode. Set through the render extension. Defaults to realtime.\\\\\\\\n    pub current_process_mode: AtomicCell&lt;ProcessMode&gt;,\\\\\\\\n    /// The incoming events for the plugin, if &#96;P::MIDI_INPUT&#96; is set to &#96;MidiConfig::Basic&#96; or\\\\\\\\n    /// higher.\\\\\\\\n    ///\\\\\\\\n    /// TODO: Maybe load these lazily at some point instead of needing to spool them all to this\\\\\\\\n    ///       queue first\\\\\\\\n    input_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    /// Stores any events the plugin has output during the current processing cycle, analogous to\\\\\\\\n    /// &#96;input_events&#96;.\\\\\\\\n    output_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    /// The last process status returned by the plugin. This is used for tail handling.\\\\\\\\n    last_process_status: AtomicCell&lt;ProcessStatus&gt;,\\\\\\\\n    /// The current latency in samples, as set by the plugin through the [&#96;ProcessContext&#96;]. Uses\\\\\\\\n    /// the latency extension.\\\\\\\\n    pub current_latency: AtomicU32,\\\\\\\\n    /// A data structure that helps manage and create buffers for all of the plugin's inputs and\\\\\\\\n    /// outputs based on channel pointers provided by the host.\\\\\\\\n    buffer_manager: AtomicRefCell&lt;BufferManager&gt;,\\\\\\\\n    /// The plugin is able to restore state through a method on the &#96;GuiContext&#96;. To avoid changing\\\\\\\\n    /// parameters mid-processing and running into garbled data if the host also tries to load state\\\\\\\\n    /// at the same time the restoring happens at the end of each processing call. If this zero\\\\\\\\n    /// capacity channel contains state data at that point, then the audio thread will take the\\\\\\\\n    /// state out of the channel, restore the state, and then send it back through the same channel.\\\\\\\\n    /// In other words, the GUI thread acts as a sender and then as a receiver, while the audio\\\\\\\\n    /// thread acts as a receiver and then as a sender. That way deallocation can happen on the GUI\\\\\\\\n    /// thread. All of this happens without any blocking on the audio thread.\\\\\\\\n    updated_state_sender: channel::Sender&lt;PluginState&gt;,\\\\\\\\n    /// The receiver belonging to [&#96;new_state_sender&#96;][Self::new_state_sender].\\\\\\\\n    updated_state_receiver: channel::Receiver&lt;PluginState&gt;,\\\\\\\\n\\\\\\\\n    // We'll query all of the host's extensions upfront\\\\\\\\n    host_callback: ClapPtr&lt;clap_host&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_audio_ports_config: clap_plugin_audio_ports_config,\\\\\\\\n\\\\\\\\n    // The main &#96;clap_plugin&#96; vtable. A pointer to this &#96;Wrapper&lt;P&gt;&#96; instance is stored in the\\\\\\\\n    // &#96;plugin_data&#96; field. This pointer is set after creating the &#96;Arc&lt;Wrapper&lt;P&gt;&gt;&#96;.\\\\\\\\n    pub clap_plugin: AtomicRefCell&lt;clap_plugin&gt;,\\\\\\\\n    /// Needs to be boxed because the plugin object is supposed to contain a static reference to\\\\\\\\n    /// this.\\\\\\\\n    _plugin_descriptor: Box&lt;PluginDescriptor&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_audio_ports: clap_plugin_audio_ports,\\\\\\\\n\\\\\\\\n    clap_plugin_gui: clap_plugin_gui,\\\\\\\\n    host_gui: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_gui&gt;&gt;&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_latency: clap_plugin_latency,\\\\\\\\n    host_latency: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_latency&gt;&gt;&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_note_ports: clap_plugin_note_ports,\\\\\\\\n\\\\\\\\n    clap_plugin_params: clap_plugin_params,\\\\\\\\n    host_params: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_params&gt;&gt;&gt;,\\\\\\\\n    // These fields are exactly the same as their VST3 wrapper counterparts.\\\\\\\\n    //\\\\\\\\n    /// The keys from &#96;param_map&#96; in a stable order.\\\\\\\\n    param_hashes: Vec&lt;u32&gt;,\\\\\\\\n    // TODO: Merge the three &#96;*_by_hash&#96; hashmaps at some point\\\\\\\\n    /// A mapping from parameter ID hashes (obtained from the string parameter IDs) to pointers to\\\\\\\\n    /// parameters belonging to the plugin. These addresses will remain stable as long as the\\\\\\\\n    /// &#96;params&#96; object does not get deallocated.\\\\\\\\n    param_by_hash: HashMap&lt;u32, ParamPtr&gt;,\\\\\\\\n    /// Mappings from parameter hashes to string parameter IDs. Used for notifying the plugin's\\\\\\\\n    /// editor about parameter changes.\\\\\\\\n    param_id_by_hash: HashMap&lt;u32, String&gt;,\\\\\\\\n    /// The group name of a parameter, indexed by the parameter's hash. Nested groups are delimited\\\\\\\\n    /// by slashes, and they're only used to allow the DAW to display parameters in a tree\\\\\\\\n    /// structure.\\\\\\\\n    param_group_by_hash: HashMap&lt;u32, String&gt;,\\\\\\\\n    /// Mappings from string parameter identifiers to parameter hashes. Useful for debug logging\\\\\\\\n    /// and when storing and restoring plugin state.\\\\\\\\n    param_id_to_hash: HashMap&lt;String, u32&gt;,\\\\\\\\n    /// The inverse mapping from [&#96;param_by_hash&#96;][Self::param_by_hash]. This is needed to be able\\\\\\\\n    /// to have an ergonomic parameter setting API that uses references to the parameters instead of\\\\\\\\n    /// having to add a setter function to the parameter (or even worse, have it be completely\\\\\\\\n    /// untyped).\\\\\\\\n    pub param_ptr_to_hash: HashMap&lt;ParamPtr, u32&gt;,\\\\\\\\n    /// For all polyphonically modulatable parameters, mappings from the parameter hash's hash to\\\\\\\\n    /// the parameter's poly modulation ID. These IDs are then passed to the plugin, so it can\\\\\\\\n    /// quickly refer to parameter by matching on constant IDs.\\\\\\\\n    poly_mod_ids_by_hash: HashMap&lt;u32, u32&gt;,\\\\\\\\n    /// A queue of parameter changes and gestures that should be output in either the next process\\\\\\\\n    /// call or in the next parameter flush.\\\\\\\\n    ///\\\\\\\\n    /// XXX: There's no guarantee that a single parameter doesn't occur twice in this queue, but\\\\\\\\n    ///      even if it does then that should still not be a problem because the host also reads it\\\\\\\\n    ///      in the same order, right?\\\\\\\\n    output_parameter_events: ArrayQueue&lt;OutputParamEvent&gt;,\\\\\\\\n\\\\\\\\n    host_thread_check: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_thread_check&gt;&gt;&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_remote_controls: clap_plugin_remote_controls,\\\\\\\\n    /// The plugin's remote control pages, if it defines any. Filled when initializing the plugin.\\\\\\\\n    remote_control_pages: Vec&lt;clap_remote_controls_page&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_render: clap_plugin_render,\\\\\\\\n\\\\\\\\n    clap_plugin_state: clap_plugin_state,\\\\\\\\n\\\\\\\\n    clap_plugin_tail: clap_plugin_tail,\\\\\\\\n\\\\\\\\n    clap_plugin_voice_info: clap_plugin_voice_info,\\\\\\\\n    host_voice_info: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_voice_info&gt;&gt;&gt;,\\\\\\\\n    /// If &#96;P::CLAP_POLY_MODULATION_CONFIG&#96; is set, then the plugin can configure the current number\\\\\\\\n    /// of active voices using a context method called from the initialization or processing\\\\\\\\n    /// context. This defaults to the maximum number of voices.\\\\\\\\n    current_voice_capacity: AtomicU32,\\\\\\\\n\\\\\\\\n    /// A queue of tasks that still need to be performed. Because CLAP lets the plugin request a\\\\\\\\n    /// host callback directly, we don't need to use the OsEventLoop we use in our other plugin\\\\\\\\n    /// implementations. Instead, we'll post tasks to this queue, ask the host to call\\\\\\\\n    /// [&#96;on_main_thread()&#96;][Self::on_main_thread()] on the main thread, and then continue to pop\\\\\\\\n    /// tasks off this queue there until it is empty.\\\\\\\\n    tasks: ArrayQueue&lt;Task&lt;P&gt;&gt;,\\\\\\\\n    /// The ID of the main thread. In practice this is the ID of the thread that created this\\\\\\\\n    /// object. If the host supports the thread check extension (and\\\\\\\\n    /// [&#96;host_thread_check&#96;][Self::host_thread_check] thus contains a value), then that extension\\\\\\\\n    /// is used instead.\\\\\\\\n    main_thread_id: ThreadId,\\\\\\\\n    /// A background thread for running tasks independently from the host'main GUI thread. Useful\\\\\\\\n    /// for longer, blocking tasks. Initialized later as it needs a reference to the wrapper.\\\\\\\\n    background_thread: AtomicRefCell&lt;Option&lt;BackgroundThread&lt;Task&lt;P&gt;, Self&gt;&gt;&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Tasks that can be sent from the plugin to be executed on the main thread in a non-blocking\\\\\\\\n/// realtime-safe way. Instead of using a random thread or the OS' event loop like in the Linux\\\\\\\\n/// implementation, this uses [&#96;clap_host::request_callback()&#96;] instead.\\\\\\\\n#[allow(clippy::enum_variant_names)]\\\\\\\\npub enum Task&lt;P: Plugin&gt; {\\\\\\\\n    /// Execute one of the plugin's background tasks.\\\\\\\\n    PluginTask(P::BackgroundTask),\\\\\\\\n    /// Inform the plugin that one or more parameter values have changed.\\\\\\\\n    ParameterValuesChanged,\\\\\\\\n    /// Inform the plugin that one parameter's value has changed. This uses the parameter hashes\\\\\\\\n    /// since the task will be created from the audio thread.\\\\\\\\n    ParameterValueChanged(u32, f32),\\\\\\\\n    /// Inform the plugin that one parameter's modulation offset has changed. This uses the\\\\\\\\n    /// parameter hashes since the task will be created from the audio thread.\\\\\\\\n    ParameterModulationChanged(u32, f32),\\\\\\\\n    /// Inform the host that the latency has changed.\\\\\\\\n    LatencyChanged,\\\\\\\\n    /// Inform the host that the voice info has changed.\\\\\\\\n    VoiceInfoChanged,\\\\\\\\n    /// Tell the host that it should rescan the current parameter values.\\\\\\\\n    RescanParamValues,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The types of CLAP parameter updates for events.\\\\\\\\npub enum ClapParamUpdate {\\\\\\\\n    /// Set the parameter to this plain value. In our wrapper the plain values are the normalized\\\\\\\\n    /// values multiplied by the step count for discrete parameters.\\\\\\\\n    PlainValueSet(f64),\\\\\\\\n    /// Set a normalized offset for the parameter's plain value. Subsequent modulation events\\\\\\\\n    /// override the previous one, but &#96;PlainValueSet&#96;s do not override the existing modulation.\\\\\\\\n    /// These values should also be divided by the step size.\\\\\\\\n    PlainValueMod(f64),\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A parameter event that should be output by the plugin, stored in a queue on the wrapper and\\\\\\\\n/// written to the host either at the end of the process function or during a flush.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub enum OutputParamEvent {\\\\\\\\n    /// Begin an automation gesture. This must always be sent before sending [&#96;SetValue&#96;].\\\\\\\\n    BeginGesture { param_hash: u32 },\\\\\\\\n    /// Change the value of a parameter using a plain CLAP value, aka the normalized value\\\\\\\\n    /// multiplied by the number of steps.\\\\\\\\n    SetValue {\\\\\\\\n        /// The internal hash for the parameter.\\\\\\\\n        param_hash: u32,\\\\\\\\n        /// The 'plain' value as reported to CLAP. This is the normalized value multiplied by\\\\\\\\n        /// [&#96;params::step_size()&#96;][crate::params::step_size()].\\\\\\\\n        clap_plain_value: f64,\\\\\\\\n    },\\\\\\\\n    /// Begin an automation gesture. This must always be sent after sending one or more [&#96;SetValue&#96;]\\\\\\\\n    /// events.\\\\\\\\n    EndGesture { param_hash: u32 },\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Because CLAP has this [&#96;clap_host::request_host_callback()&#96;] function, we don't need to use\\\\\\\\n/// &#96;OsEventLoop&#96; and can instead just request a main thread callback directly.\\\\\\\\nimpl&lt;P: ClapPlugin&gt; EventLoop&lt;Task&lt;P&gt;, Wrapper&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\\n    fn new_and_spawn(_executor: Weak&lt;Self&gt;) -&gt; Self {\\\\\\\\n        panic!(\\\\\\\\\\\\\\\"What are you doing\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn schedule_gui(&amp;self, task: Task&lt;P&gt;) -&gt; bool {\\\\\\\\n        if self.is_main_thread() {\\\\\\\\n            self.execute(task, true);\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            let success = self.tasks.push(task).is_ok();\\\\\\\\n            if success {\\\\\\\\n                // CLAP lets us use the host's event loop instead of having to implement our own\\\\\\\\n                let host = &amp;self.host_callback;\\\\\\\\n                unsafe_clap_call! { host=&gt;request_callback(&amp;**host) };\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            success\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn schedule_background(&amp;self, task: Task&lt;P&gt;) -&gt; bool {\\\\\\\\n        self.background_thread\\\\\\\\n            .borrow()\\\\\\\\n            .as_ref()\\\\\\\\n            .unwrap()\\\\\\\\n            .schedule(task)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn is_main_thread(&amp;self) -&gt; bool {\\\\\\\\n        // If the host supports the thread check interface then we'll use that, otherwise we'll\\\\\\\\n        // check if this is the same thread as the one that created the plugin instance.\\\\\\\\n        match &amp;*self.host_thread_check.borrow() {\\\\\\\\n            Some(thread_check) =&gt; {\\\\\\\\n                unsafe_clap_call! { thread_check=&gt;is_main_thread(&amp;*self.host_callback) }\\\\\\\\n            }\\\\\\\\n            // FIXME: &#96;thread::current()&#96; may allocate the first time it's called, is there a safe\\\\\\\\n            //        non-allocating version of this without using huge OS-specific libraries?\\\\\\\\n            None =&gt; permit_alloc(|| thread::current().id() == self.main_thread_id),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: ClapPlugin&gt; MainThreadExecutor&lt;Task&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\\n    fn execute(&amp;self, task: Task&lt;P&gt;, is_gui_thread: bool) {\\\\\\\\n        // This function is always called from the main thread, from [Self::on_main_thread].\\\\\\\\n        match task {\\\\\\\\n            Task::PluginTask(task) =&gt; (self.task_executor.lock())(task),\\\\\\\\n            Task::ParameterValuesChanged =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        editor.lock().param_values_changed();\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::ParameterValueChanged(param_hash, normalized_value) =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\\n                        editor\\\\\\\\n                            .lock()\\\\\\\\n                            .param_value_changed(param_id, normalized_value);\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::ParameterModulationChanged(param_hash, modulation_offset) =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\\n                        editor\\\\\\\\n                            .lock()\\\\\\\\n                            .param_modulation_changed(param_id, modulation_offset);\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::LatencyChanged =&gt; match &amp;*self.host_latency.borrow() {\\\\\\\\n                Some(host_latency) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n\\\\\\\\n                    // XXX: The CLAP docs mention that you should request a restart if this happens\\\\\\\\n                    //      while the plugin is activated (which is not entirely the same thing as\\\\\\\\n                    //      is processing, but we'll treat it as the same thing). In practice just\\\\\\\\n                    //      calling the latency changed function also seems to work just fine.\\\\\\\\n                    if self.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                        unsafe_clap_call! { &amp;*self.host_callback=&gt;request_restart(&amp;*self.host_callback) };\\\\\\\\n                    } else {\\\\\\\\n                        unsafe_clap_call! { host_latency=&gt;changed(&amp;*self.host_callback) };\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the latency extension\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n            Task::VoiceInfoChanged =&gt; match &amp;*self.host_voice_info.borrow() {\\\\\\\\n                Some(host_voice_info) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n                    unsafe_clap_call! { host_voice_info=&gt;changed(&amp;*self.host_callback) };\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the voice-info extension\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n            Task::RescanParamValues =&gt; match &amp;*self.host_params.borrow() {\\\\\\\\n                Some(host_params) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n                    unsafe_clap_call! { host_params=&gt;rescan(&amp;*self.host_callback, CLAP_PARAM_RESCAN_VALUES) };\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"The host does not support parameters? What?\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: ClapPlugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    /// # Safety\\\\\\\\n    ///\\\\\\\\n    /// &#96;host_callback&#96; needs to outlive the returned object.\\\\\\\\n    pub unsafe fn new(host_callback: *const clap_host) -&gt; Arc&lt;Self&gt; {\\\\\\\\n        let mut plugin = P::default();\\\\\\\\n        let task_executor = Mutex::new(plugin.task_executor());\\\\\\\\n\\\\\\\\n        // This is used to allow the plugin to restore preset data from its editor, see the comment\\\\\\\\n        // on &#96;Self::updated_state_sender&#96;\\\\\\\\n        let (updated_state_sender, updated_state_receiver) = channel::bounded(0);\\\\\\\\n\\\\\\\\n        let plugin_descriptor: Box&lt;PluginDescriptor&gt; =\\\\\\\\n            Box::new(PluginDescriptor::for_plugin::&lt;P&gt;());\\\\\\\\n\\\\\\\\n        // We're not allowed to query any extensions until the init function has been called, so we\\\\\\\\n        // need a bunch of AtomicRefCells instead\\\\\\\\n        assert!(!host_callback.is_null());\\\\\\\\n        let host_callback = unsafe { ClapPtr::new(host_callback) };\\\\\\\\n\\\\\\\\n        // This is a mapping from the parameter IDs specified by the plugin to pointers to those\\\\\\\\n        // parameters. These pointers are assumed to be safe to dereference as long as\\\\\\\\n        // &#96;wrapper.plugin&#96; is alive. The plugin API identifiers these parameters by hashes, which\\\\\\\\n        // we'll calculate from the string ID specified by the plugin. These parameters should also\\\\\\\\n        // remain in the same order as the one returned by the plugin.\\\\\\\\n        let params = plugin.params();\\\\\\\\n        let param_id_hashes_ptrs_groups: Vec&lt;_&gt; = params\\\\\\\\n            .param_map()\\\\\\\\n            .into_iter()\\\\\\\\n            .map(|(id, ptr, group)| {\\\\\\\\n                let hash = hash_param_id(&amp;id);\\\\\\\\n                (id, hash, ptr, group)\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n        let param_hashes = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, _, _)| *hash)\\\\\\\\n            .collect();\\\\\\\\n        let param_by_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, ptr, _)| (*hash, *ptr))\\\\\\\\n            .collect();\\\\\\\\n        let param_id_by_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(id, hash, _, _)| (*hash, id.clone()))\\\\\\\\n            .collect();\\\\\\\\n        let param_group_by_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, _, group)| (*hash, group.clone()))\\\\\\\\n            .collect();\\\\\\\\n        let param_id_to_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(id, hash, _, _)| (id.clone(), *hash))\\\\\\\\n            .collect();\\\\\\\\n        let param_ptr_to_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, ptr, _)| (*ptr, *hash))\\\\\\\\n            .collect();\\\\\\\\n        let poly_mod_ids_by_hash: HashMap&lt;u32, u32&gt; = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .filter_map(|(_, hash, ptr, _)| unsafe {\\\\\\\\n                ptr.poly_modulation_id().map(|id| (*hash, id))\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n\\\\\\\\n        if cfg!(debug_assertions) {\\\\\\\\n            let param_map = params.param_map();\\\\\\\\n            let param_ids: HashSet&lt;_&gt; = param_id_hashes_ptrs_groups\\\\\\\\n                .iter()\\\\\\\\n                .map(|(id, _, _, _)| id.clone())\\\\\\\\n                .collect();\\\\\\\\n            nih_debug_assert_eq!(\\\\\\\\n                param_map.len(),\\\\\\\\n                param_ids.len(),\\\\\\\\n                \\\\\\\\\\\\\\\"The plugin has duplicate parameter IDs, weird things may happen. Consider using \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":3232}\\\"},\\\"capabilityType\\\":15}\",\"69f8bb74-09a8-4a11-ac24-9543befc2d60\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"13b8a308-a302-4e93-8af4-1f3e9ec81e21\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_18b61dcd-ebb7-4dde-9574-bb8c39193e1\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_18b61dcd-ebb7-4dde-9574-bb8c39193e1\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"GetPluginFactory|IPluginFactory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_18b61dcd-ebb7-4dde-9574-bb8c39193e1\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"GetPluginFactory|IPluginFactory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":false}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"GetPluginFactory|IPluginFactory\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{\\\\\\\"matches\\\\\\\":[{\\\\\\\"file\\\\\\\":\\\\\\\"nih-plug/src/wrapper/vst3/factory.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":21,\\\\\\\"content\\\\\\\":\\\\\\\"/// The information queried about a plugin through the &#96;IPluginFactory*&#96; methods. Stored in a\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":50,\\\\\\\"content\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory&#96;.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":62,\\\\\\\"content\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory&#96;.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":74,\\\\\\\"content\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory2&#96;.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":91,\\\\\\\"content\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory3&#96;.\\\\\\\"}]}],\\\\\\\"totalLines\\\\\\\":5,\\\\\\\"totalMatchedLines\\\\\\\":5}}}}}\\\"},\\\"capabilityType\\\":15}\",\"f0bed69f-20ce-4f9b-a9e5-939124b2c482\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e35f535b-18a9-47c5-83a2-5d2b13f5082c\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_5b482235-f1eb-4b72-95eb-f84680c8ad2\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_5b482235-f1eb-4b72-95eb-f84680c8ad2\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/inner.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/inner.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":654}\\\"},\\\"capabilityType\\\":15}\",\"858b4a70-3176-42e4-9f45-7ce8732b0482\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e26509c5-35ba-4838-9440-72992da8550a\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_2b9a7b4d-ef9b-4a4f-930e-527fbcfcbe7\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_2b9a7b4d-ef9b-4a4f-930e-527fbcfcbe7\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/util.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/util.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/util.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\\nuse std::mem::MaybeUninit;\\\\\\\\nuse std::ops::Deref;\\\\\\\\nuse std::os::raw::c_void;\\\\\\\\n\\\\\\\\n/// Early exit out of a function with the specified return value when one of the passed pointers is\\\\\\\\n/// null.\\\\\\\\nmacro_rules! check_null_ptr {\\\\\\\\n    ($ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        $crate::wrapper::clap::util::check_null_ptr_msg!(\\\\\\\\\\\\\\\"Null pointer passed to function\\\\\\\\\\\\\\\", $ret, $ptr $(, $ptrs)*)\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;check_null_ptr!&#96;], but with a custom message.\\\\\\\\nmacro_rules! check_null_ptr_msg {\\\\\\\\n    ($msg:expr, $ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        // Clippy doesn't understand it when we use a unit in our &#96;check_null_ptr!()&#96; macro, even\\\\\\\\n        // if we explicitly pattern match on that unit\\\\\\\\n        #[allow(clippy::unused_unit)]\\\\\\\\n        if $ptr.is_null() $(|| $ptrs.is_null())* {\\\\\\\\n            nih_debug_assert_failure!($msg);\\\\\\\\n            return $ret;\\\\\\\\n        }\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Call a CLAP function. This is needed because even though none of CLAP's functions are allowed to\\\\\\\\n/// be null pointers, people will still use null pointers for some of the function arguments. This\\\\\\\\n/// also happens in the official &#96;clap-helpers&#96;. As such, these functions are now &#96;Option&lt;fn(...)&gt;&#96;\\\\\\\\n/// optional function pointers in &#96;clap-sys&#96;. This macro asserts that the pointer is not null, and\\\\\\\\n/// prints a nicely formatted error message containing the struct and function name if it is. It\\\\\\\\n/// also emulates C's syntax for accessing fields struct through a pointer. Except that it uses &#96;=&gt;&#96;\\\\\\\\n/// instead of &#96;-&gt;&#96;. Because that sounds like it would be hilarious.\\\\\\\\nmacro_rules! clap_call {\\\\\\\\n    { $obj_ptr:expr=&gt;$function_name:ident($($args:expr),* $(, )?) } =&gt; {\\\\\\\\n        match (*$obj_ptr).$function_name {\\\\\\\\n            Some(function_ptr) =&gt; function_ptr($($args),*),\\\\\\\\n            None =&gt; panic!(\\\\\\\\\\\\\\\"'{}::{}' is a null pointer, but this is not allowed\\\\\\\\\\\\\\\", $crate::wrapper::clap::util::type_name_of_ptr($obj_ptr), stringify!($function_name)),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// [&#96;clap_call!()&#96;], wrapped in an unsafe block.\\\\\\\\nmacro_rules! unsafe_clap_call {\\\\\\\\n    { $($args:tt)* } =&gt; {\\\\\\\\n        unsafe { $crate::wrapper::clap::util::clap_call! { $($args)* } }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Similar to, [&#96;std::any::type_name_of_val()&#96;], but on stable Rust, and stripping away the pointer\\\\\\\\n/// part.\\\\\\\\n#[must_use]\\\\\\\\npub fn type_name_of_ptr&lt;T: ?Sized&gt;(_ptr: *const T) -&gt; &amp;'static str {\\\\\\\\n    std::any::type_name::&lt;T&gt;()\\\\\\\\n}\\\\\\\\n\\\\\\\\npub(crate) use check_null_ptr_msg;\\\\\\\\npub(crate) use clap_call;\\\\\\\\npub(crate) use unsafe_clap_call;\\\\\\\\n\\\\\\\\n/// Send+Sync wrapper around CLAP host extension pointers.\\\\\\\\npub struct ClapPtr&lt;T&gt; {\\\\\\\\n    inner: *const T,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T&gt; Deref for ClapPtr&lt;T&gt; {\\\\\\\\n    type Target = T;\\\\\\\\n\\\\\\\\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\\\\\\\\n        unsafe { &amp;*self.inner }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nunsafe impl&lt;T&gt; Send for ClapPtr&lt;T&gt; {}\\\\\\\\nunsafe impl&lt;T&gt; Sync for ClapPtr&lt;T&gt; {}\\\\\\\\n\\\\\\\\nimpl&lt;T&gt; ClapPtr&lt;T&gt; {\\\\\\\\n    /// Create a wrapper around a CLAP object pointer.\\\\\\\\n    ///\\\\\\\\n    /// # Safety\\\\\\\\n    ///\\\\\\\\n    /// The pointer must point to a valid object with a lifetime that exceeds this object.\\\\\\\\n    pub unsafe fn new(ptr: *const T) -&gt; Self {\\\\\\\\n        Self { inner: ptr }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A buffer a stream can be read into. This is needed to allow reading into uninitialized vectors\\\\\\\\n/// using slices without invoking UB.\\\\\\\\n///\\\\\\\\n/// # Safety\\\\\\\\n///\\\\\\\\n/// This may only be implemented by slices of &#96;u8&#96; and types with the same representation as &#96;u8&#96;.\\\\\\\\npub unsafe trait ByteReadBuffer {\\\\\\\\n    /// The length of the slice, in bytes.\\\\\\\\n    fn len(&amp;self) -&gt; usize;\\\\\\\\n\\\\\\\\n    /// Get a pointer to the start of the stream.\\\\\\\\n    fn as_mut_ptr(&amp;mut self) -&gt; *mut u8;\\\\\\\\n}\\\\\\\\n\\\\\\\\nunsafe impl ByteReadBuffer for &amp;mut [u8] {\\\\\\\\n    fn len(&amp;self) -&gt; usize {\\\\\\\\n        // Bit of a fun one since we reuse the names of the original functions\\\\\\\\n        &lt;[u8]&gt;::len(self)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn as_mut_ptr(&amp;mut self) -&gt; *mut u8 {\\\\\\\\n        &lt;[u8]&gt;::as_mut_ptr(self)\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nunsafe impl ByteReadBuffer for &amp;mut [MaybeUninit&lt;u8&gt;] {\\\\\\\\n    fn len(&amp;self) -&gt; usize {\\\\\\\\n        &lt;[MaybeUninit&lt;u8&gt;]&gt;::len(self)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn as_mut_ptr(&amp;mut self) -&gt; *mut u8 {\\\\\\\\n        &lt;[MaybeUninit&lt;u8&gt;]&gt;::as_mut_ptr(self) as *mut u8\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Read from a stream until either the byte slice as been filled, or the stream doesn't contain any\\\\\\\\n/// data anymore. This correctly handles streams that only allow smaller, buffered reads. If the\\\\\\\\n/// stream ended before the entire slice has been filled, then this will return &#96;false&#96;.\\\\\\\\npub fn read_stream(stream: &amp;clap_istream, mut slice: impl ByteReadBuffer) -&gt; bool {\\\\\\\\n    let mut read_pos = 0;\\\\\\\\n    while read_pos &lt; slice.len() {\\\\\\\\n        let bytes_read = unsafe_clap_call! {\\\\\\\\n            stream=&gt;read(\\\\\\\\n                stream,\\\\\\\\n                slice.as_mut_ptr().add(read_pos) as *mut c_void,\\\\\\\\n                (slice.len() - read_pos) as u64,\\\\\\\\n            )\\\\\\\\n        };\\\\\\\\n        if bytes_read &lt;= 0 {\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        read_pos += bytes_read as usize;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    true\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Write the data from a slice to a stream until either all data has been written, or the stream\\\\\\\\n/// returns an error. This correctly handles streams that only allow smaller, buffered writes. This\\\\\\\\n/// returns &#96;false&#96; if the stream returns an error or doesn't allow any writes anymore.\\\\\\\\npub fn write_stream(stream: &amp;clap_ostream, slice: &amp;[u8]) -&gt; bool {\\\\\\\\n    let mut write_pos = 0;\\\\\\\\n    while write_pos &lt; slice.len() {\\\\\\\\n        let bytes_written = unsafe_clap_call! {\\\\\\\\n            stream=&gt;write(\\\\\\\\n                stream,\\\\\\\\n                slice.as_ptr().add(write_pos) as *const c_void,\\\\\\\\n                (slice.len() - write_pos) as u64,\\\\\\\\n            )\\\\\\\\n        };\\\\\\\\n        if bytes_written &lt;= 0 {\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        write_pos += bytes_written as usize;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    true\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":168}\\\"},\\\"capabilityType\\\":15}\",\"be40e02d-3793-4447-bd69-b057419ffed1\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"c79c95c9-d878-4bf7-91cb-8282d7445361\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_088479f7-d5b2-41f6-b333-67fcf1db2a9\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_088479f7-d5b2-41f6-b333-67fcf1db2a9\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/util.rs\\\\\\\"}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/util.rs\\\\\\\",\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/vst3/util.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"use std::cmp;\\\\\\\\nuse std::ops::Deref;\\\\\\\\nuse vst3_sys::interfaces::IUnknown;\\\\\\\\nuse vst3_sys::vst::TChar;\\\\\\\\nuse vst3_sys::ComInterface;\\\\\\\\nuse widestring::U16CString;\\\\\\\\n\\\\\\\\n/// When &#96;Plugin::MIDI_INPUT&#96; is set to &#96;MidiConfig::MidiCCs&#96; or higher then we'll register 130*16\\\\\\\\n/// additional parameters to handle MIDI CCs, channel pressure, and pitch bend, in that order.\\\\\\\\n/// vst3-sys doesn't expose these constants.\\\\\\\\npub const VST3_MIDI_CCS: u32 = 130;\\\\\\\\npub const VST3_MIDI_CHANNELS: u32 = 16;\\\\\\\\n/// The number of parameters we'll need to register if the plugin accepts MIDI CCs.\\\\\\\\npub const VST3_MIDI_NUM_PARAMS: u32 = VST3_MIDI_CCS * VST3_MIDI_CHANNELS;\\\\\\\\n/// The start of the MIDI CC parameter ranges. We'll print an assertion failure if any of the\\\\\\\\n/// plugin's parameters overlap with this range. The mapping to a parameter index is\\\\\\\\n/// &#96;VST3_MIDI_PARAMS_START + (cc_idx + (channel * VST3_MIDI_CCS))&#96;.\\\\\\\\npub const VST3_MIDI_PARAMS_START: u32 = VST3_MIDI_PARAMS_END - VST3_MIDI_NUM_PARAMS;\\\\\\\\n/// The (exclusive) end of the MIDI CC parameter range. Anything above this is reserved by the host.\\\\\\\\npub const VST3_MIDI_PARAMS_END: u32 = 1 &lt;&lt; 31;\\\\\\\\n\\\\\\\\n/// Early exit out of a VST3 function when one of the passed pointers is null\\\\\\\\nmacro_rules! check_null_ptr {\\\\\\\\n    ($ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        check_null_ptr_msg!(\\\\\\\\\\\\\\\"Null pointer passed to function\\\\\\\\\\\\\\\", $ptr $(, $ptrs)*)\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;check_null_ptr!&#96;], but with a custom message.\\\\\\\\nmacro_rules! check_null_ptr_msg {\\\\\\\\n    ($msg:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        if $ptr.is_null() $(|| $ptrs.is_null())* {\\\\\\\\n            nih_debug_assert_failure!($msg);\\\\\\\\n            return kInvalidArgument;\\\\\\\\n        }\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;strlcpy()&#96;], but for VST3's fun UTF-16 strings instead.\\\\\\\\npub fn u16strlcpy(dest: &amp;mut [TChar], src: &amp;str) {\\\\\\\\n    if dest.is_empty() {\\\\\\\\n        return;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    let src_utf16 = match U16CString::from_str(src) {\\\\\\\\n        Ok(s) =&gt; s,\\\\\\\\n        Err(err) =&gt; {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Invalid UTF-16 string: {}\\\\\\\\\\\\\\\", err);\\\\\\\\n            return;\\\\\\\\n        }\\\\\\\\n    };\\\\\\\\n    let src_utf16_chars = src_utf16.as_slice();\\\\\\\\n    let src_utf16_chars_signed: &amp;[TChar] =\\\\\\\\n        unsafe { &amp;*(src_utf16_chars as *const [u16] as *const [TChar]) };\\\\\\\\n\\\\\\\\n    // Make sure there's always room for a null terminator\\\\\\\\n    let copy_len = cmp::min(dest.len() - 1, src_utf16_chars_signed.len());\\\\\\\\n    dest[..copy_len].copy_from_slice(&amp;src_utf16_chars_signed[..copy_len]);\\\\\\\\n    dest[copy_len] = 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Send+Sync wrapper for these interface pointers.\\\\\\\\n#[repr(transparent)]\\\\\\\\npub struct VstPtr&lt;T: vst3_sys::ComInterface + ?Sized&gt; {\\\\\\\\n    ptr: vst3_sys::VstPtr&lt;T&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;VstPtr&#96;] with shared semnatics, but for objects we defined ourself since &#96;VstPtr&#96;\\\\\\\\n/// only works for interfaces.\\\\\\\\n#[repr(transparent)]\\\\\\\\npub struct ObjectPtr&lt;T: IUnknown&gt; {\\\\\\\\n    ptr: *const T,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T: ComInterface + ?Sized&gt; Deref for VstPtr&lt;T&gt; {\\\\\\\\n    type Target = vst3_sys::VstPtr&lt;T&gt;;\\\\\\\\n\\\\\\\\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\\\\\\\\n        &amp;self.ptr\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T: IUnknown&gt; Deref for ObjectPtr&lt;T&gt; {\\\\\\\\n    type Target = T;\\\\\\\\n\\\\\\\\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\\\\\\\\n        unsafe { &amp;*self.ptr }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T: vst3_sys::ComInterface + ?Sized&gt; From&lt;vst3_sys::VstPtr&lt;T&gt;&gt; for VstPtr&lt;T&gt; {\\\\\\\\n    fn from(ptr: vst3_sys::VstPtr&lt;T&gt;) -&gt; Self {\\\\\\\\n        Self { ptr }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T: IUnknown&gt; From&lt;&amp;T&gt; for ObjectPtr&lt;T&gt; {\\\\\\\\n    /// Create a smart pointer for an existing reference counted object.\\\\\\\\n    fn from(obj: &amp;T) -&gt; Self {\\\\\\\\n        unsafe { obj.add_ref() };\\\\\\\\n        Self { ptr: obj }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;T: IUnknown&gt; Drop for ObjectPtr&lt;T&gt; {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        unsafe { (*self).release() };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// SAFETY: Sharing these pointers across thread is s safe as they have internal atomic reference\\\\\\\\n/// counting, so as long as a &#96;VstPtr&lt;T&gt;&#96; handle exists the object will stay alive.\\\\\\\\nunsafe impl&lt;T: ComInterface + ?Sized&gt; Send for VstPtr&lt;T&gt; {}\\\\\\\\nunsafe impl&lt;T: ComInterface + ?Sized&gt; Sync for VstPtr&lt;T&gt; {}\\\\\\\\n\\\\\\\\nunsafe impl&lt;T: IUnknown&gt; Send for ObjectPtr&lt;T&gt; {}\\\\\\\\nunsafe impl&lt;T: IUnknown&gt; Sync for ObjectPtr&lt;T&gt; {}\\\\\\\\n\\\\\\\\n#[cfg(test)]\\\\\\\\nmod miri {\\\\\\\\n    use widestring::U16CStr;\\\\\\\\n\\\\\\\\n    use super::*;\\\\\\\\n\\\\\\\\n    #[test]\\\\\\\\n    fn u16strlcpy_normal() {\\\\\\\\n        let mut dest = [0; 256];\\\\\\\\n        u16strlcpy(&amp;mut dest, \\\\\\\\\\\\\\\"Hello, world!\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        assert_eq!(\\\\\\\\n            unsafe { U16CStr::from_ptr_str(dest.as_ptr() as *const u16) }\\\\\\\\n                .to_string()\\\\\\\\n                .unwrap(),\\\\\\\\n            \\\\\\\\\\\\\\\"Hello, world!\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    #[test]\\\\\\\\n    fn u16strlcpy_overflow() {\\\\\\\\n        let mut dest = [0; 6];\\\\\\\\n        u16strlcpy(&amp;mut dest, \\\\\\\\\\\\\\\"Hello, world!\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        assert_eq!(\\\\\\\\n            unsafe { U16CStr::from_ptr_str(dest.as_ptr() as *const u16) }\\\\\\\\n                .to_string()\\\\\\\\n                .unwrap(),\\\\\\\\n            \\\\\\\\\\\\\\\"Hello\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":151}\\\"},\\\"capabilityType\\\":15}\",\"e022594a-a3bc-49b5-b824-d103e501f4a0\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"e8908bc5-8835-4203-93a2-f75c84a55968\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nSearching for entry point exports and process function implementations:\\\\n\\\"}\",\"401e3443-3eb5-4386-8a13-b4215d483776\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"ac66aaf7-b530-4185-8d4f-ab970834b274\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.052Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_5f28be7e-2b9c-4de5-9c83-05a4d6c2921\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_5f28be7e-2b9c-4de5-9c83-05a4d6c2921\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is clap_entry exported in nih-plug CLAP wrapper?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"nih-plug\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is clap_entry exported in nih-plug CLAP wrapper?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"nih-plug\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":27,\\\\\\\"column\\\\\\\":46}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\\nmod util;\\\\\\\\n\\\\\\\\nmod context;\\\\\\\\nmod descriptor;\\\\\\\\npub mod features;\\\\\\\\nmod wrapper;\\\\\\\\n\\\\\\\\n/// Re-export for the macro\\\\\\\\npub use self::descriptor::PluginDescriptor;\\\\\\\\npub use self::wrapper::Wrapper;\\\\\\\\npub use clap_sys::entry::clap_plugin_entry;\\\\\\\\npub use clap_sys::factory::plugin_factory::{clap_plugin_factory, CLAP_PLUGIN_FACTORY_ID};\\\\\\\\npub use clap_sys::host::clap_host;\\\\\\\\npub use clap_sys::plugin::{clap_plugin, clap_plugin_descriptor};\\\\\\\\npub use clap_sys::version::CLAP_VERSION;\\\\\\\\n\\\\\\\\n/// Export one or more CLAP plugins from this library using the provided plugin types.\\\\\\\\n#[macro_export]\\\\\\\\nmacro_rules! nih_export_clap {\\\\\\\\n    ($($plugin_ty:ty),+) =&gt; {\\\\\\\\n        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\\n        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\\n        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\\n        #[doc(hidden)]\\\\\\\\n        mod clap {\\\\\\\\n            use $crate::prelude::nih_debug_assert_eq;\\\\\\\\n            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"mod context;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"mod descriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod features;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Re-export for the macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use self::descriptor::PluginDescriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use self::wrapper::Wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::entry::clap_plugin_entry;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::factory::plugin_factory::{clap_plugin_factory, CLAP_PLUGIN_FACTORY_ID};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::host::clap_host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::plugin::{clap_plugin, clap_plugin_descriptor};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::version::CLAP_VERSION;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Export one or more CLAP plugins from this library using the provided plugin types.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_export]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! nih_export_clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($($plugin_ty:ty),+) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::prelude::nih_debug_assert_eq;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28}]},\\\\\\\"score\\\\\\\":0.6243981719017029},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":134,\\\\\\\"column\\\\\\\":39},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":142,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"wrapper::clap::clap_plugin_entry =\\\\\\\\n            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\\n                clap_version: $crate::wrapper::clap::CLAP_VERSION,\\\\\\\\n                init: Some(self::clap::init),\\\\\\\\n                deinit: Some(self::clap::deinit),\\\\\\\\n                get_factory: Some(self::clap::get_factory),\\\\\\\\n            };\\\\\\\\n    };\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"wrapper::clap::clap_plugin_entry =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"                clap_version: $crate::wrapper::clap::CLAP_VERSION,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"                init: Some(self::clap::init),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"                deinit: Some(self::clap::deinit),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_factory: Some(self::clap::get_factory),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143}]},\\\\\\\"score\\\\\\\":0.5592635273933411},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":86,\\\\\\\"column\\\\\\\":18},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":136,\\\\\\\"column\\\\\\\":53}},\\\\\\\"contents\\\\\\\":\\\\\\\"const clap_plugin  {\\\\\\\\n                if plugin_id.is_null() {\\\\\\\\n                    return ::std::ptr::null();\\\\\\\\n                }\\\\\\\\n                let plugin_id_cstr = CStr::from_ptr(plugin_id);\\\\\\\\n\\\\\\\\n                // This isn't great, but we'll just assume that &#96;$plugin_ids&#96; and the descriptors\\\\\\\\n                // are in the same order. We also can't directly enumerate over them with an index,\\\\\\\\n                // which is why we do things the way we do. Otherwise we could have used a tuple\\\\\\\\n                // instead.\\\\\\\\n                let descriptors = plugin_descriptors();\\\\\\\\n                let mut descriptor_idx = 0;\\\\\\\\n                $({\\\\\\\\n                    let descriptor = &amp;descriptors[descriptor_idx];\\\\\\\\n                    if plugin_id_cstr == descriptor.clap_id() {\\\\\\\\n                        // Arc does not have a convenient leak function like Box, so this gets a bit awkward\\\\\\\\n                        // This pointer gets turned into an Arc and its reference count decremented in\\\\\\\\n                        // [Wrapper::destroy()]\\\\\\\\n                        return (*Arc::into_raw(Wrapper::&lt;$plugin_ty&gt;::new(host)))\\\\\\\\n                            .clap_plugin\\\\\\\\n                            .as_ptr();\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    descriptor_idx += 1;\\\\\\\\n                })+\\\\\\\\n\\\\\\\\n                ::std::ptr::null()\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(_plugin_path: *const c_char) -&gt; bool {\\\\\\\\n                setup_logger();\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deinit() {}\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_factory(factory_id: *const c_char) -&gt; *const c_void {\\\\\\\\n                if !factory_id.is_null() &amp;&amp; unsafe { CStr::from_ptr(factory_id) } == CLAP_PLUGIN_FACTORY_ID {\\\\\\\\n                    &amp;CLAP_PLUGIN_FACTORY as *const _ as *const c_void\\\\\\\\n                } else {\\\\\\\\n                    ::std::ptr::null()\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /// The CLAP plugin's entry point.\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[used]\\\\\\\\n        pub static clap_entry: $crate::wrapper::clap::clap_plugin_entry =\\\\\\\\n            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\\n                clap_version: $crate::wrapper::clap::\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"const clap_plugin  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                if plugin_id.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return ::std::ptr::null();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"                let plugin_id_cstr = CStr::from_ptr(plugin_id);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                // This isn't great, but we'll just assume that &#96;$plugin_ids&#96; and the descriptors\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                // are in the same order. We also can't directly enumerate over them with an index,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                // which is why we do things the way we do. Otherwise we could have used a tuple\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"                // instead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let descriptors = plugin_descriptors();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                let mut descriptor_idx = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                $({\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptor = &amp;descriptors[descriptor_idx];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if plugin_id_cstr == descriptor.clap_id() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // Arc does not have a convenient leak function like Box, so this gets a bit awkward\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // This pointer gets turned into an Arc and its reference count decremented in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // [Wrapper::destroy()]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return (*Arc::into_raw(Wrapper::&lt;$plugin_ty&gt;::new(host)))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .clap_plugin\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .as_ptr();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    descriptor_idx += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                })+\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(_plugin_path: *const c_char) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deinit() {}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_factory(factory_id: *const c_char) -&gt; *const c_void {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"                if !factory_id.is_null() &amp;&amp; unsafe { CStr::from_ptr(factory_id) } == CLAP_PLUGIN_FACTORY_ID {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;CLAP_PLUGIN_FACTORY as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The CLAP plugin's entry point.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[used]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub static clap_entry: $crate::wrapper::clap::clap_plugin_entry =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"                clap_version: $crate::wrapper::clap::\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137}]},\\\\\\\"score\\\\\\\":0.5305599570274353},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":51,\\\\\\\"column\\\\\\\":80},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":17}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\\n                    let descriptors = [$(PluginDescriptor::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\\n\\\\\\\\n                    if cfg!(debug_assertions) {\\\\\\\\n                        let unique_plugin_ids: HashSet&lt;_&gt; = descriptors.iter().map(|d| d.clap_id()).collect();\\\\\\\\n                        nih_debug_assert_eq!(\\\\\\\\n                            unique_plugin_ids.len(),\\\\\\\\n                            descriptors.len(),\\\\\\\\n                            \\\\\\\\\\\\\\\"Duplicate plugin IDs found in &#96;nih_export_clap!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\\n                        );\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    descriptors\\\\\\\\n                })\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_count(_factory: *const clap_plugin_factory) -&gt; u32 {\\\\\\\\n                plugin_descriptors().len() as u32\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_descriptor (\\\\\\\\n                _factory: *const clap_plugin_factory,\\\\\\\\n                index: u32,\\\\\\\\n            ) -&gt; *const clap_plugin_descriptor  {\\\\\\\\n                match plugin_descriptors().get(index as usize) {\\\\\\\\n                    Some(descriptor) =&gt; descriptor.clap_plugin_descriptor(),\\\\\\\\n                    None =&gt; ::std::ptr::null()\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn create_plugin (\\\\\\\\n                _factory: *const clap_plugin_factory,\\\\\\\\n                host: *const clap_host,\\\\\\\\n                plugin_id: *const c_char,\\\\\\\\n            ) -&gt; *const clap_plugin  {\\\\\\\\n                if plugin_id.is_null() {\\\\\\\\n                    return ::std::ptr::null();\\\\\\\\n                }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptors = [$(PluginDescriptor::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if cfg!(debug_assertions) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let unique_plugin_ids: HashSet&lt;_&gt; = descriptors.iter().map(|d| d.clap_id()).collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"                        nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"                            unique_plugin_ids.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                            descriptors.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                            \\\\\\\\\\\\\\\"Duplicate plugin IDs found in &#96;nih_export_clap!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                    descriptors\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_count(_factory: *const clap_plugin_factory) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_descriptors().len() as u32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_descriptor (\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                _factory: *const clap_plugin_factory,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"            ) -&gt; *const clap_plugin_descriptor  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                match plugin_descriptors().get(index as usize) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Some(descriptor) =&gt; descriptor.clap_plugin_descriptor(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                    None =&gt; ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn create_plugin (\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                _factory: *const clap_plugin_factory,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                host: *const clap_host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_id: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"            ) -&gt; *const clap_plugin  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                if plugin_id.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return ::std::ptr::null();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90}]},\\\\\\\"score\\\\\\\":0.4649682641029358},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":562,\\\\\\\"column\\\\\\\":34},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":598,\\\\\\\"column\\\\\\\":44}},\\\\\\\"contents\\\\\\\":\\\\\\\",\\\\\\\\n\\\\\\\\n            host_callback,\\\\\\\\n\\\\\\\\n            clap_plugin: AtomicRefCell::new(clap_plugin {\\\\\\\\n                // This needs to live on the heap because the plugin object contains a direct\\\\\\\\n                // reference to the manifest as a value. We could share this between instances of\\\\\\\\n                // the plugin using an &#96;Arc&#96;, but this doesn't consume a lot of memory so it's not a\\\\\\\\n                // huge deal.\\\\\\\\n                desc: plugin_descriptor.clap_plugin_descriptor(),\\\\\\\\n                // This pointer will be set to point at our wrapper instance later\\\\\\\\n                plugin_data: std::ptr::null_mut(),\\\\\\\\n                init: Some(Self::init),\\\\\\\\n                destroy: Some(Self::destroy),\\\\\\\\n                activate: Some(Self::activate),\\\\\\\\n                deactivate: Some(Self::deactivate),\\\\\\\\n                start_processing: Some(Self::start_processing),\\\\\\\\n                stop_processing: Some(Self::stop_processing),\\\\\\\\n                reset: Some(Self::reset),\\\\\\\\n                process: Some(Self::process),\\\\\\\\n                get_extension: Some(Self::get_extension),\\\\\\\\n                on_main_thread: Some(Self::on_main_thread),\\\\\\\\n            }),\\\\\\\\n            _plugin_descriptor: plugin_descriptor,\\\\\\\\n\\\\\\\\n            clap_plugin_audio_ports_config: clap_plugin_audio_ports_config {\\\\\\\\n                count: Some(Self::ext_audio_ports_config_count),\\\\\\\\n                get: Some(Self::ext_audio_ports_config_get),\\\\\\\\n                select: Some(Self::ext_audio_ports_config_select),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_audio_ports: clap_plugin_audio_ports {\\\\\\\\n                count: Some(Self::ext_audio_ports_count),\\\\\\\\n                get: Some(Self::ext_audio_ports_get),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_gui: clap_plugin_gui\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":563},{\\\\\\\"lineNumber\\\\\\\":564},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_callback,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":565},{\\\\\\\"lineNumber\\\\\\\":566},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin: AtomicRefCell::new(clap_plugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":567},{\\\\\\\"text\\\\\\\":\\\\\\\"                // This needs to live on the heap because the plugin object contains a direct\\\\\\\",\\\\\\\"lineNumber\\\\\\\":568},{\\\\\\\"text\\\\\\\":\\\\\\\"                // reference to the manifest as a value. We could share this between instances of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":569},{\\\\\\\"text\\\\\\\":\\\\\\\"                // the plugin using an &#96;Arc&#96;, but this doesn't consume a lot of memory so it's not a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":570},{\\\\\\\"text\\\\\\\":\\\\\\\"                // huge deal.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":571},{\\\\\\\"text\\\\\\\":\\\\\\\"                desc: plugin_descriptor.clap_plugin_descriptor(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":572},{\\\\\\\"text\\\\\\\":\\\\\\\"                // This pointer will be set to point at our wrapper instance later\\\\\\\",\\\\\\\"lineNumber\\\\\\\":573},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_data: std::ptr::null_mut(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":574},{\\\\\\\"text\\\\\\\":\\\\\\\"                init: Some(Self::init),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":575},{\\\\\\\"text\\\\\\\":\\\\\\\"                destroy: Some(Self::destroy),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":576},{\\\\\\\"text\\\\\\\":\\\\\\\"                activate: Some(Self::activate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":577},{\\\\\\\"text\\\\\\\":\\\\\\\"                deactivate: Some(Self::deactivate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":578},{\\\\\\\"text\\\\\\\":\\\\\\\"                start_processing: Some(Self::start_processing),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":579},{\\\\\\\"text\\\\\\\":\\\\\\\"                stop_processing: Some(Self::stop_processing),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":580},{\\\\\\\"text\\\\\\\":\\\\\\\"                reset: Some(Self::reset),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":581},{\\\\\\\"text\\\\\\\":\\\\\\\"                process: Some(Self::process),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":582},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_extension: Some(Self::get_extension),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":583},{\\\\\\\"text\\\\\\\":\\\\\\\"                on_main_thread: Some(Self::on_main_thread),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":584},{\\\\\\\"text\\\\\\\":\\\\\\\"            }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":585},{\\\\\\\"text\\\\\\\":\\\\\\\"            _plugin_descriptor: plugin_descriptor,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":586},{\\\\\\\"lineNumber\\\\\\\":587},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_audio_ports_config: clap_plugin_audio_ports_config {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":588},{\\\\\\\"text\\\\\\\":\\\\\\\"                count: Some(Self::ext_audio_ports_config_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":589},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_audio_ports_config_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":590},{\\\\\\\"text\\\\\\\":\\\\\\\"                select: Some(Self::ext_audio_ports_config_select),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":591},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":592},{\\\\\\\"lineNumber\\\\\\\":593},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_audio_ports: clap_plugin_audio_ports {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":594},{\\\\\\\"text\\\\\\\":\\\\\\\"                count: Some(Self::ext_audio_ports_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":595},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_audio_ports_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":596},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":597},{\\\\\\\"lineNumber\\\\\\\":598},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_gui: clap_plugin_gui\\\\\\\",\\\\\\\"lineNumber\\\\\\\":599}]},\\\\\\\"score\\\\\\\":0.44984498620033264},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":23,\\\\\\\"column\\\\\\\":92},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":53,\\\\\\\"column\\\\\\\":37}},\\\\\\\"contents\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\\n        mod clap {\\\\\\\\n            use $crate::prelude::nih_debug_assert_eq;\\\\\\\\n            use $crate::wrapper::setup_logger;\\\\\\\\n            use $crate::wrapper::clap::{PluginDescriptor, Wrapper};\\\\\\\\n            use $crate::wrapper::clap::{CLAP_PLUGIN_FACTORY_ID, clap_host, clap_plugin, clap_plugin_descriptor, clap_plugin_factory};\\\\\\\\n            use ::std::collections::HashSet;\\\\\\\\n            use ::std::ffi::{CStr, c_void};\\\\\\\\n            use ::std::os::raw::c_char;\\\\\\\\n            use ::std::sync::{Arc, OnceLock};\\\\\\\\n\\\\\\\\n            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\\n            // if the types are not public because this is a child module.\\\\\\\\n            use super::*;\\\\\\\\n\\\\\\\\n            const CLAP_PLUGIN_FACTORY: clap_plugin_factory = clap_plugin_factory {\\\\\\\\n                get_plugin_count: Some(get_plugin_count),\\\\\\\\n                get_plugin_descriptor: Some(get_plugin_descriptor),\\\\\\\\n                create_plugin: Some(create_plugin),\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            // Sneaky way to get the number of expanded elements\\\\\\\\n            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\\n\\\\\\\\n            // This is a type erased version of the information stored on the plugin types\\\\\\\\n            static PLUGIN_DESCRIPTORS: OnceLock&lt;[PluginDescriptor; PLUGIN_COUNT]&gt; = OnceLock::new();\\\\\\\\n\\\\\\\\n            fn plugin_descriptors() -&gt; &amp;'static [PluginDescriptor; PLUGIN_COUNT] {\\\\\\\\n                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\\n                    let descriptors =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::prelude::nih_debug_assert_eq;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::clap::{PluginDescriptor, Wrapper};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::clap::{CLAP_PLUGIN_FACTORY_ID, clap_host, clap_plugin, clap_plugin_descriptor, clap_plugin_factory};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::collections::HashSet;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::ffi::{CStr, c_void};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::os::raw::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::sync::{Arc, OnceLock};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"            // if the types are not public because this is a child module.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"            use super::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"            const CLAP_PLUGIN_FACTORY: clap_plugin_factory = clap_plugin_factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_plugin_count: Some(get_plugin_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_plugin_descriptor: Some(get_plugin_descriptor),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"                create_plugin: Some(create_plugin),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Sneaky way to get the number of expanded elements\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            // This is a type erased version of the information stored on the plugin types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"            static PLUGIN_DESCRIPTORS: OnceLock&lt;[PluginDescriptor; PLUGIN_COUNT]&gt; = OnceLock::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            fn plugin_descriptors() -&gt; &amp;'static [PluginDescriptor; PLUGIN_COUNT] {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptors =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54}]},\\\\\\\"score\\\\\\\":0.4347389042377472},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/standalone.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":59,\\\\\\\"column\\\\\\\":9}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! A standalone plugin target that directly connects to the system's audio and MIDI ports instead\\\\\\\\n//! of relying on a plugin host. This is mostly useful for quickly testing GUI changes.\\\\\\\\n\\\\\\\\nuse clap::{CommandFactory, FromArgMatches};\\\\\\\\n\\\\\\\\nuse self::backend::Backend;\\\\\\\\nuse self::config::WrapperConfig;\\\\\\\\nuse self::wrapper::{Wrapper, WrapperError};\\\\\\\\nuse super::util::setup_logger;\\\\\\\\nuse crate::prelude::Plugin;\\\\\\\\n\\\\\\\\nmod backend;\\\\\\\\nmod config;\\\\\\\\nmod context;\\\\\\\\nmod wrapper;\\\\\\\\n\\\\\\\\n/// Open an NIH-plug plugin as a standalone application. If the plugin has an editor, this will open\\\\\\\\n/// the editor and block until the editor is closed. Otherwise this will block until SIGINT is\\\\\\\\n/// received. This is mainly useful for quickly testing plugin GUIs. In order to use this, you will\\\\\\\\n/// first need to make your plugin's main struct &#96;pub&#96; and expose a &#96;lib&#96; artifact in addition to\\\\\\\\n/// your plugin's &#96;cdylib&#96;:\\\\\\\\n///\\\\\\\\n/// &#96;&#96;&#96;toml\\\\\\\\n/// # Cargo.toml\\\\\\\\n///\\\\\\\\n/// [lib]\\\\\\\\n/// # The &#96;lib&#96; artifact is needed for the standalone target\\\\\\\\n/// crate-type = [\\\\\\\\\\\\\\\"cdylib\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"lib\\\\\\\\\\\\\\\"]\\\\\\\\n/// &#96;&#96;&#96;\\\\\\\\n///\\\\\\\\n/// You can then create a &#96;src/main.rs&#96; file that calls this function:\\\\\\\\n///\\\\\\\\n/// &#96;&#96;&#96;ignore\\\\\\\\n/// // src/main.rs\\\\\\\\n///\\\\\\\\n/// use nih_plug::prelude::*;\\\\\\\\n///\\\\\\\\n/// use plugin_name::PluginName;\\\\\\\\n///\\\\\\\\n/// fn main() {\\\\\\\\n///     nih_export_standalone::&lt;PluginName&gt;();\\\\\\\\n/// }\\\\\\\\n/// &#96;&#96;&#96;\\\\\\\\n///\\\\\\\\n/// By default this will connect to the 'default' audio and MIDI ports. Use the command line options\\\\\\\\n/// to change this. &#96;--help&#96; lists all available options.\\\\\\\\n///\\\\\\\\n/// If the wrapped plugin fails to initialize or throws an error during audio processing, then this\\\\\\\\n/// function will return &#96;false&#96;.\\\\\\\\npub fn nih_export_standalone&lt;P: Plugin&gt;() -&gt; bool {\\\\\\\\n    // TODO: If the backend fails to initialize then the standalones will exit normally instead of\\\\\\\\n    //       with an error code. This should probably be changed.\\\\\\\\n    nih_export_standalone_with_args::&lt;P, _&gt;(std::env::args())\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;nih_export_standalone()&#96;], but with the arguments taken from an iterator instead\\\\\\\\n/// of using [&#96;std::env::args()&#96;].\\\\\\\\npub fn nih_export_standalone_with_args&lt;P: Plugin, Args: IntoIterator&lt;Item = String&gt;&gt;(\\\\\\\\n    args: Args,\\\\\\\\n) -&gt; bool\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! A standalone plugin target that directly connects to the system's audio and MIDI ports instead\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//! of relying on a plugin host. This is mostly useful for quickly testing GUI changes.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap::{CommandFactory, FromArgMatches};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use self::backend::Backend;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use self::config::WrapperConfig;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use self::wrapper::{Wrapper, WrapperError};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"mod backend;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"mod config;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"mod context;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"mod wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Open an NIH-plug plugin as a standalone application. If the plugin has an editor, this will open\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// the editor and block until the editor is closed. Otherwise this will block until SIGINT is\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"/// received. This is mainly useful for quickly testing plugin GUIs. In order to use this, you will\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// first need to make your plugin's main struct &#96;pub&#96; and expose a &#96;lib&#96; artifact in addition to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// your plugin's &#96;cdylib&#96;:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"/// &#96;&#96;&#96;toml\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"/// # Cargo.toml\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"/// [lib]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"/// # The &#96;lib&#96; artifact is needed for the standalone target\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"/// crate-type = [\\\\\\\\\\\\\\\"cdylib\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"lib\\\\\\\\\\\\\\\"]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"/// &#96;&#96;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"/// You can then create a &#96;src/main.rs&#96; file that calls this function:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"/// &#96;&#96;&#96;ignore\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"/// // src/main.rs\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"/// use nih_plug::prelude::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"/// use plugin_name::PluginName;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"/// fn main() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"///     nih_export_standalone::&lt;PluginName&gt;();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"/// }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"/// &#96;&#96;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"/// By default this will connect to the 'default' audio and MIDI ports. Use the command line options\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"/// to change this. &#96;--help&#96; lists all available options.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"/// If the wrapped plugin fails to initialize or throws an error during audio processing, then this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"/// function will return &#96;false&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"pub fn nih_export_standalone&lt;P: Plugin&gt;() -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    // TODO: If the backend fails to initialize then the standalones will exit normally instead of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    //       with an error code. This should probably be changed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"    nih_export_standalone_with_args::&lt;P, _&gt;(std::env::args())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The same as [&#96;nih_export_standalone()&#96;], but with the arguments taken from an iterator instead\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"/// of using [&#96;std::env::args()&#96;].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"pub fn nih_export_standalone_with_args&lt;P: Plugin, Args: IntoIterator&lt;Item = String&gt;&gt;(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    args: Args,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; bool\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60}]},\\\\\\\"score\\\\\\\":0.4159347116947174},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":13,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Wrappers for different plugin types. Each wrapper has an entry point macro that you can pass the\\\\\\\\n//! name of a type that implements &#96;Plugin&#96; to. The macro will handle the rest.\\\\\\\\n\\\\\\\\npub mod clap;\\\\\\\\npub mod state;\\\\\\\\npub(crate) mod util;\\\\\\\\n\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\\npub mod standalone;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub mod vst3;\\\\\\\\n\\\\\\\\n// This is used by the wrappers.\\\\\\\\npub use util::setup_logger;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Wrappers for different plugin types. Each wrapper has an entry point macro that you can pass the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//! name of a type that implements &#96;Plugin&#96; to. The macro will handle the rest.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod clap;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod state;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"pub(crate) mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod standalone;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// This is used by the wrappers.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use util::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14}]},\\\\\\\"score\\\\\\\":0.4148871898651123},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1836,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1869,\\\\\\\"column\\\\\\\":33}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // We weren't allowed to query these in the constructor, so we need to do it now instead.\\\\\\\\n        *wrapper.host_gui.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_gui&gt;(&amp;wrapper.host_callback, CLAP_EXT_GUI);\\\\\\\\n        *wrapper.host_latency.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_latency&gt;(&amp;wrapper.host_callback, CLAP_EXT_LATENCY);\\\\\\\\n        *wrapper.host_params.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_params&gt;(&amp;wrapper.host_callback, CLAP_EXT_PARAMS);\\\\\\\\n        *wrapper.host_voice_info.borrow_mut() = query_host_extension::&lt;clap_host_voice_info&gt;(\\\\\\\\n            &amp;wrapper.host_callback,\\\\\\\\n            CLAP_EXT_VOICE_INFO,\\\\\\\\n        );\\\\\\\\n        *wrapper.host_thread_check.borrow_mut() = query_host_extension::&lt;clap_host_thread_check&gt;(\\\\\\\\n            &amp;wrapper.host_callback,\\\\\\\\n            CLAP_EXT_THREAD_CHECK,\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn destroy(plugin: *const clap_plugin) {\\\\\\\\n        assert!(!plugin.is_null() &amp;&amp; !(*plugin).plugin_data.is_null());\\\\\\\\n        let this = Arc::from_raw((*plugin).plugin_data as *mut Self);\\\\\\\\n        nih_debug_assert_eq!(Arc::strong_count(&amp;this), 1);\\\\\\\\n\\\\\\\\n        drop(this);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(plugin: *const clap_plugin) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1839},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1840},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1841},{\\\\\\\"lineNumber\\\\\\\":1842},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We weren't allowed to query these in the constructor, so we need to do it now instead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1843},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.host_gui.borrow_mut() =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1844},{\\\\\\\"text\\\\\\\":\\\\\\\"            query_host_extension::&lt;clap_host_gui&gt;(&amp;wrapper.host_callback, CLAP_EXT_GUI);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1845},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.host_latency.borrow_mut() =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1846},{\\\\\\\"text\\\\\\\":\\\\\\\"            query_host_extension::&lt;clap_host_latency&gt;(&amp;wrapper.host_callback, CLAP_EXT_LATENCY);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1847},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.host_params.borrow_mut() =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1848},{\\\\\\\"text\\\\\\\":\\\\\\\"            query_host_extension::&lt;clap_host_params&gt;(&amp;wrapper.host_callback, CLAP_EXT_PARAMS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1849},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.host_voice_info.borrow_mut() = query_host_extension::&lt;clap_host_voice_info&gt;(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1850},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.host_callback,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1851},{\\\\\\\"text\\\\\\\":\\\\\\\"            CLAP_EXT_VOICE_INFO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1852},{\\\\\\\"text\\\\\\\":\\\\\\\"        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1853},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.host_thread_check.borrow_mut() = query_host_extension::&lt;clap_host_thread_check&gt;(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1854},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.host_callback,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1855},{\\\\\\\"text\\\\\\\":\\\\\\\"            CLAP_EXT_THREAD_CHECK,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1856},{\\\\\\\"text\\\\\\\":\\\\\\\"        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1857},{\\\\\\\"lineNumber\\\\\\\":1858},{\\\\\\\"text\\\\\\\":\\\\\\\"        true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1859},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1860},{\\\\\\\"lineNumber\\\\\\\":1861},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn destroy(plugin: *const clap_plugin) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1862},{\\\\\\\"text\\\\\\\":\\\\\\\"        assert!(!plugin.is_null() &amp;&amp; !(*plugin).plugin_data.is_null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1863},{\\\\\\\"text\\\\\\\":\\\\\\\"        let this = Arc::from_raw((*plugin).plugin_data as *mut Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1864},{\\\\\\\"text\\\\\\\":\\\\\\\"        nih_debug_assert_eq!(Arc::strong_count(&amp;this), 1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1865},{\\\\\\\"lineNumber\\\\\\\":1866},{\\\\\\\"text\\\\\\\":\\\\\\\"        drop(this);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1867},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1868},{\\\\\\\"lineNumber\\\\\\\":1869},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1870}]},\\\\\\\"score\\\\\\\":0.4091067314147949},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/nih_plug_xtask/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":387,\\\\\\\"column\\\\\\\":64},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":431,\\\\\\\"column\\\\\\\":38}},\\\\\\\"contents\\\\\\\":\\\\\\\"    eprintln!(\\\\\\\\n        \\\\\\\\\\\\\\\"Created a standalone bundle at '{}'\\\\\\\\\\\\\\\",\\\\\\\\n        standalone_bundle_home.display()\\\\\\\\n    );\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Bundle all plugin targets for a plugin library. If &#96;lib_path&#96; contains more than one path, then\\\\\\\\n/// the libraries will be combined into a single library using a method that depends on the\\\\\\\\n/// compilation target. For universal macOS builds this uses lipo.\\\\\\\\nfn bundle_plugin(\\\\\\\\n    target_dir: &amp;Path,\\\\\\\\n    package: &amp;str,\\\\\\\\n    lib_paths: &amp;[&amp;Path],\\\\\\\\n    compilation_target: CompilationTarget,\\\\\\\\n) -&gt; Result&lt;()&gt; {\\\\\\\\n    let bundle_home_dir = bundle_home(target_dir);\\\\\\\\n    let bundle_name = match load_bundler_config()?.and_then(|c| c.get(package).cloned()) {\\\\\\\\n        Some(PackageConfig { name: Some(name) }) =&gt; name,\\\\\\\\n        _ =&gt; package.to_string(),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    // We'll detect the plugin formats supported by the plugin binary and create bundled accordingly.\\\\\\\\n    // If &#96;lib_path&#96; contains paths to multiple plugins that need to be combined into a macOS\\\\\\\\n    // universal binary, then we'll assume all of them export the same symbols and only check the\\\\\\\\n    // first one.\\\\\\\\n    let first_lib_path = lib_paths.first().context(\\\\\\\\\\\\\\\"Empty library paths slice\\\\\\\\\\\\\\\")?;\\\\\\\\n\\\\\\\\n    let bundle_clap = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"clap_entry\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    // We'll ignore the platform-specific entry points for VST2 plugins since there's no reason to\\\\\\\\n    // create a new Rust VST2 plugin that doesn't work in modern DAWs\\\\\\\\n    // NOTE: NIH-plug does not support VST2, but we'll support bundling VST2 plugins anyways because\\\\\\\\n    //       this bundler can also be used standalone.\\\\\\\\n    let bundle_vst2 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"VSTPluginMain\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    let bundle_vst3 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"GetPluginFactory\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    let bundled_plugin = bundle_clap || bundle_vst2 || bundle_vst3;\\\\\\\\n\\\\\\\\n    if bundle_clap {\\\\\\\\n        let clap_bundle_library_name =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    eprintln!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":390},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"Created a standalone bundle at '{}'\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":391},{\\\\\\\"text\\\\\\\":\\\\\\\"        standalone_bundle_home.display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":392},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":393},{\\\\\\\"lineNumber\\\\\\\":394},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":395},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":396},{\\\\\\\"lineNumber\\\\\\\":397},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Bundle all plugin targets for a plugin library. If &#96;lib_path&#96; contains more than one path, then\\\\\\\",\\\\\\\"lineNumber\\\\\\\":398},{\\\\\\\"text\\\\\\\":\\\\\\\"/// the libraries will be combined into a single library using a method that depends on the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":399},{\\\\\\\"text\\\\\\\":\\\\\\\"/// compilation target. For universal macOS builds this uses lipo.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":400},{\\\\\\\"text\\\\\\\":\\\\\\\"fn bundle_plugin(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":401},{\\\\\\\"text\\\\\\\":\\\\\\\"    target_dir: &amp;Path,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":402},{\\\\\\\"text\\\\\\\":\\\\\\\"    package: &amp;str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":403},{\\\\\\\"text\\\\\\\":\\\\\\\"    lib_paths: &amp;[&amp;Path],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":404},{\\\\\\\"text\\\\\\\":\\\\\\\"    compilation_target: CompilationTarget,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":405},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":406},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_home_dir = bundle_home(target_dir);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":407},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_name = match load_bundler_config()?.and_then(|c| c.get(package).cloned()) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":408},{\\\\\\\"text\\\\\\\":\\\\\\\"        Some(PackageConfig { name: Some(name) }) =&gt; name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":409},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; package.to_string(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":410},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":411},{\\\\\\\"lineNumber\\\\\\\":412},{\\\\\\\"text\\\\\\\":\\\\\\\"    // We'll detect the plugin formats supported by the plugin binary and create bundled accordingly.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":413},{\\\\\\\"text\\\\\\\":\\\\\\\"    // If &#96;lib_path&#96; contains paths to multiple plugins that need to be combined into a macOS\\\\\\\",\\\\\\\"lineNumber\\\\\\\":414},{\\\\\\\"text\\\\\\\":\\\\\\\"    // universal binary, then we'll assume all of them export the same symbols and only check the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":415},{\\\\\\\"text\\\\\\\":\\\\\\\"    // first one.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":416},{\\\\\\\"text\\\\\\\":\\\\\\\"    let first_lib_path = lib_paths.first().context(\\\\\\\\\\\\\\\"Empty library paths slice\\\\\\\\\\\\\\\")?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":417},{\\\\\\\"lineNumber\\\\\\\":418},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_clap = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"clap_entry\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":419},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":420},{\\\\\\\"text\\\\\\\":\\\\\\\"    // We'll ignore the platform-specific entry points for VST2 plugins since there's no reason to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":421},{\\\\\\\"text\\\\\\\":\\\\\\\"    // create a new Rust VST2 plugin that doesn't work in modern DAWs\\\\\\\",\\\\\\\"lineNumber\\\\\\\":422},{\\\\\\\"text\\\\\\\":\\\\\\\"    // NOTE: NIH-plug does not support VST2, but we'll support bundling VST2 plugins anyways because\\\\\\\",\\\\\\\"lineNumber\\\\\\\":423},{\\\\\\\"text\\\\\\\":\\\\\\\"    //       this bundler can also be used standalone.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":424},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_vst2 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"VSTPluginMain\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":425},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":426},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_vst3 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"GetPluginFactory\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":427},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":428},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundled_plugin = bundle_clap || bundle_vst2 || bundle_vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":429},{\\\\\\\"lineNumber\\\\\\\":430},{\\\\\\\"text\\\\\\\":\\\\\\\"    if bundle_clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":431},{\\\\\\\"text\\\\\\\":\\\\\\\"        let clap_bundle_library_name =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":432}]},\\\\\\\"score\\\\\\\":0.4069150686264038},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/plugin/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":32}},\\\\\\\"contents\\\\\\\":\\\\\\\"use super::Plugin;\\\\\\\\nuse crate::prelude::{ClapFeature, RemoteControlsContext};\\\\\\\\n\\\\\\\\n/// Provides auxiliary metadata needed for a CLAP plugin.\\\\\\\\n#[allow(unused_variables)]\\\\\\\\npub trait ClapPlugin: Plugin {\\\\\\\\n    /// A unique ID that identifies this particular plugin. This is usually in reverse domain name\\\\\\\\n    /// notation, e.g. &#96;com.manufacturer.plugin-name&#96;.\\\\\\\\n    const CLAP_ID: &amp;'static str;\\\\\\\\n    /// An optional short description for the plugin.\\\\\\\\n    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt;;\\\\\\\\n    /// The URL to the plugin's manual, if available.\\\\\\\\n    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt;;\\\\\\\\n    /// The URL to the plugin's support page, if available.\\\\\\\\n    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt;;\\\\\\\\n    /// Keywords describing the plugin. The host may use this to classify the plugin in its plugin\\\\\\\\n    /// browser.\\\\\\\\n    const CLAP_FEATURES: &amp;'static [ClapFeature];\\\\\\\\n\\\\\\\\n    /// If set, this informs the host about the plugin's capabilities for polyphonic modulation.\\\\\\\\n    const CLAP_POLY_MODULATION_CONFIG: Option&lt;PolyModulationConfig&gt; = None;\\\\\\\\n\\\\\\\\n    /// This function can be implemented to define plugin-specific [remote control\\\\\\\\n    /// pages](https://github.com/free-audio/clap/blob/main/include/clap/ext/draft/remote-controls.h)\\\\\\\\n    /// that the host can use to provide better hardware mapping for a plugin. See the linked\\\\\\\\n    /// extension for more information.\\\\\\\\n    fn remote_controls(&amp;self, context: &amp;mut impl RemoteControlsContext) {}\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Configuration for the plugin's polyphonic modulation options, if it supports .\\\\\\\\npub struct PolyModulationConfig {\\\\\\\\n    /// The maximum number of voices this plugin will ever use. Call the context's\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use super::Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::{ClapFeature, RemoteControlsContext};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Provides auxiliary metadata needed for a CLAP plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"#[allow(unused_variables)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"pub trait ClapPlugin: Plugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// A unique ID that identifies this particular plugin. This is usually in reverse domain name\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// notation, e.g. &#96;com.manufacturer.plugin-name&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_ID: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// An optional short description for the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt;;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The URL to the plugin's manual, if available.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt;;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The URL to the plugin's support page, if available.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt;;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Keywords describing the plugin. The host may use this to classify the plugin in its plugin\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// browser.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_FEATURES: &amp;'static [ClapFeature];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// If set, this informs the host about the plugin's capabilities for polyphonic modulation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_POLY_MODULATION_CONFIG: Option&lt;PolyModulationConfig&gt; = None;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// This function can be implemented to define plugin-specific [remote control\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// pages](https://github.com/free-audio/clap/blob/main/include/clap/ext/draft/remote-controls.h)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// that the host can use to provide better hardware mapping for a plugin. See the linked\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// extension for more information.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn remote_controls(&amp;self, context: &amp;mut impl RemoteControlsContext) {}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Configuration for the plugin's polyphonic modulation options, if it supports .\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PolyModulationConfig {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The maximum number of voices this plugin will ever use. Call the context's\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32}]},\\\\\\\"score\\\\\\\":0.3952887952327728},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":161,\\\\\\\"column\\\\\\\":44},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":217,\\\\\\\"column\\\\\\\":9}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                unsafe fn get_class_info_unicode(\\\\\\\\n                    &amp;self,\\\\\\\\n                    index: i32,\\\\\\\\n                    info: *mut PClassInfoW,\\\\\\\\n                ) -&gt; tresult {\\\\\\\\n                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\\n                        return kInvalidArgument;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    *info = self.plugin_infos[index as usize].create_class_info_unicode();\\\\\\\\n\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                unsafe fn set_host_context(&amp;self, _context: *mut vst3_sys::c_void) -&gt; tresult {\\\\\\\\n                    // We don't need to do anything with this\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /// The VST3 plugin factory entry point.\\\\\\\\n        #[no_mangle]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"system\\\\\\\\\\\\\\\" fn GetPluginFactory() -&gt; *mut ::std::ffi::c_void {\\\\\\\\n            let factory = self::vst3::Factory::new();\\\\\\\\n\\\\\\\\n            Box::into_raw(factory) as *mut ::std::ffi::c_void\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // These two entry points are used on Linux, and they would theoretically also be used on\\\\\\\\n        // the BSDs:\\\\\\\\n        // https://github.com/steinbergmedia/vst3_public_sdk/blob/c3948deb407bdbff89de8fb6ab8500ea4df9d6d9/source/main/linuxmain.cpp#L47-L52\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\\n            $crate::wrapper::setup_logger();\\\\\\\\n            true\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleExit() -&gt; bool {\\\\\\\\n            true\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // These two entry points are used on macOS:\\\\\\\\n        // https://github.com/steinbergmedia/vst3_public_sdk/blob/bc459feee68803346737901471441fd4829ec3f9/source/main/macmain.cpp#L60-L61\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn bundleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\\n            $crate::wrapper::setup_logger();\\\\\\\\n            true\\\\\\\\n        }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_class_info_unicode(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"                    index: i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"                    info: *mut PClassInfoW,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"                ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"                    *info = self.plugin_infos[index as usize].create_class_info_unicode();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn set_host_context(&amp;self, _context: *mut vst3_sys::c_void) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // We don't need to do anything with this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The VST3 plugin factory entry point.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"system\\\\\\\\\\\\\\\" fn GetPluginFactory() -&gt; *mut ::std::ffi::c_void {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"            let factory = self::vst3::Factory::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"            Box::into_raw(factory) as *mut ::std::ffi::c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        // These two entry points are used on Linux, and they would theoretically also be used on\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"        // the BSDs:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"        // https://github.com/steinbergmedia/vst3_public_sdk/blob/c3948deb407bdbff89de8fb6ab8500ea4df9d6d9/source/main/linuxmain.cpp#L47-L52\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleExit() -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        // These two entry points are used on macOS:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"        // https://github.com/steinbergmedia/vst3_public_sdk/blob/bc459feee68803346737901471441fd4829ec3f9/source/main/macmain.cpp#L60-L61\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn bundleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218}]},\\\\\\\"score\\\\\\\":0.39515140652656555},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/prelude.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":43,\\\\\\\"column\\\\\\\":61}},\\\\\\\"contents\\\\\\\":\\\\\\\"// Used in [&#96;AudioIOLayout&#96;]\\\\\\\\npub use std::num::NonZeroU32;\\\\\\\\n\\\\\\\\n// Re-export the macros, derive macros are already re-exported from their respective modules\\\\\\\\npub use crate::debug::*;\\\\\\\\n\\\\\\\\npub use crate::nih_export_clap;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::nih_export_vst3;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::wrapper::standalone::{nih_export_standalone, nih_export_standalone_with_args};\\\\\\\\n\\\\\\\\npub use crate::formatters;\\\\\\\\npub use crate::util;\\\\\\\\n\\\\\\\\npub use crate::audio_setup::{\\\\\\\\n    new_nonzero_u32, AudioIOLayout, AuxiliaryBuffers, BufferConfig, PortNames, ProcessMode,\\\\\\\\n};\\\\\\\\npub use crate::buffer::Buffer;\\\\\\\\npub use crate::context::gui::{AsyncExecutor, GuiContext, ParamSetter};\\\\\\\\npub use crate::context::init::InitContext;\\\\\\\\npub use crate::context::process::{ProcessContext, Transport};\\\\\\\\npub use crate::context::remote_controls::{\\\\\\\\n    RemoteControlsContext, RemoteControlsPage, RemoteControlsSection,\\\\\\\\n};\\\\\\\\npub use crate::context::PluginApi;\\\\\\\\n// This also includes the derive macro\\\\\\\\npub use crate::editor::{Editor, ParentWindowHandle};\\\\\\\\npub use crate::midi::sysex::SysExMessage;\\\\\\\\npub use crate::midi::{control_change, MidiConfig, NoteEvent, PluginNoteEvent};\\\\\\\\npub use crate::params::enums::{Enum, EnumParam};\\\\\\\\npub use crate::params::internals::ParamPtr;\\\\\\\\npub use crate::params::range::{FloatRange, IntRange};\\\\\\\\npub use crate::params::smoothing::{AtomicF32, Smoothable, Smoother, SmoothingStyle};\\\\\\\\npub use crate::params::Params;\\\\\\\\npub use crate::params::{BoolParam, FloatParam, IntParam, Param, ParamFlags};\\\\\\\\npub use crate::plugin::clap::{ClapPlugin, PolyModulationConfig};\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::plugin::vst3::Vst3Plugin;\\\\\\\\npub use crate::plugin::{Plugin, ProcessStatus, TaskExecutor};\\\\\\\\npub use crate::wrapper::clap::features::ClapFeature;\\\\\\\\npub use crate::wrapper::state::PluginState;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::wrapper::vst3::subcategories::Vst3SubCategory;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// Used in [&#96;AudioIOLayout&#96;]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"// Re-export the macros, derive macros are already re-exported from their respective modules\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::debug::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::nih_export_clap;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::nih_export_vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::standalone::{nih_export_standalone, nih_export_standalone_with_args};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::formatters;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::audio_setup::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    new_nonzero_u32, AudioIOLayout, AuxiliaryBuffers, BufferConfig, PortNames, ProcessMode,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::buffer::Buffer;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::gui::{AsyncExecutor, GuiContext, ParamSetter};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::init::InitContext;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::process::{ProcessContext, Transport};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::remote_controls::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    RemoteControlsContext, RemoteControlsPage, RemoteControlsSection,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::PluginApi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// This also includes the derive macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::editor::{Editor, ParentWindowHandle};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::midi::sysex::SysExMessage;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::midi::{control_change, MidiConfig, NoteEvent, PluginNoteEvent};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::enums::{Enum, EnumParam};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::internals::ParamPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::range::{FloatRange, IntRange};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::smoothing::{AtomicF32, Smoothable, Smoother, SmoothingStyle};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::Params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::{BoolParam, FloatParam, IntParam, Param, ParamFlags};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::clap::{ClapPlugin, PolyModulationConfig};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::vst3::Vst3Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::{Plugin, ProcessStatus, TaskExecutor};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::clap::features::ClapFeature;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::state::PluginState;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::vst3::subcategories::Vst3SubCategory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44}]},\\\\\\\"score\\\\\\\":0.3882136940956116},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":596,\\\\\\\"column\\\\\\\":14},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":643,\\\\\\\"column\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"            clap_plugin_gui: clap_plugin_gui {\\\\\\\\n                is_api_supported: Some(Self::ext_gui_is_api_supported),\\\\\\\\n                get_preferred_api: Some(Self::ext_gui_get_preferred_api),\\\\\\\\n                create: Some(Self::ext_gui_create),\\\\\\\\n                destroy: Some(Self::ext_gui_destroy),\\\\\\\\n                set_scale: Some(Self::ext_gui_set_scale),\\\\\\\\n                get_size: Some(Self::ext_gui_get_size),\\\\\\\\n                can_resize: Some(Self::ext_gui_can_resize),\\\\\\\\n                get_resize_hints: Some(Self::ext_gui_get_resize_hints),\\\\\\\\n                adjust_size: Some(Self::ext_gui_adjust_size),\\\\\\\\n                set_size: Some(Self::ext_gui_set_size),\\\\\\\\n                set_parent: Some(Self::ext_gui_set_parent),\\\\\\\\n                set_transient: Some(Self::ext_gui_set_transient),\\\\\\\\n                suggest_title: Some(Self::ext_gui_suggest_title),\\\\\\\\n                show: Some(Self::ext_gui_show),\\\\\\\\n                hide: Some(Self::ext_gui_hide),\\\\\\\\n            },\\\\\\\\n            host_gui: AtomicRefCell::new(None),\\\\\\\\n\\\\\\\\n            clap_plugin_latency: clap_plugin_latency {\\\\\\\\n                get: Some(Self::ext_latency_get),\\\\\\\\n            },\\\\\\\\n            host_latency: AtomicRefCell::new(None),\\\\\\\\n\\\\\\\\n            clap_plugin_note_ports: clap_plugin_note_ports {\\\\\\\\n                count: Some(Self::ext_note_ports_count),\\\\\\\\n                get: Some(Self::ext_note_ports_get),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_params: clap_plugin_params {\\\\\\\\n                count: Some(Self::ext_params_count),\\\\\\\\n                get_info: Some(Self::ext_params_get_info),\\\\\\\\n                get_value: Some(Self::ext_params_get_value),\\\\\\\\n                value_to_text: Some(Self::ext_params_value_to_text),\\\\\\\\n                text_to_value: Some(Self::ext_params_text_to_value),\\\\\\\\n                flush: Some(Self::ext_params_flush),\\\\\\\\n            },\\\\\\\\n            host_params: AtomicRefCell::new(None),\\\\\\\\n            param_hashes,\\\\\\\\n            param_by_hash,\\\\\\\\n            param_id_by_hash,\\\\\\\\n            param_group_by_hash,\\\\\\\\n            param_id_to_hash,\\\\\\\\n            param_ptr_to_hash,\\\\\\\\n            poly_mod_ids_by_hash,\\\\\\\\n            output_parameter_events:\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_gui: clap_plugin_gui {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":599},{\\\\\\\"text\\\\\\\":\\\\\\\"                is_api_supported: Some(Self::ext_gui_is_api_supported),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":600},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_preferred_api: Some(Self::ext_gui_get_preferred_api),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":601},{\\\\\\\"text\\\\\\\":\\\\\\\"                create: Some(Self::ext_gui_create),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":602},{\\\\\\\"text\\\\\\\":\\\\\\\"                destroy: Some(Self::ext_gui_destroy),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":603},{\\\\\\\"text\\\\\\\":\\\\\\\"                set_scale: Some(Self::ext_gui_set_scale),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":604},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_size: Some(Self::ext_gui_get_size),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":605},{\\\\\\\"text\\\\\\\":\\\\\\\"                can_resize: Some(Self::ext_gui_can_resize),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":606},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_resize_hints: Some(Self::ext_gui_get_resize_hints),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":607},{\\\\\\\"text\\\\\\\":\\\\\\\"                adjust_size: Some(Self::ext_gui_adjust_size),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":608},{\\\\\\\"text\\\\\\\":\\\\\\\"                set_size: Some(Self::ext_gui_set_size),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":609},{\\\\\\\"text\\\\\\\":\\\\\\\"                set_parent: Some(Self::ext_gui_set_parent),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":610},{\\\\\\\"text\\\\\\\":\\\\\\\"                set_transient: Some(Self::ext_gui_set_transient),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":611},{\\\\\\\"text\\\\\\\":\\\\\\\"                suggest_title: Some(Self::ext_gui_suggest_title),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":612},{\\\\\\\"text\\\\\\\":\\\\\\\"                show: Some(Self::ext_gui_show),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":613},{\\\\\\\"text\\\\\\\":\\\\\\\"                hide: Some(Self::ext_gui_hide),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":614},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":615},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_gui: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":616},{\\\\\\\"lineNumber\\\\\\\":617},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_latency: clap_plugin_latency {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":618},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_latency_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":619},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":620},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_latency: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":621},{\\\\\\\"lineNumber\\\\\\\":622},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_note_ports: clap_plugin_note_ports {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":623},{\\\\\\\"text\\\\\\\":\\\\\\\"                count: Some(Self::ext_note_ports_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":624},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_note_ports_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":625},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":626},{\\\\\\\"lineNumber\\\\\\\":627},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_params: clap_plugin_params {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":628},{\\\\\\\"text\\\\\\\":\\\\\\\"                count: Some(Self::ext_params_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":629},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_info: Some(Self::ext_params_get_info),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":630},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_value: Some(Self::ext_params_get_value),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":631},{\\\\\\\"text\\\\\\\":\\\\\\\"                value_to_text: Some(Self::ext_params_value_to_text),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":632},{\\\\\\\"text\\\\\\\":\\\\\\\"                text_to_value: Some(Self::ext_params_text_to_value),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":633},{\\\\\\\"text\\\\\\\":\\\\\\\"                flush: Some(Self::ext_params_flush),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":634},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":635},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_params: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":636},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_hashes,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":637},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_by_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":638},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_id_by_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":639},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_group_by_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":640},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_id_to_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":641},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_ptr_to_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":642},{\\\\\\\"text\\\\\\\":\\\\\\\"            poly_mod_ids_by_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":643},{\\\\\\\"text\\\\\\\":\\\\\\\"            output_parameter_events:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":644}]},\\\\\\\"score\\\\\\\":0.38235458731651306},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":33,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"use atomic_float::AtomicF32;\\\\\\\\nuse atomic_refcell::{AtomicRefCell, AtomicRefMut};\\\\\\\\nuse clap_sys::events::{\\\\\\\\n    clap_event_header, clap_event_midi, clap_event_midi_sysex, clap_event_note,\\\\\\\\n    clap_event_note_expression, clap_event_param_gesture, clap_event_param_mod,\\\\\\\\n    clap_event_param_value, clap_event_transport, clap_input_events, clap_output_events,\\\\\\\\n    CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_IS_LIVE, CLAP_EVENT_MIDI, CLAP_EVENT_MIDI_SYSEX,\\\\\\\\n    CLAP_EVENT_NOTE_CHOKE, CLAP_EVENT_NOTE_END, CLAP_EVENT_NOTE_EXPRESSION, CLAP_EVENT_NOTE_OFF,\\\\\\\\n    CLAP_EVENT_NOTE_ON, CLAP_EVENT_PARAM_GESTURE_BEGIN, CLAP_EVENT_PARAM_GESTURE_END,\\\\\\\\n    CLAP_EVENT_PARAM_MOD, CLAP_EVENT_PARAM_VALUE, CLAP_EVENT_TRANSPORT,\\\\\\\\n    CLAP_NOTE_EXPRESSION_BRIGHTNESS, CLAP_NOTE_EXPRESSION_EXPRESSION, CLAP_NOTE_EXPRESSION_PAN,\\\\\\\\n    CLAP_NOTE_EXPRESSION_PRESSURE, CLAP_NOTE_EXPRESSION_TUNING, CLAP_NOTE_EXPRESSION_VIBRATO,\\\\\\\\n    CLAP_NOTE_EXPRESSION_VOLUME, CLAP_TRANSPORT_HAS_BEATS_TIMELINE,\\\\\\\\n    CLAP_TRANSPORT_HAS_SECONDS_TIMELINE, CLAP_TRANSPORT_HAS_TEMPO,\\\\\\\\n    CLAP_TRANSPORT_HAS_TIME_SIGNATURE, CLAP_TRANSPORT_IS_LOOP_ACTIVE, CLAP_TRANSPORT_IS_PLAYING,\\\\\\\\n    CLAP_TRANSPORT_IS_RECORDING, CLAP_TRANSPORT_IS_WITHIN_PRE_ROLL,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::audio_ports::{\\\\\\\\n    clap_audio_port_info, clap_plugin_audio_ports, CLAP_AUDIO_PORT_IS_MAIN, CLAP_EXT_AUDIO_PORTS,\\\\\\\\n    CLAP_PORT_MONO, CLAP_PORT_STEREO,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::audio_ports_config::{\\\\\\\\n    clap_audio_ports_config, clap_plugin_audio_ports_config, CLAP_EXT_AUDIO_PORTS_CONFIG,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::remote_controls::{\\\\\\\\n    clap_plugin_remote_controls, clap_remote_controls_page, CLAP_EXT_REMOTE_CONTROLS,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::gui::{\\\\\\\\n    clap_gui_resize_hints, clap_host_gui, clap_plugin_gui, clap_window, CLAP_EXT_GUI,\\\\\\\\n    CLAP_WINDOW_API_COCOA, CLAP_WINDOW_API_WIN32, CLAP_WINDOW_API_X11,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::latency::{clap_host_latency, clap_plugin_latency, CLAP_EXT_LATENCY};\\\\\\\\nuse clap_sys::ext::note_ports::{\\\\\\\\n    clap_note_port_info,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use atomic_float::AtomicF32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use atomic_refcell::{AtomicRefCell, AtomicRefMut};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::events::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_event_header, clap_event_midi, clap_event_midi_sysex, clap_event_note,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_event_note_expression, clap_event_param_gesture, clap_event_param_mod,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_event_param_value, clap_event_transport, clap_input_events, clap_output_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_IS_LIVE, CLAP_EVENT_MIDI, CLAP_EVENT_MIDI_SYSEX,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_EVENT_NOTE_CHOKE, CLAP_EVENT_NOTE_END, CLAP_EVENT_NOTE_EXPRESSION, CLAP_EVENT_NOTE_OFF,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_EVENT_NOTE_ON, CLAP_EVENT_PARAM_GESTURE_BEGIN, CLAP_EVENT_PARAM_GESTURE_END,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_EVENT_PARAM_MOD, CLAP_EVENT_PARAM_VALUE, CLAP_EVENT_TRANSPORT,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_NOTE_EXPRESSION_BRIGHTNESS, CLAP_NOTE_EXPRESSION_EXPRESSION, CLAP_NOTE_EXPRESSION_PAN,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_NOTE_EXPRESSION_PRESSURE, CLAP_NOTE_EXPRESSION_TUNING, CLAP_NOTE_EXPRESSION_VIBRATO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_NOTE_EXPRESSION_VOLUME, CLAP_TRANSPORT_HAS_BEATS_TIMELINE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_TRANSPORT_HAS_SECONDS_TIMELINE, CLAP_TRANSPORT_HAS_TEMPO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_TRANSPORT_HAS_TIME_SIGNATURE, CLAP_TRANSPORT_IS_LOOP_ACTIVE, CLAP_TRANSPORT_IS_PLAYING,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_TRANSPORT_IS_RECORDING, CLAP_TRANSPORT_IS_WITHIN_PRE_ROLL,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::audio_ports::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_audio_port_info, clap_plugin_audio_ports, CLAP_AUDIO_PORT_IS_MAIN, CLAP_EXT_AUDIO_PORTS,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PORT_MONO, CLAP_PORT_STEREO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::audio_ports_config::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_audio_ports_config, clap_plugin_audio_ports_config, CLAP_EXT_AUDIO_PORTS_CONFIG,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::remote_controls::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_remote_controls, clap_remote_controls_page, CLAP_EXT_REMOTE_CONTROLS,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::gui::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_gui_resize_hints, clap_host_gui, clap_plugin_gui, clap_window, CLAP_EXT_GUI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_WINDOW_API_COCOA, CLAP_WINDOW_API_WIN32, CLAP_WINDOW_API_X11,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::latency::{clap_host_latency, clap_plugin_latency, CLAP_EXT_LATENCY};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::note_ports::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_note_port_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34}]},\\\\\\\"score\\\\\\\":0.38059261441230774},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":639,\\\\\\\"column\\\\\\\":31},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":692,\\\\\\\"column\\\\\\\":62}},\\\\\\\"contents\\\\\\\":\\\\\\\",\\\\\\\\n            param_id_to_hash,\\\\\\\\n            param_ptr_to_hash,\\\\\\\\n            poly_mod_ids_by_hash,\\\\\\\\n            output_parameter_events: ArrayQueue::new(OUTPUT_EVENT_QUEUE_CAPACITY),\\\\\\\\n\\\\\\\\n            host_thread_check: AtomicRefCell::new(None),\\\\\\\\n\\\\\\\\n            clap_plugin_remote_controls: clap_plugin_remote_controls {\\\\\\\\n                count: Some(Self::ext_remote_controls_count),\\\\\\\\n                get: Some(Self::ext_remote_controls_get),\\\\\\\\n            },\\\\\\\\n            remote_control_pages,\\\\\\\\n\\\\\\\\n            clap_plugin_render: clap_plugin_render {\\\\\\\\n                has_hard_realtime_requirement: Some(Self::ext_render_has_hard_realtime_requirement),\\\\\\\\n                set: Some(Self::ext_render_set),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_state: clap_plugin_state {\\\\\\\\n                save: Some(Self::ext_state_save),\\\\\\\\n                load: Some(Self::ext_state_load),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_tail: clap_plugin_tail {\\\\\\\\n                get: Some(Self::ext_tail_get),\\\\\\\\n            },\\\\\\\\n\\\\\\\\n            clap_plugin_voice_info: clap_plugin_voice_info {\\\\\\\\n                get: Some(Self::ext_voice_info_get),\\\\\\\\n            },\\\\\\\\n            host_voice_info: AtomicRefCell::new(None),\\\\\\\\n            current_voice_capacity: AtomicU32::new(\\\\\\\\n                P::CLAP_POLY_MODULATION_CONFIG\\\\\\\\n                    .map(|c| {\\\\\\\\n                        nih_debug_assert!(\\\\\\\\n                            c.max_voice_capacity &gt;= 1,\\\\\\\\n                            \\\\\\\\\\\\\\\"The maximum voice capacity cannot be zero\\\\\\\\\\\\\\\"\\\\\\\\n                        );\\\\\\\\n                        c.max_voice_capacity\\\\\\\\n                    })\\\\\\\\n                    .unwrap_or(1),\\\\\\\\n            ),\\\\\\\\n\\\\\\\\n            tasks: ArrayQueue::new(TASK_QUEUE_CAPACITY),\\\\\\\\n            main_thread_id: thread::current().id(),\\\\\\\\n            // Initialized later as it needs a reference to the wrapper for the executor\\\\\\\\n            background_thread: AtomicRefCell::new(None),\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // Finally, the wrapper needs to contain a reference to itself so we can create GuiContexts\\\\\\\\n        // when opening plugin editors\\\\\\\\n        let wrapper = Arc::new(wrapper);\\\\\\\\n        *wrapper.this.borrow_mut() = Arc::downgrade(&amp;wrapper);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":640},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_id_to_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":641},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_ptr_to_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":642},{\\\\\\\"text\\\\\\\":\\\\\\\"            poly_mod_ids_by_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":643},{\\\\\\\"text\\\\\\\":\\\\\\\"            output_parameter_events: ArrayQueue::new(OUTPUT_EVENT_QUEUE_CAPACITY),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":644},{\\\\\\\"lineNumber\\\\\\\":645},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_thread_check: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":646},{\\\\\\\"lineNumber\\\\\\\":647},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_remote_controls: clap_plugin_remote_controls {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":648},{\\\\\\\"text\\\\\\\":\\\\\\\"                count: Some(Self::ext_remote_controls_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":649},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_remote_controls_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":650},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":651},{\\\\\\\"text\\\\\\\":\\\\\\\"            remote_control_pages,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":652},{\\\\\\\"lineNumber\\\\\\\":653},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_render: clap_plugin_render {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":654},{\\\\\\\"text\\\\\\\":\\\\\\\"                has_hard_realtime_requirement: Some(Self::ext_render_has_hard_realtime_requirement),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":655},{\\\\\\\"text\\\\\\\":\\\\\\\"                set: Some(Self::ext_render_set),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":656},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":657},{\\\\\\\"lineNumber\\\\\\\":658},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_state: clap_plugin_state {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":659},{\\\\\\\"text\\\\\\\":\\\\\\\"                save: Some(Self::ext_state_save),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":660},{\\\\\\\"text\\\\\\\":\\\\\\\"                load: Some(Self::ext_state_load),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":661},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":662},{\\\\\\\"lineNumber\\\\\\\":663},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_tail: clap_plugin_tail {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":664},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_tail_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":665},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":666},{\\\\\\\"lineNumber\\\\\\\":667},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_plugin_voice_info: clap_plugin_voice_info {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":668},{\\\\\\\"text\\\\\\\":\\\\\\\"                get: Some(Self::ext_voice_info_get),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":669},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":670},{\\\\\\\"text\\\\\\\":\\\\\\\"            host_voice_info: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":671},{\\\\\\\"text\\\\\\\":\\\\\\\"            current_voice_capacity: AtomicU32::new(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":672},{\\\\\\\"text\\\\\\\":\\\\\\\"                P::CLAP_POLY_MODULATION_CONFIG\\\\\\\",\\\\\\\"lineNumber\\\\\\\":673},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .map(|c| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":674},{\\\\\\\"text\\\\\\\":\\\\\\\"                        nih_debug_assert!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":675},{\\\\\\\"text\\\\\\\":\\\\\\\"                            c.max_voice_capacity &gt;= 1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":676},{\\\\\\\"text\\\\\\\":\\\\\\\"                            \\\\\\\\\\\\\\\"The maximum voice capacity cannot be zero\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":677},{\\\\\\\"text\\\\\\\":\\\\\\\"                        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":678},{\\\\\\\"text\\\\\\\":\\\\\\\"                        c.max_voice_capacity\\\\\\\",\\\\\\\"lineNumber\\\\\\\":679},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":680},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .unwrap_or(1),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":681},{\\\\\\\"text\\\\\\\":\\\\\\\"            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":682},{\\\\\\\"lineNumber\\\\\\\":683},{\\\\\\\"text\\\\\\\":\\\\\\\"            tasks: ArrayQueue::new(TASK_QUEUE_CAPACITY),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":684},{\\\\\\\"text\\\\\\\":\\\\\\\"            main_thread_id: thread::current().id(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":685},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Initialized later as it needs a reference to the wrapper for the executor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":686},{\\\\\\\"text\\\\\\\":\\\\\\\"            background_thread: AtomicRefCell::new(None),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":687},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":688},{\\\\\\\"lineNumber\\\\\\\":689},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Finally, the wrapper needs to contain a reference to itself so we can create GuiContexts\\\\\\\",\\\\\\\"lineNumber\\\\\\\":690},{\\\\\\\"text\\\\\\\":\\\\\\\"        // when opening plugin editors\\\\\\\",\\\\\\\"lineNumber\\\\\\\":691},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = Arc::new(wrapper);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":692},{\\\\\\\"text\\\\\\\":\\\\\\\"        *wrapper.this.borrow_mut() = Arc::downgrade(&amp;wrapper);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":693}]},\\\\\\\"score\\\\\\\":0.3804648518562317},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":31,\\\\\\\"column\\\\\\\":87},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":81,\\\\\\\"column\\\\\\\":25}},\\\\\\\"contents\\\\\\\":\\\\\\\"use clap_sys::ext::note_ports::{\\\\\\\\n    clap_note_port_info, clap_plugin_note_ports, CLAP_EXT_NOTE_PORTS, CLAP_NOTE_DIALECT_CLAP,\\\\\\\\n    CLAP_NOTE_DIALECT_MIDI,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::params::{\\\\\\\\n    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\\n    CLAP_PARAM_IS_AUTOMATABLE, CLAP_PARAM_IS_BYPASS, CLAP_PARAM_IS_HIDDEN,\\\\\\\\n    CLAP_PARAM_IS_MODULATABLE, CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID, CLAP_PARAM_IS_READONLY,\\\\\\\\n    CLAP_PARAM_IS_STEPPED, CLAP_PARAM_RESCAN_VALUES,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::render::{\\\\\\\\n    clap_plugin_render, clap_plugin_render_mode, CLAP_EXT_RENDER, CLAP_RENDER_OFFLINE,\\\\\\\\n    CLAP_RENDER_REALTIME,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::state::{clap_plugin_state, CLAP_EXT_STATE};\\\\\\\\nuse clap_sys::ext::tail::{clap_plugin_tail, CLAP_EXT_TAIL};\\\\\\\\nuse clap_sys::ext::thread_check::{clap_host_thread_check, CLAP_EXT_THREAD_CHECK};\\\\\\\\nuse clap_sys::ext::voice_info::{\\\\\\\\n    clap_host_voice_info, clap_plugin_voice_info, clap_voice_info, CLAP_EXT_VOICE_INFO,\\\\\\\\n    CLAP_VOICE_INFO_SUPPORTS_OVERLAPPING_NOTES,\\\\\\\\n};\\\\\\\\nuse clap_sys::fixedpoint::{CLAP_BEATTIME_FACTOR, CLAP_SECTIME_FACTOR};\\\\\\\\nuse clap_sys::host::clap_host;\\\\\\\\nuse clap_sys::id::{clap_id, CLAP_INVALID_ID};\\\\\\\\nuse clap_sys::plugin::clap_plugin;\\\\\\\\nuse clap_sys::process::{\\\\\\\\n    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\\n    CLAP_PROCESS_ERROR,\\\\\\\\n};\\\\\\\\nuse clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\\nuse crossbeam::atomic::AtomicCell;\\\\\\\\nuse crossbeam::channel::{self, SendTimeoutError};\\\\\\\\nuse crossbeam::queue::ArrayQueue;\\\\\\\\nuse parking_lot::Mutex;\\\\\\\\nuse std::any::Any;\\\\\\\\nuse std::borrow::Borrow;\\\\\\\\nuse std::collections::{HashMap, HashSet, VecDeque};\\\\\\\\nuse std::ffi::{c_void, CStr};\\\\\\\\nuse std::mem;\\\\\\\\nuse std::num::NonZeroU32;\\\\\\\\nuse std::os::raw::c_char;\\\\\\\\nuse std::ptr::NonNull;\\\\\\\\nuse std::sync::atomic::{AtomicBool, AtomicU32, Ordering};\\\\\\\\nuse std::sync::{Arc, Weak};\\\\\\\\nuse std::thread::{self, ThreadId};\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse super::context::{WrapperGuiContext, WrapperInitContext, WrapperProcessContext};\\\\\\\\nuse super::descriptor::PluginDescriptor;\\\\\\\\nuse super::util::ClapPtr;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::note_ports::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_note_port_info, clap_plugin_note_ports, CLAP_EXT_NOTE_PORTS, CLAP_NOTE_DIALECT_CLAP,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_NOTE_DIALECT_MIDI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::params::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_AUTOMATABLE, CLAP_PARAM_IS_BYPASS, CLAP_PARAM_IS_HIDDEN,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_MODULATABLE, CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID, CLAP_PARAM_IS_READONLY,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_STEPPED, CLAP_PARAM_RESCAN_VALUES,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::render::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_render, clap_plugin_render_mode, CLAP_EXT_RENDER, CLAP_RENDER_OFFLINE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_RENDER_REALTIME,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::state::{clap_plugin_state, CLAP_EXT_STATE};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::tail::{clap_plugin_tail, CLAP_EXT_TAIL};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::thread_check::{clap_host_thread_check, CLAP_EXT_THREAD_CHECK};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::voice_info::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_host_voice_info, clap_plugin_voice_info, clap_voice_info, CLAP_EXT_VOICE_INFO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_VOICE_INFO_SUPPORTS_OVERLAPPING_NOTES,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::fixedpoint::{CLAP_BEATTIME_FACTOR, CLAP_SECTIME_FACTOR};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::host::clap_host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::id::{clap_id, CLAP_INVALID_ID};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::plugin::clap_plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::process::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PROCESS_ERROR,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::atomic::AtomicCell;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::channel::{self, SendTimeoutError};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::queue::ArrayQueue;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"use parking_lot::Mutex;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::any::Any;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::collections::{HashMap, HashSet, VecDeque};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::{c_void, CStr};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::mem;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::os::raw::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ptr::NonNull;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::{Arc, Weak};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::thread::{self, ThreadId};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::context::{WrapperGuiContext, WrapperInitContext, WrapperProcessContext};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::descriptor::PluginDescriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::ClapPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82}]},\\\\\\\"score\\\\\\\":0.3769339919090271},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/util.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":43}},\\\\\\\"contents\\\\\\\":\\\\\\\"use clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\\nuse std::mem::MaybeUninit;\\\\\\\\nuse std::ops::Deref;\\\\\\\\nuse std::os::raw::c_void;\\\\\\\\n\\\\\\\\n/// Early exit out of a function with the specified return value when one of the passed pointers is\\\\\\\\n/// null.\\\\\\\\nmacro_rules! check_null_ptr {\\\\\\\\n    ($ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        $crate::wrapper::clap::util::check_null_ptr_msg!(\\\\\\\\\\\\\\\"Null pointer passed to function\\\\\\\\\\\\\\\", $ret, $ptr $(, $ptrs)*)\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The same as [&#96;check_null_ptr!&#96;], but with a custom message.\\\\\\\\nmacro_rules! check_null_ptr_msg {\\\\\\\\n    ($msg:expr, $ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\\n        // Clippy doesn't understand it when we use a unit in our &#96;check_null_ptr!()&#96; macro, even\\\\\\\\n        // if we explicitly pattern match on that unit\\\\\\\\n        #[allow(clippy::unused_unit)]\\\\\\\\n        if $ptr.is_null() $(|| $ptrs.is_null())* {\\\\\\\\n            nih_debug_assert_failure!($msg);\\\\\\\\n            return $ret;\\\\\\\\n        }\\\\\\\\n    };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Call a CLAP function. This is needed because even though none of CLAP's functions are allowed to\\\\\\\\n/// be null pointers, people will still use null pointers for some of the function arguments. This\\\\\\\\n/// also happens in the official &#96;clap-helpers&#96;. As such, these functions are now &#96;Option&lt;fn(...)&gt;&#96;\\\\\\\\n/// optional function pointers in &#96;clap-sys&#96;. This macro asserts that the pointer is not null, and\\\\\\\\n/// prints a nicely formatted error message containing the struct and function name if it is. It\\\\\\\\n/// also emulates C's syntax for accessing fields struct through a pointer. Except that it uses &#96;=&gt;&#96;\\\\\\\\n/// instead of &#96;-&gt;&#96;. Because that sounds like it would be hilarious.\\\\\\\\nmacro_rules! clap_call {\\\\\\\\n    { $obj_ptr:expr=&gt;$function_name:ident($($args:expr),* $(, )?) } =&gt; {\\\\\\\\n        match (*$obj_ptr).$function_name {\\\\\\\\n            Some(function_ptr) =&gt; function_ptr($($args),*),\\\\\\\\n            None =&gt; panic!(\\\\\\\\\\\\\\\"'{}::{}' is a null pointer, but this is not allowed\\\\\\\\\\\\\\\", $crate::wrapper::clap::util::type_name_of_ptr($obj_ptr), stringify!($function_name)),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// [&#96;clap_call!()&#96;], wrapped in an unsafe block.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::mem::MaybeUninit;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ops::Deref;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::os::raw::c_void;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Early exit out of a function with the specified return value when one of the passed pointers is\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"/// null.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! check_null_ptr {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"        $crate::wrapper::clap::util::check_null_ptr_msg!(\\\\\\\\\\\\\\\"Null pointer passed to function\\\\\\\\\\\\\\\", $ret, $ptr $(, $ptrs)*)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The same as [&#96;check_null_ptr!&#96;], but with a custom message.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! check_null_ptr_msg {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($msg:expr, $ret:expr, $ptr:expr $(, $ptrs:expr)* $(, )?) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Clippy doesn't understand it when we use a unit in our &#96;check_null_ptr!()&#96; macro, even\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"        // if we explicitly pattern match on that unit\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(clippy::unused_unit)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"        if $ptr.is_null() $(|| $ptrs.is_null())* {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_debug_assert_failure!($msg);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"            return $ret;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Call a CLAP function. This is needed because even though none of CLAP's functions are allowed to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"/// be null pointers, people will still use null pointers for some of the function arguments. This\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"/// also happens in the official &#96;clap-helpers&#96;. As such, these functions are now &#96;Option&lt;fn(...)&gt;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"/// optional function pointers in &#96;clap-sys&#96;. This macro asserts that the pointer is not null, and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"/// prints a nicely formatted error message containing the struct and function name if it is. It\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"/// also emulates C's syntax for accessing fields struct through a pointer. Except that it uses &#96;=&gt;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"/// instead of &#96;-&gt;&#96;. Because that sounds like it would be hilarious.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! clap_call {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    { $obj_ptr:expr=&gt;$function_name:ident($($args:expr),* $(, )?) } =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"        match (*$obj_ptr).$function_name {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(function_ptr) =&gt; function_ptr($($args),*),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; panic!(\\\\\\\\\\\\\\\"'{}::{}' is a null pointer, but this is not allowed\\\\\\\\\\\\\\\", $crate::wrapper::clap::util::type_name_of_ptr($obj_ptr), stringify!($function_name)),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"/// [&#96;clap_call!()&#96;], wrapped in an unsafe block.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.3768177926540375},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2310,\\\\\\\"column\\\\\\\":63},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2345,\\\\\\\"column\\\\\\\":67}},\\\\\\\"contents\\\\\\\":\\\\\\\"        let id = CStr::from_ptr(id);\\\\\\\\n\\\\\\\\n        if id == CLAP_EXT_AUDIO_PORTS_CONFIG {\\\\\\\\n            &amp;wrapper.clap_plugin_audio_ports_config as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_AUDIO_PORTS {\\\\\\\\n            &amp;wrapper.clap_plugin_audio_ports as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_GUI &amp;&amp; wrapper.editor.borrow().is_some() {\\\\\\\\n            // Only report that we support this extension if the plugin has an editor\\\\\\\\n            &amp;wrapper.clap_plugin_gui as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_LATENCY {\\\\\\\\n            &amp;wrapper.clap_plugin_latency as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_NOTE_PORTS\\\\\\\\n            &amp;&amp; (P::MIDI_INPUT &gt;= MidiConfig::Basic || P::MIDI_OUTPUT &gt;= MidiConfig::Basic)\\\\\\\\n        {\\\\\\\\n            &amp;wrapper.clap_plugin_note_ports as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_PARAMS {\\\\\\\\n            &amp;wrapper.clap_plugin_params as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_REMOTE_CONTROLS {\\\\\\\\n            &amp;wrapper.clap_plugin_remote_controls as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_RENDER {\\\\\\\\n            &amp;wrapper.clap_plugin_render as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_STATE {\\\\\\\\n            &amp;wrapper.clap_plugin_state as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_TAIL {\\\\\\\\n            &amp;wrapper.clap_plugin_tail as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_VOICE_INFO &amp;&amp; P::CLAP_POLY_MODULATION_CONFIG.is_some() {\\\\\\\\n            &amp;wrapper.clap_plugin_voice_info as *const _ as *const c_void\\\\\\\\n        } else {\\\\\\\\n            nih_trace!(\\\\\\\\\\\\\\\"Host tried to query unknown extension {:?}\\\\\\\\\\\\\\\", id);\\\\\\\\n            std::ptr::null()\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn on_main_thread(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        let id = CStr::from_ptr(id);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2313},{\\\\\\\"lineNumber\\\\\\\":2314},{\\\\\\\"text\\\\\\\":\\\\\\\"        if id == CLAP_EXT_AUDIO_PORTS_CONFIG {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2315},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_audio_ports_config as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2316},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_AUDIO_PORTS {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2317},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_audio_ports as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2318},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_GUI &amp;&amp; wrapper.editor.borrow().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2319},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Only report that we support this extension if the plugin has an editor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2320},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_gui as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2321},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_LATENCY {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2322},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_latency as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2323},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_NOTE_PORTS\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2324},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;&amp; (P::MIDI_INPUT &gt;= MidiConfig::Basic || P::MIDI_OUTPUT &gt;= MidiConfig::Basic)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2325},{\\\\\\\"text\\\\\\\":\\\\\\\"        {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2326},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_note_ports as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2327},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_PARAMS {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2328},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_params as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2329},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_REMOTE_CONTROLS {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2330},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_remote_controls as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2331},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_RENDER {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2332},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_render as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2333},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_STATE {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2334},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_state as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2335},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_TAIL {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2336},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_tail as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2337},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_VOICE_INFO &amp;&amp; P::CLAP_POLY_MODULATION_CONFIG.is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2338},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_voice_info as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2339},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2340},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_trace!(\\\\\\\\\\\\\\\"Host tried to query unknown extension {:?}\\\\\\\\\\\\\\\", id);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2341},{\\\\\\\"text\\\\\\\":\\\\\\\"            std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2342},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2343},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2344},{\\\\\\\"lineNumber\\\\\\\":2345},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn on_main_thread(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2346}]},\\\\\\\"score\\\\\\\":0.3753223419189453},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":29,\\\\\\\"column\\\\\\\":66}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\\nmod util;\\\\\\\\n\\\\\\\\nmod context;\\\\\\\\nmod factory;\\\\\\\\nmod inner;\\\\\\\\nmod note_expressions;\\\\\\\\nmod param_units;\\\\\\\\npub mod subcategories;\\\\\\\\nmod view;\\\\\\\\nmod wrapper;\\\\\\\\n\\\\\\\\n/// Re-export for the wrapper.\\\\\\\\npub use factory::PluginInfo;\\\\\\\\npub use vst3_sys;\\\\\\\\npub use wrapper::Wrapper;\\\\\\\\n\\\\\\\\n/// Export one or more VST3 plugins from this library using the provided plugin types. The first\\\\\\\\n/// plugin's vendor information is used for the factory's information.\\\\\\\\n#[macro_export]\\\\\\\\nmacro_rules! nih_export_vst3 {\\\\\\\\n    ($($plugin_ty:ty),+) =&gt; {\\\\\\\\n        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\\n        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\\n        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\\n        #[doc(hidden)]\\\\\\\\n        mod vst3 {\\\\\\\\n            use ::std::collections::HashSet;\\\\\\\\n\\\\\\\\n            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"mod context;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"mod factory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod inner;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod note_expressions;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod param_units;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod subcategories;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod view;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Re-export for the wrapper.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use factory::PluginInfo;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use vst3_sys;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use wrapper::Wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Export one or more VST3 plugins from this library using the provided plugin types. The first\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"/// plugin's vendor information is used for the factory's information.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_export]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! nih_export_vst3 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($($plugin_ty:ty),+) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod vst3 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::collections::HashSet;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30}]},\\\\\\\"score\\\\\\\":0.3744077682495117},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":71,\\\\\\\"column\\\\\\\":75},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":109,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"        // NOTE: This is safe without pinning this struct because all of the data is already stored\\\\\\\\n        //       on the heap\\\\\\\\n        descriptor.plugin_descriptor = Some(clap_plugin_descriptor {\\\\\\\\n            clap_version: CLAP_VERSION,\\\\\\\\n            id: descriptor.clap_id.as_ptr(),\\\\\\\\n            name: descriptor.name.as_ptr(),\\\\\\\\n            vendor: descriptor.vendor.as_ptr(),\\\\\\\\n            url: descriptor.url.as_ptr(),\\\\\\\\n            version: descriptor.version.as_ptr(),\\\\\\\\n            manual_url: descriptor\\\\\\\\n                .clap_manual_url\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|url| url.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            support_url: descriptor\\\\\\\\n                .clap_support_url\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|url| url.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            description: descriptor\\\\\\\\n                .clap_description\\\\\\\\n                .as_ref()\\\\\\\\n                .map(|description| description.as_ptr())\\\\\\\\n                .unwrap_or(std::ptr::null()),\\\\\\\\n            features: descriptor.clap_features_ptrs.as_ptr(),\\\\\\\\n        });\\\\\\\\n\\\\\\\\n        descriptor\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn clap_plugin_descriptor(&amp;self) -&gt; &amp;clap_plugin_descriptor {\\\\\\\\n        self.plugin_descriptor.as_ref().unwrap()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn clap_id(&amp;self) -&gt; &amp;CStr {\\\\\\\\n        self.clap_id.as_c_str()\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        // NOTE: This is safe without pinning this struct because all of the data is already stored\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"        //       on the heap\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        descriptor.plugin_descriptor = Some(clap_plugin_descriptor {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_version: CLAP_VERSION,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"            id: descriptor.clap_id.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"            name: descriptor.name.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"            vendor: descriptor.vendor.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"            url: descriptor.url.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"            version: descriptor.version.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"            manual_url: descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                .clap_manual_url\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|url| url.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"                .unwrap_or(std::ptr::null()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"            support_url: descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                .clap_support_url\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|url| url.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"                .unwrap_or(std::ptr::null()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"            description: descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                .clap_description\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|description| description.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"                .unwrap_or(std::ptr::null()),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"            features: descriptor.clap_features_ptrs.as_ptr(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"        });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn clap_plugin_descriptor(&amp;self) -&gt; &amp;clap_plugin_descriptor {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.plugin_descriptor.as_ref().unwrap()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn clap_id(&amp;self) -&gt; &amp;CStr {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.clap_id.as_c_str()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110}]},\\\\\\\"score\\\\\\\":0.3738938570022583},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":422,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":468,\\\\\\\"column\\\\\\\":19}},\\\\\\\"contents\\\\\\\":\\\\\\\"}\\\\\\\\n\\\\\\\\nimpl&lt;P: ClapPlugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    /// # Safety\\\\\\\\n    ///\\\\\\\\n    /// &#96;host_callback&#96; needs to outlive the returned object.\\\\\\\\n    pub unsafe fn new(host_callback: *const clap_host) -&gt; Arc&lt;Self&gt; {\\\\\\\\n        let mut plugin = P::default();\\\\\\\\n        let task_executor = Mutex::new(plugin.task_executor());\\\\\\\\n\\\\\\\\n        // This is used to allow the plugin to restore preset data from its editor, see the comment\\\\\\\\n        // on &#96;Self::updated_state_sender&#96;\\\\\\\\n        let (updated_state_sender, updated_state_receiver) = channel::bounded(0);\\\\\\\\n\\\\\\\\n        let plugin_descriptor: Box&lt;PluginDescriptor&gt; =\\\\\\\\n            Box::new(PluginDescriptor::for_plugin::&lt;P&gt;());\\\\\\\\n\\\\\\\\n        // We're not allowed to query any extensions until the init function has been called, so we\\\\\\\\n        // need a bunch of AtomicRefCells instead\\\\\\\\n        assert!(!host_callback.is_null());\\\\\\\\n        let host_callback = unsafe { ClapPtr::new(host_callback) };\\\\\\\\n\\\\\\\\n        // This is a mapping from the parameter IDs specified by the plugin to pointers to those\\\\\\\\n        // parameters. These pointers are assumed to be safe to dereference as long as\\\\\\\\n        // &#96;wrapper.plugin&#96; is alive. The plugin API identifiers these parameters by hashes, which\\\\\\\\n        // we'll calculate from the string ID specified by the plugin. These parameters should also\\\\\\\\n        // remain in the same order as the one returned by the plugin.\\\\\\\\n        let params = plugin.params();\\\\\\\\n        let param_id_hashes_ptrs_groups: Vec&lt;_&gt; = params\\\\\\\\n            .param_map()\\\\\\\\n            .into_iter()\\\\\\\\n            .map(|(id, ptr, group)| {\\\\\\\\n                let hash = hash_param_id(&amp;id);\\\\\\\\n                (id, hash, ptr, group)\\\\\\\\n            })\\\\\\\\n            .collect();\\\\\\\\n        let param_hashes = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, _, _)| *hash)\\\\\\\\n            .collect();\\\\\\\\n        let param_by_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\\n            .map(|(_, hash, ptr, _)| (*hash, *ptr))\\\\\\\\n            .collect();\\\\\\\\n        let param_id_by_hash = param_id_hashes_ptrs_groups\\\\\\\\n            .iter()\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":424},{\\\\\\\"lineNumber\\\\\\\":425},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":426},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// # Safety\\\\\\\",\\\\\\\"lineNumber\\\\\\\":427},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":428},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;host_callback&#96; needs to outlive the returned object.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":429},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub unsafe fn new(host_callback: *const clap_host) -&gt; Arc&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":430},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut plugin = P::default();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":431},{\\\\\\\"text\\\\\\\":\\\\\\\"        let task_executor = Mutex::new(plugin.task_executor());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":432},{\\\\\\\"lineNumber\\\\\\\":433},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This is used to allow the plugin to restore preset data from its editor, see the comment\\\\\\\",\\\\\\\"lineNumber\\\\\\\":434},{\\\\\\\"text\\\\\\\":\\\\\\\"        // on &#96;Self::updated_state_sender&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":435},{\\\\\\\"text\\\\\\\":\\\\\\\"        let (updated_state_sender, updated_state_receiver) = channel::bounded(0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":436},{\\\\\\\"lineNumber\\\\\\\":437},{\\\\\\\"text\\\\\\\":\\\\\\\"        let plugin_descriptor: Box&lt;PluginDescriptor&gt; =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":438},{\\\\\\\"text\\\\\\\":\\\\\\\"            Box::new(PluginDescriptor::for_plugin::&lt;P&gt;());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":439},{\\\\\\\"lineNumber\\\\\\\":440},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We're not allowed to query any extensions until the init function has been called, so we\\\\\\\",\\\\\\\"lineNumber\\\\\\\":441},{\\\\\\\"text\\\\\\\":\\\\\\\"        // need a bunch of AtomicRefCells instead\\\\\\\",\\\\\\\"lineNumber\\\\\\\":442},{\\\\\\\"text\\\\\\\":\\\\\\\"        assert!(!host_callback.is_null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":443},{\\\\\\\"text\\\\\\\":\\\\\\\"        let host_callback = unsafe { ClapPtr::new(host_callback) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":444},{\\\\\\\"lineNumber\\\\\\\":445},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This is a mapping from the parameter IDs specified by the plugin to pointers to those\\\\\\\",\\\\\\\"lineNumber\\\\\\\":446},{\\\\\\\"text\\\\\\\":\\\\\\\"        // parameters. These pointers are assumed to be safe to dereference as long as\\\\\\\",\\\\\\\"lineNumber\\\\\\\":447},{\\\\\\\"text\\\\\\\":\\\\\\\"        // &#96;wrapper.plugin&#96; is alive. The plugin API identifiers these parameters by hashes, which\\\\\\\",\\\\\\\"lineNumber\\\\\\\":448},{\\\\\\\"text\\\\\\\":\\\\\\\"        // we'll calculate from the string ID specified by the plugin. These parameters should also\\\\\\\",\\\\\\\"lineNumber\\\\\\\":449},{\\\\\\\"text\\\\\\\":\\\\\\\"        // remain in the same order as the one returned by the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":450},{\\\\\\\"text\\\\\\\":\\\\\\\"        let params = plugin.params();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":451},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_id_hashes_ptrs_groups: Vec&lt;_&gt; = params\\\\\\\",\\\\\\\"lineNumber\\\\\\\":452},{\\\\\\\"text\\\\\\\":\\\\\\\"            .param_map()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":453},{\\\\\\\"text\\\\\\\":\\\\\\\"            .into_iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":454},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|(id, ptr, group)| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":455},{\\\\\\\"text\\\\\\\":\\\\\\\"                let hash = hash_param_id(&amp;id);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":456},{\\\\\\\"text\\\\\\\":\\\\\\\"                (id, hash, ptr, group)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":457},{\\\\\\\"text\\\\\\\":\\\\\\\"            })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":458},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":459},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_hashes = param_id_hashes_ptrs_groups\\\\\\\",\\\\\\\"lineNumber\\\\\\\":460},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":461},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|(_, hash, _, _)| *hash)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":462},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":463},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_by_hash = param_id_hashes_ptrs_groups\\\\\\\",\\\\\\\"lineNumber\\\\\\\":464},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":465},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|(_, hash, ptr, _)| (*hash, *ptr))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":466},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":467},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_id_by_hash = param_id_hashes_ptrs_groups\\\\\\\",\\\\\\\"lineNumber\\\\\\\":468},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":469}]},\\\\\\\"score\\\\\\\":0.3737514019012451},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1866,\\\\\\\"column\\\\\\\":19},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1912,\\\\\\\"column\\\\\\\":63}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        sample_rate: f64,\\\\\\\\n        min_frames_count: u32,\\\\\\\\n        max_frames_count: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n        let buffer_config = BufferConfig {\\\\\\\\n            sample_rate: sample_rate as f32,\\\\\\\\n            min_buffer_size: Some(min_frames_count),\\\\\\\\n            max_buffer_size: max_frames_count,\\\\\\\\n            process_mode: wrapper.current_process_mode.load(),\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // Before initializing the plugin, make sure all smoothers are set the the default values\\\\\\\\n        for param in wrapper.param_by_hash.values() {\\\\\\\\n            param.update_smoother(buffer_config.sample_rate, true);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\\n        let mut init_context = wrapper.make_init_context();\\\\\\\\n        let mut plugin = wrapper.plugin.lock();\\\\\\\\n        if plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context) {\\\\\\\\n            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\\n            //       this function\\\\\\\\n\\\\\\\\n            // This preallocates enough space so we can transform all of the host's raw channel\\\\\\\\n            // pointers into a set of &#96;Buffer&#96; objects for the plugin's main and auxiliary IO\\\\\\\\n            *wrapper.buffer_manager.borrow_mut() =\\\\\\\\n                BufferManager::for_audio_io_layout(max_frames_count as usize, audio_io_layout);\\\\\\\\n\\\\\\\\n            // Also store this for later, so we can reinitialize the plugin after restoring state\\\\\\\\n            wrapper.current_buffer_config.store(Some(buffer_config));\\\\\\\\n\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            false\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1868},{\\\\\\\"lineNumber\\\\\\\":1869},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1870},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1871},{\\\\\\\"text\\\\\\\":\\\\\\\"        sample_rate: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1872},{\\\\\\\"text\\\\\\\":\\\\\\\"        min_frames_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1873},{\\\\\\\"text\\\\\\\":\\\\\\\"        max_frames_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1874},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1875},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1876},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1877},{\\\\\\\"lineNumber\\\\\\\":1878},{\\\\\\\"text\\\\\\\":\\\\\\\"        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1879},{\\\\\\\"text\\\\\\\":\\\\\\\"        let buffer_config = BufferConfig {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1880},{\\\\\\\"text\\\\\\\":\\\\\\\"            sample_rate: sample_rate as f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1881},{\\\\\\\"text\\\\\\\":\\\\\\\"            min_buffer_size: Some(min_frames_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1882},{\\\\\\\"text\\\\\\\":\\\\\\\"            max_buffer_size: max_frames_count,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1883},{\\\\\\\"text\\\\\\\":\\\\\\\"            process_mode: wrapper.current_process_mode.load(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1884},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1885},{\\\\\\\"lineNumber\\\\\\\":1886},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Before initializing the plugin, make sure all smoothers are set the the default values\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1887},{\\\\\\\"text\\\\\\\":\\\\\\\"        for param in wrapper.param_by_hash.values() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1888},{\\\\\\\"text\\\\\\\":\\\\\\\"            param.update_smoother(buffer_config.sample_rate, true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1889},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1890},{\\\\\\\"lineNumber\\\\\\\":1891},{\\\\\\\"text\\\\\\\":\\\\\\\"        // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1892},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut init_context = wrapper.make_init_context();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1893},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut plugin = wrapper.plugin.lock();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1894},{\\\\\\\"text\\\\\\\":\\\\\\\"        if plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1895},{\\\\\\\"text\\\\\\\":\\\\\\\"            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1896},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       this function\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1897},{\\\\\\\"lineNumber\\\\\\\":1898},{\\\\\\\"text\\\\\\\":\\\\\\\"            // This preallocates enough space so we can transform all of the host's raw channel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1899},{\\\\\\\"text\\\\\\\":\\\\\\\"            // pointers into a set of &#96;Buffer&#96; objects for the plugin's main and auxiliary IO\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1900},{\\\\\\\"text\\\\\\\":\\\\\\\"            *wrapper.buffer_manager.borrow_mut() =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1901},{\\\\\\\"text\\\\\\\":\\\\\\\"                BufferManager::for_audio_io_layout(max_frames_count as usize, audio_io_layout);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1902},{\\\\\\\"lineNumber\\\\\\\":1903},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Also store this for later, so we can reinitialize the plugin after restoring state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1904},{\\\\\\\"text\\\\\\\":\\\\\\\"            wrapper.current_buffer_config.store(Some(buffer_config));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1905},{\\\\\\\"lineNumber\\\\\\\":1906},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1907},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1908},{\\\\\\\"text\\\\\\\":\\\\\\\"            false\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1909},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1910},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1911},{\\\\\\\"lineNumber\\\\\\\":1912},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1913}]},\\\\\\\"score\\\\\\\":0.3691314458847046},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/plugins/loudness_war_winner/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":247,\\\\\\\"column\\\\\\\":58},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":280,\\\\\\\"column\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ClapPlugin for LoudnessWarWinner {\\\\\\\\n    const CLAP_ID: &amp;'static str = \\\\\\\\\\\\\\\"nl.robbertvanderhelm.loudness-war-winner\\\\\\\\\\\\\\\";\\\\\\\\n    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt; = Some(\\\\\\\\\\\\\\\"Win the loudness war with ease\\\\\\\\\\\\\\\");\\\\\\\\n    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt; = Some(Self::URL);\\\\\\\\n    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt; = None;\\\\\\\\n    const CLAP_FEATURES: &amp;'static [ClapFeature] = &amp;[\\\\\\\\n        ClapFeature::AudioEffect,\\\\\\\\n        ClapFeature::Stereo,\\\\\\\\n        ClapFeature::Mono,\\\\\\\\n        ClapFeature::Limiter,\\\\\\\\n        ClapFeature::Distortion,\\\\\\\\n        ClapFeature::Utility,\\\\\\\\n        ClapFeature::Custom(\\\\\\\\\\\\\\\"nih:pain\\\\\\\\\\\\\\\"),\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Vst3Plugin for LoudnessWarWinner {\\\\\\\\n    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"LoudnessWar.RvdH\\\\\\\\\\\\\\\";\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\\n        Vst3SubCategory::Fx,\\\\\\\\n        Vst3SubCategory::Dynamics,\\\\\\\\n        Vst3SubCategory::Distortion,\\\\\\\\n        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Pain\\\\\\\\\\\\\\\"),\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nnih_export_clap!(LoudnessWarWinner);\\\\\\\\nnih_export_vst3!(LoudnessWarWinner);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":249},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":250},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":251},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":252},{\\\\\\\"lineNumber\\\\\\\":253},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ClapPlugin for LoudnessWarWinner {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":254},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_ID: &amp;'static str = \\\\\\\\\\\\\\\"nl.robbertvanderhelm.loudness-war-winner\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":255},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt; = Some(\\\\\\\\\\\\\\\"Win the loudness war with ease\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":256},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt; = Some(Self::URL);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":257},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt; = None;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":258},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_FEATURES: &amp;'static [ClapFeature] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":259},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::AudioEffect,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":260},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Stereo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":261},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Mono,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":262},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Limiter,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":263},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Distortion,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":264},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Utility,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":265},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Custom(\\\\\\\\\\\\\\\"nih:pain\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":266},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":267},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":268},{\\\\\\\"lineNumber\\\\\\\":269},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Vst3Plugin for LoudnessWarWinner {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":270},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"LoudnessWar.RvdH\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":271},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":272},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Fx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":273},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Dynamics,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":274},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Distortion,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":275},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Pain\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":276},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":277},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":278},{\\\\\\\"lineNumber\\\\\\\":279},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_clap!(LoudnessWarWinner);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":280},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_vst3!(LoudnessWarWinner);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":281}]},\\\\\\\"score\\\\\\\":0.36727678775787354},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/descriptor.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":33,\\\\\\\"column\\\\\\\":40},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":74,\\\\\\\"column\\\\\\\":38}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl PluginDescriptor {\\\\\\\\n    /// Construct the plugin descriptor for a specific CLAP plugin.\\\\\\\\n    pub fn for_plugin&lt;P: ClapPlugin&gt;() -&gt; Self {\\\\\\\\n        let mut descriptor = Self {\\\\\\\\n            clap_id: CString::new(P::CLAP_ID).expect(\\\\\\\\\\\\\\\"&#96;CLAP_ID&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            name: CString::new(P::NAME).expect(\\\\\\\\\\\\\\\"&#96;NAME&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            vendor: CString::new(P::VENDOR).expect(\\\\\\\\\\\\\\\"&#96;VENDOR&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            url: CString::new(P::URL).expect(\\\\\\\\\\\\\\\"&#96;URL&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            version: CString::new(P::VERSION).expect(\\\\\\\\\\\\\\\"&#96;VERSION&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\\n            clap_manual_url: P::CLAP_MANUAL_URL\\\\\\\\n                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_MANUAL_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\\n            clap_support_url: P::CLAP_SUPPORT_URL\\\\\\\\n                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_SUPPORT_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\\n            clap_description: P::CLAP_DESCRIPTION.map(|description| {\\\\\\\\n                CString::new(description).expect(\\\\\\\\\\\\\\\"&#96;CLAP_DESCRIPTION&#96; contained null bytes\\\\\\\\\\\\\\\")\\\\\\\\n            }),\\\\\\\\n            clap_features: P::CLAP_FEATURES\\\\\\\\n                .iter()\\\\\\\\n                .map(|feat| feat.as_str())\\\\\\\\n                .map(|s| CString::new(s).expect(\\\\\\\\\\\\\\\"&#96;CLAP_FEATURES&#96; contained null bytes\\\\\\\\\\\\\\\"))\\\\\\\\n                .collect(),\\\\\\\\n\\\\\\\\n            // These need to be initialized later as they contain pointers to the fields in this\\\\\\\\n            // descriptor\\\\\\\\n            clap_features_ptrs: Vec::new(),\\\\\\\\n            plugin_descriptor: None,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // The keyword list is an environ-like list of char pointers terminated by a null pointer.\\\\\\\\n        descriptor.clap_features_ptrs = descriptor\\\\\\\\n            .clap_features\\\\\\\\n            .iter()\\\\\\\\n            .map(|feature| feature.as_ptr())\\\\\\\\n            .collect();\\\\\\\\n        descriptor.clap_features_ptrs.push(std::ptr::null());\\\\\\\\n\\\\\\\\n        // We couldn't initialize this directly because of all the CStrings\\\\\\\\n        // NOTE: This is safe without pinning this struct because all of the data is already stored\\\\\\\\n        //       on the heap\\\\\\\\n        descriptor.plugin_descriptor =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginDescriptor {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Construct the plugin descriptor for a specific CLAP plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn for_plugin&lt;P: ClapPlugin&gt;() -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut descriptor = Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_id: CString::new(P::CLAP_ID).expect(\\\\\\\\\\\\\\\"&#96;CLAP_ID&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"            name: CString::new(P::NAME).expect(\\\\\\\\\\\\\\\"&#96;NAME&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            vendor: CString::new(P::VENDOR).expect(\\\\\\\\\\\\\\\"&#96;VENDOR&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"            url: CString::new(P::URL).expect(\\\\\\\\\\\\\\\"&#96;URL&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            version: CString::new(P::VERSION).expect(\\\\\\\\\\\\\\\"&#96;VERSION&#96; contained null bytes\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_manual_url: P::CLAP_MANUAL_URL\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_MANUAL_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_support_url: P::CLAP_SUPPORT_URL\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|url| CString::new(url).expect(\\\\\\\\\\\\\\\"&#96;CLAP_SUPPORT_URL&#96; contained null bytes\\\\\\\\\\\\\\\")),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_description: P::CLAP_DESCRIPTION.map(|description| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"                CString::new(description).expect(\\\\\\\\\\\\\\\"&#96;CLAP_DESCRIPTION&#96; contained null bytes\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"            }),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_features: P::CLAP_FEATURES\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|feat| feat.as_str())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"                .map(|s| CString::new(s).expect(\\\\\\\\\\\\\\\"&#96;CLAP_FEATURES&#96; contained null bytes\\\\\\\\\\\\\\\"))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"                .collect(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"            // These need to be initialized later as they contain pointers to the fields in this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"            // descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"            clap_features_ptrs: Vec::new(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"            plugin_descriptor: None,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"        // The keyword list is an environ-like list of char pointers terminated by a null pointer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        descriptor.clap_features_ptrs = descriptor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"            .clap_features\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|feature| feature.as_ptr())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            .collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        descriptor.clap_features_ptrs.push(std::ptr::null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We couldn't initialize this directly because of all the CStrings\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        // NOTE: This is safe without pinning this struct because all of the data is already stored\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"        //       on the heap\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"        descriptor.plugin_descriptor =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75}]},\\\\\\\"score\\\\\\\":0.36290839314460754}]}\\\"},\\\"capabilityType\\\":15}\",\"02f0051c-c1b8-4bac-8e7d-c75267370a2d\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8dd6eece-d0e9-4434-95e0-4e407732daf9\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.053Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_49dffd1f-3cc5-43ba-acc9-2cf1ff86dca\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_49dffd1f-3cc5-43ba-acc9-2cf1ff86dca\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is GetPluginFactory exported in nih-plug VST3 wrapper?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"nih-plug\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How is GetPluginFactory exported in nih-plug VST3 wrapper?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"nih-plug\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":161,\\\\\\\"column\\\\\\\":44},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":217,\\\\\\\"column\\\\\\\":9}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                unsafe fn get_class_info_unicode(\\\\\\\\n                    &amp;self,\\\\\\\\n                    index: i32,\\\\\\\\n                    info: *mut PClassInfoW,\\\\\\\\n                ) -&gt; tresult {\\\\\\\\n                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\\n                        return kInvalidArgument;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    *info = self.plugin_infos[index as usize].create_class_info_unicode();\\\\\\\\n\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                unsafe fn set_host_context(&amp;self, _context: *mut vst3_sys::c_void) -&gt; tresult {\\\\\\\\n                    // We don't need to do anything with this\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /// The VST3 plugin factory entry point.\\\\\\\\n        #[no_mangle]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"system\\\\\\\\\\\\\\\" fn GetPluginFactory() -&gt; *mut ::std::ffi::c_void {\\\\\\\\n            let factory = self::vst3::Factory::new();\\\\\\\\n\\\\\\\\n            Box::into_raw(factory) as *mut ::std::ffi::c_void\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // These two entry points are used on Linux, and they would theoretically also be used on\\\\\\\\n        // the BSDs:\\\\\\\\n        // https://github.com/steinbergmedia/vst3_public_sdk/blob/c3948deb407bdbff89de8fb6ab8500ea4df9d6d9/source/main/linuxmain.cpp#L47-L52\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\\n            $crate::wrapper::setup_logger();\\\\\\\\n            true\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleExit() -&gt; bool {\\\\\\\\n            true\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // These two entry points are used on macOS:\\\\\\\\n        // https://github.com/steinbergmedia/vst3_public_sdk/blob/bc459feee68803346737901471441fd4829ec3f9/source/main/macmain.cpp#L60-L61\\\\\\\\n        #[allow(missing_docs)]\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[cfg(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")]\\\\\\\\n        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn bundleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\\n            $crate::wrapper::setup_logger();\\\\\\\\n            true\\\\\\\\n        }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_class_info_unicode(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"                    index: i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"                    info: *mut PClassInfoW,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"                ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"                    *info = self.plugin_infos[index as usize].create_class_info_unicode();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn set_host_context(&amp;self, _context: *mut vst3_sys::c_void) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // We don't need to do anything with this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The VST3 plugin factory entry point.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"system\\\\\\\\\\\\\\\" fn GetPluginFactory() -&gt; *mut ::std::ffi::c_void {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"            let factory = self::vst3::Factory::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"            Box::into_raw(factory) as *mut ::std::ffi::c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"        // These two entry points are used on Linux, and they would theoretically also be used on\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"        // the BSDs:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"        // https://github.com/steinbergmedia/vst3_public_sdk/blob/c3948deb407bdbff89de8fb6ab8500ea4df9d6d9/source/main/linuxmain.cpp#L47-L52\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ModuleExit() -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        // These two entry points are used on macOS:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"        // https://github.com/steinbergmedia/vst3_public_sdk/blob/bc459feee68803346737901471441fd4829ec3f9/source/main/macmain.cpp#L60-L61\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[allow(missing_docs)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn bundleEntry(_lib_handle: *mut ::std::ffi::c_void) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218}]},\\\\\\\"score\\\\\\\":0.5786846876144409},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":24,\\\\\\\"column\\\\\\\":92},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":75,\\\\\\\"column\\\\\\\":30}},\\\\\\\"contents\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\\n        mod vst3 {\\\\\\\\n            use ::std::collections::HashSet;\\\\\\\\n\\\\\\\\n            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\\n            use $crate::wrapper::vst3::{vst3_sys, PluginInfo, Wrapper};\\\\\\\\n            use vst3_sys::base::{kInvalidArgument, kResultOk, tresult};\\\\\\\\n            use vst3_sys::base::{\\\\\\\\n                FactoryFlags, IPluginFactory, IPluginFactory2, IPluginFactory3, IUnknown,\\\\\\\\n                PClassInfo, PClassInfo2, PClassInfoW, PFactoryInfo,\\\\\\\\n            };\\\\\\\\n            use vst3_sys::VST3;\\\\\\\\n\\\\\\\\n            // This alias is needed for the VST3 attribute macro\\\\\\\\n            use vst3_sys as vst3_com;\\\\\\\\n\\\\\\\\n            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\\n            // if the types are not public because this is a child module.\\\\\\\\n            use super::*;\\\\\\\\n\\\\\\\\n            // Sneaky way to get the number of expanded elements\\\\\\\\n            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\\n\\\\\\\\n            #[doc(hidden)]\\\\\\\\n            #[VST3(implements(IPluginFactory, IPluginFactory2, IPluginFactory3))]\\\\\\\\n            pub struct Factory {\\\\\\\\n                // This is a type erased version of the information stored on the plugin types\\\\\\\\n                plugin_infos: [PluginInfo; PLUGIN_COUNT],\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            impl Factory {\\\\\\\\n                pub fn new() -&gt; Box&lt;Self&gt; {\\\\\\\\n                    let plugin_infos = [$(PluginInfo::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\\n\\\\\\\\n                    if cfg!(debug_assertions) {\\\\\\\\n                        let unique_cids: HashSet&lt;[u8; 16]&gt; = plugin_infos.iter().map(|d| *d.cid).collect();\\\\\\\\n                        $crate::nih_debug_assert_eq!(\\\\\\\\n                            unique_cids.len(),\\\\\\\\n                            plugin_infos.len(),\\\\\\\\n                            \\\\\\\\\\\\\\\"Duplicate VST3 class IDs found in &#96;nih_export_vst3!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\\n                        );\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    Self::allocate(plugin_infos)\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            impl IPluginFactory for Factory {\\\\\\\\n                unsafe fn get_factory_info(&amp;self, info: *mut PFactoryInfo) -&gt; tresult {\\\\\\\\n                    if info.is_null() {\\\\\\\\n                        return\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod vst3 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::collections::HashSet;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::vst3::{vst3_sys, PluginInfo, Wrapper};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            use vst3_sys::base::{kInvalidArgument, kResultOk, tresult};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            use vst3_sys::base::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"                FactoryFlags, IPluginFactory, IPluginFactory2, IPluginFactory3, IUnknown,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"                PClassInfo, PClassInfo2, PClassInfoW, PFactoryInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"            use vst3_sys::VST3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"            // This alias is needed for the VST3 attribute macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"            use vst3_sys as vst3_com;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"            // if the types are not public because this is a child module.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            use super::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Sneaky way to get the number of expanded elements\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"            #[VST3(implements(IPluginFactory, IPluginFactory2, IPluginFactory3))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub struct Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"                // This is a type erased version of the information stored on the plugin types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_infos: [PluginInfo; PLUGIN_COUNT],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"            impl Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"                pub fn new() -&gt; Box&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let plugin_infos = [$(PluginInfo::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if cfg!(debug_assertions) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let unique_cids: HashSet&lt;[u8; 16]&gt; = plugin_infos.iter().map(|d| *d.cid).collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        $crate::nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                            unique_cids.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"                            plugin_infos.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                            \\\\\\\\\\\\\\\"Duplicate VST3 class IDs found in &#96;nih_export_vst3!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Self::allocate(plugin_infos)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"            impl IPluginFactory for Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_factory_info(&amp;self, info: *mut PFactoryInfo) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if info.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76}]},\\\\\\\"score\\\\\\\":0.536114513874054},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":29,\\\\\\\"column\\\\\\\":66}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\\nmod util;\\\\\\\\n\\\\\\\\nmod context;\\\\\\\\nmod factory;\\\\\\\\nmod inner;\\\\\\\\nmod note_expressions;\\\\\\\\nmod param_units;\\\\\\\\npub mod subcategories;\\\\\\\\nmod view;\\\\\\\\nmod wrapper;\\\\\\\\n\\\\\\\\n/// Re-export for the wrapper.\\\\\\\\npub use factory::PluginInfo;\\\\\\\\npub use vst3_sys;\\\\\\\\npub use wrapper::Wrapper;\\\\\\\\n\\\\\\\\n/// Export one or more VST3 plugins from this library using the provided plugin types. The first\\\\\\\\n/// plugin's vendor information is used for the factory's information.\\\\\\\\n#[macro_export]\\\\\\\\nmacro_rules! nih_export_vst3 {\\\\\\\\n    ($($plugin_ty:ty),+) =&gt; {\\\\\\\\n        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\\n        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\\n        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\\n        #[doc(hidden)]\\\\\\\\n        mod vst3 {\\\\\\\\n            use ::std::collections::HashSet;\\\\\\\\n\\\\\\\\n            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"mod context;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"mod factory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"mod inner;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod note_expressions;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"mod param_units;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod subcategories;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"mod view;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"mod wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Re-export for the wrapper.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use factory::PluginInfo;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use vst3_sys;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use wrapper::Wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Export one or more VST3 plugins from this library using the provided plugin types. The first\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"/// plugin's vendor information is used for the factory's information.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_export]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! nih_export_vst3 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($($plugin_ty:ty),+) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod vst3 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::collections::HashSet;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"            // &#96;vst3_sys&#96; is imported from the VST3 wrapper module\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30}]},\\\\\\\"score\\\\\\\":0.5304026007652283},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":72,\\\\\\\"column\\\\\\\":16},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":106,\\\\\\\"column\\\\\\\":44}},\\\\\\\"contents\\\\\\\":\\\\\\\" IPluginFactory for Factory {\\\\\\\\n                unsafe fn get_factory_info(&amp;self, info: *mut PFactoryInfo) -&gt; tresult {\\\\\\\\n                    if info.is_null() {\\\\\\\\n                        return kInvalidArgument;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    // We'll use the first plugin's info for this\\\\\\\\n                    *info = self.plugin_infos[0].create_factory_info();\\\\\\\\n\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                unsafe fn count_classes(&amp;self) -&gt; i32 {\\\\\\\\n                    self.plugin_infos.len() as i32\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                unsafe fn get_class_info(&amp;self, index: i32, info: *mut PClassInfo) -&gt; tresult {\\\\\\\\n                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\\n                        return kInvalidArgument;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    *info = self.plugin_infos[index as usize].create_class_info();\\\\\\\\n\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                unsafe fn create_instance(\\\\\\\\n                    &amp;self,\\\\\\\\n                    cid: *const vst3_sys::IID,\\\\\\\\n                    iid: *const vst3_sys::IID,\\\\\\\\n                    obj: *mut *mut vst3_sys::c_void,\\\\\\\\n                ) -&gt; tresult {\\\\\\\\n                    // Can't use &#96;check_null_ptr!()&#96; here without polluting NIH-plug's general\\\\\\\\n                    // exports\\\\\\\\n                    if cid.is_null() || obj.\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" IPluginFactory for Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_factory_info(&amp;self, info: *mut PFactoryInfo) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if info.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // We'll use the first plugin's info for this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                    *info = self.plugin_infos[0].create_factory_info();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn count_classes(&amp;self) -&gt; i32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"                    self.plugin_infos.len() as i32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_class_info(&amp;self, index: i32, info: *mut PClassInfo) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                    *info = self.plugin_infos[index as usize].create_class_info();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn create_instance(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    cid: *const vst3_sys::IID,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                    iid: *const vst3_sys::IID,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                    obj: *mut *mut vst3_sys::c_void,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"                ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Can't use &#96;check_null_ptr!()&#96; here without polluting NIH-plug's general\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // exports\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if cid.is_null() || obj.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107}]},\\\\\\\"score\\\\\\\":0.5208902955055237},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/factory.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":31,\\\\\\\"column\\\\\\\":25},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":77,\\\\\\\"column\\\\\\\":26}},\\\\\\\"contents\\\\\\\":\\\\\\\",\\\\\\\\n    pub email: &amp;'static str,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginInfo {\\\\\\\\n    pub fn for_plugin&lt;P: Vst3Plugin&gt;() -&gt; PluginInfo {\\\\\\\\n        PluginInfo {\\\\\\\\n            cid: &amp;P::PLATFORM_VST3_CLASS_ID,\\\\\\\\n            name: P::NAME,\\\\\\\\n            subcategories: make_subcategories_string::&lt;P&gt;(),\\\\\\\\n            vendor: P::VENDOR,\\\\\\\\n            version: P::VERSION,\\\\\\\\n            url: P::URL,\\\\\\\\n            email: P::EMAIL,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PFactoryInfo&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory&#96;.\\\\\\\\n    pub fn create_factory_info(&amp;self) -&gt; PFactoryInfo {\\\\\\\\n        let mut info: PFactoryInfo = unsafe { std::mem::zeroed() };\\\\\\\\n        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        strlcpy(&amp;mut info.url, self.url);\\\\\\\\n        strlcpy(&amp;mut info.email, self.email);\\\\\\\\n        info.flags = FactoryFlags::kUnicode as i32;\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfo&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory&#96;.\\\\\\\\n    pub fn create_class_info(&amp;self) -&gt; PClassInfo {\\\\\\\\n        let mut info: PClassInfo = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        strlcpy(&amp;mut info.name, self.name);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfo2&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory2&#96;.\\\\\\\\n    pub fn create_class_info_2(&amp;self) -&gt; PClassInfo2 {\\\\\\\\n        let mut info: PClassInfo2 = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub email: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn for_plugin&lt;P: Vst3Plugin&gt;() -&gt; PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"        PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"            cid: &amp;P::PLATFORM_VST3_CLASS_ID,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"            name: P::NAME,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"            subcategories: make_subcategories_string::&lt;P&gt;(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"            vendor: P::VENDOR,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"            version: P::VERSION,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            url: P::URL,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"            email: P::EMAIL,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill a [&#96;PFactoryInfo&#96;] struct with the information from this library. Used in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn create_factory_info(&amp;self) -&gt; PFactoryInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut info: PFactoryInfo = unsafe { std::mem::zeroed() };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.url, self.url);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.email, self.email);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.flags = FactoryFlags::kUnicode as i32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"        info\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill a [&#96;PClassInfo&#96;] struct with the information from this library. Used in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn create_class_info(&amp;self) -&gt; PClassInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut info: PClassInfo = unsafe { std::mem::zeroed() };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cid.data = *self.cid;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.name, self.name);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"        info\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill a [&#96;PClassInfo2&#96;] struct with the information from this library. Used in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory2&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn create_class_info_2(&amp;self) -&gt; PClassInfo2 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut info: PClassInfo2 = unsafe { std::mem::zeroed() };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cid.data = *self.cid;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cardinality =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78}]},\\\\\\\"score\\\\\\\":0.49016785621643066},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/factory.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":35,\\\\\\\"column\\\\\\\":15}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Utilities for building a VST3 factory.\\\\\\\\n//!\\\\\\\\n//! In order to support exporting multiple VST3 plugins from a single library a lot of functionality\\\\\\\\n//! had to be moved to the &#96;nih_export_vst3!()&#96; macro. Because working in macro-land can be both\\\\\\\\n//! frustrating and error prone, most code that does not specifically depend on all of the exposed\\\\\\\\n//! plugin types was moved back to this module so it can be compiled and type checked as normal.\\\\\\\\n\\\\\\\\nuse vst3_sys::base::{\\\\\\\\n    ClassCardinality, FactoryFlags, PClassInfo, PClassInfo2, PClassInfoW, PFactoryInfo,\\\\\\\\n};\\\\\\\\n\\\\\\\\nuse super::subcategories::Vst3SubCategory;\\\\\\\\nuse crate::prelude::Vst3Plugin;\\\\\\\\nuse crate::wrapper::util::strlcpy;\\\\\\\\nuse crate::wrapper::vst3::util::u16strlcpy;\\\\\\\\n\\\\\\\\n/// The VST3 SDK version this is roughly based on. The bindings include some VST 3.7 things but not\\\\\\\\n/// everything, so we'll play it safe.\\\\\\\\npub const VST3_SDK_VERSION: &amp;str = \\\\\\\\\\\\\\\"VST 3.6.14\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n/// The information queried about a plugin through the &#96;IPluginFactory*&#96; methods. Stored in a\\\\\\\\n/// separate struct so it can be type erased and stored in an array.\\\\\\\\n#[derive(Debug)]\\\\\\\\npub struct PluginInfo {\\\\\\\\n    pub cid: &amp;'static [u8; 16],\\\\\\\\n    pub name: &amp;'static str,\\\\\\\\n    pub subcategories: String,\\\\\\\\n    pub vendor: &amp;'static str,\\\\\\\\n    pub version: &amp;'static str,\\\\\\\\n\\\\\\\\n    // These are used for the factory's own info struct\\\\\\\\n    pub url: &amp;'static str,\\\\\\\\n    pub email: &amp;'static str,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl PluginInfo\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Utilities for building a VST3 factory.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//!\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"//! In order to support exporting multiple VST3 plugins from a single library a lot of functionality\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"//! had to be moved to the &#96;nih_export_vst3!()&#96; macro. Because working in macro-land can be both\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"//! frustrating and error prone, most code that does not specifically depend on all of the exposed\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"//! plugin types was moved back to this module so it can be compiled and type checked as normal.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::base::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    ClassCardinality, FactoryFlags, PClassInfo, PClassInfo2, PClassInfoW, PFactoryInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::subcategories::Vst3SubCategory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::Vst3Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::util::strlcpy;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::vst3::util::u16strlcpy;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The VST3 SDK version this is roughly based on. The bindings include some VST 3.7 things but not\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// everything, so we'll play it safe.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"pub const VST3_SDK_VERSION: &amp;str = \\\\\\\\\\\\\\\"VST 3.6.14\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The information queried about a plugin through the &#96;IPluginFactory*&#96; methods. Stored in a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// separate struct so it can be type erased and stored in an array.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct PluginInfo {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub cid: &amp;'static [u8; 16],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub name: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub subcategories: String,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub vendor: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub version: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    // These are used for the factory's own info struct\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub url: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub email: &amp;'static str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"impl PluginInfo\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36}]},\\\\\\\"score\\\\\\\":0.4889678955078125},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":27,\\\\\\\"column\\\\\\\":46}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\\nmod util;\\\\\\\\n\\\\\\\\nmod context;\\\\\\\\nmod descriptor;\\\\\\\\npub mod features;\\\\\\\\nmod wrapper;\\\\\\\\n\\\\\\\\n/// Re-export for the macro\\\\\\\\npub use self::descriptor::PluginDescriptor;\\\\\\\\npub use self::wrapper::Wrapper;\\\\\\\\npub use clap_sys::entry::clap_plugin_entry;\\\\\\\\npub use clap_sys::factory::plugin_factory::{clap_plugin_factory, CLAP_PLUGIN_FACTORY_ID};\\\\\\\\npub use clap_sys::host::clap_host;\\\\\\\\npub use clap_sys::plugin::{clap_plugin, clap_plugin_descriptor};\\\\\\\\npub use clap_sys::version::CLAP_VERSION;\\\\\\\\n\\\\\\\\n/// Export one or more CLAP plugins from this library using the provided plugin types.\\\\\\\\n#[macro_export]\\\\\\\\nmacro_rules! nih_export_clap {\\\\\\\\n    ($($plugin_ty:ty),+) =&gt; {\\\\\\\\n        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\\n        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\\n        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\\n        #[doc(hidden)]\\\\\\\\n        mod clap {\\\\\\\\n            use $crate::prelude::nih_debug_assert_eq;\\\\\\\\n            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_use]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"mod context;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"mod descriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod features;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"mod wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Re-export for the macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use self::descriptor::PluginDescriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use self::wrapper::Wrapper;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::entry::clap_plugin_entry;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::factory::plugin_factory::{clap_plugin_factory, CLAP_PLUGIN_FACTORY_ID};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::host::clap_host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::plugin::{clap_plugin, clap_plugin_descriptor};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use clap_sys::version::CLAP_VERSION;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Export one or more CLAP plugins from this library using the provided plugin types.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"#[macro_export]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"macro_rules! nih_export_clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"    ($($plugin_ty:ty),+) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Earlier versions used a simple generic struct for this, but because we don't have\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"        // variadic generics (yet) we can't generate the struct for multiple plugin types without\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"        // macros. So instead we'll generate the implementation ad-hoc inside of this macro.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::prelude::nih_debug_assert_eq;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28}]},\\\\\\\"score\\\\\\\":0.46271058917045593},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":23,\\\\\\\"column\\\\\\\":92},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":53,\\\\\\\"column\\\\\\\":37}},\\\\\\\"contents\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\\n        mod clap {\\\\\\\\n            use $crate::prelude::nih_debug_assert_eq;\\\\\\\\n            use $crate::wrapper::setup_logger;\\\\\\\\n            use $crate::wrapper::clap::{PluginDescriptor, Wrapper};\\\\\\\\n            use $crate::wrapper::clap::{CLAP_PLUGIN_FACTORY_ID, clap_host, clap_plugin, clap_plugin_descriptor, clap_plugin_factory};\\\\\\\\n            use ::std::collections::HashSet;\\\\\\\\n            use ::std::ffi::{CStr, c_void};\\\\\\\\n            use ::std::os::raw::c_char;\\\\\\\\n            use ::std::sync::{Arc, OnceLock};\\\\\\\\n\\\\\\\\n            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\\n            // if the types are not public because this is a child module.\\\\\\\\n            use super::*;\\\\\\\\n\\\\\\\\n            const CLAP_PLUGIN_FACTORY: clap_plugin_factory = clap_plugin_factory {\\\\\\\\n                get_plugin_count: Some(get_plugin_count),\\\\\\\\n                get_plugin_descriptor: Some(get_plugin_descriptor),\\\\\\\\n                create_plugin: Some(create_plugin),\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            // Sneaky way to get the number of expanded elements\\\\\\\\n            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\\n\\\\\\\\n            // This is a type erased version of the information stored on the plugin types\\\\\\\\n            static PLUGIN_DESCRIPTORS: OnceLock&lt;[PluginDescriptor; PLUGIN_COUNT]&gt; = OnceLock::new();\\\\\\\\n\\\\\\\\n            fn plugin_descriptors() -&gt; &amp;'static [PluginDescriptor; PLUGIN_COUNT] {\\\\\\\\n                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\\n                    let descriptors =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        #[doc(hidden)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"        mod clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::prelude::nih_debug_assert_eq;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::clap::{PluginDescriptor, Wrapper};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"            use $crate::wrapper::clap::{CLAP_PLUGIN_FACTORY_ID, clap_host, clap_plugin, clap_plugin_descriptor, clap_plugin_factory};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::collections::HashSet;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::ffi::{CStr, c_void};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::os::raw::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"            use ::std::sync::{Arc, OnceLock};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Because the &#96;$plugin_ty&#96;s are likely defined in the enclosing scope. This works even\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"            // if the types are not public because this is a child module.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"            use super::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"            const CLAP_PLUGIN_FACTORY: clap_plugin_factory = clap_plugin_factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_plugin_count: Some(get_plugin_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_plugin_descriptor: Some(get_plugin_descriptor),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"                create_plugin: Some(create_plugin),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Sneaky way to get the number of expanded elements\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"            const PLUGIN_COUNT: usize = [$(stringify!($plugin_ty)),+].len();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"            // This is a type erased version of the information stored on the plugin types\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"            static PLUGIN_DESCRIPTORS: OnceLock&lt;[PluginDescriptor; PLUGIN_COUNT]&gt; = OnceLock::new();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"            fn plugin_descriptors() -&gt; &amp;'static [PluginDescriptor; PLUGIN_COUNT] {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptors =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54}]},\\\\\\\"score\\\\\\\":0.453803688287735},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":51,\\\\\\\"column\\\\\\\":80},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89,\\\\\\\"column\\\\\\\":17}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\\n                    let descriptors = [$(PluginDescriptor::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\\n\\\\\\\\n                    if cfg!(debug_assertions) {\\\\\\\\n                        let unique_plugin_ids: HashSet&lt;_&gt; = descriptors.iter().map(|d| d.clap_id()).collect();\\\\\\\\n                        nih_debug_assert_eq!(\\\\\\\\n                            unique_plugin_ids.len(),\\\\\\\\n                            descriptors.len(),\\\\\\\\n                            \\\\\\\\\\\\\\\"Duplicate plugin IDs found in &#96;nih_export_clap!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\\n                        );\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    descriptors\\\\\\\\n                })\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_count(_factory: *const clap_plugin_factory) -&gt; u32 {\\\\\\\\n                plugin_descriptors().len() as u32\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_descriptor (\\\\\\\\n                _factory: *const clap_plugin_factory,\\\\\\\\n                index: u32,\\\\\\\\n            ) -&gt; *const clap_plugin_descriptor  {\\\\\\\\n                match plugin_descriptors().get(index as usize) {\\\\\\\\n                    Some(descriptor) =&gt; descriptor.clap_plugin_descriptor(),\\\\\\\\n                    None =&gt; ::std::ptr::null()\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn create_plugin (\\\\\\\\n                _factory: *const clap_plugin_factory,\\\\\\\\n                host: *const clap_host,\\\\\\\\n                plugin_id: *const c_char,\\\\\\\\n            ) -&gt; *const clap_plugin  {\\\\\\\\n                if plugin_id.is_null() {\\\\\\\\n                    return ::std::ptr::null();\\\\\\\\n                }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"                PLUGIN_DESCRIPTORS.get_or_init(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptors = [$(PluginDescriptor::for_plugin::&lt;$plugin_ty&gt;()),+];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if cfg!(debug_assertions) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let unique_plugin_ids: HashSet&lt;_&gt; = descriptors.iter().map(|d| d.clap_id()).collect();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"                        nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"                            unique_plugin_ids.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"                            descriptors.len(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"                            \\\\\\\\\\\\\\\"Duplicate plugin IDs found in &#96;nih_export_clap!()&#96; call\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"                        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"                    descriptors\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"                })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_count(_factory: *const clap_plugin_factory) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_descriptors().len() as u32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_plugin_descriptor (\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"                _factory: *const clap_plugin_factory,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"                index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"            ) -&gt; *const clap_plugin_descriptor  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"                match plugin_descriptors().get(index as usize) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Some(descriptor) =&gt; descriptor.clap_plugin_descriptor(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"                    None =&gt; ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"            unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn create_plugin (\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"                _factory: *const clap_plugin_factory,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"                host: *const clap_host,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"                plugin_id: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"            ) -&gt; *const clap_plugin  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                if plugin_id.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return ::std::ptr::null();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90}]},\\\\\\\"score\\\\\\\":0.441611647605896},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":126,\\\\\\\"column\\\\\\\":50},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":164,\\\\\\\"column\\\\\\\":31}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                                // This is a bit awkward now but if the cast succeeds we need to get\\\\\\\\n                                // rid of the reference from the &#96;wrapper&#96; binding. The VST3 query\\\\\\\\n                                // interface always increments the reference count and returns an\\\\\\\\n                                // owned reference, so we need to explicitly release the reference\\\\\\\\n                                // from &#96;wrapper&#96; and leak the &#96;Box&#96; so the wrapper doesn't\\\\\\\\n                                // automatically get deallocated when this function returns (&#96;Box&#96;\\\\\\\\n                                // is an incorrect choice on vst3-sys' part, it should have used a\\\\\\\\n                                // &#96;VstPtr&#96; instead).\\\\\\\\n                                wrapper.release();\\\\\\\\n                                Box::leak(wrapper);\\\\\\\\n\\\\\\\\n                                return kResultOk;\\\\\\\\n                            }\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        plugin_idx += 1;\\\\\\\\n                    })+\\\\\\\\n\\\\\\\\n                    kInvalidArgument\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            impl IPluginFactory2 for Factory {\\\\\\\\n                unsafe fn get_class_info2(&amp;self, index: i32, info: *mut PClassInfo2) -&gt; tresult {\\\\\\\\n                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\\n                        return kInvalidArgument;\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    *info = self.plugin_infos[index as usize].create_class_info_2();\\\\\\\\n\\\\\\\\n                    kResultOk\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            impl IPluginFactory3 for Factory {\\\\\\\\n                unsafe fn get_class_info_unicode(\\\\\\\\n                    &amp;self,\\\\\\\\n                    index: i32,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // This is a bit awkward now but if the cast succeeds we need to get\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // rid of the reference from the &#96;wrapper&#96; binding. The VST3 query\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // interface always increments the reference count and returns an\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // owned reference, so we need to explicitly release the reference\\\\\\\",\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // from &#96;wrapper&#96; and leak the &#96;Box&#96; so the wrapper doesn't\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // automatically get deallocated when this function returns (&#96;Box&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // is an incorrect choice on vst3-sys' part, it should have used a\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // &#96;VstPtr&#96; instead).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"                                wrapper.release();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"                                Box::leak(wrapper);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"                                return kResultOk;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"                        plugin_idx += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"                    })+\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kInvalidArgument\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"            impl IPluginFactory2 for Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_class_info2(&amp;self, index: i32, info: *mut PClassInfo2) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if index &lt; 0 || index &gt;= self.plugin_infos.len() as i32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"                    *info = self.plugin_infos[index as usize].create_class_info_2();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"                    kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"            impl IPluginFactory3 for Factory {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe fn get_class_info_unicode(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"                    index: i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165}]},\\\\\\\"score\\\\\\\":0.4291621446609497},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/factory.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":74,\\\\\\\"column\\\\\\\":52},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":110,\\\\\\\"column\\\\\\\":63}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        let mut info: PClassInfo2 = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        strlcpy(&amp;mut info.name, self.name);\\\\\\\\n        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\\n        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\\n        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        strlcpy(&amp;mut info.version, self.version);\\\\\\\\n        strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Fill a [&#96;PClassInfoW&#96;] struct with the information from this library. Used in\\\\\\\\n    /// &#96;IPluginFactory3&#96;.\\\\\\\\n    pub fn create_class_info_unicode(&amp;self) -&gt; PClassInfoW {\\\\\\\\n        let mut info: PClassInfoW = unsafe { std::mem::zeroed() };\\\\\\\\n        info.cid.data = *self.cid;\\\\\\\\n        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\\n        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\\n        u16strlcpy(&amp;mut info.name, self.name);\\\\\\\\n        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\\n        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\\n        u16strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\\n        u16strlcpy(&amp;mut info.version, self.version);\\\\\\\\n        u16strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\\n\\\\\\\\n        info\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Build a pipe separated subcategories string for a VST3 plugin.\\\\\\\\nfn make_subcategories_string&lt;P: Vst3Plugin&gt;() -&gt; String {\\\\\\\\n    // No idea if any hosts do something with OnlyRT, but it's part of VST3's example categories\\\\\\\\n    // list. Plugins should not be adding this feature manually\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut info: PClassInfo2 = unsafe { std::mem::zeroed() };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cid.data = *self.cid;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.name, self.name);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.version, self.version);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"        info\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Fill a [&#96;PClassInfoW&#96;] struct with the information from this library. Used in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;IPluginFactory3&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn create_class_info_unicode(&amp;self) -&gt; PClassInfoW {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut info: PClassInfoW = unsafe { std::mem::zeroed() };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cid.data = *self.cid;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.cardinality = ClassCardinality::kManyInstances as i32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.category, \\\\\\\\\\\\\\\"Audio Module Class\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"        u16strlcpy(&amp;mut info.name, self.name);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"        info.class_flags = 1 &lt;&lt; 1; // kSimpleModeSupported\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut info.subcategories, &amp;self.subcategories);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"        u16strlcpy(&amp;mut info.vendor, self.vendor);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"        u16strlcpy(&amp;mut info.version, self.version);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"        u16strlcpy(&amp;mut info.sdk_version, VST3_SDK_VERSION);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"        info\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Build a pipe separated subcategories string for a VST3 plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"fn make_subcategories_string&lt;P: Vst3Plugin&gt;() -&gt; String {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    // No idea if any hosts do something with OnlyRT, but it's part of VST3's example categories\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    // list. Plugins should not be adding this feature manually\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111}]},\\\\\\\"score\\\\\\\":0.42868080735206604},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":86,\\\\\\\"column\\\\\\\":18},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":136,\\\\\\\"column\\\\\\\":53}},\\\\\\\"contents\\\\\\\":\\\\\\\"const clap_plugin  {\\\\\\\\n                if plugin_id.is_null() {\\\\\\\\n                    return ::std::ptr::null();\\\\\\\\n                }\\\\\\\\n                let plugin_id_cstr = CStr::from_ptr(plugin_id);\\\\\\\\n\\\\\\\\n                // This isn't great, but we'll just assume that &#96;$plugin_ids&#96; and the descriptors\\\\\\\\n                // are in the same order. We also can't directly enumerate over them with an index,\\\\\\\\n                // which is why we do things the way we do. Otherwise we could have used a tuple\\\\\\\\n                // instead.\\\\\\\\n                let descriptors = plugin_descriptors();\\\\\\\\n                let mut descriptor_idx = 0;\\\\\\\\n                $({\\\\\\\\n                    let descriptor = &amp;descriptors[descriptor_idx];\\\\\\\\n                    if plugin_id_cstr == descriptor.clap_id() {\\\\\\\\n                        // Arc does not have a convenient leak function like Box, so this gets a bit awkward\\\\\\\\n                        // This pointer gets turned into an Arc and its reference count decremented in\\\\\\\\n                        // [Wrapper::destroy()]\\\\\\\\n                        return (*Arc::into_raw(Wrapper::&lt;$plugin_ty&gt;::new(host)))\\\\\\\\n                            .clap_plugin\\\\\\\\n                            .as_ptr();\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    descriptor_idx += 1;\\\\\\\\n                })+\\\\\\\\n\\\\\\\\n                ::std::ptr::null()\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(_plugin_path: *const c_char) -&gt; bool {\\\\\\\\n                setup_logger();\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deinit() {}\\\\\\\\n\\\\\\\\n            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_factory(factory_id: *const c_char) -&gt; *const c_void {\\\\\\\\n                if !factory_id.is_null() &amp;&amp; unsafe { CStr::from_ptr(factory_id) } == CLAP_PLUGIN_FACTORY_ID {\\\\\\\\n                    &amp;CLAP_PLUGIN_FACTORY as *const _ as *const c_void\\\\\\\\n                } else {\\\\\\\\n                    ::std::ptr::null()\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        /// The CLAP plugin's entry point.\\\\\\\\n        #[no_mangle]\\\\\\\\n        #[used]\\\\\\\\n        pub static clap_entry: $crate::wrapper::clap::clap_plugin_entry =\\\\\\\\n            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\\n                clap_version: $crate::wrapper::clap::\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"const clap_plugin  {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"                if plugin_id.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return ::std::ptr::null();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"                let plugin_id_cstr = CStr::from_ptr(plugin_id);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"                // This isn't great, but we'll just assume that &#96;$plugin_ids&#96; and the descriptors\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"                // are in the same order. We also can't directly enumerate over them with an index,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"                // which is why we do things the way we do. Otherwise we could have used a tuple\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"                // instead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"                let descriptors = plugin_descriptors();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"                let mut descriptor_idx = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"                $({\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let descriptor = &amp;descriptors[descriptor_idx];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if plugin_id_cstr == descriptor.clap_id() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // Arc does not have a convenient leak function like Box, so this gets a bit awkward\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // This pointer gets turned into an Arc and its reference count decremented in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // [Wrapper::destroy()]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return (*Arc::into_raw(Wrapper::&lt;$plugin_ty&gt;::new(host)))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .clap_plugin\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .as_ptr();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"                    descriptor_idx += 1;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"                })+\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"                ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"lineNumber\\\\\\\":115},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(_plugin_path: *const c_char) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":116},{\\\\\\\"text\\\\\\\":\\\\\\\"                setup_logger();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":117},{\\\\\\\"text\\\\\\\":\\\\\\\"                true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":118},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":119},{\\\\\\\"lineNumber\\\\\\\":120},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deinit() {}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":121},{\\\\\\\"lineNumber\\\\\\\":122},{\\\\\\\"text\\\\\\\":\\\\\\\"            pub extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_factory(factory_id: *const c_char) -&gt; *const c_void {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":123},{\\\\\\\"text\\\\\\\":\\\\\\\"                if !factory_id.is_null() &amp;&amp; unsafe { CStr::from_ptr(factory_id) } == CLAP_PLUGIN_FACTORY_ID {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":124},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;CLAP_PLUGIN_FACTORY as *const _ as *const c_void\\\\\\\",\\\\\\\"lineNumber\\\\\\\":125},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":126},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ::std::ptr::null()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":127},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":128},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":129},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":130},{\\\\\\\"lineNumber\\\\\\\":131},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The CLAP plugin's entry point.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[no_mangle]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[used]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"        pub static clap_entry: $crate::wrapper::clap::clap_plugin_entry =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"                clap_version: $crate::wrapper::clap::\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137}]},\\\\\\\"score\\\\\\\":0.42547568678855896},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/plugin/vst3.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":42,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"use super::Plugin;\\\\\\\\nuse crate::prelude::Vst3SubCategory;\\\\\\\\n\\\\\\\\n/// Provides auxiliary metadata needed for a VST3 plugin.\\\\\\\\npub trait Vst3Plugin: Plugin {\\\\\\\\n    /// The unique class ID that identifies this particular plugin. You can use the\\\\\\\\n    /// &#96;*b\\\\\\\\\\\\\\\"fooofooofooofooo\\\\\\\\\\\\\\\"&#96; syntax for this.\\\\\\\\n    ///\\\\\\\\n    /// This will be shuffled into a different byte order on Windows for project-compatibility.\\\\\\\\n    const VST3_CLASS_ID: [u8; 16];\\\\\\\\n    /// One or more subcategories. The host may use these to categorize the plugin. Internally this\\\\\\\\n    /// slice will be converted to a string where each character is separated by a pipe character\\\\\\\\n    /// (&#96;|&#96;). This string has a limit of 127 characters, and anything longer than that will be\\\\\\\\n    /// truncated.\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory];\\\\\\\\n\\\\\\\\n    /// [&#96;VST3_CLASS_ID&#96;][Self::VST3_CLASS_ID&#96;] in the correct order for the current platform so\\\\\\\\n    /// projects and presets can be shared between platforms. This should not be overridden.\\\\\\\\n    const PLATFORM_VST3_CLASS_ID: [u8; 16] = swap_vst3_uid_byte_order(Self::VST3_CLASS_ID);\\\\\\\\n}\\\\\\\\n\\\\\\\\n#[cfg(not(target_os = \\\\\\\\\\\\\\\"windows\\\\\\\\\\\\\\\"))]\\\\\\\\nconst fn swap_vst3_uid_byte_order(uid: [u8; 16]) -&gt; [u8; 16] {\\\\\\\\n    uid\\\\\\\\n}\\\\\\\\n\\\\\\\\n#[cfg(target_os = \\\\\\\\\\\\\\\"windows\\\\\\\\\\\\\\\")]\\\\\\\\nconst fn swap_vst3_uid_byte_order(mut uid: [u8; 16]) -&gt; [u8; 16] {\\\\\\\\n    // No mutable references in const functions, so we can't use &#96;uid.swap()&#96;\\\\\\\\n    let original_uid = uid;\\\\\\\\n\\\\\\\\n    uid[0] = original_uid[3];\\\\\\\\n    uid[1] = original_uid[2];\\\\\\\\n    uid[2] = original_uid[1];\\\\\\\\n    uid[3] = original_uid[0];\\\\\\\\n\\\\\\\\n    uid[4] = original_uid[5];\\\\\\\\n    uid[5] = original_uid[4];\\\\\\\\n    uid[6] = original_uid[7];\\\\\\\\n    uid[7] = original_uid[6];\\\\\\\\n\\\\\\\\n    uid\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use super::Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::Vst3SubCategory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Provides auxiliary metadata needed for a VST3 plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"pub trait Vst3Plugin: Plugin {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The unique class ID that identifies this particular plugin. You can use the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;*b\\\\\\\\\\\\\\\"fooofooofooofooo\\\\\\\\\\\\\\\"&#96; syntax for this.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// This will be shuffled into a different byte order on Windows for project-compatibility.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// One or more subcategories. The host may use these to categorize the plugin. Internally this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// slice will be converted to a string where each character is separated by a pipe character\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// (&#96;|&#96;). This string has a limit of 127 characters, and anything longer than that will be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// truncated.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// [&#96;VST3_CLASS_ID&#96;][Self::VST3_CLASS_ID&#96;] in the correct order for the current platform so\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// projects and presets can be shared between platforms. This should not be overridden.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"    const PLATFORM_VST3_CLASS_ID: [u8; 16] = swap_vst3_uid_byte_order(Self::VST3_CLASS_ID);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(not(target_os = \\\\\\\\\\\\\\\"windows\\\\\\\\\\\\\\\"))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"const fn swap_vst3_uid_byte_order(uid: [u8; 16]) -&gt; [u8; 16] {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(target_os = \\\\\\\\\\\\\\\"windows\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"const fn swap_vst3_uid_byte_order(mut uid: [u8; 16]) -&gt; [u8; 16] {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"    // No mutable references in const functions, so we can't use &#96;uid.swap()&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    let original_uid = uid;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[0] = original_uid[3];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[1] = original_uid[2];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[2] = original_uid[1];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[3] = original_uid[0];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[4] = original_uid[5];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[5] = original_uid[4];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[6] = original_uid[7];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid[7] = original_uid[6];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    uid\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43}]},\\\\\\\"score\\\\\\\":0.4214582145214081},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":134,\\\\\\\"column\\\\\\\":39},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":142,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"wrapper::clap::clap_plugin_entry =\\\\\\\\n            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\\n                clap_version: $crate::wrapper::clap::CLAP_VERSION,\\\\\\\\n                init: Some(self::clap::init),\\\\\\\\n                deinit: Some(self::clap::deinit),\\\\\\\\n                get_factory: Some(self::clap::get_factory),\\\\\\\\n            };\\\\\\\\n    };\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"wrapper::clap::clap_plugin_entry =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"text\\\\\\\":\\\\\\\"            $crate::wrapper::clap::clap_plugin_entry {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"                clap_version: $crate::wrapper::clap::CLAP_VERSION,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"                init: Some(self::clap::init),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"                deinit: Some(self::clap::deinit),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"text\\\\\\\":\\\\\\\"                get_factory: Some(self::clap::get_factory),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143}]},\\\\\\\"score\\\\\\\":0.40958189964294434},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":54,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\\nuse std::ffi::c_void;\\\\\\\\nuse std::mem::{self, MaybeUninit};\\\\\\\\nuse std::num::NonZeroU32;\\\\\\\\nuse std::ptr::NonNull;\\\\\\\\nuse std::sync::atomic::Ordering;\\\\\\\\nuse std::sync::Arc;\\\\\\\\nuse vst3_com::vst::{DataEvent, IProcessContextRequirementsFlags, ProcessModes};\\\\\\\\nuse vst3_sys::base::{kInvalidArgument, kNoInterface, kResultFalse, kResultOk, tresult, TBool};\\\\\\\\nuse vst3_sys::base::{IBStream, IPluginBase};\\\\\\\\nuse vst3_sys::utils::SharedVstPtr;\\\\\\\\nuse vst3_sys::vst::{\\\\\\\\n    kNoParamId, kNoParentUnitId, kNoProgramListId, kRootUnitId, Event, EventTypes, IAudioProcessor,\\\\\\\\n    IComponent, IEditController, IEventList, IMidiMapping, INoteExpressionController,\\\\\\\\n    IParamValueQueue, IParameterChanges, IProcessContextRequirements, IUnitInfo,\\\\\\\\n    LegacyMidiCCOutEvent, NoteExpressionTypeInfo, NoteExpressionValueDescription, NoteOffEvent,\\\\\\\\n    NoteOnEvent, ParameterFlags, PolyPressureEvent, ProgramListInfo, TChar, UnitInfo,\\\\\\\\n};\\\\\\\\nuse vst3_sys::VST3;\\\\\\\\nuse widestring::U16CStr;\\\\\\\\n\\\\\\\\nuse super::inner::{ProcessEvent, WrapperInner};\\\\\\\\nuse super::note_expressions::{self, NoteExpressionController};\\\\\\\\nuse super::util::{\\\\\\\\n    u16strlcpy, VstPtr, VST3_MIDI_CCS, VST3_MIDI_NUM_PARAMS, VST3_MIDI_PARAMS_START,\\\\\\\\n};\\\\\\\\nuse super::util::{VST3_MIDI_CHANNELS, VST3_MIDI_PARAMS_END};\\\\\\\\nuse super::view::WrapperView;\\\\\\\\nuse crate::prelude::{\\\\\\\\n    AuxiliaryBuffers, BufferConfig, MidiConfig, NoteEvent, ParamFlags, ProcessMode, ProcessStatus,\\\\\\\\n    SysExMessage, Transport, Vst3Plugin,\\\\\\\\n};\\\\\\\\nuse crate::util::permit_alloc;\\\\\\\\nuse crate::wrapper::state;\\\\\\\\nuse crate::wrapper::util::buffer_management::{BufferManager, ChannelPointers};\\\\\\\\nuse crate::wrapper::util::{clamp_input_event_timing, clamp_output_event_timing, process_wrapper};\\\\\\\\n\\\\\\\\n// Alias needed for the VST3 attribute macro\\\\\\\\nuse vst3_sys as vst3_com;\\\\\\\\n\\\\\\\\n#[VST3(implements(\\\\\\\\n    IComponent,\\\\\\\\n    IEditController,\\\\\\\\n    IAudioProcessor,\\\\\\\\n    IMidiMapping,\\\\\\\\n    INoteExpressionController,\\\\\\\\n    IProcessContextRequirements,\\\\\\\\n    IUnitInfo\\\\\\\\n))]\\\\\\\\npub struct Wrapper&lt;P: Vst3Plugin&gt; {\\\\\\\\n    inner: Arc&lt;WrapperInner&lt;P&gt;&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    pub fn new() -&gt; Box&lt;Self&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::c_void;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::mem::{self, MaybeUninit};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ptr::NonNull;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::atomic::Ordering;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::Arc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_com::vst::{DataEvent, IProcessContextRequirementsFlags, ProcessModes};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::base::{kInvalidArgument, kNoInterface, kResultFalse, kResultOk, tresult, TBool};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::base::{IBStream, IPluginBase};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::utils::SharedVstPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::vst::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"    kNoParamId, kNoParentUnitId, kNoProgramListId, kRootUnitId, Event, EventTypes, IAudioProcessor,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    IComponent, IEditController, IEventList, IMidiMapping, INoteExpressionController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    IParamValueQueue, IParameterChanges, IProcessContextRequirements, IUnitInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"    LegacyMidiCCOutEvent, NoteExpressionTypeInfo, NoteExpressionValueDescription, NoteOffEvent,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    NoteOnEvent, ParameterFlags, PolyPressureEvent, ProgramListInfo, TChar, UnitInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::VST3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"use widestring::U16CStr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::inner::{ProcessEvent, WrapperInner};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::note_expressions::{self, NoteExpressionController};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    u16strlcpy, VstPtr, VST3_MIDI_CCS, VST3_MIDI_NUM_PARAMS, VST3_MIDI_PARAMS_START,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::{VST3_MIDI_CHANNELS, VST3_MIDI_PARAMS_END};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::view::WrapperView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    AuxiliaryBuffers, BufferConfig, MidiConfig, NoteEvent, ParamFlags, ProcessMode, ProcessStatus,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    SysExMessage, Transport, Vst3Plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::util::permit_alloc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::state;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::util::buffer_management::{BufferManager, ChannelPointers};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::util::{clamp_input_event_timing, clamp_output_event_timing, process_wrapper};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"// Alias needed for the VST3 attribute macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys as vst3_com;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"#[VST3(implements(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    IComponent,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"    IEditController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    IAudioProcessor,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    IMidiMapping,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    INoteExpressionController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    IProcessContextRequirements,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    IUnitInfo\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct Wrapper&lt;P: Vst3Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    inner: Arc&lt;WrapperInner&lt;P&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new() -&gt; Box&lt;Self&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55}]},\\\\\\\"score\\\\\\\":0.40726375579833984},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/nih_plug_xtask/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":387,\\\\\\\"column\\\\\\\":64},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":431,\\\\\\\"column\\\\\\\":38}},\\\\\\\"contents\\\\\\\":\\\\\\\"    eprintln!(\\\\\\\\n        \\\\\\\\\\\\\\\"Created a standalone bundle at '{}'\\\\\\\\\\\\\\\",\\\\\\\\n        standalone_bundle_home.display()\\\\\\\\n    );\\\\\\\\n\\\\\\\\n    Ok(())\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Bundle all plugin targets for a plugin library. If &#96;lib_path&#96; contains more than one path, then\\\\\\\\n/// the libraries will be combined into a single library using a method that depends on the\\\\\\\\n/// compilation target. For universal macOS builds this uses lipo.\\\\\\\\nfn bundle_plugin(\\\\\\\\n    target_dir: &amp;Path,\\\\\\\\n    package: &amp;str,\\\\\\\\n    lib_paths: &amp;[&amp;Path],\\\\\\\\n    compilation_target: CompilationTarget,\\\\\\\\n) -&gt; Result&lt;()&gt; {\\\\\\\\n    let bundle_home_dir = bundle_home(target_dir);\\\\\\\\n    let bundle_name = match load_bundler_config()?.and_then(|c| c.get(package).cloned()) {\\\\\\\\n        Some(PackageConfig { name: Some(name) }) =&gt; name,\\\\\\\\n        _ =&gt; package.to_string(),\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    // We'll detect the plugin formats supported by the plugin binary and create bundled accordingly.\\\\\\\\n    // If &#96;lib_path&#96; contains paths to multiple plugins that need to be combined into a macOS\\\\\\\\n    // universal binary, then we'll assume all of them export the same symbols and only check the\\\\\\\\n    // first one.\\\\\\\\n    let first_lib_path = lib_paths.first().context(\\\\\\\\\\\\\\\"Empty library paths slice\\\\\\\\\\\\\\\")?;\\\\\\\\n\\\\\\\\n    let bundle_clap = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"clap_entry\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    // We'll ignore the platform-specific entry points for VST2 plugins since there's no reason to\\\\\\\\n    // create a new Rust VST2 plugin that doesn't work in modern DAWs\\\\\\\\n    // NOTE: NIH-plug does not support VST2, but we'll support bundling VST2 plugins anyways because\\\\\\\\n    //       this bundler can also be used standalone.\\\\\\\\n    let bundle_vst2 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"VSTPluginMain\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    let bundle_vst3 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"GetPluginFactory\\\\\\\\\\\\\\\")\\\\\\\\n        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\\n    let bundled_plugin = bundle_clap || bundle_vst2 || bundle_vst3;\\\\\\\\n\\\\\\\\n    if bundle_clap {\\\\\\\\n        let clap_bundle_library_name =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    eprintln!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":390},{\\\\\\\"text\\\\\\\":\\\\\\\"        \\\\\\\\\\\\\\\"Created a standalone bundle at '{}'\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":391},{\\\\\\\"text\\\\\\\":\\\\\\\"        standalone_bundle_home.display()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":392},{\\\\\\\"text\\\\\\\":\\\\\\\"    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":393},{\\\\\\\"lineNumber\\\\\\\":394},{\\\\\\\"text\\\\\\\":\\\\\\\"    Ok(())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":395},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":396},{\\\\\\\"lineNumber\\\\\\\":397},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Bundle all plugin targets for a plugin library. If &#96;lib_path&#96; contains more than one path, then\\\\\\\",\\\\\\\"lineNumber\\\\\\\":398},{\\\\\\\"text\\\\\\\":\\\\\\\"/// the libraries will be combined into a single library using a method that depends on the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":399},{\\\\\\\"text\\\\\\\":\\\\\\\"/// compilation target. For universal macOS builds this uses lipo.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":400},{\\\\\\\"text\\\\\\\":\\\\\\\"fn bundle_plugin(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":401},{\\\\\\\"text\\\\\\\":\\\\\\\"    target_dir: &amp;Path,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":402},{\\\\\\\"text\\\\\\\":\\\\\\\"    package: &amp;str,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":403},{\\\\\\\"text\\\\\\\":\\\\\\\"    lib_paths: &amp;[&amp;Path],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":404},{\\\\\\\"text\\\\\\\":\\\\\\\"    compilation_target: CompilationTarget,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":405},{\\\\\\\"text\\\\\\\":\\\\\\\") -&gt; Result&lt;()&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":406},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_home_dir = bundle_home(target_dir);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":407},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_name = match load_bundler_config()?.and_then(|c| c.get(package).cloned()) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":408},{\\\\\\\"text\\\\\\\":\\\\\\\"        Some(PackageConfig { name: Some(name) }) =&gt; name,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":409},{\\\\\\\"text\\\\\\\":\\\\\\\"        _ =&gt; package.to_string(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":410},{\\\\\\\"text\\\\\\\":\\\\\\\"    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":411},{\\\\\\\"lineNumber\\\\\\\":412},{\\\\\\\"text\\\\\\\":\\\\\\\"    // We'll detect the plugin formats supported by the plugin binary and create bundled accordingly.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":413},{\\\\\\\"text\\\\\\\":\\\\\\\"    // If &#96;lib_path&#96; contains paths to multiple plugins that need to be combined into a macOS\\\\\\\",\\\\\\\"lineNumber\\\\\\\":414},{\\\\\\\"text\\\\\\\":\\\\\\\"    // universal binary, then we'll assume all of them export the same symbols and only check the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":415},{\\\\\\\"text\\\\\\\":\\\\\\\"    // first one.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":416},{\\\\\\\"text\\\\\\\":\\\\\\\"    let first_lib_path = lib_paths.first().context(\\\\\\\\\\\\\\\"Empty library paths slice\\\\\\\\\\\\\\\")?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":417},{\\\\\\\"lineNumber\\\\\\\":418},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_clap = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"clap_entry\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":419},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":420},{\\\\\\\"text\\\\\\\":\\\\\\\"    // We'll ignore the platform-specific entry points for VST2 plugins since there's no reason to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":421},{\\\\\\\"text\\\\\\\":\\\\\\\"    // create a new Rust VST2 plugin that doesn't work in modern DAWs\\\\\\\",\\\\\\\"lineNumber\\\\\\\":422},{\\\\\\\"text\\\\\\\":\\\\\\\"    // NOTE: NIH-plug does not support VST2, but we'll support bundling VST2 plugins anyways because\\\\\\\",\\\\\\\"lineNumber\\\\\\\":423},{\\\\\\\"text\\\\\\\":\\\\\\\"    //       this bundler can also be used standalone.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":424},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_vst2 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"VSTPluginMain\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":425},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":426},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundle_vst3 = symbols::exported(first_lib_path, \\\\\\\\\\\\\\\"GetPluginFactory\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":427},{\\\\\\\"text\\\\\\\":\\\\\\\"        .with_context(|| format!(\\\\\\\\\\\\\\\"Could not parse '{}'\\\\\\\\\\\\\\\", first_lib_path.display()))?;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":428},{\\\\\\\"text\\\\\\\":\\\\\\\"    let bundled_plugin = bundle_clap || bundle_vst2 || bundle_vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":429},{\\\\\\\"lineNumber\\\\\\\":430},{\\\\\\\"text\\\\\\\":\\\\\\\"    if bundle_clap {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":431},{\\\\\\\"text\\\\\\\":\\\\\\\"        let clap_bundle_library_name =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":432}]},\\\\\\\"score\\\\\\\":0.39515450596809387},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":51,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":90,\\\\\\\"column\\\\\\\":39}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    pub fn new() -&gt; Box&lt;Self&gt; {\\\\\\\\n        Self::allocate(WrapperInner::new())\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; Drop for Wrapper&lt;P&gt; {\\\\\\\\n    fn drop(&amp;mut self) {\\\\\\\\n        nih_debug_assert_eq!(Arc::strong_count(&amp;self.inner), 1);\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; IPluginBase for Wrapper&lt;P&gt; {\\\\\\\\n    unsafe fn initialize(&amp;self, _context: *mut c_void) -&gt; tresult {\\\\\\\\n        // We currently don't need or allow any initialization logic\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn terminate(&amp;self) -&gt; tresult {\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; IComponent for Wrapper&lt;P&gt; {\\\\\\\\n    unsafe fn get_controller_class_id(&amp;self, _tuid: *mut vst3_sys::IID) -&gt; tresult {\\\\\\\\n        // We won't separate the edit controller to keep the implementation a bit smaller\\\\\\\\n        kNoInterface\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn set_io_mode(&amp;self, _mode: vst3_sys::vst::IoMode) -&gt; tresult {\\\\\\\\n        // Not quite sure what the point of this is when the processing setup also receives similar\\\\\\\\n        // information\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn get_bus_count(\\\\\\\\n        &amp;self,\\\\\\\\n        type_: vst3_sys::vst::MediaType\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new() -&gt; Box&lt;Self&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"        Self::allocate(WrapperInner::new())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; Drop for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn drop(&amp;mut self) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"        nih_debug_assert_eq!(Arc::strong_count(&amp;self.inner), 1);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; IPluginBase for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn initialize(&amp;self, _context: *mut c_void) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We currently don't need or allow any initialization logic\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn terminate(&amp;self) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; IComponent for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn get_controller_class_id(&amp;self, _tuid: *mut vst3_sys::IID) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We won't separate the edit controller to keep the implementation a bit smaller\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"        kNoInterface\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_io_mode(&amp;self, _mode: vst3_sys::vst::IoMode) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Not quite sure what the point of this is when the processing setup also receives similar\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"        // information\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn get_bus_count(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"        type_: vst3_sys::vst::MediaType\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91}]},\\\\\\\"score\\\\\\\":0.39333653450012207},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/plugin.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":37}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Traits and structs describing plugins and editors. This includes extension structs for features\\\\\\\\n//! that are specific to one or more plugin-APIs.\\\\\\\\n\\\\\\\\nuse std::sync::Arc;\\\\\\\\n\\\\\\\\nuse crate::prelude::{\\\\\\\\n    AsyncExecutor, AudioIOLayout, AuxiliaryBuffers, Buffer, BufferConfig, Editor, InitContext,\\\\\\\\n    MidiConfig, Params, PluginState, ProcessContext, SysExMessage,\\\\\\\\n};\\\\\\\\n\\\\\\\\npub mod clap;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub mod vst3;\\\\\\\\n\\\\\\\\n/// A function that can execute a plugin's [&#96;BackgroundTask&#96;][Plugin::BackgroundTask]s. A plugin can\\\\\\\\n/// dispatch these tasks from the &#96;initialize()&#96; function, the &#96;process()&#96; function, or the GUI, so\\\\\\\\n/// they can be deferred for later to avoid blocking realtime contexts.\\\\\\\\npub type TaskExecutor&lt;P&gt; = Box&lt;dyn Fn(&lt;P as Plugin&gt;::BackgroundTask) + Send&gt;;\\\\\\\\n\\\\\\\\n/// The main plugin trait covering functionality common across most plugin formats. Most formats\\\\\\\\n/// also have another trait with more specific data and functionality that needs to be implemented\\\\\\\\n/// before the plugin can be exported to that format. The wrappers will use this to expose the\\\\\\\\n/// plugin in a particular plugin format.\\\\\\\\n///\\\\\\\\n/// NIH-plug is semi-declarative, meaning that most information about a plugin is defined\\\\\\\\n/// declaratively but it also doesn't shy away from maintaining state when that is the path of least\\\\\\\\n/// resistance. As such, the definitions on this trait fall in one of the following classes:\\\\\\\\n///\\\\\\\\n/// - &#96;Plugin&#96; objects are stateful. During their lifetime the plugin API wrappers will call the\\\\\\\\n///   various lifecycle methods defined below, with the &#96;initialize()&#96;, &#96;reset()&#96;, and &#96;process()&#96;\\\\\\\\n///   functions being the most important ones.\\\\\\\\n/// - Most of the rest of the trait statically describes the plugin. You will find this done in\\\\\\\\n///   three different ways:\\\\\\\\n///   - Most of this data, including the supported audio IO layouts, is simple enough that it can be\\\\\\\\n///     defined through compile-time constants.\\\\\\\\n///   - Some of the data is queried through a method as doing everything at compile time would\\\\\\\\n///     impose a lot of restrictions on code structure and meta programming without any real\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Traits and structs describing plugins and editors. This includes extension structs for features\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//! that are specific to one or more plugin-APIs.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::Arc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"    AsyncExecutor, AudioIOLayout, AuxiliaryBuffers, Buffer, BufferConfig, Editor, InitContext,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"    MidiConfig, Params, PluginState, ProcessContext, SysExMessage,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod clap;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A function that can execute a plugin's [&#96;BackgroundTask&#96;][Plugin::BackgroundTask]s. A plugin can\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"/// dispatch these tasks from the &#96;initialize()&#96; function, the &#96;process()&#96; function, or the GUI, so\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// they can be deferred for later to avoid blocking realtime contexts.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"pub type TaskExecutor&lt;P&gt; = Box&lt;dyn Fn(&lt;P as Plugin&gt;::BackgroundTask) + Send&gt;;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The main plugin trait covering functionality common across most plugin formats. Most formats\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// also have another trait with more specific data and functionality that needs to be implemented\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// before the plugin can be exported to that format. The wrappers will use this to expose the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"/// plugin in a particular plugin format.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"/// NIH-plug is semi-declarative, meaning that most information about a plugin is defined\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"/// declaratively but it also doesn't shy away from maintaining state when that is the path of least\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"/// resistance. As such, the definitions on this trait fall in one of the following classes:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"/// - &#96;Plugin&#96; objects are stateful. During their lifetime the plugin API wrappers will call the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"///   various lifecycle methods defined below, with the &#96;initialize()&#96;, &#96;reset()&#96;, and &#96;process()&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"///   functions being the most important ones.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"/// - Most of the rest of the trait statically describes the plugin. You will find this done in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"///   three different ways:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"///   - Most of this data, including the supported audio IO layouts, is simple enough that it can be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"///     defined through compile-time constants.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"///   - Some of the data is queried through a method as doing everything at compile time would\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"///     impose a lot of restrictions on code structure and meta programming without any real\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37}]},\\\\\\\"score\\\\\\\":0.3928736448287964},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":13,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"//! Wrappers for different plugin types. Each wrapper has an entry point macro that you can pass the\\\\\\\\n//! name of a type that implements &#96;Plugin&#96; to. The macro will handle the rest.\\\\\\\\n\\\\\\\\npub mod clap;\\\\\\\\npub mod state;\\\\\\\\npub(crate) mod util;\\\\\\\\n\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\\npub mod standalone;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub mod vst3;\\\\\\\\n\\\\\\\\n// This is used by the wrappers.\\\\\\\\npub use util::setup_logger;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"//! Wrappers for different plugin types. Each wrapper has an entry point macro that you can pass the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"//! name of a type that implements &#96;Plugin&#96; to. The macro will handle the rest.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod clap;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod state;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"pub(crate) mod util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod standalone;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub mod vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"// This is used by the wrappers.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use util::setup_logger;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14}]},\\\\\\\"score\\\\\\\":0.390458345413208},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/prelude.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":43,\\\\\\\"column\\\\\\\":61}},\\\\\\\"contents\\\\\\\":\\\\\\\"// Used in [&#96;AudioIOLayout&#96;]\\\\\\\\npub use std::num::NonZeroU32;\\\\\\\\n\\\\\\\\n// Re-export the macros, derive macros are already re-exported from their respective modules\\\\\\\\npub use crate::debug::*;\\\\\\\\n\\\\\\\\npub use crate::nih_export_clap;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::nih_export_vst3;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::wrapper::standalone::{nih_export_standalone, nih_export_standalone_with_args};\\\\\\\\n\\\\\\\\npub use crate::formatters;\\\\\\\\npub use crate::util;\\\\\\\\n\\\\\\\\npub use crate::audio_setup::{\\\\\\\\n    new_nonzero_u32, AudioIOLayout, AuxiliaryBuffers, BufferConfig, PortNames, ProcessMode,\\\\\\\\n};\\\\\\\\npub use crate::buffer::Buffer;\\\\\\\\npub use crate::context::gui::{AsyncExecutor, GuiContext, ParamSetter};\\\\\\\\npub use crate::context::init::InitContext;\\\\\\\\npub use crate::context::process::{ProcessContext, Transport};\\\\\\\\npub use crate::context::remote_controls::{\\\\\\\\n    RemoteControlsContext, RemoteControlsPage, RemoteControlsSection,\\\\\\\\n};\\\\\\\\npub use crate::context::PluginApi;\\\\\\\\n// This also includes the derive macro\\\\\\\\npub use crate::editor::{Editor, ParentWindowHandle};\\\\\\\\npub use crate::midi::sysex::SysExMessage;\\\\\\\\npub use crate::midi::{control_change, MidiConfig, NoteEvent, PluginNoteEvent};\\\\\\\\npub use crate::params::enums::{Enum, EnumParam};\\\\\\\\npub use crate::params::internals::ParamPtr;\\\\\\\\npub use crate::params::range::{FloatRange, IntRange};\\\\\\\\npub use crate::params::smoothing::{AtomicF32, Smoothable, Smoother, SmoothingStyle};\\\\\\\\npub use crate::params::Params;\\\\\\\\npub use crate::params::{BoolParam, FloatParam, IntParam, Param, ParamFlags};\\\\\\\\npub use crate::plugin::clap::{ClapPlugin, PolyModulationConfig};\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::plugin::vst3::Vst3Plugin;\\\\\\\\npub use crate::plugin::{Plugin, ProcessStatus, TaskExecutor};\\\\\\\\npub use crate::wrapper::clap::features::ClapFeature;\\\\\\\\npub use crate::wrapper::state::PluginState;\\\\\\\\n#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\\npub use crate::wrapper::vst3::subcategories::Vst3SubCategory;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"// Used in [&#96;AudioIOLayout&#96;]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"// Re-export the macros, derive macros are already re-exported from their respective modules\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::debug::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::nih_export_clap;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::nih_export_vst3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"standalone\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::standalone::{nih_export_standalone, nih_export_standalone_with_args};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::formatters;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::util;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::audio_setup::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    new_nonzero_u32, AudioIOLayout, AuxiliaryBuffers, BufferConfig, PortNames, ProcessMode,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::buffer::Buffer;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::gui::{AsyncExecutor, GuiContext, ParamSetter};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::init::InitContext;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::process::{ProcessContext, Transport};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::remote_controls::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"    RemoteControlsContext, RemoteControlsPage, RemoteControlsSection,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::context::PluginApi;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"// This also includes the derive macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::editor::{Editor, ParentWindowHandle};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::midi::sysex::SysExMessage;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::midi::{control_change, MidiConfig, NoteEvent, PluginNoteEvent};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::enums::{Enum, EnumParam};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::internals::ParamPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::range::{FloatRange, IntRange};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::smoothing::{AtomicF32, Smoothable, Smoother, SmoothingStyle};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::Params;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::params::{BoolParam, FloatParam, IntParam, Param, ParamFlags};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::clap::{ClapPlugin, PolyModulationConfig};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::vst3::Vst3Plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::plugin::{Plugin, ProcessStatus, TaskExecutor};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::clap::features::ClapFeature;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::state::PluginState;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"#[cfg(feature = \\\\\\\\\\\\\\\"vst3\\\\\\\\\\\\\\\")]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"pub use crate::wrapper::vst3::subcategories::Vst3SubCategory;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44}]},\\\\\\\"score\\\\\\\":0.38864830136299133},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/plugins/loudness_war_winner/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":247,\\\\\\\"column\\\\\\\":58},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":280,\\\\\\\"column\\\\\\\":36}},\\\\\\\"contents\\\\\\\":\\\\\\\"            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl ClapPlugin for LoudnessWarWinner {\\\\\\\\n    const CLAP_ID: &amp;'static str = \\\\\\\\\\\\\\\"nl.robbertvanderhelm.loudness-war-winner\\\\\\\\\\\\\\\";\\\\\\\\n    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt; = Some(\\\\\\\\\\\\\\\"Win the loudness war with ease\\\\\\\\\\\\\\\");\\\\\\\\n    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt; = Some(Self::URL);\\\\\\\\n    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt; = None;\\\\\\\\n    const CLAP_FEATURES: &amp;'static [ClapFeature] = &amp;[\\\\\\\\n        ClapFeature::AudioEffect,\\\\\\\\n        ClapFeature::Stereo,\\\\\\\\n        ClapFeature::Mono,\\\\\\\\n        ClapFeature::Limiter,\\\\\\\\n        ClapFeature::Distortion,\\\\\\\\n        ClapFeature::Utility,\\\\\\\\n        ClapFeature::Custom(\\\\\\\\\\\\\\\"nih:pain\\\\\\\\\\\\\\\"),\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl Vst3Plugin for LoudnessWarWinner {\\\\\\\\n    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"LoudnessWar.RvdH\\\\\\\\\\\\\\\";\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\\n        Vst3SubCategory::Fx,\\\\\\\\n        Vst3SubCategory::Dynamics,\\\\\\\\n        Vst3SubCategory::Distortion,\\\\\\\\n        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Pain\\\\\\\\\\\\\\\"),\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nnih_export_clap!(LoudnessWarWinner);\\\\\\\\nnih_export_vst3!(LoudnessWarWinner);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":249},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":250},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":251},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":252},{\\\\\\\"lineNumber\\\\\\\":253},{\\\\\\\"text\\\\\\\":\\\\\\\"impl ClapPlugin for LoudnessWarWinner {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":254},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_ID: &amp;'static str = \\\\\\\\\\\\\\\"nl.robbertvanderhelm.loudness-war-winner\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":255},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_DESCRIPTION: Option&lt;&amp;'static str&gt; = Some(\\\\\\\\\\\\\\\"Win the loudness war with ease\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":256},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_MANUAL_URL: Option&lt;&amp;'static str&gt; = Some(Self::URL);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":257},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_SUPPORT_URL: Option&lt;&amp;'static str&gt; = None;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":258},{\\\\\\\"text\\\\\\\":\\\\\\\"    const CLAP_FEATURES: &amp;'static [ClapFeature] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":259},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::AudioEffect,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":260},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Stereo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":261},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Mono,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":262},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Limiter,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":263},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Distortion,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":264},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Utility,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":265},{\\\\\\\"text\\\\\\\":\\\\\\\"        ClapFeature::Custom(\\\\\\\\\\\\\\\"nih:pain\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":266},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":267},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":268},{\\\\\\\"lineNumber\\\\\\\":269},{\\\\\\\"text\\\\\\\":\\\\\\\"impl Vst3Plugin for LoudnessWarWinner {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":270},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"LoudnessWar.RvdH\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":271},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":272},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Fx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":273},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Dynamics,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":274},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Distortion,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":275},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Pain\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":276},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":277},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":278},{\\\\\\\"lineNumber\\\\\\\":279},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_clap!(LoudnessWarWinner);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":280},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_vst3!(LoudnessWarWinner);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":281}]},\\\\\\\"score\\\\\\\":0.38088470697402954},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/plugins/crisp/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":500,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":513,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl Vst3Plugin for Crisp {\\\\\\\\n    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"CrispPluginRvdH.\\\\\\\\\\\\\\\";\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\\n        Vst3SubCategory::Fx,\\\\\\\\n        Vst3SubCategory::Filter,\\\\\\\\n        Vst3SubCategory::Distortion,\\\\\\\\n        Vst3SubCategory::Stereo,\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nnih_export_clap!(Crisp);\\\\\\\\nnih_export_vst3!(Crisp);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl Vst3Plugin for Crisp {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":503},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"CrispPluginRvdH.\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":504},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":505},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Fx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":506},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Filter,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":507},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Distortion,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":508},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Stereo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":509},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":510},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":511},{\\\\\\\"lineNumber\\\\\\\":512},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_clap!(Crisp);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":513},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_vst3!(Crisp);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":514}]},\\\\\\\"score\\\\\\\":0.37546029686927795},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/plugins/buffr_glitch/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":442,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":455,\\\\\\\"column\\\\\\\":30}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl Vst3Plugin for BuffrGlitch {\\\\\\\\n    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"BuffrGlitch.RvdH\\\\\\\\\\\\\\\";\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\\n        Vst3SubCategory::Fx,\\\\\\\\n        Vst3SubCategory::Synth,\\\\\\\\n        Vst3SubCategory::Stereo,\\\\\\\\n        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Glitch\\\\\\\\\\\\\\\"),\\\\\\\\n    ];\\\\\\\\n}\\\\\\\\n\\\\\\\\nnih_export_clap!(BuffrGlitch);\\\\\\\\nnih_export_vst3!(BuffrGlitch);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl Vst3Plugin for BuffrGlitch {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":445},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"BuffrGlitch.RvdH\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":446},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] = &amp;[\\\\\\\",\\\\\\\"lineNumber\\\\\\\":447},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Fx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":448},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Synth,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":449},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Stereo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":450},{\\\\\\\"text\\\\\\\":\\\\\\\"        Vst3SubCategory::Custom(\\\\\\\\\\\\\\\"Glitch\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":451},{\\\\\\\"text\\\\\\\":\\\\\\\"    ];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":452},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":453},{\\\\\\\"lineNumber\\\\\\\":454},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_clap!(BuffrGlitch);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":455},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_vst3!(BuffrGlitch);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":456}]},\\\\\\\"score\\\\\\\":0.3696635961532593},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/plugins/examples/gain/src/lib.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":204,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":213,\\\\\\\"column\\\\\\\":23}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl Vst3Plugin for Gain {\\\\\\\\n    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"GainMoistestPlug\\\\\\\\\\\\\\\";\\\\\\\\n    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] =\\\\\\\\n        &amp;[Vst3SubCategory::Fx, Vst3SubCategory::Tools];\\\\\\\\n}\\\\\\\\n\\\\\\\\nnih_export_clap!(Gain);\\\\\\\\nnih_export_vst3!(Gain);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl Vst3Plugin for Gain {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_CLASS_ID: [u8; 16] = *b\\\\\\\\\\\\\\\"GainMoistestPlug\\\\\\\\\\\\\\\";\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VST3_SUBCATEGORIES: &amp;'static [Vst3SubCategory] =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;[Vst3SubCategory::Fx, Vst3SubCategory::Tools];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_clap!(Gain);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"nih_export_vst3!(Gain);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214}]},\\\\\\\"score\\\\\\\":0.3695162534713745},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/plugin.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":57},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":104}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[allow(unused_variables)]\\\\\\\\npub trait Plugin: Default + Send + 'static {\\\\\\\\n    /// The plugin's name.\\\\\\\\n    const NAME: &amp;'static str;\\\\\\\\n    /// The name of the plugin's vendor.\\\\\\\\n    const VENDOR: &amp;'static str;\\\\\\\\n    /// A URL pointing to the plugin's web page.\\\\\\\\n    const URL: &amp;'static str;\\\\\\\\n    /// The vendor's email address.\\\\\\\\n    const EMAIL: &amp;'static str;\\\\\\\\n\\\\\\\\n    /// Semver compatible version string (e.g. &#96;0.0.1&#96;). Hosts likely won't do anything with this,\\\\\\\\n    /// but just in case they do this should only contain decimals values and dots.\\\\\\\\n    const VERSION: &amp;'static str;\\\\\\\\n\\\\\\\\n    /// The plugin's supported audio IO layouts. The first config will be used as the default config\\\\\\\\n    /// if the host doesn't or can't select an alternative configuration. Because of that it's\\\\\\\\n    /// recommended to begin this slice with a stereo layout. For maximum compatibility with the\\\\\\\\n    /// different plugin formats this default layout should also include all of the plugin's\\\\\\\\n    /// auxiliary input and output ports, if the plugin has any. If the slice is empty, then the\\\\\\\\n    /// plugin will not have any audio IO.\\\\\\\\n    ///\\\\\\\\n    /// Both [&#96;AudioIOLayout&#96;] and [&#96;PortNames&#96;][crate::prelude::PortNames] have &#96;.const_default()&#96;\\\\\\\\n    /// functions for compile-time equivalents to &#96;Default::default()&#96;:\\\\\\\\n    ///\\\\\\\\n    /// &#96;&#96;&#96;\\\\\\\\n    /// # use nih_plug::prelude::*;\\\\\\\\n    /// const AUDIO_IO_LAYOUTS: &amp;'static [AudioIOLayout] = &amp;[AudioIOLayout {\\\\\\\\n    ///     main_input_channels: NonZeroU32::new(2),\\\\\\\\n    ///     main_output_channels: NonZeroU32::new(2),\\\\\\\\n    ///\\\\\\\\n    ///     aux_input_ports: &amp;[new_nonzero_u32(2)],\\\\\\\\n    ///\\\\\\\\n    ///     ..AudioIOLayout::const_default()\\\\\\\\n    /// }];\\\\\\\\n    /// &#96;&#96;&#96;\\\\\\\\n    ///\\\\\\\\n    /// # Note\\\\\\\\n    ///\\\\\\\\n    /// Some plugin hosts, like Ableton Live, don't support MIDI-only plugins and may refuse to load\\\\\\\\n    /// plugins with no main output or with zero main output channels.\\\\\\\\n    const AUDIO_IO_LAYOUTS: &amp;'static [AudioIOLayout];\\\\\\\\n\\\\\\\\n    /// Whether the plugin accepts note events, and what which events it wants to receive. If this\\\\\\\\n    /// is set to [&#96;MidiConfig::None&#96;], then the plugin won't receive any note events.\\\\\\\\n    const MIDI_INPUT: MidiConfig = MidiConfig::None;\\\\\\\\n    /// Whether the plugin can output note events. If this is set to [&#96;MidiConfig::None&#96;], then the\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[allow(unused_variables)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"pub trait Plugin: Default + Send + 'static {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The plugin's name.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"    const NAME: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The name of the plugin's vendor.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VENDOR: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// A URL pointing to the plugin's web page.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"    const URL: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The vendor's email address.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"    const EMAIL: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Semver compatible version string (e.g. &#96;0.0.1&#96;). Hosts likely won't do anything with this,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// but just in case they do this should only contain decimals values and dots.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"    const VERSION: &amp;'static str;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The plugin's supported audio IO layouts. The first config will be used as the default config\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// if the host doesn't or can't select an alternative configuration. Because of that it's\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// recommended to begin this slice with a stereo layout. For maximum compatibility with the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// different plugin formats this default layout should also include all of the plugin's\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// auxiliary input and output ports, if the plugin has any. If the slice is empty, then the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// plugin will not have any audio IO.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Both [&#96;AudioIOLayout&#96;] and [&#96;PortNames&#96;][crate::prelude::PortNames] have &#96;.const_default()&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// functions for compile-time equivalents to &#96;Default::default()&#96;:\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;&#96;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":83},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// # use nih_plug::prelude::*;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":84},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// const AUDIO_IO_LAYOUTS: &amp;'static [AudioIOLayout] = &amp;[AudioIOLayout {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":85},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///     main_input_channels: NonZeroU32::new(2),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":86},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///     main_output_channels: NonZeroU32::new(2),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":87},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":88},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///     aux_input_ports: &amp;[new_nonzero_u32(2)],\\\\\\\",\\\\\\\"lineNumber\\\\\\\":89},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///     ..AudioIOLayout::const_default()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// }];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;&#96;&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// # Note\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Some plugin hosts, like Ableton Live, don't support MIDI-only plugins and may refuse to load\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// plugins with no main output or with zero main output channels.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    const AUDIO_IO_LAYOUTS: &amp;'static [AudioIOLayout];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Whether the plugin accepts note events, and what which events it wants to receive. If this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// is set to [&#96;MidiConfig::None&#96;], then the plugin won't receive any note events.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    const MIDI_INPUT: MidiConfig = MidiConfig::None;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Whether the plugin can output note events. If this is set to [&#96;MidiConfig::None&#96;], then the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104}]},\\\\\\\"score\\\\\\\":0.3689649999141693}]}\\\"},\\\"capabilityType\\\":15}\",\"65c0da92-bee8-48a8-879c-a6f8c9003210\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"bfab3919-01b2-4018-8a99-ef53edfbdf25\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_f2679ef1-7b46-4fb1-b16d-0d1e189525a\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_f2679ef1-7b46-4fb1-b16d-0d1e189525a\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"process.*clap_process|clap_plugin.*process\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_f2679ef1-7b46-4fb1-b16d-0d1e189525a\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"process.*clap_process|clap_plugin.*process\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"process.*clap_process|clap_plugin.*process\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{\\\\\\\"matches\\\\\\\":[{\\\\\\\"file\\\\\\\":\\\\\\\"nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":59,\\\\\\\"content\\\\\\\":\\\\\\\"    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1896,\\\\\\\"content\\\\\\\":\\\\\\\"            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1953,\\\\\\\"content\\\\\\\":\\\\\\\"        process: *const clap_process,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2261,\\\\\\\"content\\\\\\\":\\\\\\\"                    ProcessStatus::Normal =&gt; CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2262,\\\\\\\"content\\\\\\\":\\\\\\\"                    ProcessStatus::Tail(_) =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2263,\\\\\\\"content\\\\\\\":\\\\\\\"                    ProcessStatus::KeepAlive =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\"}]}],\\\\\\\"totalLines\\\\\\\":6,\\\\\\\"totalMatchedLines\\\\\\\":6}}}}}\\\"},\\\"capabilityType\\\":15}\",\"8949dace-b7d5-4133-8408-14b038069709\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"89b633f1-e7f2-4ace-80c9-ac0e57ed811d\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_6064355f-a892-4fe8-9b83-05ceb50a4a3\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_6064355f-a892-4fe8-9b83-05ceb50a4a3\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":1500,\\\\\\\"limit\\\\\\\":500}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":1500,\\\\\\\"limit\\\\\\\":500,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_NOTE_OFF) =&gt; {\\\\\\\\n                if P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\\n                    let event = &amp;*(event as *const clap_event_note);\\\\\\\\n                    input_events.push_back(NoteEvent::NoteOff {\\\\\\\\n                        timing,\\\\\\\\n                        voice_id: if event.note_id != -1 {\\\\\\\\n                            Some(event.note_id)\\\\\\\\n                        } else {\\\\\\\\n                            None\\\\\\\\n                        },\\\\\\\\n                        channel: event.channel as u8,\\\\\\\\n                        note: event.key as u8,\\\\\\\\n                        velocity: event.velocity as f32,\\\\\\\\n                    });\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_NOTE_CHOKE) =&gt; {\\\\\\\\n                if P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\\n                    let event = &amp;*(event as *const clap_event_note);\\\\\\\\n                    input_events.push_back(NoteEvent::Choke {\\\\\\\\n                        timing,\\\\\\\\n                        voice_id: if event.note_id != -1 {\\\\\\\\n                            Some(event.note_id)\\\\\\\\n                        } else {\\\\\\\\n                            None\\\\\\\\n                        },\\\\\\\\n                        // FIXME: These values are also allowed to be -1, we need to support that\\\\\\\\n                        channel: event.channel as u8,\\\\\\\\n                        note: event.key as u8,\\\\\\\\n                    });\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_NOTE_EXPRESSION) =&gt; {\\\\\\\\n                if P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\\n                    // TODO: Add support for the other expression types\\\\\\\\n                    let event = &amp;*(event as *const clap_event_note_expression);\\\\\\\\n                    match event.expression_id {\\\\\\\\n                        CLAP_NOTE_EXPRESSION_PRESSURE =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyPressure {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                pressure: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_VOLUME =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyVolume {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                gain: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_PAN =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyPan {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                // In CLAP this value goes from [0, 1] instead of [-1, 1]\\\\\\\\n                                pan: (event.value as f32 * 2.0) - 1.0,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_TUNING =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyTuning {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                tuning: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_VIBRATO =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyVibrato {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                vibrato: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_EXPRESSION =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyExpression {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                expression: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        CLAP_NOTE_EXPRESSION_BRIGHTNESS =&gt; {\\\\\\\\n                            input_events.push_back(NoteEvent::PolyBrightness {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: if event.note_id != -1 {\\\\\\\\n                                    Some(event.note_id)\\\\\\\\n                                } else {\\\\\\\\n                                    None\\\\\\\\n                                },\\\\\\\\n                                channel: event.channel as u8,\\\\\\\\n                                note: event.key as u8,\\\\\\\\n                                brightness: event.value as f32,\\\\\\\\n                            });\\\\\\\\n                        }\\\\\\\\n                        n =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unhandled note expression ID {}\\\\\\\\\\\\\\\", n),\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_MIDI) =&gt; {\\\\\\\\n                // In the Basic note port type, we'll still handle note on, note off, and polyphonic\\\\\\\\n                // pressure events if the host sents us those. But we'll throw away any other MIDI\\\\\\\\n                // messages to stay consistent with the VST3 wrapper.\\\\\\\\n                let event = &amp;*(event as *const clap_event_midi);\\\\\\\\n\\\\\\\\n                match NoteEvent::from_midi(timing, &amp;event.data) {\\\\\\\\n                    Ok(\\\\\\\\n                        note_event @ (NoteEvent::NoteOn { .. }\\\\\\\\n                        | NoteEvent::NoteOff { .. }\\\\\\\\n                        | NoteEvent::PolyPressure { .. }),\\\\\\\\n                    ) if P::MIDI_INPUT &gt;= MidiConfig::Basic =&gt; {\\\\\\\\n                        input_events.push_back(note_event);\\\\\\\\n                    }\\\\\\\\n                    Ok(note_event) if P::MIDI_INPUT &gt;= MidiConfig::MidiCCs =&gt; {\\\\\\\\n                        input_events.push_back(note_event);\\\\\\\\n                    }\\\\\\\\n                    Ok(_) =&gt; (),\\\\\\\\n                    Err(n) =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unhandled MIDI message type {}\\\\\\\\\\\\\\\", n),\\\\\\\\n                };\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_MIDI_SYSEX)\\\\\\\\n                if P::MIDI_INPUT &gt;= MidiConfig::Basic =&gt;\\\\\\\\n            {\\\\\\\\n                let event = &amp;*(event as *const clap_event_midi_sysex);\\\\\\\\n\\\\\\\\n                // &#96;NoteEvent::from_midi&#96; prints some tracing if parsing fails, which is not\\\\\\\\n                // necessarily an error\\\\\\\\n                assert!(!event.buffer.is_null());\\\\\\\\n                let sysex_buffer = std::slice::from_raw_parts(event.buffer, event.size as usize);\\\\\\\\n                if let Ok(note_event) = NoteEvent::from_midi(timing, sysex_buffer) {\\\\\\\\n                    input_events.push_back(note_event);\\\\\\\\n                };\\\\\\\\n            }\\\\\\\\n            _ =&gt; {\\\\\\\\n                nih_trace!(\\\\\\\\n                    \\\\\\\\\\\\\\\"Unhandled CLAP event type {} for namespace {}\\\\\\\\\\\\\\\",\\\\\\\\n                    raw_event.type_,\\\\\\\\n                    raw_event.space_id\\\\\\\\n                );\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Get the plugin's state object, may be called by the plugin's GUI as part of its own preset\\\\\\\\n    /// management. The wrapper doesn't use these functions and serializes and deserializes directly\\\\\\\\n    /// the JSON in the relevant plugin API methods instead.\\\\\\\\n    pub fn get_state_object(&amp;self) -&gt; PluginState {\\\\\\\\n        unsafe {\\\\\\\\n            state::serialize_object::&lt;P&gt;(\\\\\\\\n                self.params.clone(),\\\\\\\\n                state::make_params_iter(&amp;self.param_by_hash, &amp;self.param_id_to_hash),\\\\\\\\n            )\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Update the plugin's internal state, called by the plugin itself from the GUI thread. To\\\\\\\\n    /// prevent corrupting data and changing parameters during processing the actual state is only\\\\\\\\n    /// updated at the end of the audio processing cycle.\\\\\\\\n    pub fn set_state_object_from_gui(&amp;self, mut state: PluginState) {\\\\\\\\n        // Use a loop and timeouts to handle the super rare edge case when this function gets called\\\\\\\\n        // between a process call and the host disabling the plugin\\\\\\\\n        loop {\\\\\\\\n            if self.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                // If the plugin is currently processing audio, then we'll perform the restore\\\\\\\\n                // operation at the end of the audio call. This involves sending the state to the\\\\\\\\n                // audio thread, having the audio thread handle the state restore at the very end of\\\\\\\\n                // the process function, and then sending the state back to this thread so it can be\\\\\\\\n                // deallocated without blocking the audio thread.\\\\\\\\n                match self\\\\\\\\n                    .updated_state_sender\\\\\\\\n                    .send_timeout(state, Duration::from_secs(1))\\\\\\\\n                {\\\\\\\\n                    Ok(_) =&gt; {\\\\\\\\n                        // As mentioned above, the state object will be passed back to this thread\\\\\\\\n                        // so we can deallocate it without blocking.\\\\\\\\n                        let state = self.updated_state_receiver.recv();\\\\\\\\n                        drop(state);\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                    Err(SendTimeoutError::Timeout(value)) =&gt; {\\\\\\\\n                        state = value;\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n                    Err(SendTimeoutError::Disconnected(_)) =&gt; {\\\\\\\\n                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"State update channel got disconnected\\\\\\\\\\\\\\\");\\\\\\\\n                        return;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            } else {\\\\\\\\n                // Otherwise we'll set the state right here and now, since this function should be\\\\\\\\n                // called from a GUI thread\\\\\\\\n                self.set_state_inner(&amp;mut state);\\\\\\\\n                break;\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // After the state has been updated, notify the host about the new parameter values\\\\\\\\n        let task_posted = self.schedule_gui(Task::RescanParamValues);\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn set_latency_samples(&amp;self, samples: u32) {\\\\\\\\n        // Only make a callback if it's actually needed\\\\\\\\n        // XXX: For CLAP we could move this handling to the Plugin struct, but it may be worthwhile\\\\\\\\n        //      to keep doing it this way to stay consistent with VST3.\\\\\\\\n        let old_latency = self.current_latency.swap(samples, Ordering::SeqCst);\\\\\\\\n        if old_latency != samples {\\\\\\\\n            let task_posted = self.schedule_gui(Task::LatencyChanged);\\\\\\\\n            nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn set_current_voice_capacity(&amp;self, capacity: u32) {\\\\\\\\n        match P::CLAP_POLY_MODULATION_CONFIG {\\\\\\\\n            Some(config) =&gt; {\\\\\\\\n                let clamped_capacity = capacity.clamp(1, config.max_voice_capacity);\\\\\\\\n                nih_debug_assert_eq!(\\\\\\\\n                    capacity,\\\\\\\\n                    clamped_capacity,\\\\\\\\n                    \\\\\\\\\\\\\\\"The current voice capacity must be between 1 and the maximum capacity\\\\\\\\\\\\\\\"\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                if clamped_capacity != self.current_voice_capacity.load(Ordering::Relaxed) {\\\\\\\\n                    self.current_voice_capacity\\\\\\\\n                        .store(clamped_capacity, Ordering::Relaxed);\\\\\\\\n                    let task_posted = self.schedule_gui(Task::VoiceInfoChanged);\\\\\\\\n                    nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\n                \\\\\\\\\\\\\\\"Configuring the current voice capacity is only possible when \\\\\\\\\\\\\\\\\\\\\\\\n                 'ClapPlugin::CLAP_POLY_MODULATION_CONFIG' is set\\\\\\\\\\\\\\\"\\\\\\\\n            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Immediately set the plugin state. Returns &#96;false&#96; if the deserialization failed. The plugin\\\\\\\\n    /// state is set from a couple places, so this function aims to deduplicate that. Includes\\\\\\\\n    /// &#96;permit_alloc()&#96;s around the deserialization and initialization for the use case where\\\\\\\\n    /// &#96;set_state_object_from_gui()&#96; was called while the plugin is process audio.\\\\\\\\n    ///\\\\\\\\n    /// Implicitly emits &#96;Task::ParameterValuesChanged&#96;.\\\\\\\\n    ///\\\\\\\\n    /// # Notes\\\\\\\\n    ///\\\\\\\\n    /// &#96;self.plugin&#96; must _not_ be locked while calling this function or it will deadlock.\\\\\\\\n    pub fn set_state_inner(&amp;self, state: &amp;mut PluginState) -&gt; bool {\\\\\\\\n        let audio_io_layout = self.current_audio_io_layout.load();\\\\\\\\n        let buffer_config = self.current_buffer_config.load();\\\\\\\\n\\\\\\\\n        // FIXME: This is obviously not realtime-safe, but loading presets without doing this could\\\\\\\\n        //        lead to inconsistencies. It's the plugin's responsibility to not perform any\\\\\\\\n        //        realtime-unsafe work when the initialize function is called a second time if it\\\\\\\\n        //        supports runtime preset loading.  &#96;state::deserialize_object()&#96; normally never\\\\\\\\n        //        allocates, but if the plugin has persistent non-parameter data then its\\\\\\\\n        //        &#96;deserialize_fields()&#96; implementation may still allocate.\\\\\\\\n        let mut success = permit_alloc(|| unsafe {\\\\\\\\n            state::deserialize_object::&lt;P&gt;(\\\\\\\\n                state,\\\\\\\\n                self.params.clone(),\\\\\\\\n                state::make_params_getter(&amp;self.param_by_hash, &amp;self.param_id_to_hash),\\\\\\\\n                self.current_buffer_config.load().as_ref(),\\\\\\\\n            )\\\\\\\\n        });\\\\\\\\n        if !success {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Deserializing plugin state from a state object failed\\\\\\\\\\\\\\\");\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // If the plugin was already initialized then it needs to be reinitialized\\\\\\\\n        if let Some(buffer_config) = buffer_config {\\\\\\\\n            // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\\n            let mut init_context = self.make_init_context();\\\\\\\\n            let mut plugin = self.plugin.lock();\\\\\\\\n\\\\\\\\n            // See above\\\\\\\\n            success = permit_alloc(|| {\\\\\\\\n                plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context)\\\\\\\\n            });\\\\\\\\n            if success {\\\\\\\\n                process_wrapper(|| plugin.reset());\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        nih_debug_assert!(\\\\\\\\n            success,\\\\\\\\n            \\\\\\\\\\\\\\\"Plugin returned false when reinitializing after loading state\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        // Reinitialize the plugin after loading state so it can respond to the new parameter values\\\\\\\\n        let task_posted = self.schedule_gui(Task::ParameterValuesChanged);\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n        // TODO: Right now there's no way to know if loading the state changed the GUI's size. We\\\\\\\\n        //       could keep track of the last known size and compare the GUI's current size against\\\\\\\\n        //       that but that also seems brittle.\\\\\\\\n        if self.editor_handle.lock().is_some() {\\\\\\\\n            self.request_resize();\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        success\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn init(plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // We weren't allowed to query these in the constructor, so we need to do it now instead.\\\\\\\\n        *wrapper.host_gui.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_gui&gt;(&amp;wrapper.host_callback, CLAP_EXT_GUI);\\\\\\\\n        *wrapper.host_latency.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_latency&gt;(&amp;wrapper.host_callback, CLAP_EXT_LATENCY);\\\\\\\\n        *wrapper.host_params.borrow_mut() =\\\\\\\\n            query_host_extension::&lt;clap_host_params&gt;(&amp;wrapper.host_callback, CLAP_EXT_PARAMS);\\\\\\\\n        *wrapper.host_voice_info.borrow_mut() = query_host_extension::&lt;clap_host_voice_info&gt;(\\\\\\\\n            &amp;wrapper.host_callback,\\\\\\\\n            CLAP_EXT_VOICE_INFO,\\\\\\\\n        );\\\\\\\\n        *wrapper.host_thread_check.borrow_mut() = query_host_extension::&lt;clap_host_thread_check&gt;(\\\\\\\\n            &amp;wrapper.host_callback,\\\\\\\\n            CLAP_EXT_THREAD_CHECK,\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn destroy(plugin: *const clap_plugin) {\\\\\\\\n        assert!(!plugin.is_null() &amp;&amp; !(*plugin).plugin_data.is_null());\\\\\\\\n        let this = Arc::from_raw((*plugin).plugin_data as *mut Self);\\\\\\\\n        nih_debug_assert_eq!(Arc::strong_count(&amp;this), 1);\\\\\\\\n\\\\\\\\n        drop(this);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        sample_rate: f64,\\\\\\\\n        min_frames_count: u32,\\\\\\\\n        max_frames_count: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n        let buffer_config = BufferConfig {\\\\\\\\n            sample_rate: sample_rate as f32,\\\\\\\\n            min_buffer_size: Some(min_frames_count),\\\\\\\\n            max_buffer_size: max_frames_count,\\\\\\\\n            process_mode: wrapper.current_process_mode.load(),\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // Before initializing the plugin, make sure all smoothers are set the the default values\\\\\\\\n        for param in wrapper.param_by_hash.values() {\\\\\\\\n            param.update_smoother(buffer_config.sample_rate, true);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\\n        let mut init_context = wrapper.make_init_context();\\\\\\\\n        let mut plugin = wrapper.plugin.lock();\\\\\\\\n        if plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context) {\\\\\\\\n            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\\n            //       this function\\\\\\\\n\\\\\\\\n            // This preallocates enough space so we can transform all of the host's raw channel\\\\\\\\n            // pointers into a set of &#96;Buffer&#96; objects for the plugin's main and auxiliary IO\\\\\\\\n            *wrapper.buffer_manager.borrow_mut() =\\\\\\\\n                BufferManager::for_audio_io_layout(max_frames_count as usize, audio_io_layout);\\\\\\\\n\\\\\\\\n            // Also store this for later, so we can reinitialize the plugin after restoring state\\\\\\\\n            wrapper.current_buffer_config.store(Some(buffer_config));\\\\\\\\n\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            false\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.plugin.lock().deactivate();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn start_processing(plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        // We just need to keep track of our processing state so we can request a flush when\\\\\\\\n        // updating parameters from the GUI while the processing loop isn't running\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // Always reset the processing status when the plugin gets activated or deactivated\\\\\\\\n        wrapper.last_process_status.store(ProcessStatus::Normal);\\\\\\\\n        wrapper.is_processing.store(true, Ordering::SeqCst);\\\\\\\\n\\\\\\\\n        // To be consistent with the VST3 wrapper, we'll also reset the buffers here in addition to\\\\\\\\n        // the dedicated &#96;reset()&#96; function.\\\\\\\\n        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn stop_processing(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.is_processing.store(false, Ordering::SeqCst);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn reset(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn process(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        process: *const clap_process,\\\\\\\\n    ) -&gt; clap_process_status {\\\\\\\\n        check_null_ptr!(CLAP_PROCESS_ERROR, plugin, (*plugin).plugin_data, process);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // Panic on allocations if the &#96;assert_process_allocs&#96; feature has been enabled, and make\\\\\\\\n        // sure that FTZ is set up correctly\\\\\\\\n        process_wrapper(|| {\\\\\\\\n            // We need to handle incoming automation and MIDI events. Since we don't support sample\\\\\\\\n            // accuration automation yet and there's no way to get the last event for a parameter,\\\\\\\\n            // we'll process every incoming event.\\\\\\\\n            let process = &amp;*process;\\\\\\\\n            let total_buffer_len = process.frames_count as usize;\\\\\\\\n\\\\\\\\n            let current_audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n            let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\\n            let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\\n            let aux_input_start_idx = if has_main_input { 1 } else { 0 };\\\\\\\\n            let aux_output_start_idx = if has_main_output { 1 } else { 0 };\\\\\\\\n\\\\\\\\n            // If &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set, then we'll split up the audio buffer into\\\\\\\\n            // chunks whenever a parameter change occurs\\\\\\\\n            let mut block_start = 0;\\\\\\\\n            let mut block_end = total_buffer_len;\\\\\\\\n            let mut event_start_idx = 0;\\\\\\\\n\\\\\\\\n            // The host may send new transport information as an event. In that case we'll also\\\\\\\\n            // split the buffer.\\\\\\\\n            let mut transport_info = process.transport;\\\\\\\\n\\\\\\\\n            let result = loop {\\\\\\\\n                if !process.in_events.is_null() {\\\\\\\\n                    let split_result = wrapper.handle_in_events_until(\\\\\\\\n                        &amp;*process.in_events,\\\\\\\\n                        &amp;mut transport_info,\\\\\\\\n                        block_start,\\\\\\\\n                        total_buffer_len,\\\\\\\\n                        event_start_idx,\\\\\\\\n                        |next_event| {\\\\\\\\n                            // Always split the buffer on transport information changes (tempo, time\\\\\\\\n                            // signature, or position changes), and also split on parameter value\\\\\\\\n                            // changes after the current sample if sample accurate automation is\\\\\\\\n                            // enabled\\\\\\\\n                            if P::SAMPLE_ACCURATE_AUTOMATION {\\\\\\\\n                                match ((*next_event).space_id, (*next_event).type_) {\\\\\\\\n                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE)\\\\\\\\n                                    | (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT) =&gt; true,\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":3232}\\\"},\\\"capabilityType\\\":15}\",\"2fb527c2-cc71-4d2e-b5bb-9d3bc8acc3c2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"d1e631a1-4302-4022-961e-73262290a91c\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_cf59fc22-624b-44bd-8d06-13cf5a3c41d\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_cf59fc22-624b-44bd-8d06-13cf5a3c41d\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":2000,\\\\\\\"limit\\\\\\\":500}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":2000,\\\\\\\"limit\\\\\\\":500,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\\n                                        let next_event =\\\\\\\\n                                            &amp;*(next_event as *const clap_event_param_mod);\\\\\\\\n\\\\\\\\n                                        // The buffer should not be split on polyphonic modulation\\\\\\\\n                                        // as those events will be converted to note events\\\\\\\\n                                        !(next_event.note_id != -1\\\\\\\\n                                            &amp;&amp; wrapper\\\\\\\\n                                                .poly_mod_ids_by_hash\\\\\\\\n                                                .contains_key(&amp;next_event.param_id))\\\\\\\\n                                    }\\\\\\\\n                                    _ =&gt; false,\\\\\\\\n                                }\\\\\\\\n                            } else {\\\\\\\\n                                matches!(\\\\\\\\n                                    ((*next_event).space_id, (*next_event).type_,),\\\\\\\\n                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT)\\\\\\\\n                                )\\\\\\\\n                            }\\\\\\\\n                        },\\\\\\\\n                    );\\\\\\\\n\\\\\\\\n                    // If there are any parameter changes after &#96;block_start&#96; and sample\\\\\\\\n                    // accurate automation is enabled or the host sends new transport\\\\\\\\n                    // information, then we'll process a new block just after that. Otherwise we can\\\\\\\\n                    // process all audio until the end of the buffer.\\\\\\\\n                    match split_result {\\\\\\\\n                        Some((next_param_change_sample_idx, next_param_change_event_idx)) =&gt; {\\\\\\\\n                            block_end = next_param_change_sample_idx;\\\\\\\\n                            event_start_idx = next_param_change_event_idx;\\\\\\\\n                        }\\\\\\\\n                        None =&gt; block_end = total_buffer_len,\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                // After processing the events we now know where/if the block should be split, and\\\\\\\\n                // we can start preparing audio processing\\\\\\\\n                let block_len = block_end - block_start;\\\\\\\\n\\\\\\\\n                // The buffer manager preallocated buffer slices for all the IO and storage for any\\\\\\\\n                // axuiliary inputs.\\\\\\\\n                // TODO: The audio buffers have a latency field, should we use those?\\\\\\\\n                // TODO: Like with VST3, should we expose some way to access or set the silence/constant\\\\\\\\n                //       flags?\\\\\\\\n                let mut buffer_manager = wrapper.buffer_manager.borrow_mut();\\\\\\\\n                let buffers =\\\\\\\\n                    buffer_manager.create_buffers(block_start, block_len, |buffer_source| {\\\\\\\\n                        // Explicitly take plugins with no main output that does have auxiliary\\\\\\\\n                        // outputs into account. Shouldn't happen, but if we just start copying\\\\\\\\n                        // audio here then that would result in unsoundness.\\\\\\\\n                        if process.audio_outputs_count &gt; 0\\\\\\\\n                            &amp;&amp; !process.audio_outputs.is_null()\\\\\\\\n                            &amp;&amp; !(*process.audio_outputs).data32.is_null()\\\\\\\\n                            &amp;&amp; has_main_output\\\\\\\\n                        {\\\\\\\\n                            let audio_output = &amp;*process.audio_outputs;\\\\\\\\n                            let ptrs = NonNull::new(audio_output.data32 as *mut *mut f32).unwrap();\\\\\\\\n                            let num_channels = audio_output.channel_count as usize;\\\\\\\\n\\\\\\\\n                            *buffer_source.main_output_channel_pointers =\\\\\\\\n                                Some(ChannelPointers { ptrs, num_channels });\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        if process.audio_inputs_count &gt; 0\\\\\\\\n                            &amp;&amp; !process.audio_inputs.is_null()\\\\\\\\n                            &amp;&amp; !(*process.audio_inputs).data32.is_null()\\\\\\\\n                            &amp;&amp; has_main_input\\\\\\\\n                        {\\\\\\\\n                            let audio_input = &amp;*process.audio_inputs;\\\\\\\\n                            let ptrs = NonNull::new(audio_input.data32 as *mut *mut f32).unwrap();\\\\\\\\n                            let num_channels = audio_input.channel_count as usize;\\\\\\\\n\\\\\\\\n                            *buffer_source.main_input_channel_pointers =\\\\\\\\n                                Some(ChannelPointers { ptrs, num_channels });\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        if !process.audio_inputs.is_null() {\\\\\\\\n                            for (aux_input_no, aux_input_channel_pointers) in buffer_source\\\\\\\\n                                .aux_input_channel_pointers\\\\\\\\n                                .iter_mut()\\\\\\\\n                                .enumerate()\\\\\\\\n                            {\\\\\\\\n                                let aux_input_idx = aux_input_no + aux_input_start_idx;\\\\\\\\n                                if aux_input_idx &gt; process.audio_inputs_count as usize {\\\\\\\\n                                    break;\\\\\\\\n                                }\\\\\\\\n\\\\\\\\n                                let audio_input = &amp;*process.audio_inputs.add(aux_input_idx);\\\\\\\\n                                match NonNull::new(audio_input.data32 as *mut *mut f32) {\\\\\\\\n                                    Some(ptrs) =&gt; {\\\\\\\\n                                        let num_channels = audio_input.channel_count as usize;\\\\\\\\n\\\\\\\\n                                        *aux_input_channel_pointers =\\\\\\\\n                                            Some(ChannelPointers { ptrs, num_channels });\\\\\\\\n                                    }\\\\\\\\n                                    None =&gt; continue,\\\\\\\\n                                }\\\\\\\\n                            }\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        if !process.audio_outputs.is_null() {\\\\\\\\n                            for (aux_output_no, aux_output_channel_pointers) in buffer_source\\\\\\\\n                                .aux_output_channel_pointers\\\\\\\\n                                .iter_mut()\\\\\\\\n                                .enumerate()\\\\\\\\n                            {\\\\\\\\n                                let aux_output_idx = aux_output_no + aux_output_start_idx;\\\\\\\\n                                if aux_output_idx &gt; process.audio_outputs_count as usize {\\\\\\\\n                                    break;\\\\\\\\n                                }\\\\\\\\n\\\\\\\\n                                let audio_output = &amp;*process.audio_outputs.add(aux_output_idx);\\\\\\\\n                                match NonNull::new(audio_output.data32 as *mut *mut f32) {\\\\\\\\n                                    Some(ptrs) =&gt; {\\\\\\\\n                                        let num_channels = audio_output.channel_count as usize;\\\\\\\\n\\\\\\\\n                                        *aux_output_channel_pointers =\\\\\\\\n                                            Some(ChannelPointers { ptrs, num_channels });\\\\\\\\n                                    }\\\\\\\\n                                    None =&gt; continue,\\\\\\\\n                                }\\\\\\\\n                            }\\\\\\\\n                        }\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                // If the host does not provide outputs or if it does not provide the required\\\\\\\\n                // number of channels (should not happen, but Ableton Live does this for bypassed\\\\\\\\n                // VST3 plugins) then we'll skip audio processing. In that case\\\\\\\\n                // &#96;buffer_manager.create_buffers&#96; will have set one or more of the output buffers\\\\\\\\n                // to empty slices since there is no storage to point them to. The auxiliary input\\\\\\\\n                // buffers always point to valid storage.\\\\\\\\n                let mut buffer_is_valid = true;\\\\\\\\n                for output_buffer_slice in buffers.main_buffer.as_slice_immutable().iter().chain(\\\\\\\\n                    buffers\\\\\\\\n                        .aux_outputs\\\\\\\\n                        .iter()\\\\\\\\n                        .flat_map(|buffer| buffer.as_slice_immutable().iter()),\\\\\\\\n                ) {\\\\\\\\n                    if output_buffer_slice.is_empty() {\\\\\\\\n                        buffer_is_valid = false;\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                nih_debug_assert!(buffer_is_valid);\\\\\\\\n\\\\\\\\n                // Some of the fields are left empty because CLAP does not provide this information,\\\\\\\\n                // but the methods on [&#96;Transport&#96;] can reconstruct these values from the other\\\\\\\\n                // fields\\\\\\\\n                let sample_rate = wrapper\\\\\\\\n                    .current_buffer_config\\\\\\\\n                    .load()\\\\\\\\n                    .expect(\\\\\\\\\\\\\\\"Process call without prior initialization call\\\\\\\\\\\\\\\")\\\\\\\\n                    .sample_rate;\\\\\\\\n                let mut transport = Transport::new(sample_rate);\\\\\\\\n                if !transport_info.is_null() {\\\\\\\\n                    let context = &amp;*transport_info;\\\\\\\\n\\\\\\\\n                    transport.playing = context.flags &amp; CLAP_TRANSPORT_IS_PLAYING != 0;\\\\\\\\n                    transport.recording = context.flags &amp; CLAP_TRANSPORT_IS_RECORDING != 0;\\\\\\\\n                    transport.preroll_active =\\\\\\\\n                        Some(context.flags &amp; CLAP_TRANSPORT_IS_WITHIN_PRE_ROLL != 0);\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_HAS_TEMPO != 0 {\\\\\\\\n                        transport.tempo = Some(context.tempo);\\\\\\\\n                    }\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_HAS_TIME_SIGNATURE != 0 {\\\\\\\\n                        transport.time_sig_numerator = Some(context.tsig_num as i32);\\\\\\\\n                        transport.time_sig_denominator = Some(context.tsig_denom as i32);\\\\\\\\n                    }\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_HAS_BEATS_TIMELINE != 0 {\\\\\\\\n                        let beats = context.song_pos_beats as f64 / CLAP_BEATTIME_FACTOR as f64;\\\\\\\\n\\\\\\\\n                        // This is a bit messy, but we'll try to compensate for the block splitting.\\\\\\\\n                        // We can't use the functions on the transport information object for this\\\\\\\\n                        // because we don't have any sample information.\\\\\\\\n                        if P::SAMPLE_ACCURATE_AUTOMATION\\\\\\\\n                            &amp;&amp; block_start &gt; 0\\\\\\\\n                            &amp;&amp; (context.flags &amp; CLAP_TRANSPORT_HAS_TEMPO != 0)\\\\\\\\n                        {\\\\\\\\n                            transport.pos_beats = Some(\\\\\\\\n                                beats\\\\\\\\n                                    + (block_start as f64 / sample_rate as f64 / 60.0\\\\\\\\n                                        * context.tempo),\\\\\\\\n                            );\\\\\\\\n                        } else {\\\\\\\\n                            transport.pos_beats = Some(beats);\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_HAS_SECONDS_TIMELINE != 0 {\\\\\\\\n                        let seconds = context.song_pos_seconds as f64 / CLAP_SECTIME_FACTOR as f64;\\\\\\\\n\\\\\\\\n                        // Same here\\\\\\\\n                        if P::SAMPLE_ACCURATE_AUTOMATION\\\\\\\\n                            &amp;&amp; block_start &gt; 0\\\\\\\\n                            &amp;&amp; (context.flags &amp; CLAP_TRANSPORT_HAS_TEMPO != 0)\\\\\\\\n                        {\\\\\\\\n                            transport.pos_seconds =\\\\\\\\n                                Some(seconds + (block_start as f64 / sample_rate as f64));\\\\\\\\n                        } else {\\\\\\\\n                            transport.pos_seconds = Some(seconds);\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n                    // TODO: CLAP does not mention whether this is behind a flag or not\\\\\\\\n                    if P::SAMPLE_ACCURATE_AUTOMATION &amp;&amp; block_start &gt; 0 {\\\\\\\\n                        transport.bar_start_pos_beats = match transport.bar_start_pos_beats() {\\\\\\\\n                            Some(updated) =&gt; Some(updated),\\\\\\\\n                            None =&gt; Some(context.bar_start as f64 / CLAP_BEATTIME_FACTOR as f64),\\\\\\\\n                        };\\\\\\\\n                        transport.bar_number = match transport.bar_number() {\\\\\\\\n                            Some(updated) =&gt; Some(updated),\\\\\\\\n                            None =&gt; Some(context.bar_number),\\\\\\\\n                        };\\\\\\\\n                    } else {\\\\\\\\n                        transport.bar_start_pos_beats =\\\\\\\\n                            Some(context.bar_start as f64 / CLAP_BEATTIME_FACTOR as f64);\\\\\\\\n                        transport.bar_number = Some(context.bar_number);\\\\\\\\n                    }\\\\\\\\n                    // TODO: They also aren't very clear about this, but presumably if the loop is\\\\\\\\n                    //       active and the corresponding song transport information is available then\\\\\\\\n                    //       this is also available\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\\n                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_BEATS_TIMELINE != 0\\\\\\\\n                    {\\\\\\\\n                        transport.loop_range_beats = Some((\\\\\\\\n                            context.loop_start_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\\n                            context.loop_end_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\\n                        ));\\\\\\\\n                    }\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\\n                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_SECONDS_TIMELINE != 0\\\\\\\\n                    {\\\\\\\\n                        transport.loop_range_seconds = Some((\\\\\\\\n                            context.loop_start_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\\n                            context.loop_end_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\\n                        ));\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                let result = if buffer_is_valid {\\\\\\\\n                    let mut plugin = wrapper.plugin.lock();\\\\\\\\n                    // SAFETY: Shortening these borrows is safe as even if the plugin overwrites the\\\\\\\\n                    //         slices (which it cannot do without using unsafe code), then they\\\\\\\\n                    //         would still be reset on the next iteration\\\\\\\\n                    let mut aux = AuxiliaryBuffers {\\\\\\\\n                        inputs: buffers.aux_inputs,\\\\\\\\n                        outputs: buffers.aux_outputs,\\\\\\\\n                    };\\\\\\\\n                    let mut context = wrapper.make_process_context(transport);\\\\\\\\n                    let result = plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context);\\\\\\\\n                    wrapper.last_process_status.store(result);\\\\\\\\n                    result\\\\\\\\n                } else {\\\\\\\\n                    ProcessStatus::Normal\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                let clap_result = match result {\\\\\\\\n                    ProcessStatus::Error(err) =&gt; {\\\\\\\\n                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Process error: {}\\\\\\\\\\\\\\\", err);\\\\\\\\n\\\\\\\\n                        return CLAP_PROCESS_ERROR;\\\\\\\\n                    }\\\\\\\\n                    ProcessStatus::Normal =&gt; CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\\n                    ProcessStatus::Tail(_) =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\\n                    ProcessStatus::KeepAlive =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                // After processing audio, send all spooled events to the host. This include note\\\\\\\\n                // events.\\\\\\\\n                if !process.out_events.is_null() {\\\\\\\\n                    wrapper.handle_out_events(&amp;*process.out_events, block_start, total_buffer_len);\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                // If our block ends at the end of the buffer then that means there are no more\\\\\\\\n                // unprocessed (parameter) events. If there are more events, we'll just keep going\\\\\\\\n                // through this process until we've processed the entire buffer.\\\\\\\\n                if block_end == total_buffer_len {\\\\\\\\n                    break clap_result;\\\\\\\\n                } else {\\\\\\\\n                    block_start = block_end;\\\\\\\\n                }\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            // After processing audio, we'll check if the editor has sent us updated plugin state.\\\\\\\\n            // We'll restore that here on the audio thread to prevent changing the values during the\\\\\\\\n            // process call and also to prevent inconsistent state when the host also wants to load\\\\\\\\n            // plugin state.\\\\\\\\n            // FIXME: Zero capacity channels allocate on receiving, find a better alternative that\\\\\\\\n            //        doesn't do that\\\\\\\\n            let updated_state = permit_alloc(|| wrapper.updated_state_receiver.try_recv());\\\\\\\\n            if let Ok(mut state) = updated_state {\\\\\\\\n                wrapper.set_state_inner(&amp;mut state);\\\\\\\\n\\\\\\\\n                // We'll pass the state object back to the GUI thread so deallocation can happen\\\\\\\\n                // there without potentially blocking the audio thread\\\\\\\\n                if let Err(err) = wrapper.updated_state_sender.send(state) {\\\\\\\\n                    nih_debug_assert_failure!(\\\\\\\\n                        \\\\\\\\\\\\\\\"Failed to send state object back to GUI thread: {}\\\\\\\\\\\\\\\",\\\\\\\\n                        err\\\\\\\\n                    );\\\\\\\\n                };\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            result\\\\\\\\n        })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn get_extension(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        id: *const c_char,\\\\\\\\n    ) -&gt; *const c_void {\\\\\\\\n        check_null_ptr!(std::ptr::null(), plugin, (*plugin).plugin_data, id);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let id = CStr::from_ptr(id);\\\\\\\\n\\\\\\\\n        if id == CLAP_EXT_AUDIO_PORTS_CONFIG {\\\\\\\\n            &amp;wrapper.clap_plugin_audio_ports_config as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_AUDIO_PORTS {\\\\\\\\n            &amp;wrapper.clap_plugin_audio_ports as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_GUI &amp;&amp; wrapper.editor.borrow().is_some() {\\\\\\\\n            // Only report that we support this extension if the plugin has an editor\\\\\\\\n            &amp;wrapper.clap_plugin_gui as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_LATENCY {\\\\\\\\n            &amp;wrapper.clap_plugin_latency as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_NOTE_PORTS\\\\\\\\n            &amp;&amp; (P::MIDI_INPUT &gt;= MidiConfig::Basic || P::MIDI_OUTPUT &gt;= MidiConfig::Basic)\\\\\\\\n        {\\\\\\\\n            &amp;wrapper.clap_plugin_note_ports as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_PARAMS {\\\\\\\\n            &amp;wrapper.clap_plugin_params as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_REMOTE_CONTROLS {\\\\\\\\n            &amp;wrapper.clap_plugin_remote_controls as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_RENDER {\\\\\\\\n            &amp;wrapper.clap_plugin_render as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_STATE {\\\\\\\\n            &amp;wrapper.clap_plugin_state as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_TAIL {\\\\\\\\n            &amp;wrapper.clap_plugin_tail as *const _ as *const c_void\\\\\\\\n        } else if id == CLAP_EXT_VOICE_INFO &amp;&amp; P::CLAP_POLY_MODULATION_CONFIG.is_some() {\\\\\\\\n            &amp;wrapper.clap_plugin_voice_info as *const _ as *const c_void\\\\\\\\n        } else {\\\\\\\\n            nih_trace!(\\\\\\\\\\\\\\\"Host tried to query unknown extension {:?}\\\\\\\\\\\\\\\", id);\\\\\\\\n            std::ptr::null()\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn on_main_thread(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // [Self::schedule_gui] posts a task to the queue and asks the host to call this function\\\\\\\\n        // on the main thread, so once that's done we can just handle all requests here\\\\\\\\n        while let Some(task) = wrapper.tasks.pop() {\\\\\\\\n            wrapper.execute(task, true);\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_audio_ports_config_count(plugin: *const clap_plugin) -&gt; u32 {\\\\\\\\n        check_null_ptr!(0, plugin, (*plugin).plugin_data);\\\\\\\\n\\\\\\\\n        P::AUDIO_IO_LAYOUTS.len() as u32\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_audio_ports_config_get(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        index: u32,\\\\\\\\n        config: *mut clap_audio_ports_config,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, config);\\\\\\\\n\\\\\\\\n        // This function directly maps to &#96;P::AUDIO_IO_LAYOUTS&#96;, and we thus also don't need to\\\\\\\\n        // access the &#96;wrapper&#96; instance\\\\\\\\n        match P::AUDIO_IO_LAYOUTS.get(index as usize) {\\\\\\\\n            Some(audio_io_layout) =&gt; {\\\\\\\\n                let name = audio_io_layout.name();\\\\\\\\n\\\\\\\\n                let main_input_channels = audio_io_layout.main_input_channels.map(NonZeroU32::get);\\\\\\\\n                let main_output_channels =\\\\\\\\n                    audio_io_layout.main_output_channels.map(NonZeroU32::get);\\\\\\\\n                let input_port_type = match main_input_channels {\\\\\\\\n                    Some(1) =&gt; CLAP_PORT_MONO.as_ptr(),\\\\\\\\n                    Some(2) =&gt; CLAP_PORT_STEREO.as_ptr(),\\\\\\\\n                    _ =&gt; std::ptr::null(),\\\\\\\\n                };\\\\\\\\n                let output_port_type = match main_output_channels {\\\\\\\\n                    Some(1) =&gt; CLAP_PORT_MONO.as_ptr(),\\\\\\\\n                    Some(2) =&gt; CLAP_PORT_STEREO.as_ptr(),\\\\\\\\n                    _ =&gt; std::ptr::null(),\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                *config = std::mem::zeroed();\\\\\\\\n\\\\\\\\n                let config = &amp;mut *config;\\\\\\\\n                config.id = index;\\\\\\\\n                strlcpy(&amp;mut config.name, &amp;name);\\\\\\\\n                config.input_port_count = (if main_input_channels.is_some() { 1 } else { 0 }\\\\\\\\n                    + audio_io_layout.aux_input_ports.len())\\\\\\\\n                    as u32;\\\\\\\\n                config.output_port_count = (if main_output_channels.is_some() { 1 } else { 0 }\\\\\\\\n                    + audio_io_layout.aux_output_ports.len())\\\\\\\\n                    as u32;\\\\\\\\n                config.has_main_input = main_input_channels.is_some();\\\\\\\\n                config.main_input_channel_count = main_input_channels.unwrap_or_default();\\\\\\\\n                config.main_input_port_type = input_port_type;\\\\\\\\n                config.has_main_output = main_output_channels.is_some();\\\\\\\\n                config.main_output_channel_count = main_output_channels.unwrap_or_default();\\\\\\\\n                config.main_output_port_type = output_port_type;\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\n                    \\\\\\\\\\\\\\\"Host tried to query out of bounds audio port config {}\\\\\\\\\\\\\\\",\\\\\\\\n                    index\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                false\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_audio_ports_config_select(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        config_id: clap_id,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // We use the vector indices for the config ID\\\\\\\\n        match P::AUDIO_IO_LAYOUTS.get(config_id as usize) {\\\\\\\\n            Some(audio_io_layout) =&gt; {\\\\\\\\n                wrapper.current_audio_io_layout.store(*audio_io_layout);\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\n                    \\\\\\\\\\\\\\\"Host tried to select out of bounds audio port config {}\\\\\\\\\\\\\\\",\\\\\\\\n                    config_id\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                false\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_audio_ports_count(plugin: *const clap_plugin, is_input: bool) -&gt; u32 {\\\\\\\\n        check_null_ptr!(0, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n        if is_input {\\\\\\\\n            let main_ports = if audio_io_layout.main_input_channels.is_some() {\\\\\\\\n                1\\\\\\\\n            } else {\\\\\\\\n                0\\\\\\\\n            };\\\\\\\\n            let aux_ports = audio_io_layout.aux_input_ports.len();\\\\\\\\n\\\\\\\\n            (main_ports + aux_ports) as u32\\\\\\\\n        } else {\\\\\\\\n            let main_ports = if audio_io_layout.main_output_channels.is_some() {\\\\\\\\n                1\\\\\\\\n            } else {\\\\\\\\n                0\\\\\\\\n            };\\\\\\\\n            let aux_ports = audio_io_layout.aux_output_ports.len();\\\\\\\\n\\\\\\\\n            (main_ports + aux_ports) as u32\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_audio_ports_get(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        index: u32,\\\\\\\\n        is_input: bool,\\\\\\\\n        info: *mut clap_audio_port_info,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, info);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let num_input_ports = Self::ext_audio_ports_count(plugin, true);\\\\\\\\n        let num_output_ports = Self::ext_audio_ports_count(plugin, false);\\\\\\\\n        if (is_input &amp;&amp; index &gt;= num_input_ports) || (!is_input &amp;&amp; index &gt;= num_output_ports) {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\n                \\\\\\\\\\\\\\\"Host tried to query information for out of bounds audio port {} (input: {})\\\\\\\\\\\\\\\",\\\\\\\\n                index,\\\\\\\\n                is_input\\\\\\\\n            );\\\\\\\\n\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let current_audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n        let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\\n        let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\\n\\\\\\\\n        // Whether this port is a main port or an auxiliary (sidechain) port\\\\\\\\n        let is_main_port =\\\\\\\\n            index == 0 &amp;&amp; ((is_input &amp;&amp; has_main_input) || (!is_input &amp;&amp; has_main_output));\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":3232}\\\"},\\\"capabilityType\\\":15}\",\"743d70c2-ba23-49ee-a0f5-c21f98e8c686\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"381549c7-1097-452f-be9e-4453150a7184\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\nReviewing parameter handling and state save/load:\\\\n\\\"}\",\"b4f0e9e1-26ed-485d-9fb3-fc0142152dba\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"8954793c-a3e3-45cd-bbe4-b9bd79d95573\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_49d25610-5231-4442-9d2f-6851d99a90c\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_49d25610-5231-4442-9d2f-6851d99a90c\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"ripgrep_raw_search\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"ext_params|clap_plugin_params|get_param_info|param_value|param_mod\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true,\\\\\\\"multiline\\\\\\\":false,\\\\\\\"toolCallId\\\\\\\":\\\\\\\"tool_49d25610-5231-4442-9d2f-6851d99a90c\\\\\\\"}\\\",\\\"tool\\\":41,\\\"params\\\":\\\"{\\\\\\\"pattern\\\\\\\":\\\\\\\"ext_params|clap_plugin_params|get_param_info|param_value|param_mod\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"caseInsensitive\\\\\\\":true}\\\",\\\"result\\\":\\\"{\\\\\\\"success\\\\\\\":{\\\\\\\"pattern\\\\\\\":\\\\\\\"ext_params|clap_plugin_params|get_param_info|param_value|param_mod\\\\\\\",\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"outputMode\\\\\\\":\\\\\\\"content\\\\\\\",\\\\\\\"workspaceResults\\\\\\\":{\\\\\\\"/Users/b/code/z-plug\\\\\\\":{\\\\\\\"content\\\\\\\":{\\\\\\\"matches\\\\\\\":[{\\\\\\\"file\\\\\\\":\\\\\\\"nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"matches\\\\\\\":[{\\\\\\\"lineNumber\\\\\\\":5,\\\\\\\"content\\\\\\\":\\\\\\\"    clap_event_note_expression, clap_event_param_gesture, clap_event_param_mod,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":6,\\\\\\\"content\\\\\\\":\\\\\\\"    clap_event_param_value, clap_event_transport, clap_input_events, clap_output_events,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":10,\\\\\\\"content\\\\\\\":\\\\\\\"    CLAP_EVENT_PARAM_MOD, CLAP_EVENT_PARAM_VALUE, CLAP_EVENT_TRANSPORT,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":38,\\\\\\\"content\\\\\\\":\\\\\\\"    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":188,\\\\\\\"content\\\\\\\":\\\\\\\"    clap_plugin_params: clap_plugin_params,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":368,\\\\\\\"content\\\\\\\":\\\\\\\"                        editor.lock().param_values_changed();\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":378,\\\\\\\"content\\\\\\\":\\\\\\\"                            .param_value_changed(param_id, normalized_value);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":388,\\\\\\\"content\\\\\\\":\\\\\\\"                            .param_modulation_changed(param_id, modulation_offset);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":628,\\\\\\\"content\\\\\\\":\\\\\\\"            clap_plugin_params: clap_plugin_params {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":629,\\\\\\\"content\\\\\\\":\\\\\\\"                count: Some(Self::ext_params_count),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":630,\\\\\\\"content\\\\\\\":\\\\\\\"                get_info: Some(Self::ext_params_get_info),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":631,\\\\\\\"content\\\\\\\":\\\\\\\"                get_value: Some(Self::ext_params_get_value),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":632,\\\\\\\"content\\\\\\\":\\\\\\\"                value_to_text: Some(Self::ext_params_value_to_text),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":633,\\\\\\\"content\\\\\\\":\\\\\\\"                text_to_value: Some(Self::ext_params_text_to_value),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":634,\\\\\\\"content\\\\\\\":\\\\\\\"                flush: Some(Self::ext_params_flush),\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":817,\\\\\\\"content\\\\\\\":\\\\\\\"    /// [&#96;notify_param_values_changed()&#96;][Self::notify_param_values_changed()] to allow the editor\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":844,\\\\\\\"content\\\\\\\":\\\\\\\"                            // triggers an &#96;Editor::param_value_changed()&#96; call on the GUI thread.\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1020,\\\\\\\"content\\\\\\\":\\\\\\\"                    let event = clap_event_param_value {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1022,\\\\\\\"content\\\\\\\":\\\\\\\"                            size: mem::size_of::&lt;clap_event_param_value&gt;() as u32,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1025,\\\\\\\"content\\\\\\\":\\\\\\\"                            type_: CLAP_EVENT_PARAM_VALUE,\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1415,\\\\\\\"content\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE) =&gt; {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1416,\\\\\\\"content\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_param_value);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1441,\\\\\\\"content\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1442,\\\\\\\"content\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_param_mod);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1849,\\\\\\\"content\\\\\\\":\\\\\\\"            query_host_extension::&lt;clap_host_params&gt;(&amp;wrapper.host_callback, CLAP_EXT_PARAMS);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":1998,\\\\\\\"content\\\\\\\":\\\\\\\"                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE)\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2000,\\\\\\\"content\\\\\\\":\\\\\\\"                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2002,\\\\\\\"content\\\\\\\":\\\\\\\"                                            &amp;*(next_event as *const clap_event_param_mod);\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2328,\\\\\\\"content\\\\\\\":\\\\\\\"        } else if id == CLAP_EXT_PARAMS {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2329,\\\\\\\"content\\\\\\\":\\\\\\\"            &amp;wrapper.clap_plugin_params as *const _ as *const c_void\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2885,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_count(plugin: *const clap_plugin) -&gt; u32 {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2892,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_info(\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2900,\\\\\\\"content\\\\\\\":\\\\\\\"        if param_index &gt; Self::ext_params_count(plugin) {\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2953,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_value(\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":2972,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_value_to_text(\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":3001,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_text_to_value(\\\\\\\"},{\\\\\\\"lineNumber\\\\\\\":3029,\\\\\\\"content\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_flush(\\\\\\\"}]}],\\\\\\\"totalLines\\\\\\\":37,\\\\\\\"totalMatchedLines\\\\\\\":37}}}}}\\\"},\\\"capabilityType\\\":15}\",\"00fdbacc-c0c4-49df-a6c5-4bb5b56093e7\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"177cea8a-f3c4-4619-9912-706ac13cd656\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.054Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_1516e735-dc11-44bd-8017-f90cfb53bb9\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_1516e735-dc11-44bd-8017-f90cfb53bb9\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"read_file_v2\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"path\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":2600,\\\\\\\"limit\\\\\\\":400}\\\",\\\"tool\\\":40,\\\"params\\\":\\\"{\\\\\\\"targetFile\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"offset\\\\\\\":2600,\\\\\\\"limit\\\\\\\":400,\\\\\\\"charsLimit\\\\\\\":1000000,\\\\\\\"effectiveUri\\\\\\\":\\\\\\\"/Users/b/code/z-plug/nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"contents\\\\\\\":\\\\\\\"\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_get_preferred_api(\\\\\\\\n        _plugin: *const clap_plugin,\\\\\\\\n        api: *mut *const c_char,\\\\\\\\n        is_floating: *mut bool,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, api, is_floating);\\\\\\\\n\\\\\\\\n        #[cfg(all(target_family = \\\\\\\\\\\\\\\"unix\\\\\\\\\\\\\\\", not(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")))]\\\\\\\\n        {\\\\\\\\n            *api = CLAP_WINDOW_API_X11.as_ptr();\\\\\\\\n        }\\\\\\\\n        #[cfg(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\")]\\\\\\\\n        {\\\\\\\\n            *api = CLAP_WINDOW_API_COCOA.as_ptr();\\\\\\\\n        }\\\\\\\\n        #[cfg(target_os = \\\\\\\\\\\\\\\"windows\\\\\\\\\\\\\\\")]\\\\\\\\n        {\\\\\\\\n            *api = CLAP_WINDOW_API_WIN32.as_ptr();\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // We don't do standalone floating windows yet\\\\\\\\n        *is_floating = false;\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_create(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        api: *const c_char,\\\\\\\\n        is_floating: bool,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        // Double check this in case the host didn't\\\\\\\\n        if !Self::ext_gui_is_api_supported(plugin, api, is_floating) {\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // In CLAP creating the editor window and embedding it in another window are separate, and\\\\\\\\n        // those things are one and the same in our framework. So we'll just pretend we did\\\\\\\\n        // something here.\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let editor_handle = wrapper.editor_handle.lock();\\\\\\\\n        if editor_handle.is_none() {\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Tried creating editor while the editor was already active\\\\\\\\\\\\\\\");\\\\\\\\n            false\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_destroy(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let mut editor_handle = wrapper.editor_handle.lock();\\\\\\\\n        if editor_handle.is_some() {\\\\\\\\n            *editor_handle = None;\\\\\\\\n        } else {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Tried destroying editor while the editor was not active\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_set_scale(plugin: *const clap_plugin, scale: f64) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // On macOS scaling is done by the OS, and all window sizes are in logical pixels\\\\\\\\n        if cfg!(target_os = \\\\\\\\\\\\\\\"macos\\\\\\\\\\\\\\\") {\\\\\\\\n            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Ignoring host request to set explicit DPI scaling factor\\\\\\\\\\\\\\\");\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        if wrapper\\\\\\\\n            .editor\\\\\\\\n            .borrow()\\\\\\\\n            .as_ref()\\\\\\\\n            .unwrap()\\\\\\\\n            .lock()\\\\\\\\n            .set_scale_factor(scale as f32)\\\\\\\\n        {\\\\\\\\n            wrapper\\\\\\\\n                .editor_scaling_factor\\\\\\\\n                .store(scale as f32, std::sync::atomic::Ordering::Relaxed);\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            false\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_get_size(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        width: *mut u32,\\\\\\\\n        height: *mut u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, width, height);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // For macOS the scaling factor is always 1\\\\\\\\n        let (unscaled_width, unscaled_height) =\\\\\\\\n            wrapper.editor.borrow().as_ref().unwrap().lock().size();\\\\\\\\n        let scaling_factor = wrapper.editor_scaling_factor.load(Ordering::Relaxed);\\\\\\\\n        (*width, *height) = (\\\\\\\\n            (unscaled_width as f32 * scaling_factor).round() as u32,\\\\\\\\n            (unscaled_height as f32 * scaling_factor).round() as u32,\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_can_resize(_plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        // TODO: Implement Host-&gt;Plugin GUI resizing\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_get_resize_hints(\\\\\\\\n        _plugin: *const clap_plugin,\\\\\\\\n        _hints: *mut clap_gui_resize_hints,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        // TODO: Implement Host-&gt;Plugin GUI resizing\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_adjust_size(\\\\\\\\n        _plugin: *const clap_plugin,\\\\\\\\n        _width: *mut u32,\\\\\\\\n        _height: *mut u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        // TODO: Implement Host-&gt;Plugin GUI resizing\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_set_size(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        width: u32,\\\\\\\\n        height: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        // TODO: Implement Host-&gt;Plugin GUI resizing\\\\\\\\n        // TODO: The host will also call this if an asynchronous (on Linux) resize request fails\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let (unscaled_width, unscaled_height) =\\\\\\\\n            wrapper.editor.borrow().as_ref().unwrap().lock().size();\\\\\\\\n        let scaling_factor = wrapper.editor_scaling_factor.load(Ordering::Relaxed);\\\\\\\\n        let (editor_width, editor_height) = (\\\\\\\\n            (unscaled_width as f32 * scaling_factor).round() as u32,\\\\\\\\n            (unscaled_height as f32 * scaling_factor).round() as u32,\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        width == editor_width &amp;&amp; height == editor_height\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_set_parent(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        window: *const clap_window,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, window);\\\\\\\\n        // For this function we need the underlying Arc so we can pass it to the editor\\\\\\\\n        let wrapper = Arc::from_raw((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let window = &amp;*window;\\\\\\\\n\\\\\\\\n        let result = {\\\\\\\\n            let mut editor_handle = wrapper.editor_handle.lock();\\\\\\\\n            if editor_handle.is_none() {\\\\\\\\n                let api = CStr::from_ptr(window.api);\\\\\\\\n                let parent_handle = if api == CLAP_WINDOW_API_X11 {\\\\\\\\n                    ParentWindowHandle::X11Window(window.specific.x11 as u32)\\\\\\\\n                } else if api == CLAP_WINDOW_API_COCOA {\\\\\\\\n                    ParentWindowHandle::AppKitNsView(window.specific.cocoa)\\\\\\\\n                } else if api == CLAP_WINDOW_API_WIN32 {\\\\\\\\n                    ParentWindowHandle::Win32Hwnd(window.specific.win32)\\\\\\\\n                } else {\\\\\\\\n                    nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host passed an invalid API\\\\\\\\\\\\\\\");\\\\\\\\n                    return false;\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                // This extension is only exposed when we have an editor\\\\\\\\n                *editor_handle = Some(\\\\\\\\n                    wrapper\\\\\\\\n                        .editor\\\\\\\\n                        .borrow()\\\\\\\\n                        .as_ref()\\\\\\\\n                        .unwrap()\\\\\\\\n                        .lock()\\\\\\\\n                        .spawn(parent_handle, wrapper.clone().make_gui_context()),\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            } else {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\n                    \\\\\\\\\\\\\\\"Host tried to attach editor while the editor is already attached\\\\\\\\\\\\\\\"\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                false\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // Leak the Arc again since we only needed a clone to pass to the GuiContext\\\\\\\\n        let _ = Arc::into_raw(wrapper);\\\\\\\\n\\\\\\\\n        result\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_set_transient(\\\\\\\\n        _plugin: *const clap_plugin,\\\\\\\\n        _window: *const clap_window,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        // This is only relevant for floating windows\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_suggest_title(_plugin: *const clap_plugin, _title: *const c_char) {\\\\\\\\n        // This is only relevant for floating windows\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_show(_plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        // TODO: Does this get used? Is this only for the free-standing window extension? (which we\\\\\\\\n        //       don't implement) This wouldn't make any sense for embedded editors.\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_gui_hide(_plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        // TODO: Same as the above\\\\\\\\n        false\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_latency_get(plugin: *const clap_plugin) -&gt; u32 {\\\\\\\\n        check_null_ptr!(0, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.current_latency.load(Ordering::SeqCst)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_note_ports_count(_plugin: *const clap_plugin, is_input: bool) -&gt; u32 {\\\\\\\\n        match is_input {\\\\\\\\n            true if P::MIDI_INPUT &gt;= MidiConfig::Basic =&gt; 1,\\\\\\\\n            false if P::MIDI_OUTPUT &gt;= MidiConfig::Basic =&gt; 1,\\\\\\\\n            _ =&gt; 0,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_note_ports_get(\\\\\\\\n        _plugin: *const clap_plugin,\\\\\\\\n        index: u32,\\\\\\\\n        is_input: bool,\\\\\\\\n        info: *mut clap_note_port_info,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        match (index, is_input) {\\\\\\\\n            (0, true) if P::MIDI_INPUT &gt;= MidiConfig::Basic =&gt; {\\\\\\\\n                *info = std::mem::zeroed();\\\\\\\\n\\\\\\\\n                let info = &amp;mut *info;\\\\\\\\n                info.id = 0;\\\\\\\\n                // NOTE: REAPER won't send us SysEx if we don't support the MIDI dialect\\\\\\\\n                // TODO: Implement MPE (would just be a toggle for the plugin to expose it) and MIDI2\\\\\\\\n                info.supported_dialects = CLAP_NOTE_DIALECT_CLAP | CLAP_NOTE_DIALECT_MIDI;\\\\\\\\n                info.preferred_dialect = CLAP_NOTE_DIALECT_CLAP;\\\\\\\\n                strlcpy(&amp;mut info.name, \\\\\\\\\\\\\\\"Note Input\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            (0, false) if P::MIDI_OUTPUT &gt;= MidiConfig::Basic =&gt; {\\\\\\\\n                *info = std::mem::zeroed();\\\\\\\\n\\\\\\\\n                let info = &amp;mut *info;\\\\\\\\n                info.id = 0;\\\\\\\\n                // If &#96;P::MIDI_OUTPUT &lt; MidiConfig::MidiCCs&#96; we'll throw away MIDI CCs, pitch bend\\\\\\\\n                // messages, and other messages that are not basic note on, off and polyphonic\\\\\\\\n                // pressure messages. This way the behavior is the same as the VST3 wrapper.\\\\\\\\n                info.supported_dialects = CLAP_NOTE_DIALECT_CLAP | CLAP_NOTE_DIALECT_MIDI;\\\\\\\\n                info.preferred_dialect = CLAP_NOTE_DIALECT_CLAP;\\\\\\\\n                strlcpy(&amp;mut info.name, \\\\\\\\\\\\\\\"Note Output\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_count(plugin: *const clap_plugin) -&gt; u32 {\\\\\\\\n        check_null_ptr!(0, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.param_hashes.len() as u32\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_info(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_index: u32,\\\\\\\\n        param_info: *mut clap_param_info,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, param_info);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        if param_index &gt; Self::ext_params_count(plugin) {\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let param_hash = &amp;wrapper.param_hashes[param_index as usize];\\\\\\\\n        let param_group = &amp;wrapper.param_group_by_hash[param_hash];\\\\\\\\n        let param_ptr = &amp;wrapper.param_by_hash[param_hash];\\\\\\\\n        let default_value = param_ptr.default_normalized_value();\\\\\\\\n        let step_count = param_ptr.step_count();\\\\\\\\n        let flags = param_ptr.flags();\\\\\\\\n        let automatable = !flags.contains(ParamFlags::NON_AUTOMATABLE);\\\\\\\\n        let hidden = flags.contains(ParamFlags::HIDDEN);\\\\\\\\n        let is_bypass = flags.contains(ParamFlags::BYPASS);\\\\\\\\n\\\\\\\\n        *param_info = std::mem::zeroed();\\\\\\\\n\\\\\\\\n        // TODO: We don't use the cookies at this point. In theory this would be faster than the ID\\\\\\\\n        //       hashmap lookup, but for now we'll stay consistent with the VST3 implementation.\\\\\\\\n        let param_info = &amp;mut *param_info;\\\\\\\\n        param_info.id = *param_hash;\\\\\\\\n        // TODO: Somehow expose per note/channel/port modulation\\\\\\\\n        param_info.flags = 0;\\\\\\\\n        if automatable &amp;&amp; !hidden {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_AUTOMATABLE | CLAP_PARAM_IS_MODULATABLE;\\\\\\\\n            if wrapper.poly_mod_ids_by_hash.contains_key(param_hash) {\\\\\\\\n                param_info.flags |= CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID;\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n        if hidden {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_HIDDEN | CLAP_PARAM_IS_READONLY;\\\\\\\\n        }\\\\\\\\n        if is_bypass {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_BYPASS\\\\\\\\n        }\\\\\\\\n        if step_count.is_some() {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_STEPPED\\\\\\\\n        }\\\\\\\\n        param_info.cookie = std::ptr::null_mut();\\\\\\\\n        strlcpy(&amp;mut param_info.name, param_ptr.name());\\\\\\\\n        strlcpy(&amp;mut param_info.module, param_group);\\\\\\\\n        // We don't use the actual minimum and maximum values here because that would not scale\\\\\\\\n        // with skewed integer ranges. Instead, just treat all parameters as &#96;[0, 1]&#96; normalized\\\\\\\\n        // parameters multiplied by the step size.\\\\\\\\n        param_info.min_value = 0.0;\\\\\\\\n        // Stepped parameters are unnormalized float parameters since there's no separate step\\\\\\\\n        // range option\\\\\\\\n        // TODO: This should probably be encapsulated in some way so we don't forget about this in one place\\\\\\\\n        param_info.max_value = step_count.unwrap_or(1) as f64;\\\\\\\\n        param_info.default_value = default_value as f64 * step_count.unwrap_or(1) as f64;\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_value(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_id: clap_id,\\\\\\\\n        value: *mut f64,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, value);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                *value = param_ptr.modulated_normalized_value() as f64\\\\\\\\n                    * param_ptr.step_count().unwrap_or(1) as f64;\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_value_to_text(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_id: clap_id,\\\\\\\\n        value: f64,\\\\\\\\n        display: *mut c_char,\\\\\\\\n        size: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, display);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let dest = std::slice::from_raw_parts_mut(display, size as usize);\\\\\\\\n\\\\\\\\n        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                strlcpy(\\\\\\\\n                    dest,\\\\\\\\n                    // CLAP does not have a separate unit, so we'll include the unit here\\\\\\\\n                    &amp;param_ptr.normalized_value_to_string(\\\\\\\\n                        value as f32 / param_ptr.step_count().unwrap_or(1) as f32,\\\\\\\\n                        true,\\\\\\\\n                    ),\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\",\\\\\\\"totalLinesInFile\\\\\\\":3232}\\\"},\\\"capabilityType\\\":15}\",\"d21bdb00-e31f-4866-bbb3-fcfc5cf73920\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"5c138f43-ee1c-4b9b-93c5-4d199076a626\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.055Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_b3cc72e6-5af9-4ca6-b7d0-17795578180\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_b3cc72e6-5af9-4ca6-b7d0-17795578180\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does CLAP wrapper handle parameter value changes and modulation in the process function?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"nih-plug/src/wrapper/clap\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does CLAP wrapper handle parameter value changes and modulation in the process function?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/clap\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":354,\\\\\\\"column\\\\\\\":61},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":392,\\\\\\\"column\\\\\\\":37}},\\\\\\\"contents\\\\\\\":\\\\\\\" self.main_thread_id),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: ClapPlugin&gt; MainThreadExecutor&lt;Task&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\\n    fn execute(&amp;self, task: Task&lt;P&gt;, is_gui_thread: bool) {\\\\\\\\n        // This function is always called from the main thread, from [Self::on_main_thread].\\\\\\\\n        match task {\\\\\\\\n            Task::PluginTask(task) =&gt; (self.task_executor.lock())(task),\\\\\\\\n            Task::ParameterValuesChanged =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        editor.lock().param_values_changed();\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::ParameterValueChanged(param_hash, normalized_value) =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\\n                        editor\\\\\\\\n                            .lock()\\\\\\\\n                            .param_value_changed(param_id, normalized_value);\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::ParameterModulationChanged(param_hash, modulation_offset) =&gt; {\\\\\\\\n                if self.editor_handle.lock().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\\n                        editor\\\\\\\\n                            .lock()\\\\\\\\n                            .param_modulation_changed(param_id, modulation_offset);\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::LatencyChanged =&gt; match &amp;*self.host_latency.borrow() {\\\\\\\\n                Some(host_latency) =&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" self.main_thread_id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":355},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":356},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":357},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":358},{\\\\\\\"lineNumber\\\\\\\":359},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; MainThreadExecutor&lt;Task&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":360},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn execute(&amp;self, task: Task&lt;P&gt;, is_gui_thread: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":361},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This function is always called from the main thread, from [Self::on_main_thread].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":362},{\\\\\\\"text\\\\\\\":\\\\\\\"        match task {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":363},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::PluginTask(task) =&gt; (self.task_executor.lock())(task),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":364},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::ParameterValuesChanged =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":365},{\\\\\\\"text\\\\\\\":\\\\\\\"                if self.editor_handle.lock().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":366},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":367},{\\\\\\\"text\\\\\\\":\\\\\\\"                        editor.lock().param_values_changed();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":368},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":369},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":370},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":371},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::ParameterValueChanged(param_hash, normalized_value) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":372},{\\\\\\\"text\\\\\\\":\\\\\\\"                if self.editor_handle.lock().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":373},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":374},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":375},{\\\\\\\"text\\\\\\\":\\\\\\\"                        editor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":376},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .lock()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":377},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .param_value_changed(param_id, normalized_value);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":378},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":379},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":380},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":381},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::ParameterModulationChanged(param_hash, modulation_offset) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":382},{\\\\\\\"text\\\\\\\":\\\\\\\"                if self.editor_handle.lock().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":383},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":384},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":385},{\\\\\\\"text\\\\\\\":\\\\\\\"                        editor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":386},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .lock()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":387},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .param_modulation_changed(param_id, modulation_offset);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":388},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":389},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":390},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":391},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::LatencyChanged =&gt; match &amp;*self.host_latency.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":392},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(host_latency) =&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":393}]},\\\\\\\"score\\\\\\\":0.5136846303939819},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":853,\\\\\\\"column\\\\\\\":21},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":909,\\\\\\\"column\\\\\\\":7}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueMod(clap_plain_delta) =&gt; {\\\\\\\\n                        let normalized_delta = clap_plain_delta as f32\\\\\\\\n                            / unsafe { param_ptr.step_count() }.unwrap_or(1) as f32;\\\\\\\\n\\\\\\\\n                        if unsafe { param_ptr.modulate_value(normalized_delta) } {\\\\\\\\n                            if let Some(sample_rate) = sample_rate {\\\\\\\\n                                unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\\n                            }\\\\\\\\n\\\\\\\\n                            let task_posted = self.schedule_gui(Task::ParameterModulationChanged(\\\\\\\\n                                hash,\\\\\\\\n                                normalized_delta,\\\\\\\\n                            ));\\\\\\\\n                            nih_debug_assert!(\\\\\\\\n                                task_posted,\\\\\\\\n                                \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\"\\\\\\\\n                            );\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        true\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Handle all incoming events from an event queue. This will clear &#96;self.input_events&#96; first.\\\\\\\\n    ///\\\\\\\\n    /// # Safety\\\\\\\\n    ///\\\\\\\\n    /// &#96;in_&#96; must contain only pointers to valid data (Clippy insists on there being a safety\\\\\\\\n    /// section here).\\\\\\\\n    pub unsafe fn handle_in_events(\\\\\\\\n        &amp;self,\\\\\\\\n        in_: &amp;clap_input_events,\\\\\\\\n        current_sample_idx: usize,\\\\\\\\n        total_buffer_len: usize,\\\\\\\\n    ) {\\\\\\\\n        let mut input_events = self.input_events.borrow_mut();\\\\\\\\n        input_events.clear();\\\\\\\\n\\\\\\\\n        let num_events = clap_call! { in_=&gt;size(in_) };\\\\\\\\n        for event_idx in 0..num_events {\\\\\\\\n            let event = clap_call! { in_=&gt;get(in_, event_idx) };\\\\\\\\n            self.handle_in_event(\\\\\\\\n                event,\\\\\\\\n                &amp;mut input_events,\\\\\\\\n                None,\\\\\\\\n                current_sample_idx,\\\\\\\\n                total_buffer_len,\\\\\\\\n            );\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueMod(clap_plain_delta) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":855},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let normalized_delta = clap_plain_delta as f32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":856},{\\\\\\\"text\\\\\\\":\\\\\\\"                            / unsafe { param_ptr.step_count() }.unwrap_or(1) as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":857},{\\\\\\\"lineNumber\\\\\\\":858},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if unsafe { param_ptr.modulate_value(normalized_delta) } {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":859},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if let Some(sample_rate) = sample_rate {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":860},{\\\\\\\"text\\\\\\\":\\\\\\\"                                unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":861},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":862},{\\\\\\\"lineNumber\\\\\\\":863},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let task_posted = self.schedule_gui(Task::ParameterModulationChanged(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":864},{\\\\\\\"text\\\\\\\":\\\\\\\"                                hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":865},{\\\\\\\"text\\\\\\\":\\\\\\\"                                normalized_delta,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":866},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":867},{\\\\\\\"text\\\\\\\":\\\\\\\"                            nih_debug_assert!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":868},{\\\\\\\"text\\\\\\\":\\\\\\\"                                task_posted,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":869},{\\\\\\\"text\\\\\\\":\\\\\\\"                                \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":870},{\\\\\\\"text\\\\\\\":\\\\\\\"                            );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":871},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":872},{\\\\\\\"lineNumber\\\\\\\":873},{\\\\\\\"text\\\\\\\":\\\\\\\"                        true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":874},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":875},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":876},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":877},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":878},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":879},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":880},{\\\\\\\"lineNumber\\\\\\\":881},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Handle all incoming events from an event queue. This will clear &#96;self.input_events&#96; first.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":882},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":883},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// # Safety\\\\\\\",\\\\\\\"lineNumber\\\\\\\":884},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":885},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;in_&#96; must contain only pointers to valid data (Clippy insists on there being a safety\\\\\\\",\\\\\\\"lineNumber\\\\\\\":886},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// section here).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":887},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub unsafe fn handle_in_events(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":888},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":889},{\\\\\\\"text\\\\\\\":\\\\\\\"        in_: &amp;clap_input_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":890},{\\\\\\\"text\\\\\\\":\\\\\\\"        current_sample_idx: usize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":891},{\\\\\\\"text\\\\\\\":\\\\\\\"        total_buffer_len: usize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":892},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":893},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut input_events = self.input_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":894},{\\\\\\\"text\\\\\\\":\\\\\\\"        input_events.clear();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":895},{\\\\\\\"lineNumber\\\\\\\":896},{\\\\\\\"text\\\\\\\":\\\\\\\"        let num_events = clap_call! { in_=&gt;size(in_) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":897},{\\\\\\\"text\\\\\\\":\\\\\\\"        for event_idx in 0..num_events {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":898},{\\\\\\\"text\\\\\\\":\\\\\\\"            let event = clap_call! { in_=&gt;get(in_, event_idx) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":899},{\\\\\\\"text\\\\\\\":\\\\\\\"            self.handle_in_event(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":900},{\\\\\\\"text\\\\\\\":\\\\\\\"                event,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":901},{\\\\\\\"text\\\\\\\":\\\\\\\"                &amp;mut input_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":902},{\\\\\\\"text\\\\\\\":\\\\\\\"                None,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":903},{\\\\\\\"text\\\\\\\":\\\\\\\"                current_sample_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":904},{\\\\\\\"text\\\\\\\":\\\\\\\"                total_buffer_len,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":905},{\\\\\\\"text\\\\\\\":\\\\\\\"            );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":906},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":907},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":908},{\\\\\\\"lineNumber\\\\\\\":909},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":910}]},\\\\\\\"score\\\\\\\":0.5112767815589905},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1948,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1983,\\\\\\\"column\\\\\\\":18}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn process(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        process: *const clap_process,\\\\\\\\n    ) -&gt; clap_process_status {\\\\\\\\n        check_null_ptr!(CLAP_PROCESS_ERROR, plugin, (*plugin).plugin_data, process);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // Panic on allocations if the &#96;assert_process_allocs&#96; feature has been enabled, and make\\\\\\\\n        // sure that FTZ is set up correctly\\\\\\\\n        process_wrapper(|| {\\\\\\\\n            // We need to handle incoming automation and MIDI events. Since we don't support sample\\\\\\\\n            // accuration automation yet and there's no way to get the last event for a parameter,\\\\\\\\n            // we'll process every incoming event.\\\\\\\\n            let process = &amp;*process;\\\\\\\\n            let total_buffer_len = process.frames_count as usize;\\\\\\\\n\\\\\\\\n            let current_audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n            let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\\n            let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\\n            let aux_input_start_idx = if has_main_input { 1 } else { 0 };\\\\\\\\n            let aux_output_start_idx = if has_main_output { 1 } else { 0 };\\\\\\\\n\\\\\\\\n            // If &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set, then we'll split up the audio buffer into\\\\\\\\n            // chunks whenever a parameter change occurs\\\\\\\\n            let mut block_start = 0;\\\\\\\\n            let mut block_end = total_buffer_len;\\\\\\\\n            let mut event_start_idx = 0;\\\\\\\\n\\\\\\\\n            // The host may send new transport information as an event. In that case we'll also\\\\\\\\n            // split the buffer.\\\\\\\\n            let mut transport_info = process.transport;\\\\\\\\n\\\\\\\\n            let result = loop {\\\\\\\\n                if\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1951},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1952},{\\\\\\\"text\\\\\\\":\\\\\\\"        process: *const clap_process,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1953},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; clap_process_status {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1954},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(CLAP_PROCESS_ERROR, plugin, (*plugin).plugin_data, process);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1955},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1956},{\\\\\\\"lineNumber\\\\\\\":1957},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Panic on allocations if the &#96;assert_process_allocs&#96; feature has been enabled, and make\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1958},{\\\\\\\"text\\\\\\\":\\\\\\\"        // sure that FTZ is set up correctly\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1959},{\\\\\\\"text\\\\\\\":\\\\\\\"        process_wrapper(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1960},{\\\\\\\"text\\\\\\\":\\\\\\\"            // We need to handle incoming automation and MIDI events. Since we don't support sample\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1961},{\\\\\\\"text\\\\\\\":\\\\\\\"            // accuration automation yet and there's no way to get the last event for a parameter,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1962},{\\\\\\\"text\\\\\\\":\\\\\\\"            // we'll process every incoming event.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1963},{\\\\\\\"text\\\\\\\":\\\\\\\"            let process = &amp;*process;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1964},{\\\\\\\"text\\\\\\\":\\\\\\\"            let total_buffer_len = process.frames_count as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1965},{\\\\\\\"lineNumber\\\\\\\":1966},{\\\\\\\"text\\\\\\\":\\\\\\\"            let current_audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1967},{\\\\\\\"text\\\\\\\":\\\\\\\"            let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1968},{\\\\\\\"text\\\\\\\":\\\\\\\"            let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1969},{\\\\\\\"text\\\\\\\":\\\\\\\"            let aux_input_start_idx = if has_main_input { 1 } else { 0 };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1970},{\\\\\\\"text\\\\\\\":\\\\\\\"            let aux_output_start_idx = if has_main_output { 1 } else { 0 };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1971},{\\\\\\\"lineNumber\\\\\\\":1972},{\\\\\\\"text\\\\\\\":\\\\\\\"            // If &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set, then we'll split up the audio buffer into\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1973},{\\\\\\\"text\\\\\\\":\\\\\\\"            // chunks whenever a parameter change occurs\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1974},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut block_start = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1975},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut block_end = total_buffer_len;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1976},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut event_start_idx = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1977},{\\\\\\\"lineNumber\\\\\\\":1978},{\\\\\\\"text\\\\\\\":\\\\\\\"            // The host may send new transport information as an event. In that case we'll also\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1979},{\\\\\\\"text\\\\\\\":\\\\\\\"            // split the buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1980},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut transport_info = process.transport;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1981},{\\\\\\\"lineNumber\\\\\\\":1982},{\\\\\\\"text\\\\\\\":\\\\\\\"            let result = loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1983},{\\\\\\\"text\\\\\\\":\\\\\\\"                if\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1984}]},\\\\\\\"score\\\\\\\":0.5032490491867065},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":263},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":299}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[allow(clippy::enum_variant_names)]\\\\\\\\npub enum Task&lt;P: Plugin&gt; {\\\\\\\\n    /// Execute one of the plugin's background tasks.\\\\\\\\n    PluginTask(P::BackgroundTask),\\\\\\\\n    /// Inform the plugin that one or more parameter values have changed.\\\\\\\\n    ParameterValuesChanged,\\\\\\\\n    /// Inform the plugin that one parameter's value has changed. This uses the parameter hashes\\\\\\\\n    /// since the task will be created from the audio thread.\\\\\\\\n    ParameterValueChanged(u32, f32),\\\\\\\\n    /// Inform the plugin that one parameter's modulation offset has changed. This uses the\\\\\\\\n    /// parameter hashes since the task will be created from the audio thread.\\\\\\\\n    ParameterModulationChanged(u32, f32),\\\\\\\\n    /// Inform the host that the latency has changed.\\\\\\\\n    LatencyChanged,\\\\\\\\n    /// Inform the host that the voice info has changed.\\\\\\\\n    VoiceInfoChanged,\\\\\\\\n    /// Tell the host that it should rescan the current parameter values.\\\\\\\\n    RescanParamValues,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// The types of CLAP parameter updates for events.\\\\\\\\npub enum ClapParamUpdate {\\\\\\\\n    /// Set the parameter to this plain value. In our wrapper the plain values are the normalized\\\\\\\\n    /// values multiplied by the step count for discrete parameters.\\\\\\\\n    PlainValueSet(f64),\\\\\\\\n    /// Set a normalized offset for the parameter's plain value. Subsequent modulation events\\\\\\\\n    /// override the previous one, but &#96;PlainValueSet&#96;s do not override the existing modulation.\\\\\\\\n    /// These values should also be divided by the step size.\\\\\\\\n    PlainValueMod(f64),\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A parameter event that should be output by the plugin, stored in a queue on the wrapper and\\\\\\\\n/// written to the host either at the end of the process function or during a flush.\\\\\\\\n#[derive(Debug, Clone)]\\\\\\\\npub enum OutputParamEvent {\\\\\\\\n    /// Begin an automation gesture. This must always be sent before sending [&#96;SetValue&#96;].\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[allow(clippy::enum_variant_names)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":264},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum Task&lt;P: Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":265},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Execute one of the plugin's background tasks.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":266},{\\\\\\\"text\\\\\\\":\\\\\\\"    PluginTask(P::BackgroundTask),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":267},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the plugin that one or more parameter values have changed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":268},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterValuesChanged,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":269},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the plugin that one parameter's value has changed. This uses the parameter hashes\\\\\\\",\\\\\\\"lineNumber\\\\\\\":270},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// since the task will be created from the audio thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":271},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterValueChanged(u32, f32),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":272},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the plugin that one parameter's modulation offset has changed. This uses the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":273},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// parameter hashes since the task will be created from the audio thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":274},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterModulationChanged(u32, f32),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":275},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the host that the latency has changed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":276},{\\\\\\\"text\\\\\\\":\\\\\\\"    LatencyChanged,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":277},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the host that the voice info has changed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":278},{\\\\\\\"text\\\\\\\":\\\\\\\"    VoiceInfoChanged,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":279},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Tell the host that it should rescan the current parameter values.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":280},{\\\\\\\"text\\\\\\\":\\\\\\\"    RescanParamValues,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":281},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":282},{\\\\\\\"lineNumber\\\\\\\":283},{\\\\\\\"text\\\\\\\":\\\\\\\"/// The types of CLAP parameter updates for events.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":284},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum ClapParamUpdate {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":285},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Set the parameter to this plain value. In our wrapper the plain values are the normalized\\\\\\\",\\\\\\\"lineNumber\\\\\\\":286},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// values multiplied by the step count for discrete parameters.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":287},{\\\\\\\"text\\\\\\\":\\\\\\\"    PlainValueSet(f64),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":288},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Set a normalized offset for the parameter's plain value. Subsequent modulation events\\\\\\\",\\\\\\\"lineNumber\\\\\\\":289},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// override the previous one, but &#96;PlainValueSet&#96;s do not override the existing modulation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":290},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// These values should also be divided by the step size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":291},{\\\\\\\"text\\\\\\\":\\\\\\\"    PlainValueMod(f64),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":292},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":293},{\\\\\\\"lineNumber\\\\\\\":294},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A parameter event that should be output by the plugin, stored in a queue on the wrapper and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":295},{\\\\\\\"text\\\\\\\":\\\\\\\"/// written to the host either at the end of the process function or during a flush.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":296},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":297},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum OutputParamEvent {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":298},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Begin an automation gesture. This must always be sent before sending [&#96;SetValue&#96;].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":299}]},\\\\\\\"score\\\\\\\":0.4983350932598114},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":824,\\\\\\\"column\\\\\\\":37},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":855,\\\\\\\"column\\\\\\\":46}},\\\\\\\"contents\\\\\\\":\\\\\\\"(\\\\\\\\n        &amp;self,\\\\\\\\n        hash: u32,\\\\\\\\n        update_type: ClapParamUpdate,\\\\\\\\n        sample_rate: Option&lt;f32&gt;,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        match self.param_by_hash.get(&amp;hash) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                match update_type {\\\\\\\\n                    ClapParamUpdate::PlainValueSet(clap_plain_value) =&gt; {\\\\\\\\n                        let normalized_value = clap_plain_value as f32\\\\\\\\n                            / unsafe { param_ptr.step_count() }.unwrap_or(1) as f32;\\\\\\\\n\\\\\\\\n                        if unsafe { param_ptr.set_normalized_value(normalized_value) } {\\\\\\\\n                            if let Some(sample_rate) = sample_rate {\\\\\\\\n                                unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\\n                            }\\\\\\\\n\\\\\\\\n                            // The GUI needs to be informed about the changed parameter value. This\\\\\\\\n                            // triggers an &#96;Editor::param_value_changed()&#96; call on the GUI thread.\\\\\\\\n                            let task_posted = self\\\\\\\\n                                .schedule_gui(Task::ParameterValueChanged(hash, normalized_value));\\\\\\\\n                            nih_debug_assert!(\\\\\\\\n                                task_posted,\\\\\\\\n                                \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\"\\\\\\\\n                            );\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        true\\\\\\\\n                    }\\\\\\\\n                    ClapParamUpdate::PlainValueMod(clap_plain_delta) =&gt; {\\\\\\\\n                        let normalized_delta =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":825},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":826},{\\\\\\\"text\\\\\\\":\\\\\\\"        hash: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":827},{\\\\\\\"text\\\\\\\":\\\\\\\"        update_type: ClapParamUpdate,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":828},{\\\\\\\"text\\\\\\\":\\\\\\\"        sample_rate: Option&lt;f32&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":829},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":830},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.param_by_hash.get(&amp;hash) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":831},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":832},{\\\\\\\"text\\\\\\\":\\\\\\\"                match update_type {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":833},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueSet(clap_plain_value) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":834},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let normalized_value = clap_plain_value as f32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":835},{\\\\\\\"text\\\\\\\":\\\\\\\"                            / unsafe { param_ptr.step_count() }.unwrap_or(1) as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":836},{\\\\\\\"lineNumber\\\\\\\":837},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if unsafe { param_ptr.set_normalized_value(normalized_value) } {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":838},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if let Some(sample_rate) = sample_rate {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":839},{\\\\\\\"text\\\\\\\":\\\\\\\"                                unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":840},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":841},{\\\\\\\"lineNumber\\\\\\\":842},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // The GUI needs to be informed about the changed parameter value. This\\\\\\\",\\\\\\\"lineNumber\\\\\\\":843},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // triggers an &#96;Editor::param_value_changed()&#96; call on the GUI thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":844},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let task_posted = self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":845},{\\\\\\\"text\\\\\\\":\\\\\\\"                                .schedule_gui(Task::ParameterValueChanged(hash, normalized_value));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":846},{\\\\\\\"text\\\\\\\":\\\\\\\"                            nih_debug_assert!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":847},{\\\\\\\"text\\\\\\\":\\\\\\\"                                task_posted,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":848},{\\\\\\\"text\\\\\\\":\\\\\\\"                                \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":849},{\\\\\\\"text\\\\\\\":\\\\\\\"                            );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":850},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":851},{\\\\\\\"lineNumber\\\\\\\":852},{\\\\\\\"text\\\\\\\":\\\\\\\"                        true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":853},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":854},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueMod(clap_plain_delta) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":855},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let normalized_delta =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":856}]},\\\\\\\"score\\\\\\\":0.4907621145248413},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1980,\\\\\\\"column\\\\\\\":55},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2014,\\\\\\\"column\\\\\\\":82}},\\\\\\\"contents\\\\\\\":\\\\\\\"            let result = loop {\\\\\\\\n                if !process.in_events.is_null() {\\\\\\\\n                    let split_result = wrapper.handle_in_events_until(\\\\\\\\n                        &amp;*process.in_events,\\\\\\\\n                        &amp;mut transport_info,\\\\\\\\n                        block_start,\\\\\\\\n                        total_buffer_len,\\\\\\\\n                        event_start_idx,\\\\\\\\n                        |next_event| {\\\\\\\\n                            // Always split the buffer on transport information changes (tempo, time\\\\\\\\n                            // signature, or position changes), and also split on parameter value\\\\\\\\n                            // changes after the current sample if sample accurate automation is\\\\\\\\n                            // enabled\\\\\\\\n                            if P::SAMPLE_ACCURATE_AUTOMATION {\\\\\\\\n                                match ((*next_event).space_id, (*next_event).type_) {\\\\\\\\n                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE)\\\\\\\\n                                    | (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT) =&gt; true,\\\\\\\\n                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\\n                                        let next_event =\\\\\\\\n                                            &amp;*(next_event as *const clap_event_param_mod);\\\\\\\\n\\\\\\\\n                                        // The buffer should not be split on polyphonic modulation\\\\\\\\n                                        // as those events will be converted to note events\\\\\\\\n                                        !(next_event.note_id != -1\\\\\\\\n                                            &amp;&amp; wrapper\\\\\\\\n                                                .poly_mod_ids_by_hash\\\\\\\\n                                                .contains_key(&amp;next_event.param_id))\\\\\\\\n                                    }\\\\\\\\n                                    _ =&gt; false,\\\\\\\\n                                }\\\\\\\\n                            } else {\\\\\\\\n                                matches!(\\\\\\\\n                                    ((*next_event).space_id, (*next_event).type_,)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            let result = loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1983},{\\\\\\\"text\\\\\\\":\\\\\\\"                if !process.in_events.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1984},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let split_result = wrapper.handle_in_events_until(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1985},{\\\\\\\"text\\\\\\\":\\\\\\\"                        &amp;*process.in_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1986},{\\\\\\\"text\\\\\\\":\\\\\\\"                        &amp;mut transport_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1987},{\\\\\\\"text\\\\\\\":\\\\\\\"                        block_start,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1988},{\\\\\\\"text\\\\\\\":\\\\\\\"                        total_buffer_len,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1989},{\\\\\\\"text\\\\\\\":\\\\\\\"                        event_start_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1990},{\\\\\\\"text\\\\\\\":\\\\\\\"                        |next_event| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1991},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // Always split the buffer on transport information changes (tempo, time\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1992},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // signature, or position changes), and also split on parameter value\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1993},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // changes after the current sample if sample accurate automation is\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1994},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // enabled\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1995},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if P::SAMPLE_ACCURATE_AUTOMATION {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1996},{\\\\\\\"text\\\\\\\":\\\\\\\"                                match ((*next_event).space_id, (*next_event).type_) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1997},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1998},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    | (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT) =&gt; true,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1999},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2000},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        let next_event =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2001},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            &amp;*(next_event as *const clap_event_param_mod);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2002},{\\\\\\\"lineNumber\\\\\\\":2003},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        // The buffer should not be split on polyphonic modulation\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2004},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        // as those events will be converted to note events\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2005},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        !(next_event.note_id != -1\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2006},{\\\\\\\"text\\\\\\\":\\\\\\\"                                            &amp;&amp; wrapper\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2007},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                .poly_mod_ids_by_hash\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2008},{\\\\\\\"text\\\\\\\":\\\\\\\"                                                .contains_key(&amp;next_event.param_id))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2009},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2010},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2011},{\\\\\\\"text\\\\\\\":\\\\\\\"                                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2012},{\\\\\\\"text\\\\\\\":\\\\\\\"                            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2013},{\\\\\\\"text\\\\\\\":\\\\\\\"                                matches!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2014},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    ((*next_event).space_id, (*next_event).type_,)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2015}]},\\\\\\\"score\\\\\\\":0.48250216245651245},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1411,\\\\\\\"column\\\\\\\":10},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1441,\\\\\\\"column\\\\\\\":69}},\\\\\\\"contents\\\\\\\":\\\\\\\"        match (raw_event.space_id, raw_event.type_) {\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE) =&gt; {\\\\\\\\n                let event = &amp;*(event as *const clap_event_param_value);\\\\\\\\n                self.update_plain_value_by_hash(\\\\\\\\n                    event.param_id,\\\\\\\\n                    ClapParamUpdate::PlainValueSet(event.value),\\\\\\\\n                    self.current_buffer_config.load().map(|c| c.sample_rate),\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                // If the parameter supports polyphonic modulation, then the plugin needs to be\\\\\\\\n                // informed that the parameter has been monophonically automated. This allows the\\\\\\\\n                // plugin to update all of its polyphonic modulation values, since polyphonic\\\\\\\\n                // modulation acts as an offset to the monophonic value.\\\\\\\\n                if let Some(poly_modulation_id) = self.poly_mod_ids_by_hash.get(&amp;event.param_id) {\\\\\\\\n                    // The modulation offset needs to be normalized to account for modulated\\\\\\\\n                    // integer or enum parameters\\\\\\\\n                    let param_ptr = self.param_by_hash[&amp;event.param_id];\\\\\\\\n                    let normalized_value =\\\\\\\\n                        event.value as f32 / param_ptr.step_count().unwrap_or(1) as f32;\\\\\\\\n\\\\\\\\n                    input_events.push_back(NoteEvent::MonoAutomation {\\\\\\\\n                        timing,\\\\\\\\n                        poly_modulation_id: *poly_modulation_id,\\\\\\\\n                        normalized_value,\\\\\\\\n                    });\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\\n                let event = &amp;*(event as *const clap_event_param_mod);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        match (raw_event.space_id, raw_event.type_) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1414},{\\\\\\\"text\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_VALUE) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1415},{\\\\\\\"text\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_param_value);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1416},{\\\\\\\"text\\\\\\\":\\\\\\\"                self.update_plain_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1417},{\\\\\\\"text\\\\\\\":\\\\\\\"                    event.param_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1418},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueSet(event.value),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1419},{\\\\\\\"text\\\\\\\":\\\\\\\"                    self.current_buffer_config.load().map(|c| c.sample_rate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1420},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1421},{\\\\\\\"lineNumber\\\\\\\":1422},{\\\\\\\"text\\\\\\\":\\\\\\\"                // If the parameter supports polyphonic modulation, then the plugin needs to be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1423},{\\\\\\\"text\\\\\\\":\\\\\\\"                // informed that the parameter has been monophonically automated. This allows the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1424},{\\\\\\\"text\\\\\\\":\\\\\\\"                // plugin to update all of its polyphonic modulation values, since polyphonic\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1425},{\\\\\\\"text\\\\\\\":\\\\\\\"                // modulation acts as an offset to the monophonic value.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1426},{\\\\\\\"text\\\\\\\":\\\\\\\"                if let Some(poly_modulation_id) = self.poly_mod_ids_by_hash.get(&amp;event.param_id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1427},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // The modulation offset needs to be normalized to account for modulated\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1428},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // integer or enum parameters\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1429},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let param_ptr = self.param_by_hash[&amp;event.param_id];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1430},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let normalized_value =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1431},{\\\\\\\"text\\\\\\\":\\\\\\\"                        event.value as f32 / param_ptr.step_count().unwrap_or(1) as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1432},{\\\\\\\"lineNumber\\\\\\\":1433},{\\\\\\\"text\\\\\\\":\\\\\\\"                    input_events.push_back(NoteEvent::MonoAutomation {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1434},{\\\\\\\"text\\\\\\\":\\\\\\\"                        timing,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1435},{\\\\\\\"text\\\\\\\":\\\\\\\"                        poly_modulation_id: *poly_modulation_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1436},{\\\\\\\"text\\\\\\\":\\\\\\\"                        normalized_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1437},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1438},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1439},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1440},{\\\\\\\"text\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1441},{\\\\\\\"text\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_param_mod);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1442}]},\\\\\\\"score\\\\\\\":0.47141003608703613},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/context.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":165,\\\\\\\"column\\\\\\\":75},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":207,\\\\\\\"column\\\\\\\":59}},\\\\\\\"contents\\\\\\\":\\\\\\\"            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_set_parameter_normalized(&amp;self, param: ParamPtr, normalized: f32) {\\\\\\\\n        match self.wrapper.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n            Some(hash) =&gt; {\\\\\\\\n                // We queue the parameter change event here, and it will be sent to the host either\\\\\\\\n                // at the end of the current processing cycle or after requesting an explicit flush\\\\\\\\n                // (when the plugin isn't processing audio). The parameter's actual value will only\\\\\\\\n                // be changed when the output event is written to prevent changing parameter values\\\\\\\\n                // in the middle of processing audio.\\\\\\\\n                let clap_plain_value = normalized as f64 * param.step_count().unwrap_or(1) as f64;\\\\\\\\n                let success = self\\\\\\\\n                    .wrapper\\\\\\\\n                    .queue_parameter_event(OutputParamEvent::SetValue {\\\\\\\\n                        param_hash: *hash,\\\\\\\\n                        clap_plain_value,\\\\\\\\n                    });\\\\\\\\n\\\\\\\\n                nih_debug_assert!(\\\\\\\\n                    success,\\\\\\\\n                    \\\\\\\\\\\\\\\"Parameter output event queue was full, parameter change will not be sent to \\\\\\\\\\\\\\\\\\\\\\\\n                     the host\\\\\\\\\\\\\\\"\\\\\\\\n                );\\\\\\\\n            }\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.wrapper.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .set_parameter(param_id),\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_end_set_parameter(&amp;self, param: ParamPtr)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_set_parameter_normalized(&amp;self, param: ParamPtr, normalized: f32) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.wrapper.param_ptr_to_hash.get(&amp;param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(hash) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"                // We queue the parameter change event here, and it will be sent to the host either\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                // at the end of the current processing cycle or after requesting an explicit flush\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"                // (when the plugin isn't processing audio). The parameter's actual value will only\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                // be changed when the output event is written to prevent changing parameter values\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"                // in the middle of processing audio.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"                let clap_plain_value = normalized as f64 * param.step_count().unwrap_or(1) as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"                let success = self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .wrapper\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .queue_parameter_event(OutputParamEvent::SetValue {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"                        param_hash: *hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"                        clap_plain_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"                    success,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"                    \\\\\\\\\\\\\\\"Parameter output event queue was full, parameter change will not be sent to \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"                     the host\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(debug_assertions)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.wrapper.param_id_from_ptr(param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_id) =&gt; self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"                .param_gesture_checker\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"text\\\\\\\":\\\\\\\"                .borrow_mut()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"                .set_parameter(param_id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_end_set_parameter(&amp;self, param: ParamPtr)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208}]},\\\\\\\"score\\\\\\\":0.47055020928382874},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":993,\\\\\\\"column\\\\\\\":67},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1039,\\\\\\\"column\\\\\\\":56}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n            let push_successful = match change {\\\\\\\\n                OutputParamEvent::BeginGesture { param_hash } =&gt; {\\\\\\\\n                    let event = clap_event_param_gesture {\\\\\\\\n                        header: clap_event_header {\\\\\\\\n                            size: mem::size_of::&lt;clap_event_param_gesture&gt;() as u32,\\\\\\\\n                            time: current_sample_idx as u32,\\\\\\\\n                            space_id: CLAP_CORE_EVENT_SPACE_ID,\\\\\\\\n                            type_: CLAP_EVENT_PARAM_GESTURE_BEGIN,\\\\\\\\n                            flags: CLAP_EVENT_IS_LIVE,\\\\\\\\n                        },\\\\\\\\n                        param_id: param_hash,\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    clap_call! { out=&gt;try_push(out, &amp;event.header) }\\\\\\\\n                }\\\\\\\\n                OutputParamEvent::SetValue {\\\\\\\\n                    param_hash,\\\\\\\\n                    clap_plain_value,\\\\\\\\n                } =&gt; {\\\\\\\\n                    self.update_plain_value_by_hash(\\\\\\\\n                        param_hash,\\\\\\\\n                        ClapParamUpdate::PlainValueSet(clap_plain_value),\\\\\\\\n                        sample_rate,\\\\\\\\n                    );\\\\\\\\n\\\\\\\\n                    let event = clap_event_param_value {\\\\\\\\n                        header: clap_event_header {\\\\\\\\n                            size: mem::size_of::&lt;clap_event_param_value&gt;() as u32,\\\\\\\\n                            time: current_sample_idx as u32,\\\\\\\\n                            space_id: CLAP_CORE_EVENT_SPACE_ID,\\\\\\\\n                            type_: CLAP_EVENT_PARAM_VALUE,\\\\\\\\n                            flags: CLAP_EVENT_IS_LIVE,\\\\\\\\n                        },\\\\\\\\n                        param_id: param_hash,\\\\\\\\n                        cookie: std::ptr::null_mut(),\\\\\\\\n                        port_index: -1,\\\\\\\\n                        note_id: -1,\\\\\\\\n                        channel: -1,\\\\\\\\n                        key: -1,\\\\\\\\n                        value: clap_plain_value,\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    clap_call! { out=&gt;try_push(out, &amp;event.header) }\\\\\\\\n                }\\\\\\\\n                OutputParamEvent::EndGesture { param_hash } =&gt; {\\\\\\\\n                    let event = clap_event_param_gesture\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":994},{\\\\\\\"text\\\\\\\":\\\\\\\"            let push_successful = match change {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":995},{\\\\\\\"text\\\\\\\":\\\\\\\"                OutputParamEvent::BeginGesture { param_hash } =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":996},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let event = clap_event_param_gesture {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":997},{\\\\\\\"text\\\\\\\":\\\\\\\"                        header: clap_event_header {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":998},{\\\\\\\"text\\\\\\\":\\\\\\\"                            size: mem::size_of::&lt;clap_event_param_gesture&gt;() as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":999},{\\\\\\\"text\\\\\\\":\\\\\\\"                            time: current_sample_idx as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1000},{\\\\\\\"text\\\\\\\":\\\\\\\"                            space_id: CLAP_CORE_EVENT_SPACE_ID,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1001},{\\\\\\\"text\\\\\\\":\\\\\\\"                            type_: CLAP_EVENT_PARAM_GESTURE_BEGIN,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1002},{\\\\\\\"text\\\\\\\":\\\\\\\"                            flags: CLAP_EVENT_IS_LIVE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1003},{\\\\\\\"text\\\\\\\":\\\\\\\"                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1004},{\\\\\\\"text\\\\\\\":\\\\\\\"                        param_id: param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1005},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1006},{\\\\\\\"lineNumber\\\\\\\":1007},{\\\\\\\"text\\\\\\\":\\\\\\\"                    clap_call! { out=&gt;try_push(out, &amp;event.header) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1008},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1009},{\\\\\\\"text\\\\\\\":\\\\\\\"                OutputParamEvent::SetValue {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1010},{\\\\\\\"text\\\\\\\":\\\\\\\"                    param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1011},{\\\\\\\"text\\\\\\\":\\\\\\\"                    clap_plain_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1012},{\\\\\\\"text\\\\\\\":\\\\\\\"                } =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1013},{\\\\\\\"text\\\\\\\":\\\\\\\"                    self.update_plain_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1014},{\\\\\\\"text\\\\\\\":\\\\\\\"                        param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1015},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ClapParamUpdate::PlainValueSet(clap_plain_value),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1016},{\\\\\\\"text\\\\\\\":\\\\\\\"                        sample_rate,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1017},{\\\\\\\"text\\\\\\\":\\\\\\\"                    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1018},{\\\\\\\"lineNumber\\\\\\\":1019},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let event = clap_event_param_value {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1020},{\\\\\\\"text\\\\\\\":\\\\\\\"                        header: clap_event_header {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1021},{\\\\\\\"text\\\\\\\":\\\\\\\"                            size: mem::size_of::&lt;clap_event_param_value&gt;() as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1022},{\\\\\\\"text\\\\\\\":\\\\\\\"                            time: current_sample_idx as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1023},{\\\\\\\"text\\\\\\\":\\\\\\\"                            space_id: CLAP_CORE_EVENT_SPACE_ID,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1024},{\\\\\\\"text\\\\\\\":\\\\\\\"                            type_: CLAP_EVENT_PARAM_VALUE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1025},{\\\\\\\"text\\\\\\\":\\\\\\\"                            flags: CLAP_EVENT_IS_LIVE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1026},{\\\\\\\"text\\\\\\\":\\\\\\\"                        },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1027},{\\\\\\\"text\\\\\\\":\\\\\\\"                        param_id: param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1028},{\\\\\\\"text\\\\\\\":\\\\\\\"                        cookie: std::ptr::null_mut(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1029},{\\\\\\\"text\\\\\\\":\\\\\\\"                        port_index: -1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1030},{\\\\\\\"text\\\\\\\":\\\\\\\"                        note_id: -1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1031},{\\\\\\\"text\\\\\\\":\\\\\\\"                        channel: -1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1032},{\\\\\\\"text\\\\\\\":\\\\\\\"                        key: -1,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1033},{\\\\\\\"text\\\\\\\":\\\\\\\"                        value: clap_plain_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1034},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1035},{\\\\\\\"lineNumber\\\\\\\":1036},{\\\\\\\"text\\\\\\\":\\\\\\\"                    clap_call! { out=&gt;try_push(out, &amp;event.header) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1037},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1038},{\\\\\\\"text\\\\\\\":\\\\\\\"                OutputParamEvent::EndGesture { param_hash } =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1039},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let event = clap_event_param_gesture\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1040}]},\\\\\\\"score\\\\\\\":0.46558550000190735},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":741,\\\\\\\"column\\\\\\\":60},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":789}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        WrapperInitContext {\\\\\\\\n            wrapper: self,\\\\\\\\n            pending_requests: Default::default(),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn make_process_context(&amp;self, transport: Transport) -&gt; WrapperProcessContext&lt;'_, P&gt; {\\\\\\\\n        WrapperProcessContext {\\\\\\\\n            wrapper: self,\\\\\\\\n            input_events_guard: self.input_events.borrow_mut(),\\\\\\\\n            output_events_guard: self.output_events.borrow_mut(),\\\\\\\\n            transport,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Get a parameter's ID based on a &#96;ParamPtr&#96;. Used in the &#96;GuiContext&#96; implementation for the\\\\\\\\n    /// gesture checks.\\\\\\\\n    #[allow(unused)]\\\\\\\\n    pub fn param_id_from_ptr(&amp;self, param: ParamPtr) -&gt; Option&lt;&amp;str&gt; {\\\\\\\\n        self.param_ptr_to_hash\\\\\\\\n            .get(&amp;param)\\\\\\\\n            .and_then(|hash| self.param_id_by_hash.get(hash))\\\\\\\\n            .map(|s| s.as_str())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Queue a parameter output event to be sent to the host at the end of the audio processing\\\\\\\\n    /// cycle, and request a parameter flush from the host if the plugin is not currently processing\\\\\\\\n    /// audio. The parameter's actual value will only be updated at that point so the value won't\\\\\\\\n    /// change in the middle of a processing call.\\\\\\\\n    ///\\\\\\\\n    /// Returns &#96;false&#96; if the parameter value queue was full and the update will not be sent to the\\\\\\\\n    /// host (it will still be set on the plugin either way).\\\\\\\\n    pub fn queue_parameter_event(&amp;self, event: OutputParamEvent) -&gt; bool {\\\\\\\\n        let result = self.output_parameter_events.push(event).is_ok();\\\\\\\\n\\\\\\\\n        // Requesting a flush is fine even during audio processing. This avoids a race condition.\\\\\\\\n        match &amp;*self.host_params.borrow() {\\\\\\\\n            Some(host_params) =&gt; {\\\\\\\\n                unsafe_clap_call! { host_params=&gt;request_flush(&amp;*self.host_callback) }\\\\\\\\n            }\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"The host does not support parameters? What?\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        result\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Request a resize based on the editor's current reported size. As of CLAP 0.24 this can\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":742},{\\\\\\\"text\\\\\\\":\\\\\\\"        WrapperInitContext {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":743},{\\\\\\\"text\\\\\\\":\\\\\\\"            wrapper: self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":744},{\\\\\\\"text\\\\\\\":\\\\\\\"            pending_requests: Default::default(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":745},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":746},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":747},{\\\\\\\"lineNumber\\\\\\\":748},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn make_process_context(&amp;self, transport: Transport) -&gt; WrapperProcessContext&lt;'_, P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":749},{\\\\\\\"text\\\\\\\":\\\\\\\"        WrapperProcessContext {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":750},{\\\\\\\"text\\\\\\\":\\\\\\\"            wrapper: self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":751},{\\\\\\\"text\\\\\\\":\\\\\\\"            input_events_guard: self.input_events.borrow_mut(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":752},{\\\\\\\"text\\\\\\\":\\\\\\\"            output_events_guard: self.output_events.borrow_mut(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":753},{\\\\\\\"text\\\\\\\":\\\\\\\"            transport,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":754},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":755},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":756},{\\\\\\\"lineNumber\\\\\\\":757},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get a parameter's ID based on a &#96;ParamPtr&#96;. Used in the &#96;GuiContext&#96; implementation for the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":758},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// gesture checks.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":759},{\\\\\\\"text\\\\\\\":\\\\\\\"    #[allow(unused)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":760},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn param_id_from_ptr(&amp;self, param: ParamPtr) -&gt; Option&lt;&amp;str&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":761},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.param_ptr_to_hash\\\\\\\",\\\\\\\"lineNumber\\\\\\\":762},{\\\\\\\"text\\\\\\\":\\\\\\\"            .get(&amp;param)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":763},{\\\\\\\"text\\\\\\\":\\\\\\\"            .and_then(|hash| self.param_id_by_hash.get(hash))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":764},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| s.as_str())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":765},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":766},{\\\\\\\"lineNumber\\\\\\\":767},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Queue a parameter output event to be sent to the host at the end of the audio processing\\\\\\\",\\\\\\\"lineNumber\\\\\\\":768},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// cycle, and request a parameter flush from the host if the plugin is not currently processing\\\\\\\",\\\\\\\"lineNumber\\\\\\\":769},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// audio. The parameter's actual value will only be updated at that point so the value won't\\\\\\\",\\\\\\\"lineNumber\\\\\\\":770},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// change in the middle of a processing call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":771},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":772},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Returns &#96;false&#96; if the parameter value queue was full and the update will not be sent to the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":773},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// host (it will still be set on the plugin either way).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":774},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn queue_parameter_event(&amp;self, event: OutputParamEvent) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":775},{\\\\\\\"text\\\\\\\":\\\\\\\"        let result = self.output_parameter_events.push(event).is_ok();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":776},{\\\\\\\"lineNumber\\\\\\\":777},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Requesting a flush is fine even during audio processing. This avoids a race condition.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":778},{\\\\\\\"text\\\\\\\":\\\\\\\"        match &amp;*self.host_params.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":779},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(host_params) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":780},{\\\\\\\"text\\\\\\\":\\\\\\\"                unsafe_clap_call! { host_params=&gt;request_flush(&amp;*self.host_callback) }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":781},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":782},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"The host does not support parameters? What?\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":783},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":784},{\\\\\\\"lineNumber\\\\\\\":785},{\\\\\\\"text\\\\\\\":\\\\\\\"        result\\\\\\\",\\\\\\\"lineNumber\\\\\\\":786},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":787},{\\\\\\\"lineNumber\\\\\\\":788},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Request a resize based on the editor's current reported size. As of CLAP 0.24 this can\\\\\\\",\\\\\\\"lineNumber\\\\\\\":789}]},\\\\\\\"score\\\\\\\":0.4210415482521057},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2936,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2971,\\\\\\\"column\\\\\\\":24}},\\\\\\\"contents\\\\\\\":\\\\\\\"        strlcpy(&amp;mut param_info.name, param_ptr.name());\\\\\\\\n        strlcpy(&amp;mut param_info.module, param_group);\\\\\\\\n        // We don't use the actual minimum and maximum values here because that would not scale\\\\\\\\n        // with skewed integer ranges. Instead, just treat all parameters as &#96;[0, 1]&#96; normalized\\\\\\\\n        // parameters multiplied by the step size.\\\\\\\\n        param_info.min_value = 0.0;\\\\\\\\n        // Stepped parameters are unnormalized float parameters since there's no separate step\\\\\\\\n        // range option\\\\\\\\n        // TODO: This should probably be encapsulated in some way so we don't forget about this in one place\\\\\\\\n        param_info.max_value = step_count.unwrap_or(1) as f64;\\\\\\\\n        param_info.default_value = default_value as f64 * step_count.unwrap_or(1) as f64;\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_value(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_id: clap_id,\\\\\\\\n        value: *mut f64,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, value);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                *value = param_ptr.modulated_normalized_value() as f64\\\\\\\\n                    * param_ptr.step_count().unwrap_or(1) as f64;\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut param_info.name, param_ptr.name());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2938},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut param_info.module, param_group);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2939},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We don't use the actual minimum and maximum values here because that would not scale\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2940},{\\\\\\\"text\\\\\\\":\\\\\\\"        // with skewed integer ranges. Instead, just treat all parameters as &#96;[0, 1]&#96; normalized\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2941},{\\\\\\\"text\\\\\\\":\\\\\\\"        // parameters multiplied by the step size.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2942},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.min_value = 0.0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2943},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Stepped parameters are unnormalized float parameters since there's no separate step\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2944},{\\\\\\\"text\\\\\\\":\\\\\\\"        // range option\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2945},{\\\\\\\"text\\\\\\\":\\\\\\\"        // TODO: This should probably be encapsulated in some way so we don't forget about this in one place\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2946},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.max_value = step_count.unwrap_or(1) as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2947},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.default_value = default_value as f64 * step_count.unwrap_or(1) as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2948},{\\\\\\\"lineNumber\\\\\\\":2949},{\\\\\\\"text\\\\\\\":\\\\\\\"        true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2950},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2951},{\\\\\\\"lineNumber\\\\\\\":2952},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2953},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2954},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: clap_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2955},{\\\\\\\"text\\\\\\\":\\\\\\\"        value: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2956},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2957},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data, value);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2958},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2959},{\\\\\\\"lineNumber\\\\\\\":2960},{\\\\\\\"text\\\\\\\":\\\\\\\"        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2961},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2962},{\\\\\\\"text\\\\\\\":\\\\\\\"                *value = param_ptr.modulated_normalized_value() as f64\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2963},{\\\\\\\"text\\\\\\\":\\\\\\\"                    * param_ptr.step_count().unwrap_or(1) as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2964},{\\\\\\\"lineNumber\\\\\\\":2965},{\\\\\\\"text\\\\\\\":\\\\\\\"                true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2966},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2967},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2968},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2969},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2970},{\\\\\\\"lineNumber\\\\\\\":2971},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2972}]},\\\\\\\"score\\\\\\\":0.4101001024246216},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2218,\\\\\\\"column\\\\\\\":51},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2254,\\\\\\\"column\\\\\\\":46}},\\\\\\\"contents\\\\\\\":\\\\\\\"                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\\n                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_BEATS_TIMELINE != 0\\\\\\\\n                    {\\\\\\\\n                        transport.loop_range_beats = Some((\\\\\\\\n                            context.loop_start_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\\n                            context.loop_end_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\\n                        ));\\\\\\\\n                    }\\\\\\\\n                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\\n                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_SECONDS_TIMELINE != 0\\\\\\\\n                    {\\\\\\\\n                        transport.loop_range_seconds = Some((\\\\\\\\n                            context.loop_start_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\\n                            context.loop_end_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\\n                        ));\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                let result = if buffer_is_valid {\\\\\\\\n                    let mut plugin = wrapper.plugin.lock();\\\\\\\\n                    // SAFETY: Shortening these borrows is safe as even if the plugin overwrites the\\\\\\\\n                    //         slices (which it cannot do without using unsafe code), then they\\\\\\\\n                    //         would still be reset on the next iteration\\\\\\\\n                    let mut aux = AuxiliaryBuffers {\\\\\\\\n                        inputs: buffers.aux_inputs,\\\\\\\\n                        outputs: buffers.aux_outputs,\\\\\\\\n                    };\\\\\\\\n                    let mut context = wrapper.make_process_context(transport);\\\\\\\\n                    let result = plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context);\\\\\\\\n                    wrapper.last_process_status.store(result);\\\\\\\\n                    result\\\\\\\\n                } else {\\\\\\\\n                    ProcessStatus::Normal\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                let clap_result = match result\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2220},{\\\\\\\"text\\\\\\\":\\\\\\\"                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_BEATS_TIMELINE != 0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2221},{\\\\\\\"text\\\\\\\":\\\\\\\"                    {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2222},{\\\\\\\"text\\\\\\\":\\\\\\\"                        transport.loop_range_beats = Some((\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2223},{\\\\\\\"text\\\\\\\":\\\\\\\"                            context.loop_start_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2224},{\\\\\\\"text\\\\\\\":\\\\\\\"                            context.loop_end_beats as f64 / CLAP_BEATTIME_FACTOR as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2225},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2226},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2227},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if context.flags &amp; CLAP_TRANSPORT_IS_LOOP_ACTIVE != 0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2228},{\\\\\\\"text\\\\\\\":\\\\\\\"                        &amp;&amp; context.flags &amp; CLAP_TRANSPORT_HAS_SECONDS_TIMELINE != 0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2229},{\\\\\\\"text\\\\\\\":\\\\\\\"                    {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2230},{\\\\\\\"text\\\\\\\":\\\\\\\"                        transport.loop_range_seconds = Some((\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2231},{\\\\\\\"text\\\\\\\":\\\\\\\"                            context.loop_start_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2232},{\\\\\\\"text\\\\\\\":\\\\\\\"                            context.loop_end_seconds as f64 / CLAP_SECTIME_FACTOR as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2233},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2234},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2235},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2236},{\\\\\\\"lineNumber\\\\\\\":2237},{\\\\\\\"text\\\\\\\":\\\\\\\"                let result = if buffer_is_valid {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2238},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut plugin = wrapper.plugin.lock();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2239},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // SAFETY: Shortening these borrows is safe as even if the plugin overwrites the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2240},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //         slices (which it cannot do without using unsafe code), then they\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2241},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //         would still be reset on the next iteration\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2242},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut aux = AuxiliaryBuffers {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2243},{\\\\\\\"text\\\\\\\":\\\\\\\"                        inputs: buffers.aux_inputs,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2244},{\\\\\\\"text\\\\\\\":\\\\\\\"                        outputs: buffers.aux_outputs,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2245},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2246},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut context = wrapper.make_process_context(transport);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2247},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let result = plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2248},{\\\\\\\"text\\\\\\\":\\\\\\\"                    wrapper.last_process_status.store(result);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2249},{\\\\\\\"text\\\\\\\":\\\\\\\"                    result\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2250},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2251},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessStatus::Normal\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2252},{\\\\\\\"text\\\\\\\":\\\\\\\"                };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2253},{\\\\\\\"lineNumber\\\\\\\":2254},{\\\\\\\"text\\\\\\\":\\\\\\\"                let clap_result = match result\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2255}]},\\\\\\\"score\\\\\\\":0.4073339104652405},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2252,\\\\\\\"column\\\\\\\":18},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2289,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\"                let clap_result = match result {\\\\\\\\n                    ProcessStatus::Error(err) =&gt; {\\\\\\\\n                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Process error: {}\\\\\\\\\\\\\\\", err);\\\\\\\\n\\\\\\\\n                        return CLAP_PROCESS_ERROR;\\\\\\\\n                    }\\\\\\\\n                    ProcessStatus::Normal =&gt; CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\\n                    ProcessStatus::Tail(_) =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\\n                    ProcessStatus::KeepAlive =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                // After processing audio, send all spooled events to the host. This include note\\\\\\\\n                // events.\\\\\\\\n                if !process.out_events.is_null() {\\\\\\\\n                    wrapper.handle_out_events(&amp;*process.out_events, block_start, total_buffer_len);\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                // If our block ends at the end of the buffer then that means there are no more\\\\\\\\n                // unprocessed (parameter) events. If there are more events, we'll just keep going\\\\\\\\n                // through this process until we've processed the entire buffer.\\\\\\\\n                if block_end == total_buffer_len {\\\\\\\\n                    break clap_result;\\\\\\\\n                } else {\\\\\\\\n                    block_start = block_end;\\\\\\\\n                }\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            // After processing audio, we'll check if the editor has sent us updated plugin state.\\\\\\\\n            // We'll restore that here on the audio thread to prevent changing the values during the\\\\\\\\n            // process call and also to prevent inconsistent state when the host also wants to load\\\\\\\\n            // plugin state.\\\\\\\\n            // FIXME: Zero capacity channels allocate on receiving, find a better alternative that\\\\\\\\n            //        doesn't do that\\\\\\\\n            let updated_state = permit_alloc(|| wrapper.updated_state_receiver.try_recv());\\\\\\\\n            if let Ok(mut state) = updated_state {\\\\\\\\n                wrapper.set_state_inner(&amp;mut state);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                let clap_result = match result {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2255},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessStatus::Error(err) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2256},{\\\\\\\"text\\\\\\\":\\\\\\\"                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Process error: {}\\\\\\\\\\\\\\\", err);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2257},{\\\\\\\"lineNumber\\\\\\\":2258},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return CLAP_PROCESS_ERROR;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2259},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2260},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessStatus::Normal =&gt; CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2261},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessStatus::Tail(_) =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2262},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessStatus::KeepAlive =&gt; CLAP_PROCESS_CONTINUE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2263},{\\\\\\\"text\\\\\\\":\\\\\\\"                };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2264},{\\\\\\\"lineNumber\\\\\\\":2265},{\\\\\\\"text\\\\\\\":\\\\\\\"                // After processing audio, send all spooled events to the host. This include note\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2266},{\\\\\\\"text\\\\\\\":\\\\\\\"                // events.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2267},{\\\\\\\"text\\\\\\\":\\\\\\\"                if !process.out_events.is_null() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2268},{\\\\\\\"text\\\\\\\":\\\\\\\"                    wrapper.handle_out_events(&amp;*process.out_events, block_start, total_buffer_len);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2269},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2270},{\\\\\\\"lineNumber\\\\\\\":2271},{\\\\\\\"text\\\\\\\":\\\\\\\"                // If our block ends at the end of the buffer then that means there are no more\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2272},{\\\\\\\"text\\\\\\\":\\\\\\\"                // unprocessed (parameter) events. If there are more events, we'll just keep going\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2273},{\\\\\\\"text\\\\\\\":\\\\\\\"                // through this process until we've processed the entire buffer.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2274},{\\\\\\\"text\\\\\\\":\\\\\\\"                if block_end == total_buffer_len {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2275},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break clap_result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2276},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2277},{\\\\\\\"text\\\\\\\":\\\\\\\"                    block_start = block_end;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2278},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2279},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2280},{\\\\\\\"lineNumber\\\\\\\":2281},{\\\\\\\"text\\\\\\\":\\\\\\\"            // After processing audio, we'll check if the editor has sent us updated plugin state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2282},{\\\\\\\"text\\\\\\\":\\\\\\\"            // We'll restore that here on the audio thread to prevent changing the values during the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2283},{\\\\\\\"text\\\\\\\":\\\\\\\"            // process call and also to prevent inconsistent state when the host also wants to load\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2284},{\\\\\\\"text\\\\\\\":\\\\\\\"            // plugin state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2285},{\\\\\\\"text\\\\\\\":\\\\\\\"            // FIXME: Zero capacity channels allocate on receiving, find a better alternative that\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2286},{\\\\\\\"text\\\\\\\":\\\\\\\"            //        doesn't do that\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2287},{\\\\\\\"text\\\\\\\":\\\\\\\"            let updated_state = permit_alloc(|| wrapper.updated_state_receiver.try_recv());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2288},{\\\\\\\"text\\\\\\\":\\\\\\\"            if let Ok(mut state) = updated_state {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2289},{\\\\\\\"text\\\\\\\":\\\\\\\"                wrapper.set_state_inner(&amp;mut state);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2290}]},\\\\\\\"score\\\\\\\":0.4070098400115967},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1437,\\\\\\\"column\\\\\\\":23},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1478,\\\\\\\"column\\\\\\\":69}},\\\\\\\"contents\\\\\\\":\\\\\\\"                }\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\\n                let event = &amp;*(event as *const clap_event_param_mod);\\\\\\\\n\\\\\\\\n                if event.note_id != -1 &amp;&amp; P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\\n                    match self.poly_mod_ids_by_hash.get(&amp;event.param_id) {\\\\\\\\n                        Some(poly_modulation_id) =&gt; {\\\\\\\\n                            // The modulation offset needs to be normalized to account for modulated\\\\\\\\n                            // integer or enum parameters\\\\\\\\n                            let param_ptr = self.param_by_hash[&amp;event.param_id];\\\\\\\\n                            let normalized_offset =\\\\\\\\n                                event.amount as f32 / param_ptr.step_count().unwrap_or(1) as f32;\\\\\\\\n\\\\\\\\n                            // The host may also add key and channel information here, but it may\\\\\\\\n                            // also pass -1. So not having that information here at all seems like\\\\\\\\n                            // the safest choice.\\\\\\\\n                            input_events.push_back(NoteEvent::PolyModulation {\\\\\\\\n                                timing,\\\\\\\\n                                voice_id: event.note_id,\\\\\\\\n                                poly_modulation_id: *poly_modulation_id,\\\\\\\\n                                normalized_offset,\\\\\\\\n                            });\\\\\\\\n\\\\\\\\n                            return;\\\\\\\\n                        }\\\\\\\\n                        None =&gt; nih_debug_assert_failure!(\\\\\\\\n                            \\\\\\\\\\\\\\\"Polyphonic modulation sent for a parameter without a poly modulation \\\\\\\\\\\\\\\\\\\\\\\\n                             ID\\\\\\\\\\\\\\\"\\\\\\\\n                        ),\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                self.update_plain_value_by_hash(\\\\\\\\n                    event.param_id,\\\\\\\\n                    ClapParamUpdate::PlainValueMod(event.amount),\\\\\\\\n                    self.current_buffer_config.load().map(|c| c.sample_rate),\\\\\\\\n                );\\\\\\\\n            }\\\\\\\\n            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT) =&gt; {\\\\\\\\n                let event = &amp;*(event as *const clap_event_transport);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1439},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1440},{\\\\\\\"text\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_PARAM_MOD) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1441},{\\\\\\\"text\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_param_mod);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1442},{\\\\\\\"lineNumber\\\\\\\":1443},{\\\\\\\"text\\\\\\\":\\\\\\\"                if event.note_id != -1 &amp;&amp; P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1444},{\\\\\\\"text\\\\\\\":\\\\\\\"                    match self.poly_mod_ids_by_hash.get(&amp;event.param_id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1445},{\\\\\\\"text\\\\\\\":\\\\\\\"                        Some(poly_modulation_id) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1446},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // The modulation offset needs to be normalized to account for modulated\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1447},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // integer or enum parameters\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1448},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let param_ptr = self.param_by_hash[&amp;event.param_id];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1449},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let normalized_offset =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1450},{\\\\\\\"text\\\\\\\":\\\\\\\"                                event.amount as f32 / param_ptr.step_count().unwrap_or(1) as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1451},{\\\\\\\"lineNumber\\\\\\\":1452},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // The host may also add key and channel information here, but it may\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1453},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // also pass -1. So not having that information here at all seems like\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1454},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // the safest choice.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1455},{\\\\\\\"text\\\\\\\":\\\\\\\"                            input_events.push_back(NoteEvent::PolyModulation {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1456},{\\\\\\\"text\\\\\\\":\\\\\\\"                                timing,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1457},{\\\\\\\"text\\\\\\\":\\\\\\\"                                voice_id: event.note_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1458},{\\\\\\\"text\\\\\\\":\\\\\\\"                                poly_modulation_id: *poly_modulation_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1459},{\\\\\\\"text\\\\\\\":\\\\\\\"                                normalized_offset,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1460},{\\\\\\\"text\\\\\\\":\\\\\\\"                            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1461},{\\\\\\\"lineNumber\\\\\\\":1462},{\\\\\\\"text\\\\\\\":\\\\\\\"                            return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1463},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1464},{\\\\\\\"text\\\\\\\":\\\\\\\"                        None =&gt; nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1465},{\\\\\\\"text\\\\\\\":\\\\\\\"                            \\\\\\\\\\\\\\\"Polyphonic modulation sent for a parameter without a poly modulation \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1466},{\\\\\\\"text\\\\\\\":\\\\\\\"                             ID\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1467},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1468},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1469},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1470},{\\\\\\\"lineNumber\\\\\\\":1471},{\\\\\\\"text\\\\\\\":\\\\\\\"                self.update_plain_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1472},{\\\\\\\"text\\\\\\\":\\\\\\\"                    event.param_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1473},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ClapParamUpdate::PlainValueMod(event.amount),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1474},{\\\\\\\"text\\\\\\\":\\\\\\\"                    self.current_buffer_config.load().map(|c| c.sample_rate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1475},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1476},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1477},{\\\\\\\"text\\\\\\\":\\\\\\\"            (CLAP_CORE_EVENT_SPACE_ID, CLAP_EVENT_TRANSPORT) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1478},{\\\\\\\"text\\\\\\\":\\\\\\\"                let event = &amp;*(event as *const clap_event_transport);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1479}]},\\\\\\\"score\\\\\\\":0.4062157869338989},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":923,\\\\\\\"column\\\\\\\":40},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":979}},\\\\\\\"contents\\\\\\\":\\\\\\\"(\\\\\\\\n        &amp;self,\\\\\\\\n        in_: &amp;clap_input_events,\\\\\\\\n        transport_info: &amp;mut *const clap_event_transport,\\\\\\\\n        current_sample_idx: usize,\\\\\\\\n        total_buffer_len: usize,\\\\\\\\n        resume_from_event_idx: usize,\\\\\\\\n        stop_predicate: impl Fn(*const clap_event_header) -&gt; bool,\\\\\\\\n    ) -&gt; Option&lt;(usize, usize)&gt; {\\\\\\\\n        let mut input_events = self.input_events.borrow_mut();\\\\\\\\n        input_events.clear();\\\\\\\\n\\\\\\\\n        // To achieve this, we'll always read one event ahead\\\\\\\\n        let num_events = clap_call! { in_=&gt;size(in_) };\\\\\\\\n        if num_events == 0 {\\\\\\\\n            return None;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let start_idx = resume_from_event_idx as u32;\\\\\\\\n        let mut event: *const clap_event_header = clap_call! { in_=&gt;get(in_, start_idx) };\\\\\\\\n        for next_event_idx in (start_idx + 1)..num_events {\\\\\\\\n            self.handle_in_event(\\\\\\\\n                event,\\\\\\\\n                &amp;mut input_events,\\\\\\\\n                Some(transport_info),\\\\\\\\n                current_sample_idx,\\\\\\\\n                total_buffer_len,\\\\\\\\n            );\\\\\\\\n\\\\\\\\n            // Stop just before the next parameter change or transport information event at a sample\\\\\\\\n            // after the current sample\\\\\\\\n            let next_event: *const clap_event_header = clap_call! { in_=&gt;get(in_, next_event_idx) };\\\\\\\\n            if (*next_event).time &gt; current_sample_idx as u32 &amp;&amp; stop_predicate(next_event) {\\\\\\\\n                return Some(((*next_event).time as usize, next_event_idx as usize));\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            event = next_event;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // Don't forget about the last event\\\\\\\\n        self.handle_in_event(\\\\\\\\n            event,\\\\\\\\n            &amp;mut input_events,\\\\\\\\n            Some(transport_info),\\\\\\\\n            current_sample_idx,\\\\\\\\n            total_buffer_len,\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        None\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Write the unflushed parameter changes to the host's output event queue. The sample index is\\\\\\\\n    /// used as part of splitting up the input buffer for sample accurate automation changes. This\\\\\\\\n    /// will also modify the actual parameter values, since we should only do that while the wrapped\\\\\\\\n    /// plugin is not actually processing audio.\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":924},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":925},{\\\\\\\"text\\\\\\\":\\\\\\\"        in_: &amp;clap_input_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":926},{\\\\\\\"text\\\\\\\":\\\\\\\"        transport_info: &amp;mut *const clap_event_transport,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":927},{\\\\\\\"text\\\\\\\":\\\\\\\"        current_sample_idx: usize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":928},{\\\\\\\"text\\\\\\\":\\\\\\\"        total_buffer_len: usize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":929},{\\\\\\\"text\\\\\\\":\\\\\\\"        resume_from_event_idx: usize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":930},{\\\\\\\"text\\\\\\\":\\\\\\\"        stop_predicate: impl Fn(*const clap_event_header) -&gt; bool,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":931},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; Option&lt;(usize, usize)&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":932},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut input_events = self.input_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":933},{\\\\\\\"text\\\\\\\":\\\\\\\"        input_events.clear();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":934},{\\\\\\\"lineNumber\\\\\\\":935},{\\\\\\\"text\\\\\\\":\\\\\\\"        // To achieve this, we'll always read one event ahead\\\\\\\",\\\\\\\"lineNumber\\\\\\\":936},{\\\\\\\"text\\\\\\\":\\\\\\\"        let num_events = clap_call! { in_=&gt;size(in_) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":937},{\\\\\\\"text\\\\\\\":\\\\\\\"        if num_events == 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":938},{\\\\\\\"text\\\\\\\":\\\\\\\"            return None;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":939},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":940},{\\\\\\\"lineNumber\\\\\\\":941},{\\\\\\\"text\\\\\\\":\\\\\\\"        let start_idx = resume_from_event_idx as u32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":942},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut event: *const clap_event_header = clap_call! { in_=&gt;get(in_, start_idx) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":943},{\\\\\\\"text\\\\\\\":\\\\\\\"        for next_event_idx in (start_idx + 1)..num_events {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":944},{\\\\\\\"text\\\\\\\":\\\\\\\"            self.handle_in_event(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":945},{\\\\\\\"text\\\\\\\":\\\\\\\"                event,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":946},{\\\\\\\"text\\\\\\\":\\\\\\\"                &amp;mut input_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":947},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(transport_info),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":948},{\\\\\\\"text\\\\\\\":\\\\\\\"                current_sample_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":949},{\\\\\\\"text\\\\\\\":\\\\\\\"                total_buffer_len,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":950},{\\\\\\\"text\\\\\\\":\\\\\\\"            );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":951},{\\\\\\\"lineNumber\\\\\\\":952},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Stop just before the next parameter change or transport information event at a sample\\\\\\\",\\\\\\\"lineNumber\\\\\\\":953},{\\\\\\\"text\\\\\\\":\\\\\\\"            // after the current sample\\\\\\\",\\\\\\\"lineNumber\\\\\\\":954},{\\\\\\\"text\\\\\\\":\\\\\\\"            let next_event: *const clap_event_header = clap_call! { in_=&gt;get(in_, next_event_idx) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":955},{\\\\\\\"text\\\\\\\":\\\\\\\"            if (*next_event).time &gt; current_sample_idx as u32 &amp;&amp; stop_predicate(next_event) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":956},{\\\\\\\"text\\\\\\\":\\\\\\\"                return Some(((*next_event).time as usize, next_event_idx as usize));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":957},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":958},{\\\\\\\"lineNumber\\\\\\\":959},{\\\\\\\"text\\\\\\\":\\\\\\\"            event = next_event;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":960},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":961},{\\\\\\\"lineNumber\\\\\\\":962},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Don't forget about the last event\\\\\\\",\\\\\\\"lineNumber\\\\\\\":963},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.handle_in_event(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":964},{\\\\\\\"text\\\\\\\":\\\\\\\"            event,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":965},{\\\\\\\"text\\\\\\\":\\\\\\\"            &amp;mut input_events,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":966},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(transport_info),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":967},{\\\\\\\"text\\\\\\\":\\\\\\\"            current_sample_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":968},{\\\\\\\"text\\\\\\\":\\\\\\\"            total_buffer_len,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":969},{\\\\\\\"text\\\\\\\":\\\\\\\"        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":970},{\\\\\\\"lineNumber\\\\\\\":971},{\\\\\\\"text\\\\\\\":\\\\\\\"        None\\\\\\\",\\\\\\\"lineNumber\\\\\\\":972},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":973},{\\\\\\\"lineNumber\\\\\\\":974},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Write the unflushed parameter changes to the host's output event queue. The sample index is\\\\\\\",\\\\\\\"lineNumber\\\\\\\":975},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// used as part of splitting up the input buffer for sample accurate automation changes. This\\\\\\\",\\\\\\\"lineNumber\\\\\\\":976},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// will also modify the actual parameter values, since we should only do that while the wrapped\\\\\\\",\\\\\\\"lineNumber\\\\\\\":977},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// plugin is not actually processing audio.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":978},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":979}]},\\\\\\\"score\\\\\\\":0.3887815475463867},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":389,\\\\\\\"column\\\\\\\":17},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":428}},\\\\\\\"contents\\\\\\\":\\\\\\\"            }\\\\\\\\n            Task::LatencyChanged =&gt; match &amp;*self.host_latency.borrow() {\\\\\\\\n                Some(host_latency) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n\\\\\\\\n                    // XXX: The CLAP docs mention that you should request a restart if this happens\\\\\\\\n                    //      while the plugin is activated (which is not entirely the same thing as\\\\\\\\n                    //      is processing, but we'll treat it as the same thing). In practice just\\\\\\\\n                    //      calling the latency changed function also seems to work just fine.\\\\\\\\n                    if self.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                        unsafe_clap_call! { &amp;*self.host_callback=&gt;request_restart(&amp;*self.host_callback) };\\\\\\\\n                    } else {\\\\\\\\n                        unsafe_clap_call! { host_latency=&gt;changed(&amp;*self.host_callback) };\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the latency extension\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n            Task::VoiceInfoChanged =&gt; match &amp;*self.host_voice_info.borrow() {\\\\\\\\n                Some(host_voice_info) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n                    unsafe_clap_call! { host_voice_info=&gt;changed(&amp;*self.host_callback) };\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the voice-info extension\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n            Task::RescanParamValues =&gt; match &amp;*self.host_params.borrow() {\\\\\\\\n                Some(host_params) =&gt; {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n                    unsafe_clap_call! { host_params=&gt;rescan(&amp;*self.host_callback, CLAP_PARAM_RESCAN_VALUES) };\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"The host does not support parameters? What?\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n        };\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: ClapPlugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    /// # Safety\\\\\\\\n    ///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":391},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::LatencyChanged =&gt; match &amp;*self.host_latency.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":392},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(host_latency) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":393},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(is_gui_thread);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":394},{\\\\\\\"lineNumber\\\\\\\":395},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // XXX: The CLAP docs mention that you should request a restart if this happens\\\\\\\",\\\\\\\"lineNumber\\\\\\\":396},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //      while the plugin is activated (which is not entirely the same thing as\\\\\\\",\\\\\\\"lineNumber\\\\\\\":397},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //      is processing, but we'll treat it as the same thing). In practice just\\\\\\\",\\\\\\\"lineNumber\\\\\\\":398},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //      calling the latency changed function also seems to work just fine.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":399},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if self.is_processing.load(Ordering::SeqCst) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":400},{\\\\\\\"text\\\\\\\":\\\\\\\"                        unsafe_clap_call! { &amp;*self.host_callback=&gt;request_restart(&amp;*self.host_callback) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":401},{\\\\\\\"text\\\\\\\":\\\\\\\"                    } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":402},{\\\\\\\"text\\\\\\\":\\\\\\\"                        unsafe_clap_call! { host_latency=&gt;changed(&amp;*self.host_callback) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":403},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":404},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":405},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the latency extension\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":406},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":407},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::VoiceInfoChanged =&gt; match &amp;*self.host_voice_info.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":408},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(host_voice_info) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":409},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(is_gui_thread);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":410},{\\\\\\\"text\\\\\\\":\\\\\\\"                    unsafe_clap_call! { host_voice_info=&gt;changed(&amp;*self.host_callback) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":411},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":412},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Host does not support the voice-info extension\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":413},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":414},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::RescanParamValues =&gt; match &amp;*self.host_params.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":415},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(host_params) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":416},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(is_gui_thread);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":417},{\\\\\\\"text\\\\\\\":\\\\\\\"                    unsafe_clap_call! { host_params=&gt;rescan(&amp;*self.host_callback, CLAP_PARAM_RESCAN_VALUES) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":418},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":419},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"The host does not support parameters? What?\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":420},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":421},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":422},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":423},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":424},{\\\\\\\"lineNumber\\\\\\\":425},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":426},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// # Safety\\\\\\\",\\\\\\\"lineNumber\\\\\\\":427},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":428}]},\\\\\\\"score\\\\\\\":0.38871413469314575},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1729,\\\\\\\"column\\\\\\\":9},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1772}},\\\\\\\"contents\\\\\\\":\\\\\\\"        // After the state has been updated, notify the host about the new parameter values\\\\\\\\n        let task_posted = self.schedule_gui(Task::RescanParamValues);\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn set_latency_samples(&amp;self, samples: u32) {\\\\\\\\n        // Only make a callback if it's actually needed\\\\\\\\n        // XXX: For CLAP we could move this handling to the Plugin struct, but it may be worthwhile\\\\\\\\n        //      to keep doing it this way to stay consistent with VST3.\\\\\\\\n        let old_latency = self.current_latency.swap(samples, Ordering::SeqCst);\\\\\\\\n        if old_latency != samples {\\\\\\\\n            let task_posted = self.schedule_gui(Task::LatencyChanged);\\\\\\\\n            nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    pub fn set_current_voice_capacity(&amp;self, capacity: u32) {\\\\\\\\n        match P::CLAP_POLY_MODULATION_CONFIG {\\\\\\\\n            Some(config) =&gt; {\\\\\\\\n                let clamped_capacity = capacity.clamp(1, config.max_voice_capacity);\\\\\\\\n                nih_debug_assert_eq!(\\\\\\\\n                    capacity,\\\\\\\\n                    clamped_capacity,\\\\\\\\n                    \\\\\\\\\\\\\\\"The current voice capacity must be between 1 and the maximum capacity\\\\\\\\\\\\\\\"\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                if clamped_capacity != self.current_voice_capacity.load(Ordering::Relaxed) {\\\\\\\\n                    self.current_voice_capacity\\\\\\\\n                        .store(clamped_capacity, Ordering::Relaxed);\\\\\\\\n                    let task_posted = self.schedule_gui(Task::VoiceInfoChanged);\\\\\\\\n                    nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\n                \\\\\\\\\\\\\\\"Configuring the current voice capacity is only possible when \\\\\\\\\\\\\\\\\\\\\\\\n                 'ClapPlugin::CLAP_POLY_MODULATION_CONFIG' is set\\\\\\\\\\\\\\\"\\\\\\\\n            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Immediately set the plugin state. Returns &#96;false&#96; if the deserialization failed. The plugin\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        // After the state has been updated, notify the host about the new parameter values\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1732},{\\\\\\\"text\\\\\\\":\\\\\\\"        let task_posted = self.schedule_gui(Task::RescanParamValues);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1733},{\\\\\\\"text\\\\\\\":\\\\\\\"        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1734},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1735},{\\\\\\\"lineNumber\\\\\\\":1736},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_latency_samples(&amp;self, samples: u32) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1737},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Only make a callback if it's actually needed\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1738},{\\\\\\\"text\\\\\\\":\\\\\\\"        // XXX: For CLAP we could move this handling to the Plugin struct, but it may be worthwhile\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1739},{\\\\\\\"text\\\\\\\":\\\\\\\"        //      to keep doing it this way to stay consistent with VST3.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1740},{\\\\\\\"text\\\\\\\":\\\\\\\"        let old_latency = self.current_latency.swap(samples, Ordering::SeqCst);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1741},{\\\\\\\"text\\\\\\\":\\\\\\\"        if old_latency != samples {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1742},{\\\\\\\"text\\\\\\\":\\\\\\\"            let task_posted = self.schedule_gui(Task::LatencyChanged);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1743},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1744},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1745},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1746},{\\\\\\\"lineNumber\\\\\\\":1747},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_current_voice_capacity(&amp;self, capacity: u32) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1748},{\\\\\\\"text\\\\\\\":\\\\\\\"        match P::CLAP_POLY_MODULATION_CONFIG {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1749},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(config) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1750},{\\\\\\\"text\\\\\\\":\\\\\\\"                let clamped_capacity = capacity.clamp(1, config.max_voice_capacity);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1751},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1752},{\\\\\\\"text\\\\\\\":\\\\\\\"                    capacity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1753},{\\\\\\\"text\\\\\\\":\\\\\\\"                    clamped_capacity,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1754},{\\\\\\\"text\\\\\\\":\\\\\\\"                    \\\\\\\\\\\\\\\"The current voice capacity must be between 1 and the maximum capacity\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1755},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1756},{\\\\\\\"lineNumber\\\\\\\":1757},{\\\\\\\"text\\\\\\\":\\\\\\\"                if clamped_capacity != self.current_voice_capacity.load(Ordering::Relaxed) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1758},{\\\\\\\"text\\\\\\\":\\\\\\\"                    self.current_voice_capacity\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1759},{\\\\\\\"text\\\\\\\":\\\\\\\"                        .store(clamped_capacity, Ordering::Relaxed);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1760},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let task_posted = self.schedule_gui(Task::VoiceInfoChanged);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1761},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1762},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1763},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1764},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1765},{\\\\\\\"text\\\\\\\":\\\\\\\"                \\\\\\\\\\\\\\\"Configuring the current voice capacity is only possible when \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1766},{\\\\\\\"text\\\\\\\":\\\\\\\"                 'ClapPlugin::CLAP_POLY_MODULATION_CONFIG' is set\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1767},{\\\\\\\"text\\\\\\\":\\\\\\\"            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1768},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1769},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1770},{\\\\\\\"lineNumber\\\\\\\":1771},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Immediately set the plugin state. Returns &#96;false&#96; if the deserialization failed. The plugin\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1772}]},\\\\\\\"score\\\\\\\":0.3874070942401886},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1910,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1951,\\\\\\\"column\\\\\\\":35}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.plugin.lock().deactivate();\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn start_processing(plugin: *const clap_plugin) -&gt; bool {\\\\\\\\n        // We just need to keep track of our processing state so we can request a flush when\\\\\\\\n        // updating parameters from the GUI while the processing loop isn't running\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        // Always reset the processing status when the plugin gets activated or deactivated\\\\\\\\n        wrapper.last_process_status.store(ProcessStatus::Normal);\\\\\\\\n        wrapper.is_processing.store(true, Ordering::SeqCst);\\\\\\\\n\\\\\\\\n        // To be consistent with the VST3 wrapper, we'll also reset the buffers here in addition to\\\\\\\\n        // the dedicated &#96;reset()&#96; function.\\\\\\\\n        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\\n\\\\\\\\n        true\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn stop_processing(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        wrapper.is_processing.store(false, Ordering::SeqCst);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn reset(plugin: *const clap_plugin) {\\\\\\\\n        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn process(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1913},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1914},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1915},{\\\\\\\"lineNumber\\\\\\\":1916},{\\\\\\\"text\\\\\\\":\\\\\\\"        wrapper.plugin.lock().deactivate();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1917},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1918},{\\\\\\\"lineNumber\\\\\\\":1919},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn start_processing(plugin: *const clap_plugin) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1920},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We just need to keep track of our processing state so we can request a flush when\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1921},{\\\\\\\"text\\\\\\\":\\\\\\\"        // updating parameters from the GUI while the processing loop isn't running\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1922},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1923},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1924},{\\\\\\\"lineNumber\\\\\\\":1925},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Always reset the processing status when the plugin gets activated or deactivated\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1926},{\\\\\\\"text\\\\\\\":\\\\\\\"        wrapper.last_process_status.store(ProcessStatus::Normal);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1927},{\\\\\\\"text\\\\\\\":\\\\\\\"        wrapper.is_processing.store(true, Ordering::SeqCst);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1928},{\\\\\\\"lineNumber\\\\\\\":1929},{\\\\\\\"text\\\\\\\":\\\\\\\"        // To be consistent with the VST3 wrapper, we'll also reset the buffers here in addition to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1930},{\\\\\\\"text\\\\\\\":\\\\\\\"        // the dedicated &#96;reset()&#96; function.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1931},{\\\\\\\"text\\\\\\\":\\\\\\\"        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1932},{\\\\\\\"lineNumber\\\\\\\":1933},{\\\\\\\"text\\\\\\\":\\\\\\\"        true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1934},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1935},{\\\\\\\"lineNumber\\\\\\\":1936},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn stop_processing(plugin: *const clap_plugin) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1937},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1938},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1939},{\\\\\\\"lineNumber\\\\\\\":1940},{\\\\\\\"text\\\\\\\":\\\\\\\"        wrapper.is_processing.store(false, Ordering::SeqCst);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1941},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1942},{\\\\\\\"lineNumber\\\\\\\":1943},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn reset(plugin: *const clap_plugin) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1944},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!((), plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1945},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1946},{\\\\\\\"lineNumber\\\\\\\":1947},{\\\\\\\"text\\\\\\\":\\\\\\\"        process_wrapper(|| wrapper.plugin.lock().reset());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1948},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1949},{\\\\\\\"lineNumber\\\\\\\":1950},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn process(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1951},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1952}]},\\\\\\\"score\\\\\\\":0.37981081008911133},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2966,\\\\\\\"column\\\\\\\":13},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":3028,\\\\\\\"column\\\\\\\":41}},\\\\\\\"contents\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_value_to_text(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_id: clap_id,\\\\\\\\n        value: f64,\\\\\\\\n        display: *mut c_char,\\\\\\\\n        size: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, display);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let dest = std::slice::from_raw_parts_mut(display, size as usize);\\\\\\\\n\\\\\\\\n        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                strlcpy(\\\\\\\\n                    dest,\\\\\\\\n                    // CLAP does not have a separate unit, so we'll include the unit here\\\\\\\\n                    &amp;param_ptr.normalized_value_to_string(\\\\\\\\n                        value as f32 / param_ptr.step_count().unwrap_or(1) as f32,\\\\\\\\n                        true,\\\\\\\\n                    ),\\\\\\\\n                );\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_text_to_value(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_id: clap_id,\\\\\\\\n        display: *const c_char,\\\\\\\\n        value: *mut f64,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, display, value);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let display = match CStr::from_ptr(display).to_str() {\\\\\\\\n            Ok(s) =&gt; s,\\\\\\\\n            Err(_) =&gt; return false,\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                let normalized_value = match param_ptr.string_to_normalized_value(display) {\\\\\\\\n                    Some(v) =&gt; v as f64,\\\\\\\\n                    None =&gt; return false,\\\\\\\\n                };\\\\\\\\n                *value = normalized_value * param_ptr.step_count().unwrap_or(1) as f64;\\\\\\\\n\\\\\\\\n                true\\\\\\\\n            }\\\\\\\\n            _ =&gt; false,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_flush\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2968},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2969},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2970},{\\\\\\\"lineNumber\\\\\\\":2971},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_value_to_text(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2972},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2973},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: clap_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2974},{\\\\\\\"text\\\\\\\":\\\\\\\"        value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2975},{\\\\\\\"text\\\\\\\":\\\\\\\"        display: *mut c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2976},{\\\\\\\"text\\\\\\\":\\\\\\\"        size: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2977},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2978},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data, display);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2979},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2980},{\\\\\\\"lineNumber\\\\\\\":2981},{\\\\\\\"text\\\\\\\":\\\\\\\"        let dest = std::slice::from_raw_parts_mut(display, size as usize);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2982},{\\\\\\\"lineNumber\\\\\\\":2983},{\\\\\\\"text\\\\\\\":\\\\\\\"        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2984},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2985},{\\\\\\\"text\\\\\\\":\\\\\\\"                strlcpy(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2986},{\\\\\\\"text\\\\\\\":\\\\\\\"                    dest,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2987},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // CLAP does not have a separate unit, so we'll include the unit here\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2988},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;param_ptr.normalized_value_to_string(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2989},{\\\\\\\"text\\\\\\\":\\\\\\\"                        value as f32 / param_ptr.step_count().unwrap_or(1) as f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2990},{\\\\\\\"text\\\\\\\":\\\\\\\"                        true,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2991},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2992},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2993},{\\\\\\\"lineNumber\\\\\\\":2994},{\\\\\\\"text\\\\\\\":\\\\\\\"                true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2995},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2996},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2997},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2998},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2999},{\\\\\\\"lineNumber\\\\\\\":3000},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_text_to_value(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3001},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3002},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_id: clap_id,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3003},{\\\\\\\"text\\\\\\\":\\\\\\\"        display: *const c_char,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3004},{\\\\\\\"text\\\\\\\":\\\\\\\"        value: *mut f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3005},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3006},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data, display, value);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3007},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3008},{\\\\\\\"lineNumber\\\\\\\":3009},{\\\\\\\"text\\\\\\\":\\\\\\\"        let display = match CStr::from_ptr(display).to_str() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3010},{\\\\\\\"text\\\\\\\":\\\\\\\"            Ok(s) =&gt; s,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3011},{\\\\\\\"text\\\\\\\":\\\\\\\"            Err(_) =&gt; return false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3012},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3013},{\\\\\\\"lineNumber\\\\\\\":3014},{\\\\\\\"text\\\\\\\":\\\\\\\"        match wrapper.param_by_hash.get(&amp;param_id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3015},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3016},{\\\\\\\"text\\\\\\\":\\\\\\\"                let normalized_value = match param_ptr.string_to_normalized_value(display) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3017},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Some(v) =&gt; v as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3018},{\\\\\\\"text\\\\\\\":\\\\\\\"                    None =&gt; return false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3019},{\\\\\\\"text\\\\\\\":\\\\\\\"                };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3020},{\\\\\\\"text\\\\\\\":\\\\\\\"                *value = normalized_value * param_ptr.step_count().unwrap_or(1) as f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3021},{\\\\\\\"lineNumber\\\\\\\":3022},{\\\\\\\"text\\\\\\\":\\\\\\\"                true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3023},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3024},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; false,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3025},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3026},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3027},{\\\\\\\"lineNumber\\\\\\\":3028},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_flush\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3029}]},\\\\\\\"score\\\\\\\":0.3793627619743347},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2889,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":2938,\\\\\\\"column\\\\\\\":53}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_info(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        param_index: u32,\\\\\\\\n        param_info: *mut clap_param_info,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data, param_info);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        if param_index &gt; Self::ext_params_count(plugin) {\\\\\\\\n            return false;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let param_hash = &amp;wrapper.param_hashes[param_index as usize];\\\\\\\\n        let param_group = &amp;wrapper.param_group_by_hash[param_hash];\\\\\\\\n        let param_ptr = &amp;wrapper.param_by_hash[param_hash];\\\\\\\\n        let default_value = param_ptr.default_normalized_value();\\\\\\\\n        let step_count = param_ptr.step_count();\\\\\\\\n        let flags = param_ptr.flags();\\\\\\\\n        let automatable = !flags.contains(ParamFlags::NON_AUTOMATABLE);\\\\\\\\n        let hidden = flags.contains(ParamFlags::HIDDEN);\\\\\\\\n        let is_bypass = flags.contains(ParamFlags::BYPASS);\\\\\\\\n\\\\\\\\n        *param_info = std::mem::zeroed();\\\\\\\\n\\\\\\\\n        // TODO: We don't use the cookies at this point. In theory this would be faster than the ID\\\\\\\\n        //       hashmap lookup, but for now we'll stay consistent with the VST3 implementation.\\\\\\\\n        let param_info = &amp;mut *param_info;\\\\\\\\n        param_info.id = *param_hash;\\\\\\\\n        // TODO: Somehow expose per note/channel/port modulation\\\\\\\\n        param_info.flags = 0;\\\\\\\\n        if automatable &amp;&amp; !hidden {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_AUTOMATABLE | CLAP_PARAM_IS_MODULATABLE;\\\\\\\\n            if wrapper.poly_mod_ids_by_hash.contains_key(param_hash) {\\\\\\\\n                param_info.flags |= CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID;\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n        if hidden {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_HIDDEN | CLAP_PARAM_IS_READONLY;\\\\\\\\n        }\\\\\\\\n        if is_bypass {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_BYPASS\\\\\\\\n        }\\\\\\\\n        if step_count.is_some() {\\\\\\\\n            param_info.flags |= CLAP_PARAM_IS_STEPPED\\\\\\\\n        }\\\\\\\\n        param_info.cookie = std::ptr::null_mut();\\\\\\\\n        strlcpy(&amp;mut param_info.name, param_ptr.name());\\\\\\\\n        strlcpy(&amp;mut param_info.module, param_group);\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn ext_params_get_info(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2892},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2893},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_index: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2894},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info: *mut clap_param_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2895},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2896},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data, param_info);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2897},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2898},{\\\\\\\"lineNumber\\\\\\\":2899},{\\\\\\\"text\\\\\\\":\\\\\\\"        if param_index &gt; Self::ext_params_count(plugin) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2900},{\\\\\\\"text\\\\\\\":\\\\\\\"            return false;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2901},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2902},{\\\\\\\"lineNumber\\\\\\\":2903},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_hash = &amp;wrapper.param_hashes[param_index as usize];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2904},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_group = &amp;wrapper.param_group_by_hash[param_hash];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2905},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_ptr = &amp;wrapper.param_by_hash[param_hash];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2906},{\\\\\\\"text\\\\\\\":\\\\\\\"        let default_value = param_ptr.default_normalized_value();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2907},{\\\\\\\"text\\\\\\\":\\\\\\\"        let step_count = param_ptr.step_count();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2908},{\\\\\\\"text\\\\\\\":\\\\\\\"        let flags = param_ptr.flags();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2909},{\\\\\\\"text\\\\\\\":\\\\\\\"        let automatable = !flags.contains(ParamFlags::NON_AUTOMATABLE);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2910},{\\\\\\\"text\\\\\\\":\\\\\\\"        let hidden = flags.contains(ParamFlags::HIDDEN);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2911},{\\\\\\\"text\\\\\\\":\\\\\\\"        let is_bypass = flags.contains(ParamFlags::BYPASS);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2912},{\\\\\\\"lineNumber\\\\\\\":2913},{\\\\\\\"text\\\\\\\":\\\\\\\"        *param_info = std::mem::zeroed();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2914},{\\\\\\\"lineNumber\\\\\\\":2915},{\\\\\\\"text\\\\\\\":\\\\\\\"        // TODO: We don't use the cookies at this point. In theory this would be faster than the ID\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2916},{\\\\\\\"text\\\\\\\":\\\\\\\"        //       hashmap lookup, but for now we'll stay consistent with the VST3 implementation.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2917},{\\\\\\\"text\\\\\\\":\\\\\\\"        let param_info = &amp;mut *param_info;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2918},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.id = *param_hash;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2919},{\\\\\\\"text\\\\\\\":\\\\\\\"        // TODO: Somehow expose per note/channel/port modulation\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2920},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.flags = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2921},{\\\\\\\"text\\\\\\\":\\\\\\\"        if automatable &amp;&amp; !hidden {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2922},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_info.flags |= CLAP_PARAM_IS_AUTOMATABLE | CLAP_PARAM_IS_MODULATABLE;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2923},{\\\\\\\"text\\\\\\\":\\\\\\\"            if wrapper.poly_mod_ids_by_hash.contains_key(param_hash) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2924},{\\\\\\\"text\\\\\\\":\\\\\\\"                param_info.flags |= CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2925},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2926},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2927},{\\\\\\\"text\\\\\\\":\\\\\\\"        if hidden {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2928},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_info.flags |= CLAP_PARAM_IS_HIDDEN | CLAP_PARAM_IS_READONLY;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2929},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2930},{\\\\\\\"text\\\\\\\":\\\\\\\"        if is_bypass {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2931},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_info.flags |= CLAP_PARAM_IS_BYPASS\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2932},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2933},{\\\\\\\"text\\\\\\\":\\\\\\\"        if step_count.is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2934},{\\\\\\\"text\\\\\\\":\\\\\\\"            param_info.flags |= CLAP_PARAM_IS_STEPPED\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2935},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2936},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_info.cookie = std::ptr::null_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2937},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut param_info.name, param_ptr.name());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2938},{\\\\\\\"text\\\\\\\":\\\\\\\"        strlcpy(&amp;mut param_info.module, param_group);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2939}]},\\\\\\\"score\\\\\\\":0.374470591545105},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":296},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":319,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\\npub enum OutputParamEvent {\\\\\\\\n    /// Begin an automation gesture. This must always be sent before sending [&#96;SetValue&#96;].\\\\\\\\n    BeginGesture { param_hash: u32 },\\\\\\\\n    /// Change the value of a parameter using a plain CLAP value, aka the normalized value\\\\\\\\n    /// multiplied by the number of steps.\\\\\\\\n    SetValue {\\\\\\\\n        /// The internal hash for the parameter.\\\\\\\\n        param_hash: u32,\\\\\\\\n        /// The 'plain' value as reported to CLAP. This is the normalized value multiplied by\\\\\\\\n        /// [&#96;params::step_size()&#96;][crate::params::step_size()].\\\\\\\\n        clap_plain_value: f64,\\\\\\\\n    },\\\\\\\\n    /// Begin an automation gesture. This must always be sent after sending one or more [&#96;SetValue&#96;]\\\\\\\\n    /// events.\\\\\\\\n    EndGesture { param_hash: u32 },\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Because CLAP has this [&#96;clap_host::request_host_callback()&#96;] function, we don't need to use\\\\\\\\n/// &#96;OsEventLoop&#96; and can instead just request a main thread callback directly.\\\\\\\\nimpl&lt;P: ClapPlugin&gt; EventLoop&lt;Task&lt;P&gt;, Wrapper&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\\n    fn new_and_spawn(_executor: Weak&lt;Self&gt;) -&gt; Self {\\\\\\\\n        panic!(\\\\\\\\\\\\\\\"What are you doing\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Clone)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":297},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum OutputParamEvent {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":298},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Begin an automation gesture. This must always be sent before sending [&#96;SetValue&#96;].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":299},{\\\\\\\"text\\\\\\\":\\\\\\\"    BeginGesture { param_hash: u32 },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":300},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Change the value of a parameter using a plain CLAP value, aka the normalized value\\\\\\\",\\\\\\\"lineNumber\\\\\\\":301},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// multiplied by the number of steps.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":302},{\\\\\\\"text\\\\\\\":\\\\\\\"    SetValue {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":303},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The internal hash for the parameter.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":304},{\\\\\\\"text\\\\\\\":\\\\\\\"        param_hash: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":305},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The 'plain' value as reported to CLAP. This is the normalized value multiplied by\\\\\\\",\\\\\\\"lineNumber\\\\\\\":306},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// [&#96;params::step_size()&#96;][crate::params::step_size()].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":307},{\\\\\\\"text\\\\\\\":\\\\\\\"        clap_plain_value: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":308},{\\\\\\\"text\\\\\\\":\\\\\\\"    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":309},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Begin an automation gesture. This must always be sent after sending one or more [&#96;SetValue&#96;]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":310},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// events.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":311},{\\\\\\\"text\\\\\\\":\\\\\\\"    EndGesture { param_hash: u32 },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":312},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":313},{\\\\\\\"lineNumber\\\\\\\":314},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Because CLAP has this [&#96;clap_host::request_host_callback()&#96;] function, we don't need to use\\\\\\\",\\\\\\\"lineNumber\\\\\\\":315},{\\\\\\\"text\\\\\\\":\\\\\\\"/// &#96;OsEventLoop&#96; and can instead just request a main thread callback directly.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":316},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; EventLoop&lt;Task&lt;P&gt;, Wrapper&lt;P&gt;&gt; for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":317},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn new_and_spawn(_executor: Weak&lt;Self&gt;) -&gt; Self {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":318},{\\\\\\\"text\\\\\\\":\\\\\\\"        panic!(\\\\\\\\\\\\\\\"What are you doing\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":319},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":320}]},\\\\\\\"score\\\\\\\":0.36707571148872375},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1866,\\\\\\\"column\\\\\\\":19},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1912,\\\\\\\"column\\\\\\\":63}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate(\\\\\\\\n        plugin: *const clap_plugin,\\\\\\\\n        sample_rate: f64,\\\\\\\\n        min_frames_count: u32,\\\\\\\\n        max_frames_count: u32,\\\\\\\\n    ) -&gt; bool {\\\\\\\\n        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\\n        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\\n\\\\\\\\n        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\\n        let buffer_config = BufferConfig {\\\\\\\\n            sample_rate: sample_rate as f32,\\\\\\\\n            min_buffer_size: Some(min_frames_count),\\\\\\\\n            max_buffer_size: max_frames_count,\\\\\\\\n            process_mode: wrapper.current_process_mode.load(),\\\\\\\\n        };\\\\\\\\n\\\\\\\\n        // Before initializing the plugin, make sure all smoothers are set the the default values\\\\\\\\n        for param in wrapper.param_by_hash.values() {\\\\\\\\n            param.update_smoother(buffer_config.sample_rate, true);\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\\n        let mut init_context = wrapper.make_init_context();\\\\\\\\n        let mut plugin = wrapper.plugin.lock();\\\\\\\\n        if plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context) {\\\\\\\\n            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\\n            //       this function\\\\\\\\n\\\\\\\\n            // This preallocates enough space so we can transform all of the host's raw channel\\\\\\\\n            // pointers into a set of &#96;Buffer&#96; objects for the plugin's main and auxiliary IO\\\\\\\\n            *wrapper.buffer_manager.borrow_mut() =\\\\\\\\n                BufferManager::for_audio_io_layout(max_frames_count as usize, audio_io_layout);\\\\\\\\n\\\\\\\\n            // Also store this for later, so we can reinitialize the plugin after restoring state\\\\\\\\n            wrapper.current_buffer_config.store(Some(buffer_config));\\\\\\\\n\\\\\\\\n            true\\\\\\\\n        } else {\\\\\\\\n            false\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1868},{\\\\\\\"lineNumber\\\\\\\":1869},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn activate(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1870},{\\\\\\\"text\\\\\\\":\\\\\\\"        plugin: *const clap_plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1871},{\\\\\\\"text\\\\\\\":\\\\\\\"        sample_rate: f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1872},{\\\\\\\"text\\\\\\\":\\\\\\\"        min_frames_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1873},{\\\\\\\"text\\\\\\\":\\\\\\\"        max_frames_count: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1874},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1875},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(false, plugin, (*plugin).plugin_data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1876},{\\\\\\\"text\\\\\\\":\\\\\\\"        let wrapper = &amp;*((*plugin).plugin_data as *const Self);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1877},{\\\\\\\"lineNumber\\\\\\\":1878},{\\\\\\\"text\\\\\\\":\\\\\\\"        let audio_io_layout = wrapper.current_audio_io_layout.load();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1879},{\\\\\\\"text\\\\\\\":\\\\\\\"        let buffer_config = BufferConfig {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1880},{\\\\\\\"text\\\\\\\":\\\\\\\"            sample_rate: sample_rate as f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1881},{\\\\\\\"text\\\\\\\":\\\\\\\"            min_buffer_size: Some(min_frames_count),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1882},{\\\\\\\"text\\\\\\\":\\\\\\\"            max_buffer_size: max_frames_count,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1883},{\\\\\\\"text\\\\\\\":\\\\\\\"            process_mode: wrapper.current_process_mode.load(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1884},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1885},{\\\\\\\"lineNumber\\\\\\\":1886},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Before initializing the plugin, make sure all smoothers are set the the default values\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1887},{\\\\\\\"text\\\\\\\":\\\\\\\"        for param in wrapper.param_by_hash.values() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1888},{\\\\\\\"text\\\\\\\":\\\\\\\"            param.update_smoother(buffer_config.sample_rate, true);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1889},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1890},{\\\\\\\"lineNumber\\\\\\\":1891},{\\\\\\\"text\\\\\\\":\\\\\\\"        // NOTE: This needs to be dropped after the &#96;plugin&#96; lock to avoid deadlocks\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1892},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut init_context = wrapper.make_init_context();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1893},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mut plugin = wrapper.plugin.lock();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1894},{\\\\\\\"text\\\\\\\":\\\\\\\"        if plugin.initialize(&amp;audio_io_layout, &amp;buffer_config, &amp;mut init_context) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1895},{\\\\\\\"text\\\\\\\":\\\\\\\"            // NOTE: &#96;Plugin::reset()&#96; is called in &#96;clap_plugin::start_processing()&#96; instead of in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1896},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       this function\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1897},{\\\\\\\"lineNumber\\\\\\\":1898},{\\\\\\\"text\\\\\\\":\\\\\\\"            // This preallocates enough space so we can transform all of the host's raw channel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1899},{\\\\\\\"text\\\\\\\":\\\\\\\"            // pointers into a set of &#96;Buffer&#96; objects for the plugin's main and auxiliary IO\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1900},{\\\\\\\"text\\\\\\\":\\\\\\\"            *wrapper.buffer_manager.borrow_mut() =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1901},{\\\\\\\"text\\\\\\\":\\\\\\\"                BufferManager::for_audio_io_layout(max_frames_count as usize, audio_io_layout);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1902},{\\\\\\\"lineNumber\\\\\\\":1903},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Also store this for later, so we can reinitialize the plugin after restoring state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1904},{\\\\\\\"text\\\\\\\":\\\\\\\"            wrapper.current_buffer_config.store(Some(buffer_config));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1905},{\\\\\\\"lineNumber\\\\\\\":1906},{\\\\\\\"text\\\\\\\":\\\\\\\"            true\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1907},{\\\\\\\"text\\\\\\\":\\\\\\\"        } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1908},{\\\\\\\"text\\\\\\\":\\\\\\\"            false\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1909},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1910},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1911},{\\\\\\\"lineNumber\\\\\\\":1912},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe extern \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\" fn deactivate(plugin: *const clap_plugin)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1913}]},\\\\\\\"score\\\\\\\":0.3622781038284302},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":202},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":240}},\\\\\\\"contents\\\\\\\":\\\\\\\"    /// by slashes, and they're only used to allow the DAW to display parameters in a tree\\\\\\\\n    /// structure.\\\\\\\\n    param_group_by_hash: HashMap&lt;u32, String&gt;,\\\\\\\\n    /// Mappings from string parameter identifiers to parameter hashes. Useful for debug logging\\\\\\\\n    /// and when storing and restoring plugin state.\\\\\\\\n    param_id_to_hash: HashMap&lt;String, u32&gt;,\\\\\\\\n    /// The inverse mapping from [&#96;param_by_hash&#96;][Self::param_by_hash]. This is needed to be able\\\\\\\\n    /// to have an ergonomic parameter setting API that uses references to the parameters instead of\\\\\\\\n    /// having to add a setter function to the parameter (or even worse, have it be completely\\\\\\\\n    /// untyped).\\\\\\\\n    pub param_ptr_to_hash: HashMap&lt;ParamPtr, u32&gt;,\\\\\\\\n    /// For all polyphonically modulatable parameters, mappings from the parameter hash's hash to\\\\\\\\n    /// the parameter's poly modulation ID. These IDs are then passed to the plugin, so it can\\\\\\\\n    /// quickly refer to parameter by matching on constant IDs.\\\\\\\\n    poly_mod_ids_by_hash: HashMap&lt;u32, u32&gt;,\\\\\\\\n    /// A queue of parameter changes and gestures that should be output in either the next process\\\\\\\\n    /// call or in the next parameter flush.\\\\\\\\n    ///\\\\\\\\n    /// XXX: There's no guarantee that a single parameter doesn't occur twice in this queue, but\\\\\\\\n    ///      even if it does then that should still not be a problem because the host also reads it\\\\\\\\n    ///      in the same order, right?\\\\\\\\n    output_parameter_events: ArrayQueue&lt;OutputParamEvent&gt;,\\\\\\\\n\\\\\\\\n    host_thread_check: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_thread_check&gt;&gt;&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_remote_controls: clap_plugin_remote_controls,\\\\\\\\n    /// The plugin's remote control pages, if it defines any. Filled when initializing the plugin.\\\\\\\\n    remote_control_pages: Vec&lt;clap_remote_controls_page&gt;,\\\\\\\\n\\\\\\\\n    clap_plugin_render: clap_plugin_render,\\\\\\\\n\\\\\\\\n    clap_plugin_state: clap_plugin_state,\\\\\\\\n\\\\\\\\n    clap_plugin_tail: clap_plugin_tail,\\\\\\\\n\\\\\\\\n    clap_plugin_voice_info: clap_plugin_voice_info,\\\\\\\\n    host_voice_info: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_voice_info&gt;&gt;&gt;,\\\\\\\\n    /// If &#96;P::CLAP_POLY_MODULATION_CONFIG&#96; is set, then the plugin can configure the current number\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    /// by slashes, and they're only used to allow the DAW to display parameters in a tree\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// structure.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"    param_group_by_hash: HashMap&lt;u32, String&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Mappings from string parameter identifiers to parameter hashes. Useful for debug logging\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// and when storing and restoring plugin state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"    param_id_to_hash: HashMap&lt;String, u32&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The inverse mapping from [&#96;param_by_hash&#96;][Self::param_by_hash]. This is needed to be able\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// to have an ergonomic parameter setting API that uses references to the parameters instead of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// having to add a setter function to the parameter (or even worse, have it be completely\\\\\\\",\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// untyped).\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub param_ptr_to_hash: HashMap&lt;ParamPtr, u32&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// For all polyphonically modulatable parameters, mappings from the parameter hash's hash to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// the parameter's poly modulation ID. These IDs are then passed to the plugin, so it can\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// quickly refer to parameter by matching on constant IDs.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"    poly_mod_ids_by_hash: HashMap&lt;u32, u32&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// A queue of parameter changes and gestures that should be output in either the next process\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// call or in the next parameter flush.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// XXX: There's no guarantee that a single parameter doesn't occur twice in this queue, but\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///      even if it does then that should still not be a problem because the host also reads it\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///      in the same order, right?\\\\\\\",\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"    output_parameter_events: ArrayQueue&lt;OutputParamEvent&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"    host_thread_check: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_thread_check&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_remote_controls: clap_plugin_remote_controls,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The plugin's remote control pages, if it defines any. Filled when initializing the plugin.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"    remote_control_pages: Vec&lt;clap_remote_controls_page&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"lineNumber\\\\\\\":231},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_render: clap_plugin_render,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":232},{\\\\\\\"lineNumber\\\\\\\":233},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_state: clap_plugin_state,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":234},{\\\\\\\"lineNumber\\\\\\\":235},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_tail: clap_plugin_tail,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":236},{\\\\\\\"lineNumber\\\\\\\":237},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_voice_info: clap_plugin_voice_info,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":238},{\\\\\\\"text\\\\\\\":\\\\\\\"    host_voice_info: AtomicRefCell&lt;Option&lt;ClapPtr&lt;clap_host_voice_info&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":239},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// If &#96;P::CLAP_POLY_MODULATION_CONFIG&#96; is set, then the plugin can configure the current number\\\\\\\",\\\\\\\"lineNumber\\\\\\\":240}]},\\\\\\\"score\\\\\\\":0.3513216972351074},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/context.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":129,\\\\\\\"column\\\\\\\":1},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":170,\\\\\\\"column\\\\\\\":42}},\\\\\\\"contents\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; GuiContext for WrapperGuiContext&lt;P&gt; {\\\\\\\\n    fn plugin_api(&amp;self) -&gt; PluginApi {\\\\\\\\n        PluginApi::Clap\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn request_resize(&amp;self) -&gt; bool {\\\\\\\\n        self.wrapper.request_resize()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // All of these functions are supposed to be called from the main thread, so we'll put some\\\\\\\\n    // trust in the caller and assume that this is indeed the case\\\\\\\\n    unsafe fn raw_begin_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\\n        match self.wrapper.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n            Some(hash) =&gt; {\\\\\\\\n                let success = self\\\\\\\\n                    .wrapper\\\\\\\\n                    .queue_parameter_event(OutputParamEvent::BeginGesture { param_hash: *hash });\\\\\\\\n\\\\\\\\n                nih_debug_assert!(\\\\\\\\n                    success,\\\\\\\\n                    \\\\\\\\\\\\\\\"Parameter output event queue was full, parameter change will not be sent to \\\\\\\\\\\\\\\\\\\\\\\\n                     the host\\\\\\\\\\\\\\\"\\\\\\\\n                );\\\\\\\\n            }\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.wrapper.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .begin_set_parameter(param_id),\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\n                \\\\\\\\\\\\\\\"raw_begin_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\"\\\\\\\\n            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_set_parameter_normalized\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: ClapPlugin&gt; GuiContext for WrapperGuiContext&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":132},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn plugin_api(&amp;self) -&gt; PluginApi {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":133},{\\\\\\\"text\\\\\\\":\\\\\\\"        PluginApi::Clap\\\\\\\",\\\\\\\"lineNumber\\\\\\\":134},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":135},{\\\\\\\"lineNumber\\\\\\\":136},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn request_resize(&amp;self) -&gt; bool {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":137},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.wrapper.request_resize()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":138},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":139},{\\\\\\\"lineNumber\\\\\\\":140},{\\\\\\\"text\\\\\\\":\\\\\\\"    // All of these functions are supposed to be called from the main thread, so we'll put some\\\\\\\",\\\\\\\"lineNumber\\\\\\\":141},{\\\\\\\"text\\\\\\\":\\\\\\\"    // trust in the caller and assume that this is indeed the case\\\\\\\",\\\\\\\"lineNumber\\\\\\\":142},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_begin_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":143},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.wrapper.param_ptr_to_hash.get(&amp;param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":144},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(hash) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":145},{\\\\\\\"text\\\\\\\":\\\\\\\"                let success = self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .wrapper\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .queue_parameter_event(OutputParamEvent::BeginGesture { param_hash: *hash });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"                    success,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"                    \\\\\\\\\\\\\\\"Parameter output event queue was full, parameter change will not be sent to \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"                     the host\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(debug_assertions)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.wrapper.param_id_from_ptr(param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_id) =&gt; self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"                .param_gesture_checker\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"                .borrow_mut()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"                .begin_set_parameter(param_id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"                \\\\\\\\\\\\\\\"raw_begin_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_set_parameter_normalized\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171}]},\\\\\\\"score\\\\\\\":0.3496069014072418},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/clap/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":31,\\\\\\\"column\\\\\\\":87},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":81,\\\\\\\"column\\\\\\\":25}},\\\\\\\"contents\\\\\\\":\\\\\\\"use clap_sys::ext::note_ports::{\\\\\\\\n    clap_note_port_info, clap_plugin_note_ports, CLAP_EXT_NOTE_PORTS, CLAP_NOTE_DIALECT_CLAP,\\\\\\\\n    CLAP_NOTE_DIALECT_MIDI,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::params::{\\\\\\\\n    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\\n    CLAP_PARAM_IS_AUTOMATABLE, CLAP_PARAM_IS_BYPASS, CLAP_PARAM_IS_HIDDEN,\\\\\\\\n    CLAP_PARAM_IS_MODULATABLE, CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID, CLAP_PARAM_IS_READONLY,\\\\\\\\n    CLAP_PARAM_IS_STEPPED, CLAP_PARAM_RESCAN_VALUES,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::render::{\\\\\\\\n    clap_plugin_render, clap_plugin_render_mode, CLAP_EXT_RENDER, CLAP_RENDER_OFFLINE,\\\\\\\\n    CLAP_RENDER_REALTIME,\\\\\\\\n};\\\\\\\\nuse clap_sys::ext::state::{clap_plugin_state, CLAP_EXT_STATE};\\\\\\\\nuse clap_sys::ext::tail::{clap_plugin_tail, CLAP_EXT_TAIL};\\\\\\\\nuse clap_sys::ext::thread_check::{clap_host_thread_check, CLAP_EXT_THREAD_CHECK};\\\\\\\\nuse clap_sys::ext::voice_info::{\\\\\\\\n    clap_host_voice_info, clap_plugin_voice_info, clap_voice_info, CLAP_EXT_VOICE_INFO,\\\\\\\\n    CLAP_VOICE_INFO_SUPPORTS_OVERLAPPING_NOTES,\\\\\\\\n};\\\\\\\\nuse clap_sys::fixedpoint::{CLAP_BEATTIME_FACTOR, CLAP_SECTIME_FACTOR};\\\\\\\\nuse clap_sys::host::clap_host;\\\\\\\\nuse clap_sys::id::{clap_id, CLAP_INVALID_ID};\\\\\\\\nuse clap_sys::plugin::clap_plugin;\\\\\\\\nuse clap_sys::process::{\\\\\\\\n    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\\n    CLAP_PROCESS_ERROR,\\\\\\\\n};\\\\\\\\nuse clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\\nuse crossbeam::atomic::AtomicCell;\\\\\\\\nuse crossbeam::channel::{self, SendTimeoutError};\\\\\\\\nuse crossbeam::queue::ArrayQueue;\\\\\\\\nuse parking_lot::Mutex;\\\\\\\\nuse std::any::Any;\\\\\\\\nuse std::borrow::Borrow;\\\\\\\\nuse std::collections::{HashMap, HashSet, VecDeque};\\\\\\\\nuse std::ffi::{c_void, CStr};\\\\\\\\nuse std::mem;\\\\\\\\nuse std::num::NonZeroU32;\\\\\\\\nuse std::os::raw::c_char;\\\\\\\\nuse std::ptr::NonNull;\\\\\\\\nuse std::sync::atomic::{AtomicBool, AtomicU32, Ordering};\\\\\\\\nuse std::sync::{Arc, Weak};\\\\\\\\nuse std::thread::{self, ThreadId};\\\\\\\\nuse std::time::Duration;\\\\\\\\n\\\\\\\\nuse super::context::{WrapperGuiContext, WrapperInitContext, WrapperProcessContext};\\\\\\\\nuse super::descriptor::PluginDescriptor;\\\\\\\\nuse super::util::ClapPtr;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::note_ports::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_note_port_info, clap_plugin_note_ports, CLAP_EXT_NOTE_PORTS, CLAP_NOTE_DIALECT_CLAP,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_NOTE_DIALECT_MIDI,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::params::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_host_params, clap_param_info, clap_plugin_params, CLAP_EXT_PARAMS,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_AUTOMATABLE, CLAP_PARAM_IS_BYPASS, CLAP_PARAM_IS_HIDDEN,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_MODULATABLE, CLAP_PARAM_IS_MODULATABLE_PER_NOTE_ID, CLAP_PARAM_IS_READONLY,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PARAM_IS_STEPPED, CLAP_PARAM_RESCAN_VALUES,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::render::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_plugin_render, clap_plugin_render_mode, CLAP_EXT_RENDER, CLAP_RENDER_OFFLINE,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_RENDER_REALTIME,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::state::{clap_plugin_state, CLAP_EXT_STATE};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::tail::{clap_plugin_tail, CLAP_EXT_TAIL};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::thread_check::{clap_host_thread_check, CLAP_EXT_THREAD_CHECK};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::ext::voice_info::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_host_voice_info, clap_plugin_voice_info, clap_voice_info, CLAP_EXT_VOICE_INFO,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_VOICE_INFO_SUPPORTS_OVERLAPPING_NOTES,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::fixedpoint::{CLAP_BEATTIME_FACTOR, CLAP_SECTIME_FACTOR};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::host::clap_host;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::id::{clap_id, CLAP_INVALID_ID};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":56},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::plugin::clap_plugin;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":57},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::process::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":58},{\\\\\\\"text\\\\\\\":\\\\\\\"    clap_process, clap_process_status, CLAP_PROCESS_CONTINUE, CLAP_PROCESS_CONTINUE_IF_NOT_QUIET,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":59},{\\\\\\\"text\\\\\\\":\\\\\\\"    CLAP_PROCESS_ERROR,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":60},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":61},{\\\\\\\"text\\\\\\\":\\\\\\\"use clap_sys::stream::{clap_istream, clap_ostream};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":62},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::atomic::AtomicCell;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":63},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::channel::{self, SendTimeoutError};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":64},{\\\\\\\"text\\\\\\\":\\\\\\\"use crossbeam::queue::ArrayQueue;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":65},{\\\\\\\"text\\\\\\\":\\\\\\\"use parking_lot::Mutex;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":66},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::any::Any;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":67},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":68},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::collections::{HashMap, HashSet, VecDeque};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":69},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::{c_void, CStr};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":70},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::mem;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":71},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":72},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::os::raw::c_char;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":73},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ptr::NonNull;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":74},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":75},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::{Arc, Weak};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":76},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::thread::{self, ThreadId};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":77},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::time::Duration;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":78},{\\\\\\\"lineNumber\\\\\\\":79},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::context::{WrapperGuiContext, WrapperInitContext, WrapperProcessContext};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":80},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::descriptor::PluginDescriptor;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":81},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::ClapPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":82}]},\\\\\\\"score\\\\\\\":0.34722980856895447}]}\\\"},\\\"capabilityType\\\":15}\",\"44679531-09e9-4229-bb3e-c09420b18fb2\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"2fce1350-0998-4435-b80a-9247e9ede18a\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.055Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\",\\\"toolFormerData\\\":{\\\"toolCallId\\\":\\\"tool_366fcb83-9292-4154-ae92-ba2876b80b4\\\",\\\"toolIndex\\\":0,\\\"modelCallId\\\":\\\"tool_366fcb83-9292-4154-ae92-ba2876b80b4\\\",\\\"status\\\":\\\"completed\\\",\\\"name\\\":\\\"semantic_search_full\\\",\\\"rawArgs\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does VST3 wrapper handle parameter changes from IParameterChanges in the process function?\\\\\\\",\\\\\\\"targetDirectories\\\\\\\":[\\\\\\\"nih-plug/src/wrapper/vst3\\\\\\\"],\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"tool\\\":9,\\\"params\\\":\\\"{\\\\\\\"query\\\\\\\":\\\\\\\"How does VST3 wrapper handle parameter changes from IParameterChanges in the process function?\\\\\\\",\\\\\\\"includePattern\\\\\\\":\\\\\\\"nih-plug/src/wrapper/vst3\\\\\\\",\\\\\\\"topK\\\\\\\":10,\\\\\\\"explanation\\\\\\\":\\\\\\\"\\\\\\\"}\\\",\\\"result\\\":\\\"{\\\\\\\"codeResults\\\\\\\":[{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":930,\\\\\\\"column\\\\\\\":54},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":969,\\\\\\\"column\\\\\\\":40}},\\\\\\\"contents\\\\\\\":\\\\\\\"    #[allow(clippy::mut_range_bound)]\\\\\\\\n    unsafe fn process(&amp;self, data: *mut vst3_sys::vst::ProcessData) -&gt; tresult {\\\\\\\\n        check_null_ptr!(data);\\\\\\\\n\\\\\\\\n        // Panic on allocations if the &#96;assert_process_allocs&#96; feature has been enabled, and make\\\\\\\\n        // sure that FTZ is set up correctly\\\\\\\\n        process_wrapper(|| {\\\\\\\\n            // We need to handle incoming automation first\\\\\\\\n            let data = &amp;*data;\\\\\\\\n            let sample_rate = self\\\\\\\\n                .inner\\\\\\\\n                .current_buffer_config\\\\\\\\n                .load()\\\\\\\\n                .expect(\\\\\\\\\\\\\\\"Process call without prior setup call\\\\\\\\\\\\\\\")\\\\\\\\n                .sample_rate;\\\\\\\\n\\\\\\\\n            nih_debug_assert!(data.num_inputs &gt;= 0 &amp;&amp; data.num_outputs &gt;= 0);\\\\\\\\n            nih_debug_assert_eq!(\\\\\\\\n                data.symbolic_sample_size,\\\\\\\\n                vst3_sys::vst::SymbolicSampleSizes::kSample32 as i32\\\\\\\\n            );\\\\\\\\n            nih_debug_assert!(data.num_samples &gt;= 0);\\\\\\\\n\\\\\\\\n            let total_buffer_len = data.num_samples as usize;\\\\\\\\n\\\\\\\\n            let current_audio_io_layout = self.inner.current_audio_io_layout.load();\\\\\\\\n            let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\\n            let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\\n            let aux_input_start_idx = if has_main_input { 1 } else { 0 };\\\\\\\\n            let aux_output_start_idx = if has_main_output { 1 } else { 0 };\\\\\\\\n\\\\\\\\n            // NOTE: VST3 hosts may trigger a 'parameter flush' by calling the process function for\\\\\\\\n            //       0 input samples. If this is the case then we'll only handle events and skip all\\\\\\\\n            //       audio processing. Some hosts, like Ableton Live, implement this in a broken way\\\\\\\\n            //       and instead only set the number of channels to 0. In that case the\\\\\\\\n            //       'buffer_is_valid' check from below should still prevent audio processing.\\\\\\\\n            let mut is_param_flush = total_buffer_len == 0;\\\\\\\\n            if (data.num_outputs == 0 || data.outputs.is_null())\\\\\\\\n                &amp;&amp; (has_main_output || !\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    #[allow(clippy::mut_range_bound)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":932},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn process(&amp;self, data: *mut vst3_sys::vst::ProcessData) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":933},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":934},{\\\\\\\"lineNumber\\\\\\\":935},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Panic on allocations if the &#96;assert_process_allocs&#96; feature has been enabled, and make\\\\\\\",\\\\\\\"lineNumber\\\\\\\":936},{\\\\\\\"text\\\\\\\":\\\\\\\"        // sure that FTZ is set up correctly\\\\\\\",\\\\\\\"lineNumber\\\\\\\":937},{\\\\\\\"text\\\\\\\":\\\\\\\"        process_wrapper(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":938},{\\\\\\\"text\\\\\\\":\\\\\\\"            // We need to handle incoming automation first\\\\\\\",\\\\\\\"lineNumber\\\\\\\":939},{\\\\\\\"text\\\\\\\":\\\\\\\"            let data = &amp;*data;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":940},{\\\\\\\"text\\\\\\\":\\\\\\\"            let sample_rate = self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":941},{\\\\\\\"text\\\\\\\":\\\\\\\"                .inner\\\\\\\",\\\\\\\"lineNumber\\\\\\\":942},{\\\\\\\"text\\\\\\\":\\\\\\\"                .current_buffer_config\\\\\\\",\\\\\\\"lineNumber\\\\\\\":943},{\\\\\\\"text\\\\\\\":\\\\\\\"                .load()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":944},{\\\\\\\"text\\\\\\\":\\\\\\\"                .expect(\\\\\\\\\\\\\\\"Process call without prior setup call\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":945},{\\\\\\\"text\\\\\\\":\\\\\\\"                .sample_rate;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":946},{\\\\\\\"lineNumber\\\\\\\":947},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_debug_assert!(data.num_inputs &gt;= 0 &amp;&amp; data.num_outputs &gt;= 0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":948},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":949},{\\\\\\\"text\\\\\\\":\\\\\\\"                data.symbolic_sample_size,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":950},{\\\\\\\"text\\\\\\\":\\\\\\\"                vst3_sys::vst::SymbolicSampleSizes::kSample32 as i32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":951},{\\\\\\\"text\\\\\\\":\\\\\\\"            );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":952},{\\\\\\\"text\\\\\\\":\\\\\\\"            nih_debug_assert!(data.num_samples &gt;= 0);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":953},{\\\\\\\"lineNumber\\\\\\\":954},{\\\\\\\"text\\\\\\\":\\\\\\\"            let total_buffer_len = data.num_samples as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":955},{\\\\\\\"lineNumber\\\\\\\":956},{\\\\\\\"text\\\\\\\":\\\\\\\"            let current_audio_io_layout = self.inner.current_audio_io_layout.load();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":957},{\\\\\\\"text\\\\\\\":\\\\\\\"            let has_main_input = current_audio_io_layout.main_input_channels.is_some();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":958},{\\\\\\\"text\\\\\\\":\\\\\\\"            let has_main_output = current_audio_io_layout.main_output_channels.is_some();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":959},{\\\\\\\"text\\\\\\\":\\\\\\\"            let aux_input_start_idx = if has_main_input { 1 } else { 0 };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":960},{\\\\\\\"text\\\\\\\":\\\\\\\"            let aux_output_start_idx = if has_main_output { 1 } else { 0 };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":961},{\\\\\\\"lineNumber\\\\\\\":962},{\\\\\\\"text\\\\\\\":\\\\\\\"            // NOTE: VST3 hosts may trigger a 'parameter flush' by calling the process function for\\\\\\\",\\\\\\\"lineNumber\\\\\\\":963},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       0 input samples. If this is the case then we'll only handle events and skip all\\\\\\\",\\\\\\\"lineNumber\\\\\\\":964},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       audio processing. Some hosts, like Ableton Live, implement this in a broken way\\\\\\\",\\\\\\\"lineNumber\\\\\\\":965},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       and instead only set the number of channels to 0. In that case the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":966},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       'buffer_is_valid' check from below should still prevent audio processing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":967},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut is_param_flush = total_buffer_len == 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":968},{\\\\\\\"text\\\\\\\":\\\\\\\"            if (data.num_outputs == 0 || data.outputs.is_null())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":969},{\\\\\\\"text\\\\\\\":\\\\\\\"                &amp;&amp; (has_main_output || !\\\\\\\",\\\\\\\"lineNumber\\\\\\\":970}]},\\\\\\\"score\\\\\\\":0.5514850616455078},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":984,\\\\\\\"column\\\\\\\":43},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1002,\\\\\\\"column\\\\\\\":50}},\\\\\\\"contents\\\\\\\":\\\\\\\"            if let Some(param_changes) = data.input_param_changes.upgrade() {\\\\\\\\n                let num_param_queues = param_changes.get_parameter_count();\\\\\\\\n                for change_queue_idx in 0..num_param_queues {\\\\\\\\n                    if let Some(param_change_queue) =\\\\\\\\n                        param_changes.get_parameter_data(change_queue_idx).upgrade()\\\\\\\\n                    {\\\\\\\\n                        let param_hash = param_change_queue.get_parameter_id();\\\\\\\\n                        let num_changes = param_change_queue.get_point_count();\\\\\\\\n                        if num_changes &lt;= 0 {\\\\\\\\n                            continue;\\\\\\\\n                        }\\\\\\\\n\\\\\\\\n                        let mut sample_offset = 0i32;\\\\\\\\n                        let mut value = 0.0f64;\\\\\\\\n                        for change_idx in 0..num_changes {\\\\\\\\n                            if param_change_queue.get_point(\\\\\\\\n                                change_idx,\\\\\\\\n                                &amp;mut sample_offset\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            if let Some(param_changes) = data.input_param_changes.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":986},{\\\\\\\"text\\\\\\\":\\\\\\\"                let num_param_queues = param_changes.get_parameter_count();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":987},{\\\\\\\"text\\\\\\\":\\\\\\\"                for change_queue_idx in 0..num_param_queues {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":988},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(param_change_queue) =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":989},{\\\\\\\"text\\\\\\\":\\\\\\\"                        param_changes.get_parameter_data(change_queue_idx).upgrade()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":990},{\\\\\\\"text\\\\\\\":\\\\\\\"                    {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":991},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let param_hash = param_change_queue.get_parameter_id();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":992},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let num_changes = param_change_queue.get_point_count();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":993},{\\\\\\\"text\\\\\\\":\\\\\\\"                        if num_changes &lt;= 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":994},{\\\\\\\"text\\\\\\\":\\\\\\\"                            continue;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":995},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":996},{\\\\\\\"lineNumber\\\\\\\":997},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let mut sample_offset = 0i32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":998},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let mut value = 0.0f64;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":999},{\\\\\\\"text\\\\\\\":\\\\\\\"                        for change_idx in 0..num_changes {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1000},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if param_change_queue.get_point(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1001},{\\\\\\\"text\\\\\\\":\\\\\\\"                                change_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1002},{\\\\\\\"text\\\\\\\":\\\\\\\"                                &amp;mut sample_offset\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1003}]},\\\\\\\"score\\\\\\\":0.5404864549636841},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1182,\\\\\\\"column\\\\\\\":93},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1221,\\\\\\\"column\\\\\\\":28}},\\\\\\\"contents\\\\\\\":\\\\\\\"                {\\\\\\\\n                    let mut input_events = self.inner.input_events.borrow_mut();\\\\\\\\n                    input_events.clear();\\\\\\\\n\\\\\\\\n                    block_end = total_buffer_len;\\\\\\\\n                    for event_idx in event_start_idx..process_events.len() {\\\\\\\\n                        match &amp;process_events[event_idx] {\\\\\\\\n                            ProcessEvent::ParameterChange {\\\\\\\\n                                timing,\\\\\\\\n                                hash,\\\\\\\\n                                normalized_value,\\\\\\\\n                            } =&gt; {\\\\\\\\n                                // If this parameter change happens after the start of this block, then\\\\\\\\n                                // we'll split the block here and handle this parameter change after\\\\\\\\n                                // we've processed this block\\\\\\\\n                                if *timing != block_start as u32 {\\\\\\\\n                                    event_start_idx = event_idx;\\\\\\\\n                                    block_end = *timing as usize;\\\\\\\\n                                    break;\\\\\\\\n                                }\\\\\\\\n\\\\\\\\n                                self.inner.set_normalized_value_by_hash(\\\\\\\\n                                    *hash,\\\\\\\\n                                    *normalized_value,\\\\\\\\n                                    Some(sample_rate),\\\\\\\\n                                );\\\\\\\\n                            }\\\\\\\\n                            ProcessEvent::NoteEvent(event) =&gt; {\\\\\\\\n                                // We need to make sure to compensate the event for any block splitting,\\\\\\\\n                                // since we had to create the event object beforehand\\\\\\\\n                                let mut event = event.clone();\\\\\\\\n                                event.subtract_timing(block_start as u32);\\\\\\\\n                                input_events.push_back(event);\\\\\\\\n                            }\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                let result =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1184},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut input_events = self.inner.input_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1185},{\\\\\\\"text\\\\\\\":\\\\\\\"                    input_events.clear();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1186},{\\\\\\\"lineNumber\\\\\\\":1187},{\\\\\\\"text\\\\\\\":\\\\\\\"                    block_end = total_buffer_len;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1188},{\\\\\\\"text\\\\\\\":\\\\\\\"                    for event_idx in event_start_idx..process_events.len() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1189},{\\\\\\\"text\\\\\\\":\\\\\\\"                        match &amp;process_events[event_idx] {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1190},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ProcessEvent::ParameterChange {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1191},{\\\\\\\"text\\\\\\\":\\\\\\\"                                timing,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1192},{\\\\\\\"text\\\\\\\":\\\\\\\"                                hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1193},{\\\\\\\"text\\\\\\\":\\\\\\\"                                normalized_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1194},{\\\\\\\"text\\\\\\\":\\\\\\\"                            } =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1195},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // If this parameter change happens after the start of this block, then\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1196},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // we'll split the block here and handle this parameter change after\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1197},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // we've processed this block\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1198},{\\\\\\\"text\\\\\\\":\\\\\\\"                                if *timing != block_start as u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1199},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    event_start_idx = event_idx;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1200},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    block_end = *timing as usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1201},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1202},{\\\\\\\"text\\\\\\\":\\\\\\\"                                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1203},{\\\\\\\"lineNumber\\\\\\\":1204},{\\\\\\\"text\\\\\\\":\\\\\\\"                                self.inner.set_normalized_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1205},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    *hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1206},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    *normalized_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1207},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    Some(sample_rate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1208},{\\\\\\\"text\\\\\\\":\\\\\\\"                                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1209},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1210},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ProcessEvent::NoteEvent(event) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1211},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // We need to make sure to compensate the event for any block splitting,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1212},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // since we had to create the event object beforehand\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1213},{\\\\\\\"text\\\\\\\":\\\\\\\"                                let mut event = event.clone();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1214},{\\\\\\\"text\\\\\\\":\\\\\\\"                                event.subtract_timing(block_start as u32);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1215},{\\\\\\\"text\\\\\\\":\\\\\\\"                                input_events.push_back(event);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1216},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1217},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1218},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1219},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1220},{\\\\\\\"lineNumber\\\\\\\":1221},{\\\\\\\"text\\\\\\\":\\\\\\\"                let result =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1222}]},\\\\\\\"score\\\\\\\":0.5334084630012512},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":967,\\\\\\\"column\\\\\\\":59},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":986,\\\\\\\"column\\\\\\\":75}},\\\\\\\"contents\\\\\\\":\\\\\\\"            if (data.num_outputs == 0 || data.outputs.is_null())\\\\\\\\n                &amp;&amp; (has_main_output || !current_audio_io_layout.aux_output_ports.is_empty())\\\\\\\\n            {\\\\\\\\n                is_param_flush = true;\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            // If &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set, then we'll split up the audio buffer into\\\\\\\\n            // chunks whenever a parameter change occurs. To do that, we'll store all of those\\\\\\\\n            // parameter changes in a vector. Otherwise all parameter changes are handled right here\\\\\\\\n            // and now. We'll also need to store the note events in the same vector because MIDI CC\\\\\\\\n            // messages are sent through parameter changes. This vector gets sorted at the end so we\\\\\\\\n            // can treat it as a sort of queue.\\\\\\\\n            let mut process_events = self.inner.process_events.borrow_mut();\\\\\\\\n            process_events.clear();\\\\\\\\n\\\\\\\\n            // First we'll go through the parameter changes. This may also include MIDI CC messages\\\\\\\\n            // if the plugin supports those\\\\\\\\n            if let Some(param_changes) = data.input_param_changes.upgrade() {\\\\\\\\n                let num_param_queues = param_changes.get_parameter_count();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            if (data.num_outputs == 0 || data.outputs.is_null())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":969},{\\\\\\\"text\\\\\\\":\\\\\\\"                &amp;&amp; (has_main_output || !current_audio_io_layout.aux_output_ports.is_empty())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":970},{\\\\\\\"text\\\\\\\":\\\\\\\"            {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":971},{\\\\\\\"text\\\\\\\":\\\\\\\"                is_param_flush = true;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":972},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":973},{\\\\\\\"lineNumber\\\\\\\":974},{\\\\\\\"text\\\\\\\":\\\\\\\"            // If &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set, then we'll split up the audio buffer into\\\\\\\",\\\\\\\"lineNumber\\\\\\\":975},{\\\\\\\"text\\\\\\\":\\\\\\\"            // chunks whenever a parameter change occurs. To do that, we'll store all of those\\\\\\\",\\\\\\\"lineNumber\\\\\\\":976},{\\\\\\\"text\\\\\\\":\\\\\\\"            // parameter changes in a vector. Otherwise all parameter changes are handled right here\\\\\\\",\\\\\\\"lineNumber\\\\\\\":977},{\\\\\\\"text\\\\\\\":\\\\\\\"            // and now. We'll also need to store the note events in the same vector because MIDI CC\\\\\\\",\\\\\\\"lineNumber\\\\\\\":978},{\\\\\\\"text\\\\\\\":\\\\\\\"            // messages are sent through parameter changes. This vector gets sorted at the end so we\\\\\\\",\\\\\\\"lineNumber\\\\\\\":979},{\\\\\\\"text\\\\\\\":\\\\\\\"            // can treat it as a sort of queue.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":980},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut process_events = self.inner.process_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":981},{\\\\\\\"text\\\\\\\":\\\\\\\"            process_events.clear();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":982},{\\\\\\\"lineNumber\\\\\\\":983},{\\\\\\\"text\\\\\\\":\\\\\\\"            // First we'll go through the parameter changes. This may also include MIDI CC messages\\\\\\\",\\\\\\\"lineNumber\\\\\\\":984},{\\\\\\\"text\\\\\\\":\\\\\\\"            // if the plugin supports those\\\\\\\",\\\\\\\"lineNumber\\\\\\\":985},{\\\\\\\"text\\\\\\\":\\\\\\\"            if let Some(param_changes) = data.input_param_changes.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":986},{\\\\\\\"text\\\\\\\":\\\\\\\"                let num_param_queues = param_changes.get_parameter_count();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":987}]},\\\\\\\"score\\\\\\\":0.5047345757484436},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/context.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":154,\\\\\\\"column\\\\\\\":75},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":191,\\\\\\\"column\\\\\\\":38}},\\\\\\\"contents\\\\\\\":\\\\\\\"            ),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_set_parameter_normalized(&amp;self, param: ParamPtr, normalized: f32) {\\\\\\\\n        match &amp;*self.inner.component_handler.borrow() {\\\\\\\\n            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n                Some(hash) =&gt; {\\\\\\\\n                    // Only update the parameters manually if the host is not processing audio. If\\\\\\\\n                    // the plugin is currently processing audio, the host will pass this change back\\\\\\\\n                    // to the plugin in the audio callback. This also prevents the values from\\\\\\\\n                    // changing in the middle of the process callback, which would be unsound.\\\\\\\\n                    // FIXME: So this doesn't work for REAPER, because they just silently stop\\\\\\\\n                    //        processing audio when you bypass the plugin. Great. We can add a time\\\\\\\\n                    //        based heuristic to work around this in the meantime.\\\\\\\\n                    if !self.inner.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                        self.inner.set_normalized_value_by_hash(\\\\\\\\n                            *hash,\\\\\\\\n                            normalized,\\\\\\\\n                            self.inner\\\\\\\\n                                .current_buffer_config\\\\\\\\n                                .load()\\\\\\\\n                                .map(|c| c.sample_rate),\\\\\\\\n                        );\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    handler.perform_edit(*hash, normalized as f64);\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n            },\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_set_parameter_normalized(&amp;self, param: ParamPtr, normalized: f32) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"text\\\\\\\":\\\\\\\"        match &amp;*self.inner.component_handler.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(hash) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // Only update the parameters manually if the host is not processing audio. If\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // the plugin is currently processing audio, the host will pass this change back\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // to the plugin in the audio callback. This also prevents the values from\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // changing in the middle of the process callback, which would be unsound.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"                    // FIXME: So this doesn't work for REAPER, because they just silently stop\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //        processing audio when you bypass the plugin. Great. We can add a time\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"                    //        based heuristic to work around this in the meantime.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if !self.inner.is_processing.load(Ordering::SeqCst) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"                        self.inner.set_normalized_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"                            *hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"                            normalized,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"                            self.inner\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"                                .current_buffer_config\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"                                .load()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"                                .map(|c| c.sample_rate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"                        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"                    handler.perform_edit(*hash, normalized as f64);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(debug_assertions)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.param_id_from_ptr(param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_id) =&gt; self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"                .param_gesture_checker\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192}]},\\\\\\\"score\\\\\\\":0.4933880567550659},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":607,\\\\\\\"column\\\\\\\":67},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":643,\\\\\\\"column\\\\\\\":41}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n    fn execute(&amp;self, task: Task&lt;P&gt;, is_gui_thread: bool) {\\\\\\\\n        // This function is always called from the main thread\\\\\\\\n        match task {\\\\\\\\n            Task::PluginTask(task) =&gt; (self.task_executor.lock())(task),\\\\\\\\n            Task::ParameterValuesChanged =&gt; {\\\\\\\\n                if self.plug_view.read().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        editor.lock().param_values_changed();\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::ParameterValueChanged(param_hash, normalized_value) =&gt; {\\\\\\\\n                if self.plug_view.read().is_some() {\\\\\\\\n                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\\n                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\\n                        editor\\\\\\\\n                            .lock()\\\\\\\\n                            .param_value_changed(param_id, normalized_value);\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n            Task::TriggerRestart(flags) =&gt; match &amp;*self.component_handler.borrow() {\\\\\\\\n                Some(handler) =&gt; unsafe {\\\\\\\\n                    nih_debug_assert!(is_gui_thread);\\\\\\\\n                    let result = handler.restart_component(flags);\\\\\\\\n                    nih_debug_assert_eq!(\\\\\\\\n                        result,\\\\\\\\n                        kResultOk,\\\\\\\\n                        \\\\\\\\\\\\\\\"Failed the restart request call with flags '{:?}'\\\\\\\\\\\\\\\",\\\\\\\\n                        flags\\\\\\\\n                    );\\\\\\\\n                },\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n            },\\\\\\\\n            Task::RequestResize =&gt; match &amp;*self.plug_view.read() {\\\\\\\\n                Some(plug_view) =&gt; unsafe\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":608},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn execute(&amp;self, task: Task&lt;P&gt;, is_gui_thread: bool) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":609},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This function is always called from the main thread\\\\\\\",\\\\\\\"lineNumber\\\\\\\":610},{\\\\\\\"text\\\\\\\":\\\\\\\"        match task {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":611},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::PluginTask(task) =&gt; (self.task_executor.lock())(task),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":612},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::ParameterValuesChanged =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":613},{\\\\\\\"text\\\\\\\":\\\\\\\"                if self.plug_view.read().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":614},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":615},{\\\\\\\"text\\\\\\\":\\\\\\\"                        editor.lock().param_values_changed();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":616},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":617},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":618},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":619},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::ParameterValueChanged(param_hash, normalized_value) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":620},{\\\\\\\"text\\\\\\\":\\\\\\\"                if self.plug_view.read().is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":621},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(editor) = self.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":622},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let param_id = &amp;self.param_id_by_hash[&amp;param_hash];\\\\\\\",\\\\\\\"lineNumber\\\\\\\":623},{\\\\\\\"text\\\\\\\":\\\\\\\"                        editor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":624},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .lock()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":625},{\\\\\\\"text\\\\\\\":\\\\\\\"                            .param_value_changed(param_id, normalized_value);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":626},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":627},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":628},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":629},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::TriggerRestart(flags) =&gt; match &amp;*self.component_handler.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":630},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(handler) =&gt; unsafe {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":631},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(is_gui_thread);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":632},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let result = handler.restart_component(flags);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":633},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":634},{\\\\\\\"text\\\\\\\":\\\\\\\"                        result,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":635},{\\\\\\\"text\\\\\\\":\\\\\\\"                        kResultOk,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":636},{\\\\\\\"text\\\\\\\":\\\\\\\"                        \\\\\\\\\\\\\\\"Failed the restart request call with flags '{:?}'\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":637},{\\\\\\\"text\\\\\\\":\\\\\\\"                        flags\\\\\\\",\\\\\\\"lineNumber\\\\\\\":638},{\\\\\\\"text\\\\\\\":\\\\\\\"                    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":639},{\\\\\\\"text\\\\\\\":\\\\\\\"                },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":640},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":641},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":642},{\\\\\\\"text\\\\\\\":\\\\\\\"            Task::RequestResize =&gt; match &amp;*self.plug_view.read() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":643},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(plug_view) =&gt; unsafe\\\\\\\",\\\\\\\"lineNumber\\\\\\\":644}]},\\\\\\\"score\\\\\\\":0.4746057391166687},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":164},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":188,\\\\\\\"column\\\\\\\":27}},\\\\\\\"contents\\\\\\\":\\\\\\\"#[derive(Debug, PartialEq)]\\\\\\\\npub enum ProcessEvent&lt;P: Plugin&gt; {\\\\\\\\n    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\\n    /// automation has been enabled, and the parameters are only updated when we process this\\\\\\\\n    /// spooled event at the start of a block.\\\\\\\\n    ParameterChange {\\\\\\\\n        /// The event's sample offset within the buffer. Used for sorting.\\\\\\\\n        timing: u32,\\\\\\\\n        /// The parameter's hash, as used everywhere else.\\\\\\\\n        hash: u32,\\\\\\\\n        /// The normalized values, as provided by the host.\\\\\\\\n        normalized_value: f32,\\\\\\\\n    },\\\\\\\\n    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\\n    /// automation has been enabled, and the parameters are only updated when we process this\\\\\\\\n    /// spooled event at the start of a block.\\\\\\\\n    ///\\\\\\\\n    /// The timing stored within the note event needs to have the block start index subtraced from\\\\\\\\n    /// it. make sure to subtract the block start index with [&#96;NoteEvent::subtract_timing()&#96;] before\\\\\\\\n    /// putting this into the input event queue.\\\\\\\\n    NoteEvent(PluginNoteEvent&lt;P&gt;),\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; WrapperInner&lt;P&gt; {\\\\\\\\n    #[allow(unused_unsafe)]\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, PartialEq)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum ProcessEvent&lt;P: Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// automation has been enabled, and the parameters are only updated when we process this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":168},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// spooled event at the start of a block.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":169},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterChange {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":170},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The event's sample offset within the buffer. Used for sorting.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":171},{\\\\\\\"text\\\\\\\":\\\\\\\"        timing: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":172},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The parameter's hash, as used everywhere else.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":173},{\\\\\\\"text\\\\\\\":\\\\\\\"        hash: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":174},{\\\\\\\"text\\\\\\\":\\\\\\\"        /// The normalized values, as provided by the host.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":175},{\\\\\\\"text\\\\\\\":\\\\\\\"        normalized_value: f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":176},{\\\\\\\"text\\\\\\\":\\\\\\\"    },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":177},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\",\\\\\\\"lineNumber\\\\\\\":178},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// automation has been enabled, and the parameters are only updated when we process this\\\\\\\",\\\\\\\"lineNumber\\\\\\\":179},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// spooled event at the start of a block.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":180},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":181},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The timing stored within the note event needs to have the block start index subtraced from\\\\\\\",\\\\\\\"lineNumber\\\\\\\":182},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// it. make sure to subtract the block start index with [&#96;NoteEvent::subtract_timing()&#96;] before\\\\\\\",\\\\\\\"lineNumber\\\\\\\":183},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// putting this into the input event queue.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":184},{\\\\\\\"text\\\\\\\":\\\\\\\"    NoteEvent(PluginNoteEvent&lt;P&gt;),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":185},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":186},{\\\\\\\"lineNumber\\\\\\\":187},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; WrapperInner&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":188},{\\\\\\\"text\\\\\\\":\\\\\\\"    #[allow(unused_unsafe)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":189}]},\\\\\\\"score\\\\\\\":0.4714125394821167},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1161,\\\\\\\"column\\\\\\\":99},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1184,\\\\\\\"column\\\\\\\":80}},\\\\\\\"contents\\\\\\\":\\\\\\\"            //       on the exclusive end index) of the block.\\\\\\\\n            // FIXME: Apparently stable sort allcoates if the slice is large enough. This should be\\\\\\\\n            //        fixed at some point.\\\\\\\\n            permit_alloc(|| {\\\\\\\\n                process_events.sort_by_key(|event| match event {\\\\\\\\n                    ProcessEvent::ParameterChange { timing, .. } =&gt; *timing,\\\\\\\\n                    ProcessEvent::NoteEvent(event) =&gt; event.timing(),\\\\\\\\n                })\\\\\\\\n            });\\\\\\\\n\\\\\\\\n            let mut block_start = 0usize;\\\\\\\\n            let mut block_end;\\\\\\\\n            let mut event_start_idx = 0;\\\\\\\\n            let result = loop {\\\\\\\\n                // In sample-accurate automation mode we'll handle all parameter changes from the\\\\\\\\n                // sorted process event array until we run into for the current sample, and then\\\\\\\\n                // process the block between the current sample and the sample containing the next\\\\\\\\n                // parameter change, if any. All timings also need to be compensated for this. As\\\\\\\\n                // mentioned above, for this to work correctly parameter changes need to be ordered\\\\\\\\n                // before note events at the same index.\\\\\\\\n                // The extra scope is here to make sure we release the borrow on input_events\\\\\\\\n                {\\\\\\\\n                    let mut input_events = self.inner.input_events.borrow_mut();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"            //       on the exclusive end index) of the block.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1163},{\\\\\\\"text\\\\\\\":\\\\\\\"            // FIXME: Apparently stable sort allcoates if the slice is large enough. This should be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1164},{\\\\\\\"text\\\\\\\":\\\\\\\"            //        fixed at some point.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1165},{\\\\\\\"text\\\\\\\":\\\\\\\"            permit_alloc(|| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1166},{\\\\\\\"text\\\\\\\":\\\\\\\"                process_events.sort_by_key(|event| match event {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1167},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessEvent::ParameterChange { timing, .. } =&gt; *timing,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1168},{\\\\\\\"text\\\\\\\":\\\\\\\"                    ProcessEvent::NoteEvent(event) =&gt; event.timing(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1169},{\\\\\\\"text\\\\\\\":\\\\\\\"                })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1170},{\\\\\\\"text\\\\\\\":\\\\\\\"            });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1171},{\\\\\\\"lineNumber\\\\\\\":1172},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut block_start = 0usize;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1173},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut block_end;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1174},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut event_start_idx = 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1175},{\\\\\\\"text\\\\\\\":\\\\\\\"            let result = loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1176},{\\\\\\\"text\\\\\\\":\\\\\\\"                // In sample-accurate automation mode we'll handle all parameter changes from the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1177},{\\\\\\\"text\\\\\\\":\\\\\\\"                // sorted process event array until we run into for the current sample, and then\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1178},{\\\\\\\"text\\\\\\\":\\\\\\\"                // process the block between the current sample and the sample containing the next\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1179},{\\\\\\\"text\\\\\\\":\\\\\\\"                // parameter change, if any. All timings also need to be compensated for this. As\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1180},{\\\\\\\"text\\\\\\\":\\\\\\\"                // mentioned above, for this to work correctly parameter changes need to be ordered\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1181},{\\\\\\\"text\\\\\\\":\\\\\\\"                // before note events at the same index.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1182},{\\\\\\\"text\\\\\\\":\\\\\\\"                // The extra scope is here to make sure we release the borrow on input_events\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1183},{\\\\\\\"text\\\\\\\":\\\\\\\"                {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1184},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut input_events = self.inner.input_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1185}]},\\\\\\\"score\\\\\\\":0.4653485119342804},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1047,\\\\\\\"column\\\\\\\":33},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1068,\\\\\\\"column\\\\\\\":52}},\\\\\\\"contents\\\\\\\":\\\\\\\" else if P::SAMPLE_ACCURATE_AUTOMATION {\\\\\\\\n                                    process_events.push(ProcessEvent::ParameterChange {\\\\\\\\n                                        timing,\\\\\\\\n                                        hash: param_hash,\\\\\\\\n                                        normalized_value: value,\\\\\\\\n                                    });\\\\\\\\n                                } else {\\\\\\\\n                                    self.inner.set_normalized_value_by_hash(\\\\\\\\n                                        param_hash,\\\\\\\\n                                        value,\\\\\\\\n                                        Some(sample_rate),\\\\\\\\n                                    );\\\\\\\\n                                }\\\\\\\\n                            }\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            // Then we'll add all of our input events\\\\\\\\n            if P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\\n                let mut note_expression_controller =\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" else if P::SAMPLE_ACCURATE_AUTOMATION {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1048},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    process_events.push(ProcessEvent::ParameterChange {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1049},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        timing,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1050},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        hash: param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1051},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        normalized_value: value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1052},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    });\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1053},{\\\\\\\"text\\\\\\\":\\\\\\\"                                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1054},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    self.inner.set_normalized_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1055},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        param_hash,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1056},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1057},{\\\\\\\"text\\\\\\\":\\\\\\\"                                        Some(sample_rate),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1058},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1059},{\\\\\\\"text\\\\\\\":\\\\\\\"                                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1060},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1061},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1062},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1063},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1064},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1065},{\\\\\\\"lineNumber\\\\\\\":1066},{\\\\\\\"text\\\\\\\":\\\\\\\"            // Then we'll add all of our input events\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1067},{\\\\\\\"text\\\\\\\":\\\\\\\"            if P::MIDI_INPUT &gt;= MidiConfig::Basic {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1068},{\\\\\\\"text\\\\\\\":\\\\\\\"                let mut note_expression_controller =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1069}]},\\\\\\\"score\\\\\\\":0.4538806080818176},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":89},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":115}},\\\\\\\"contents\\\\\\\":\\\\\\\"    ///       creating the process context\\\\\\\\n    pub input_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    /// Stores any events the plugin has output during the current processing cycle, analogous to\\\\\\\\n    /// &#96;input_events&#96;.\\\\\\\\n    pub output_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    /// VST3 has several useful predefined note expressions, but for some reason they are the only\\\\\\\\n    /// note event type that don't have MIDI note ID and channel fields. So we need to keep track of\\\\\\\\n    /// the most recent VST3 note IDs we've seen, and then map those back to MIDI note IDs and\\\\\\\\n    /// channels as needed.\\\\\\\\n    pub note_expression_controller: AtomicRefCell&lt;NoteExpressionController&gt;,\\\\\\\\n    /// Unprocessed parameter changes and note events sent by the host during a process call.\\\\\\\\n    /// Parameter changes are sent as separate queues for each parameter, and note events are in\\\\\\\\n    /// another queue on top of that. And if &#96;P::MIDI_INPUT &gt;= MidiConfig::MidiCCs&#96;, then we can\\\\\\\\n    /// also receive MIDI CC messages through special parameter changes. On top of that, we also\\\\\\\\n    /// support sample accurate automation through block splitting if\\\\\\\\n    /// &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set. To account for all of this, we'll read all of the\\\\\\\\n    /// parameter changes and events into a vector at the start of the process call, sort it, and\\\\\\\\n    /// then do the block splitting based on that. Note events need to have their timing adjusted to\\\\\\\\n    /// match the block start, since they're all read upfront.\\\\\\\\n    pub process_events: AtomicRefCell&lt;Vec&lt;ProcessEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    /// The plugin is able to restore state through a method on the &#96;GuiContext&#96;. To avoid changing\\\\\\\\n    /// parameters mid-processing and running into garbled data if the host also tries to load state\\\\\\\\n    /// at the same time the restoring happens at the end of each processing call. If this zero\\\\\\\\n    /// capacity channel contains state data at that point, then the audio thread will take the\\\\\\\\n    /// state out of the channel, restore the state, and then send it back through the same channel.\\\\\\\\n    /// In other words, the GUI thread acts as a sender and then as a receiver, while the audio\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    ///       creating the process context\\\\\\\",\\\\\\\"lineNumber\\\\\\\":90},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub input_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":91},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Stores any events the plugin has output during the current processing cycle, analogous to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":92},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;input_events&#96;.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":93},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub output_events: AtomicRefCell&lt;VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":94},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// VST3 has several useful predefined note expressions, but for some reason they are the only\\\\\\\",\\\\\\\"lineNumber\\\\\\\":95},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// note event type that don't have MIDI note ID and channel fields. So we need to keep track of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":96},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// the most recent VST3 note IDs we've seen, and then map those back to MIDI note IDs and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":97},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// channels as needed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":98},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub note_expression_controller: AtomicRefCell&lt;NoteExpressionController&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":99},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Unprocessed parameter changes and note events sent by the host during a process call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":100},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Parameter changes are sent as separate queues for each parameter, and note events are in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":101},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// another queue on top of that. And if &#96;P::MIDI_INPUT &gt;= MidiConfig::MidiCCs&#96;, then we can\\\\\\\",\\\\\\\"lineNumber\\\\\\\":102},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// also receive MIDI CC messages through special parameter changes. On top of that, we also\\\\\\\",\\\\\\\"lineNumber\\\\\\\":103},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// support sample accurate automation through block splitting if\\\\\\\",\\\\\\\"lineNumber\\\\\\\":104},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// &#96;P::SAMPLE_ACCURATE_AUTOMATION&#96; is set. To account for all of this, we'll read all of the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":105},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// parameter changes and events into a vector at the start of the process call, sort it, and\\\\\\\",\\\\\\\"lineNumber\\\\\\\":106},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// then do the block splitting based on that. Note events need to have their timing adjusted to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":107},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// match the block start, since they're all read upfront.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":108},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub process_events: AtomicRefCell&lt;Vec&lt;ProcessEvent&lt;P&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":109},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The plugin is able to restore state through a method on the &#96;GuiContext&#96;. To avoid changing\\\\\\\",\\\\\\\"lineNumber\\\\\\\":110},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// parameters mid-processing and running into garbled data if the host also tries to load state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":111},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// at the same time the restoring happens at the end of each processing call. If this zero\\\\\\\",\\\\\\\"lineNumber\\\\\\\":112},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// capacity channel contains state data at that point, then the audio thread will take the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":113},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// state out of the channel, restore the state, and then send it back through the same channel.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":114},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// In other words, the GUI thread acts as a sender and then as a receiver, while the audio\\\\\\\",\\\\\\\"lineNumber\\\\\\\":115}]},\\\\\\\"score\\\\\\\":0.4524202048778534},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":54,\\\\\\\"column\\\\\\\":29}},\\\\\\\"contents\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\\nuse std::ffi::c_void;\\\\\\\\nuse std::mem::{self, MaybeUninit};\\\\\\\\nuse std::num::NonZeroU32;\\\\\\\\nuse std::ptr::NonNull;\\\\\\\\nuse std::sync::atomic::Ordering;\\\\\\\\nuse std::sync::Arc;\\\\\\\\nuse vst3_com::vst::{DataEvent, IProcessContextRequirementsFlags, ProcessModes};\\\\\\\\nuse vst3_sys::base::{kInvalidArgument, kNoInterface, kResultFalse, kResultOk, tresult, TBool};\\\\\\\\nuse vst3_sys::base::{IBStream, IPluginBase};\\\\\\\\nuse vst3_sys::utils::SharedVstPtr;\\\\\\\\nuse vst3_sys::vst::{\\\\\\\\n    kNoParamId, kNoParentUnitId, kNoProgramListId, kRootUnitId, Event, EventTypes, IAudioProcessor,\\\\\\\\n    IComponent, IEditController, IEventList, IMidiMapping, INoteExpressionController,\\\\\\\\n    IParamValueQueue, IParameterChanges, IProcessContextRequirements, IUnitInfo,\\\\\\\\n    LegacyMidiCCOutEvent, NoteExpressionTypeInfo, NoteExpressionValueDescription, NoteOffEvent,\\\\\\\\n    NoteOnEvent, ParameterFlags, PolyPressureEvent, ProgramListInfo, TChar, UnitInfo,\\\\\\\\n};\\\\\\\\nuse vst3_sys::VST3;\\\\\\\\nuse widestring::U16CStr;\\\\\\\\n\\\\\\\\nuse super::inner::{ProcessEvent, WrapperInner};\\\\\\\\nuse super::note_expressions::{self, NoteExpressionController};\\\\\\\\nuse super::util::{\\\\\\\\n    u16strlcpy, VstPtr, VST3_MIDI_CCS, VST3_MIDI_NUM_PARAMS, VST3_MIDI_PARAMS_START,\\\\\\\\n};\\\\\\\\nuse super::util::{VST3_MIDI_CHANNELS, VST3_MIDI_PARAMS_END};\\\\\\\\nuse super::view::WrapperView;\\\\\\\\nuse crate::prelude::{\\\\\\\\n    AuxiliaryBuffers, BufferConfig, MidiConfig, NoteEvent, ParamFlags, ProcessMode, ProcessStatus,\\\\\\\\n    SysExMessage, Transport, Vst3Plugin,\\\\\\\\n};\\\\\\\\nuse crate::util::permit_alloc;\\\\\\\\nuse crate::wrapper::state;\\\\\\\\nuse crate::wrapper::util::buffer_management::{BufferManager, ChannelPointers};\\\\\\\\nuse crate::wrapper::util::{clamp_input_event_timing, clamp_output_event_timing, process_wrapper};\\\\\\\\n\\\\\\\\n// Alias needed for the VST3 attribute macro\\\\\\\\nuse vst3_sys as vst3_com;\\\\\\\\n\\\\\\\\n#[VST3(implements(\\\\\\\\n    IComponent,\\\\\\\\n    IEditController,\\\\\\\\n    IAudioProcessor,\\\\\\\\n    IMidiMapping,\\\\\\\\n    INoteExpressionController,\\\\\\\\n    IProcessContextRequirements,\\\\\\\\n    IUnitInfo\\\\\\\\n))]\\\\\\\\npub struct Wrapper&lt;P: Vst3Plugin&gt; {\\\\\\\\n    inner: Arc&lt;WrapperInner&lt;P&gt;&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\\n    pub fn new() -&gt; Box&lt;Self&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use std::borrow::Borrow;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ffi::c_void;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::mem::{self, MaybeUninit};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::num::NonZeroU32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::ptr::NonNull;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::atomic::Ordering;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::Arc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_com::vst::{DataEvent, IProcessContextRequirementsFlags, ProcessModes};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::base::{kInvalidArgument, kNoInterface, kResultFalse, kResultOk, tresult, TBool};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::base::{IBStream, IPluginBase};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::utils::SharedVstPtr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::vst::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"    kNoParamId, kNoParentUnitId, kNoProgramListId, kRootUnitId, Event, EventTypes, IAudioProcessor,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"text\\\\\\\":\\\\\\\"    IComponent, IEditController, IEventList, IMidiMapping, INoteExpressionController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"    IParamValueQueue, IParameterChanges, IProcessContextRequirements, IUnitInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"    LegacyMidiCCOutEvent, NoteExpressionTypeInfo, NoteExpressionValueDescription, NoteOffEvent,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"    NoteOnEvent, ParameterFlags, PolyPressureEvent, ProgramListInfo, TChar, UnitInfo,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::VST3;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"use widestring::U16CStr;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::inner::{ProcessEvent, WrapperInner};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::note_expressions::{self, NoteExpressionController};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    u16strlcpy, VstPtr, VST3_MIDI_CCS, VST3_MIDI_NUM_PARAMS, VST3_MIDI_PARAMS_START,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::util::{VST3_MIDI_CHANNELS, VST3_MIDI_PARAMS_END};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::view::WrapperView;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"    AuxiliaryBuffers, BufferConfig, MidiConfig, NoteEvent, ParamFlags, ProcessMode, ProcessStatus,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"    SysExMessage, Transport, Vst3Plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::util::permit_alloc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::state;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::util::buffer_management::{BufferManager, ChannelPointers};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::wrapper::util::{clamp_input_event_timing, clamp_output_event_timing, process_wrapper};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"// Alias needed for the VST3 attribute macro\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys as vst3_com;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"#[VST3(implements(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    IComponent,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"    IEditController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    IAudioProcessor,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"    IMidiMapping,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"text\\\\\\\":\\\\\\\"    INoteExpressionController,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"    IProcessContextRequirements,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47},{\\\\\\\"text\\\\\\\":\\\\\\\"    IUnitInfo\\\\\\\",\\\\\\\"lineNumber\\\\\\\":48},{\\\\\\\"text\\\\\\\":\\\\\\\"))]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":49},{\\\\\\\"text\\\\\\\":\\\\\\\"pub struct Wrapper&lt;P: Vst3Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":50},{\\\\\\\"text\\\\\\\":\\\\\\\"    inner: Arc&lt;WrapperInner&lt;P&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":51},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":52},{\\\\\\\"lineNumber\\\\\\\":53},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":54},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn new() -&gt; Box&lt;Self&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":55}]},\\\\\\\"score\\\\\\\":0.4509347677230835},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":999,\\\\\\\"column\\\\\\\":56},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1018,\\\\\\\"column\\\\\\\":40}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                            if param_change_queue.get_point(\\\\\\\\n                                change_idx,\\\\\\\\n                                &amp;mut sample_offset,\\\\\\\\n                                &amp;mut value,\\\\\\\\n                            ) == kResultOk\\\\\\\\n                            {\\\\\\\\n                                // Later this timing will be compensated for block splits by calling\\\\\\\\n                                // &#96;event.subtract_timing(block_start)&#96; before it is passed to the\\\\\\\\n                                // plugin. Out of bounds events are clamped to the buffer&gt;\\\\\\\\n                                let timing = clamp_input_event_timing(\\\\\\\\n                                    sample_offset as u32,\\\\\\\\n                                    total_buffer_len as u32,\\\\\\\\n                                );\\\\\\\\n                                let value = value as f32;\\\\\\\\n\\\\\\\\n                                // MIDI CC messages, channel pressure, and pitch bend are also sent\\\\\\\\n                                // as parameter changes\\\\\\\\n                                if P::MIDI_INPUT &gt;= MidiConfig::MidiCCs\\\\\\\\n                                    &amp;&amp; (\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1000},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if param_change_queue.get_point(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1001},{\\\\\\\"text\\\\\\\":\\\\\\\"                                change_idx,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1002},{\\\\\\\"text\\\\\\\":\\\\\\\"                                &amp;mut sample_offset,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1003},{\\\\\\\"text\\\\\\\":\\\\\\\"                                &amp;mut value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1004},{\\\\\\\"text\\\\\\\":\\\\\\\"                            ) == kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1005},{\\\\\\\"text\\\\\\\":\\\\\\\"                            {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1006},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // Later this timing will be compensated for block splits by calling\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1007},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // &#96;event.subtract_timing(block_start)&#96; before it is passed to the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1008},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // plugin. Out of bounds events are clamped to the buffer&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1009},{\\\\\\\"text\\\\\\\":\\\\\\\"                                let timing = clamp_input_event_timing(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1010},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    sample_offset as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1011},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    total_buffer_len as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1012},{\\\\\\\"text\\\\\\\":\\\\\\\"                                );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1013},{\\\\\\\"text\\\\\\\":\\\\\\\"                                let value = value as f32;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1014},{\\\\\\\"lineNumber\\\\\\\":1015},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // MIDI CC messages, channel pressure, and pitch bend are also sent\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1016},{\\\\\\\"text\\\\\\\":\\\\\\\"                                // as parameter changes\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1017},{\\\\\\\"text\\\\\\\":\\\\\\\"                                if P::MIDI_INPUT &gt;= MidiConfig::MidiCCs\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1018},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    &amp;&amp; (\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1019}]},\\\\\\\"score\\\\\\\":0.44884970784187317},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1387,\\\\\\\"column\\\\\\\":64},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1419,\\\\\\\"column\\\\\\\":82}},\\\\\\\"contents\\\\\\\":\\\\\\\" context.cycle_end_music));\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    let result = if buffer_is_valid {\\\\\\\\n                        // NOTE: &#96;parking_lot&#96;'s mutexes sometimes allocate because of their use of\\\\\\\\n                        //       thread locals\\\\\\\\n                        let mut plugin = permit_alloc(|| self.inner.plugin.lock());\\\\\\\\n                        let mut aux = AuxiliaryBuffers {\\\\\\\\n                            inputs: buffers.aux_inputs,\\\\\\\\n                            outputs: buffers.aux_outputs,\\\\\\\\n                        };\\\\\\\\n                        let mut context = self.inner.make_process_context(transport);\\\\\\\\n                        let result = plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context);\\\\\\\\n                        self.inner.last_process_status.store(result);\\\\\\\\n                        result\\\\\\\\n                    } else {\\\\\\\\n                        ProcessStatus::Normal\\\\\\\\n                    };\\\\\\\\n\\\\\\\\n                    match result {\\\\\\\\n                        ProcessStatus::Error(err) =&gt; {\\\\\\\\n                            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Process error: {}\\\\\\\\\\\\\\\", err);\\\\\\\\n\\\\\\\\n                            return kResultFalse;\\\\\\\\n                        }\\\\\\\\n                        _ =&gt; kResultOk,\\\\\\\\n                    }\\\\\\\\n                };\\\\\\\\n\\\\\\\\n                // Send any events output by the plugin during the process cycle\\\\\\\\n                if let Some(events) = data.output_events.upgrade() {\\\\\\\\n                    let mut output_events = self.inner.output_events.borrow_mut();\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" context.cycle_end_music));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1388},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1389},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1390},{\\\\\\\"lineNumber\\\\\\\":1391},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let result = if buffer_is_valid {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1392},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // NOTE: &#96;parking_lot&#96;'s mutexes sometimes allocate because of their use of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1393},{\\\\\\\"text\\\\\\\":\\\\\\\"                        //       thread locals\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1394},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let mut plugin = permit_alloc(|| self.inner.plugin.lock());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1395},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let mut aux = AuxiliaryBuffers {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1396},{\\\\\\\"text\\\\\\\":\\\\\\\"                            inputs: buffers.aux_inputs,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1397},{\\\\\\\"text\\\\\\\":\\\\\\\"                            outputs: buffers.aux_outputs,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1398},{\\\\\\\"text\\\\\\\":\\\\\\\"                        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1399},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let mut context = self.inner.make_process_context(transport);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1400},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let result = plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1401},{\\\\\\\"text\\\\\\\":\\\\\\\"                        self.inner.last_process_status.store(result);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1402},{\\\\\\\"text\\\\\\\":\\\\\\\"                        result\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1403},{\\\\\\\"text\\\\\\\":\\\\\\\"                    } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1404},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ProcessStatus::Normal\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1405},{\\\\\\\"text\\\\\\\":\\\\\\\"                    };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1406},{\\\\\\\"lineNumber\\\\\\\":1407},{\\\\\\\"text\\\\\\\":\\\\\\\"                    match result {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1408},{\\\\\\\"text\\\\\\\":\\\\\\\"                        ProcessStatus::Error(err) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1409},{\\\\\\\"text\\\\\\\":\\\\\\\"                            nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Process error: {}\\\\\\\\\\\\\\\", err);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1410},{\\\\\\\"lineNumber\\\\\\\":1411},{\\\\\\\"text\\\\\\\":\\\\\\\"                            return kResultFalse;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1412},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1413},{\\\\\\\"text\\\\\\\":\\\\\\\"                        _ =&gt; kResultOk,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1414},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1415},{\\\\\\\"text\\\\\\\":\\\\\\\"                };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1416},{\\\\\\\"lineNumber\\\\\\\":1417},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Send any events output by the plugin during the process cycle\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1418},{\\\\\\\"text\\\\\\\":\\\\\\\"                if let Some(events) = data.output_events.upgrade() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1419},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let mut output_events = self.inner.output_events.borrow_mut();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1420}]},\\\\\\\"score\\\\\\\":0.4380171298980713},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1640,\\\\\\\"column\\\\\\\":80},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1682,\\\\\\\"column\\\\\\\":47}},\\\\\\\"contents\\\\\\\":\\\\\\\"                if block_end == total_buffer_len {\\\\\\\\n                    break result;\\\\\\\\n                } else {\\\\\\\\n                    block_start = block_end;\\\\\\\\n                }\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            // After processing audio, we'll check if the editor has sent us updated plugin state.\\\\\\\\n            // We'll restore that here on the audio thread to prevent changing the values during the\\\\\\\\n            // process call and also to prevent inconsistent state when the host also wants to load\\\\\\\\n            // plugin state.\\\\\\\\n            // FIXME: Zero capacity channels allocate on receiving, find a better alternative that\\\\\\\\n            //        doesn't do that\\\\\\\\n            let updated_state = permit_alloc(|| self.inner.updated_state_receiver.try_recv());\\\\\\\\n            if let Ok(mut state) = updated_state {\\\\\\\\n                self.inner.set_state_inner(&amp;mut state);\\\\\\\\n\\\\\\\\n                // We'll pass the state object back to the GUI thread so deallocation can happen\\\\\\\\n                // there without potentially blocking the audio thread\\\\\\\\n                if let Err(err) = self.inner.updated_state_sender.send(state) {\\\\\\\\n                    nih_debug_assert_failure!(\\\\\\\\n                        \\\\\\\\\\\\\\\"Failed to send state object back to GUI thread: {}\\\\\\\\\\\\\\\",\\\\\\\\n                        err\\\\\\\\n                    );\\\\\\\\n                };\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            result\\\\\\\\n        })\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn get_tail_samples(&amp;self) -&gt; u32 {\\\\\\\\n        // https://github.com/steinbergmedia/vst3_pluginterfaces/blob/2ad397ade5b51007860bedb3b01b8afd2c5f6fba/vst/ivstaudioprocessor.h#L145-L159\\\\\\\\n        match self.inner.last_process_status.load() {\\\\\\\\n            ProcessStatus::Tail(samples) =&gt; samples,\\\\\\\\n            ProcessStatus::KeepAlive =&gt; u32::MAX, // kInfiniteTail\\\\\\\\n            _ =&gt; 0,                               // kNoTail\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; IMidiMapping for Wrapper&lt;P&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"                if block_end == total_buffer_len {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1642},{\\\\\\\"text\\\\\\\":\\\\\\\"                    break result;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1643},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1644},{\\\\\\\"text\\\\\\\":\\\\\\\"                    block_start = block_end;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1645},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1646},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1647},{\\\\\\\"lineNumber\\\\\\\":1648},{\\\\\\\"text\\\\\\\":\\\\\\\"            // After processing audio, we'll check if the editor has sent us updated plugin state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1649},{\\\\\\\"text\\\\\\\":\\\\\\\"            // We'll restore that here on the audio thread to prevent changing the values during the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1650},{\\\\\\\"text\\\\\\\":\\\\\\\"            // process call and also to prevent inconsistent state when the host also wants to load\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1651},{\\\\\\\"text\\\\\\\":\\\\\\\"            // plugin state.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1652},{\\\\\\\"text\\\\\\\":\\\\\\\"            // FIXME: Zero capacity channels allocate on receiving, find a better alternative that\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1653},{\\\\\\\"text\\\\\\\":\\\\\\\"            //        doesn't do that\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1654},{\\\\\\\"text\\\\\\\":\\\\\\\"            let updated_state = permit_alloc(|| self.inner.updated_state_receiver.try_recv());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1655},{\\\\\\\"text\\\\\\\":\\\\\\\"            if let Ok(mut state) = updated_state {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1656},{\\\\\\\"text\\\\\\\":\\\\\\\"                self.inner.set_state_inner(&amp;mut state);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1657},{\\\\\\\"lineNumber\\\\\\\":1658},{\\\\\\\"text\\\\\\\":\\\\\\\"                // We'll pass the state object back to the GUI thread so deallocation can happen\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1659},{\\\\\\\"text\\\\\\\":\\\\\\\"                // there without potentially blocking the audio thread\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1660},{\\\\\\\"text\\\\\\\":\\\\\\\"                if let Err(err) = self.inner.updated_state_sender.send(state) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1661},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1662},{\\\\\\\"text\\\\\\\":\\\\\\\"                        \\\\\\\\\\\\\\\"Failed to send state object back to GUI thread: {}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1663},{\\\\\\\"text\\\\\\\":\\\\\\\"                        err\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1664},{\\\\\\\"text\\\\\\\":\\\\\\\"                    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1665},{\\\\\\\"text\\\\\\\":\\\\\\\"                };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1666},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1667},{\\\\\\\"lineNumber\\\\\\\":1668},{\\\\\\\"text\\\\\\\":\\\\\\\"            result\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1669},{\\\\\\\"text\\\\\\\":\\\\\\\"        })\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1670},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1671},{\\\\\\\"lineNumber\\\\\\\":1672},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn get_tail_samples(&amp;self) -&gt; u32 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1673},{\\\\\\\"text\\\\\\\":\\\\\\\"        // https://github.com/steinbergmedia/vst3_pluginterfaces/blob/2ad397ade5b51007860bedb3b01b8afd2c5f6fba/vst/ivstaudioprocessor.h#L145-L159\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1674},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.last_process_status.load() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1675},{\\\\\\\"text\\\\\\\":\\\\\\\"            ProcessStatus::Tail(samples) =&gt; samples,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1676},{\\\\\\\"text\\\\\\\":\\\\\\\"            ProcessStatus::KeepAlive =&gt; u32::MAX, // kInfiniteTail\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1677},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; 0,                               // kNoTail\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1678},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1679},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1680},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1681},{\\\\\\\"lineNumber\\\\\\\":1682},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; IMidiMapping for Wrapper&lt;P&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1683}]},\\\\\\\"score\\\\\\\":0.4112482964992523},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":144,\\\\\\\"column\\\\\\\":36},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":167}},\\\\\\\"contents\\\\\\\":\\\\\\\"pub enum Task&lt;P: Plugin&gt; {\\\\\\\\n    /// Execute one of the plugin's background tasks.\\\\\\\\n    PluginTask(P::BackgroundTask),\\\\\\\\n    /// Inform the plugin that one or more parameter values have changed.\\\\\\\\n    ParameterValuesChanged,\\\\\\\\n    /// Inform the plugin that one parameter's value has changed. This uses the parameter hashes\\\\\\\\n    /// since the task will be created from the audio thread.\\\\\\\\n    ParameterValueChanged(u32, f32),\\\\\\\\n    /// Trigger a restart with the given restart flags. This is a bit set of the flags from\\\\\\\\n    /// [&#96;vst3_sys::vst::RestartFlags&#96;].\\\\\\\\n    TriggerRestart(i32),\\\\\\\\n    /// Request the editor to be resized according to its current size. Right now there is no way to\\\\\\\\n    /// handle \\\\\\\\\\\\\\\"denied resize\\\\\\\\\\\\\\\" requests yet.\\\\\\\\n    RequestResize,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// VST3 makes audio processing pretty complicated. In order to support both block splitting for\\\\\\\\n/// sample accurate automation and MIDI CC handling through parameters we need to put all parameter\\\\\\\\n/// changes and (translated) note events into a sorted array first.\\\\\\\\n#[derive(Debug, PartialEq)]\\\\\\\\npub enum ProcessEvent&lt;P: Plugin&gt; {\\\\\\\\n    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum Task&lt;P: Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":146},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Execute one of the plugin's background tasks.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":147},{\\\\\\\"text\\\\\\\":\\\\\\\"    PluginTask(P::BackgroundTask),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":148},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the plugin that one or more parameter values have changed.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":149},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterValuesChanged,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":150},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Inform the plugin that one parameter's value has changed. This uses the parameter hashes\\\\\\\",\\\\\\\"lineNumber\\\\\\\":151},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// since the task will be created from the audio thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":152},{\\\\\\\"text\\\\\\\":\\\\\\\"    ParameterValueChanged(u32, f32),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":153},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Trigger a restart with the given restart flags. This is a bit set of the flags from\\\\\\\",\\\\\\\"lineNumber\\\\\\\":154},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// [&#96;vst3_sys::vst::RestartFlags&#96;].\\\\\\\",\\\\\\\"lineNumber\\\\\\\":155},{\\\\\\\"text\\\\\\\":\\\\\\\"    TriggerRestart(i32),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":156},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Request the editor to be resized according to its current size. Right now there is no way to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":157},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// handle \\\\\\\\\\\\\\\"denied resize\\\\\\\\\\\\\\\" requests yet.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":158},{\\\\\\\"text\\\\\\\":\\\\\\\"    RequestResize,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":159},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":160},{\\\\\\\"lineNumber\\\\\\\":161},{\\\\\\\"text\\\\\\\":\\\\\\\"/// VST3 makes audio processing pretty complicated. In order to support both block splitting for\\\\\\\",\\\\\\\"lineNumber\\\\\\\":162},{\\\\\\\"text\\\\\\\":\\\\\\\"/// sample accurate automation and MIDI CC handling through parameters we need to put all parameter\\\\\\\",\\\\\\\"lineNumber\\\\\\\":163},{\\\\\\\"text\\\\\\\":\\\\\\\"/// changes and (translated) note events into a sorted array first.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":164},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, PartialEq)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":165},{\\\\\\\"text\\\\\\\":\\\\\\\"pub enum ProcessEvent&lt;P: Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":166},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// An incoming parameter change sent by the host. This will only be used when sample accurate\\\\\\\",\\\\\\\"lineNumber\\\\\\\":167}]},\\\\\\\"score\\\\\\\":0.40728089213371277},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":651,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":703,\\\\\\\"column\\\\\\\":50}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe fn plain_param_to_normalized(&amp;self, id: u32, plain_value: f64) -&gt; f64 {\\\\\\\\n        match self.inner.param_by_hash.get(&amp;id) {\\\\\\\\n            Some(param_ptr) =&gt; param_ptr.preview_normalized(plain_value as f32) as f64,\\\\\\\\n            _ =&gt; plain_value,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn get_param_normalized(&amp;self, id: u32) -&gt; f64 {\\\\\\\\n        match self.inner.param_by_hash.get(&amp;id) {\\\\\\\\n            Some(param_ptr) =&gt; param_ptr.modulated_normalized_value() as f64,\\\\\\\\n            _ =&gt; 0.5,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn set_param_normalized(&amp;self, id: u32, value: f64) -&gt; tresult {\\\\\\\\n        // If the plugin is currently processing audio, then this parameter change will also be sent\\\\\\\\n        // to the process function\\\\\\\\n        if self.inner.is_processing.load(Ordering::SeqCst) {\\\\\\\\n            return kResultOk;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        let sample_rate = self\\\\\\\\n            .inner\\\\\\\\n            .current_buffer_config\\\\\\\\n            .load()\\\\\\\\n            .map(|c| c.sample_rate);\\\\\\\\n        self.inner\\\\\\\\n            .set_normalized_value_by_hash(id, value as f32, sample_rate)\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn set_component_handler(\\\\\\\\n        &amp;self,\\\\\\\\n        handler: SharedVstPtr&lt;dyn vst3_sys::vst::IComponentHandler&gt;,\\\\\\\\n    ) -&gt; tresult {\\\\\\\\n        *self.inner.component_handler.borrow_mut() = handler.upgrade().map(VstPtr::from);\\\\\\\\n\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn create_view(&amp;self, _name: vst3_sys::base::FIDString) -&gt; *mut c_void {\\\\\\\\n        // Without specialization this is the least redundant way to check if the plugin has an\\\\\\\\n        // editor. The default implementation returns a None here.\\\\\\\\n        match self.inner.editor.borrow().as_ref() {\\\\\\\\n            Some(editor) =&gt; Box::into_raw(WrapperView::new(self.inner.clone(), editor.clone()))\\\\\\\\n                as *mut vst3_sys::c_void,\\\\\\\\n            None =&gt; std::ptr::null_mut(),\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; IAudioProcessor for Wrapper&lt;P&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn plain_param_to_normalized(&amp;self, id: u32, plain_value: f64) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":654},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.param_by_hash.get(&amp;id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":655},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; param_ptr.preview_normalized(plain_value as f32) as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":656},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; plain_value,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":657},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":658},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":659},{\\\\\\\"lineNumber\\\\\\\":660},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn get_param_normalized(&amp;self, id: u32) -&gt; f64 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":661},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.param_by_hash.get(&amp;id) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":662},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; param_ptr.modulated_normalized_value() as f64,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":663},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; 0.5,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":664},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":665},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":666},{\\\\\\\"lineNumber\\\\\\\":667},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_param_normalized(&amp;self, id: u32, value: f64) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":668},{\\\\\\\"text\\\\\\\":\\\\\\\"        // If the plugin is currently processing audio, then this parameter change will also be sent\\\\\\\",\\\\\\\"lineNumber\\\\\\\":669},{\\\\\\\"text\\\\\\\":\\\\\\\"        // to the process function\\\\\\\",\\\\\\\"lineNumber\\\\\\\":670},{\\\\\\\"text\\\\\\\":\\\\\\\"        if self.inner.is_processing.load(Ordering::SeqCst) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":671},{\\\\\\\"text\\\\\\\":\\\\\\\"            return kResultOk;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":672},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":673},{\\\\\\\"lineNumber\\\\\\\":674},{\\\\\\\"text\\\\\\\":\\\\\\\"        let sample_rate = self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":675},{\\\\\\\"text\\\\\\\":\\\\\\\"            .inner\\\\\\\",\\\\\\\"lineNumber\\\\\\\":676},{\\\\\\\"text\\\\\\\":\\\\\\\"            .current_buffer_config\\\\\\\",\\\\\\\"lineNumber\\\\\\\":677},{\\\\\\\"text\\\\\\\":\\\\\\\"            .load()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":678},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|c| c.sample_rate);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":679},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner\\\\\\\",\\\\\\\"lineNumber\\\\\\\":680},{\\\\\\\"text\\\\\\\":\\\\\\\"            .set_normalized_value_by_hash(id, value as f32, sample_rate)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":681},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":682},{\\\\\\\"lineNumber\\\\\\\":683},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_component_handler(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":684},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":685},{\\\\\\\"text\\\\\\\":\\\\\\\"        handler: SharedVstPtr&lt;dyn vst3_sys::vst::IComponentHandler&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":686},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":687},{\\\\\\\"text\\\\\\\":\\\\\\\"        *self.inner.component_handler.borrow_mut() = handler.upgrade().map(VstPtr::from);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":688},{\\\\\\\"lineNumber\\\\\\\":689},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":690},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":691},{\\\\\\\"lineNumber\\\\\\\":692},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn create_view(&amp;self, _name: vst3_sys::base::FIDString) -&gt; *mut c_void {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":693},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Without specialization this is the least redundant way to check if the plugin has an\\\\\\\",\\\\\\\"lineNumber\\\\\\\":694},{\\\\\\\"text\\\\\\\":\\\\\\\"        // editor. The default implementation returns a None here.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":695},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.editor.borrow().as_ref() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":696},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(editor) =&gt; Box::into_raw(WrapperView::new(self.inner.clone(), editor.clone()))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":697},{\\\\\\\"text\\\\\\\":\\\\\\\"                as *mut vst3_sys::c_void,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":698},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; std::ptr::null_mut(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":699},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":700},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":701},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":702},{\\\\\\\"lineNumber\\\\\\\":703},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; IAudioProcessor for Wrapper&lt;P&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":704}]},\\\\\\\"score\\\\\\\":0.40450170636177063},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/context.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":188,\\\\\\\"column\\\\\\\":32},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":230,\\\\\\\"column\\\\\\\":1}},\\\\\\\"contents\\\\\\\":\\\\\\\"        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .set_parameter(param_id),\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn raw_end_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\\n        match &amp;*self.inner.component_handler.borrow() {\\\\\\\\n            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\\n                Some(hash) =&gt; {\\\\\\\\n                    handler.end_edit(*hash);\\\\\\\\n                }\\\\\\\\n                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\\n            },\\\\\\\\n            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        #[cfg(debug_assertions)]\\\\\\\\n        match self.inner.param_id_from_ptr(param) {\\\\\\\\n            Some(param_id) =&gt; self\\\\\\\\n                .param_gesture_checker\\\\\\\\n                .borrow_mut()\\\\\\\\n                .end_set_parameter(param_id),\\\\\\\\n            None =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_end_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn get_state(&amp;self) -&gt; PluginState {\\\\\\\\n        self.inner.get_state_object()\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    fn set_state(&amp;self, state: PluginState) {\\\\\\\\n        self.inner.set_state_object_from_gui(state)\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.param_id_from_ptr(param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":190},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_id) =&gt; self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":191},{\\\\\\\"text\\\\\\\":\\\\\\\"                .param_gesture_checker\\\\\\\",\\\\\\\"lineNumber\\\\\\\":192},{\\\\\\\"text\\\\\\\":\\\\\\\"                .borrow_mut()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":193},{\\\\\\\"text\\\\\\\":\\\\\\\"                .set_parameter(param_id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":194},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":195},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":196},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":197},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":198},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":199},{\\\\\\\"lineNumber\\\\\\\":200},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn raw_end_set_parameter(&amp;self, param: ParamPtr) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":201},{\\\\\\\"text\\\\\\\":\\\\\\\"        match &amp;*self.inner.component_handler.borrow() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":202},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(handler) =&gt; match self.inner.param_ptr_to_hash.get(&amp;param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":203},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(hash) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":204},{\\\\\\\"text\\\\\\\":\\\\\\\"                    handler.end_edit(*hash);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":205},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":206},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown parameter: {:?}\\\\\\\\\\\\\\\", param),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":207},{\\\\\\\"text\\\\\\\":\\\\\\\"            },\\\\\\\",\\\\\\\"lineNumber\\\\\\\":208},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Component handler not yet set\\\\\\\\\\\\\\\"),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":209},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":210},{\\\\\\\"lineNumber\\\\\\\":211},{\\\\\\\"text\\\\\\\":\\\\\\\"        #[cfg(debug_assertions)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":212},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.inner.param_id_from_ptr(param) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":213},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_id) =&gt; self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":214},{\\\\\\\"text\\\\\\\":\\\\\\\"                .param_gesture_checker\\\\\\\",\\\\\\\"lineNumber\\\\\\\":215},{\\\\\\\"text\\\\\\\":\\\\\\\"                .borrow_mut()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":216},{\\\\\\\"text\\\\\\\":\\\\\\\"                .end_set_parameter(param_id),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":217},{\\\\\\\"text\\\\\\\":\\\\\\\"            None =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":218},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"raw_end_set_parameter() called with an unknown ParamPtr\\\\\\\\\\\\\\\")\\\\\\\",\\\\\\\"lineNumber\\\\\\\":219},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":220},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":221},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":222},{\\\\\\\"lineNumber\\\\\\\":223},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn get_state(&amp;self) -&gt; PluginState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":224},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.get_state_object()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":225},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":226},{\\\\\\\"lineNumber\\\\\\\":227},{\\\\\\\"text\\\\\\\":\\\\\\\"    fn set_state(&amp;self, state: PluginState) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":228},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.set_state_object_from_gui(state)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":229},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":230},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":231}]},\\\\\\\"score\\\\\\\":0.39906924962997437},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1128,\\\\\\\"column\\\\\\\":93},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":1163,\\\\\\\"column\\\\\\\":99}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                            let event = event.event.note_expression_value;\\\\\\\\n                            match note_expression_controller.translate_event(timing, &amp;event) {\\\\\\\\n                                Some(translated_event) =&gt; {\\\\\\\\n                                    process_events.push(ProcessEvent::NoteEvent(translated_event))\\\\\\\\n                                }\\\\\\\\n                                None =&gt; nih_debug_assert_failure!(\\\\\\\\n                                    \\\\\\\\\\\\\\\"Unhandled note expression type: {}\\\\\\\\\\\\\\\",\\\\\\\\n                                    event.type_id\\\\\\\\n                                ),\\\\\\\\n                            }\\\\\\\\n                        } else if event.type_ == EventTypes::kDataEvent as u16\\\\\\\\n                            &amp;&amp; event.event.data.type_ == 0\\\\\\\\n                        {\\\\\\\\n                            // 0 = kMidiSysEx\\\\\\\\n                            let event = event.event.data;\\\\\\\\n\\\\\\\\n                            // &#96;NoteEvent::from_midi&#96; prints some tracing if parsing fails, which is\\\\\\\\n                            // not necessarily an error\\\\\\\\n                            assert!(!event.bytes.is_null());\\\\\\\\n                            let sysex_buffer =\\\\\\\\n                                std::slice::from_raw_parts(event.bytes, event.size as usize);\\\\\\\\n                            if let Ok(note_event) = NoteEvent::from_midi(timing, sysex_buffer) {\\\\\\\\n                                process_events.push(ProcessEvent::NoteEvent(note_event));\\\\\\\\n                            };\\\\\\\\n                        }\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            }\\\\\\\\n\\\\\\\\n            // And then we'll make sure everything is in the right order\\\\\\\\n            // NOTE: It's important that this sort is stable, because parameter changes need to be\\\\\\\\n            //       processed before note events. Otherwise you'll get out of bounds note events\\\\\\\\n            //       with block splitting when the note event occurs at one index after the end (or\\\\\\\\n            //       on the exclusive end index) of the block.\\\\\\\\n            // FIXME: Apparently stable sort allcoates if the slice is large enough. This should be\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1129},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let event = event.event.note_expression_value;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1130},{\\\\\\\"text\\\\\\\":\\\\\\\"                            match note_expression_controller.translate_event(timing, &amp;event) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1131},{\\\\\\\"text\\\\\\\":\\\\\\\"                                Some(translated_event) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1132},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    process_events.push(ProcessEvent::NoteEvent(translated_event))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1133},{\\\\\\\"text\\\\\\\":\\\\\\\"                                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1134},{\\\\\\\"text\\\\\\\":\\\\\\\"                                None =&gt; nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1135},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    \\\\\\\\\\\\\\\"Unhandled note expression type: {}\\\\\\\\\\\\\\\",\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1136},{\\\\\\\"text\\\\\\\":\\\\\\\"                                    event.type_id\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1137},{\\\\\\\"text\\\\\\\":\\\\\\\"                                ),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1138},{\\\\\\\"text\\\\\\\":\\\\\\\"                            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1139},{\\\\\\\"text\\\\\\\":\\\\\\\"                        } else if event.type_ == EventTypes::kDataEvent as u16\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1140},{\\\\\\\"text\\\\\\\":\\\\\\\"                            &amp;&amp; event.event.data.type_ == 0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1141},{\\\\\\\"text\\\\\\\":\\\\\\\"                        {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1142},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // 0 = kMidiSysEx\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1143},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let event = event.event.data;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1144},{\\\\\\\"lineNumber\\\\\\\":1145},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // &#96;NoteEvent::from_midi&#96; prints some tracing if parsing fails, which is\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1146},{\\\\\\\"text\\\\\\\":\\\\\\\"                            // not necessarily an error\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1147},{\\\\\\\"text\\\\\\\":\\\\\\\"                            assert!(!event.bytes.is_null());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1148},{\\\\\\\"text\\\\\\\":\\\\\\\"                            let sysex_buffer =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1149},{\\\\\\\"text\\\\\\\":\\\\\\\"                                std::slice::from_raw_parts(event.bytes, event.size as usize);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1150},{\\\\\\\"text\\\\\\\":\\\\\\\"                            if let Ok(note_event) = NoteEvent::from_midi(timing, sysex_buffer) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1151},{\\\\\\\"text\\\\\\\":\\\\\\\"                                process_events.push(ProcessEvent::NoteEvent(note_event));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1152},{\\\\\\\"text\\\\\\\":\\\\\\\"                            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1153},{\\\\\\\"text\\\\\\\":\\\\\\\"                        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1154},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1155},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1156},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1157},{\\\\\\\"lineNumber\\\\\\\":1158},{\\\\\\\"text\\\\\\\":\\\\\\\"            // And then we'll make sure everything is in the right order\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1159},{\\\\\\\"text\\\\\\\":\\\\\\\"            // NOTE: It's important that this sort is stable, because parameter changes need to be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1160},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       processed before note events. Otherwise you'll get out of bounds note events\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1161},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       with block splitting when the note event occurs at one index after the end (or\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1162},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       on the exclusive end index) of the block.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1163},{\\\\\\\"text\\\\\\\":\\\\\\\"            // FIXME: Apparently stable sort allcoates if the slice is large enough. This should be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1164}]},\\\\\\\"score\\\\\\\":0.3951559066772461},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":699,\\\\\\\"column\\\\\\\":9},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":745,\\\\\\\"column\\\\\\\":22}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n}\\\\\\\\n\\\\\\\\nimpl&lt;P: Vst3Plugin&gt; IAudioProcessor for Wrapper&lt;P&gt; {\\\\\\\\n    unsafe fn set_bus_arrangements(\\\\\\\\n        &amp;self,\\\\\\\\n        inputs: *mut vst3_sys::vst::SpeakerArrangement,\\\\\\\\n        num_ins: i32,\\\\\\\\n        outputs: *mut vst3_sys::vst::SpeakerArrangement,\\\\\\\\n        num_outs: i32,\\\\\\\\n    ) -&gt; tresult {\\\\\\\\n        check_null_ptr!(inputs, outputs);\\\\\\\\n\\\\\\\\n        // Why are these signed integers again?\\\\\\\\n        if num_ins &lt; 0 || num_outs &lt; 0 {\\\\\\\\n            return kInvalidArgument;\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // NIH-plug no longer supports flexible IO layouts. Instead we'll try to find an audio IO\\\\\\\\n        // layout that matches the host's requested layout.\\\\\\\\n        let matching_layout = P::AUDIO_IO_LAYOUTS\\\\\\\\n            .iter()\\\\\\\\n            .find(|layout| {\\\\\\\\n                // If the number of ports/busses doesn't match then we can immediately discard the\\\\\\\\n                // layout. VST3 doesn't allow for optional switchable ports like CLAP does. Only the\\\\\\\\n                // channel counts can change.\\\\\\\\n                let num_layout_ins = if layout.main_input_channels.is_some() {\\\\\\\\n                    1\\\\\\\\n                } else {\\\\\\\\n                    0\\\\\\\\n                } + layout.aux_input_ports.len();\\\\\\\\n                let num_layout_outs = if layout.main_output_channels.is_some() {\\\\\\\\n                    1\\\\\\\\n                } else {\\\\\\\\n                    0\\\\\\\\n                } + layout.aux_output_ports.len();\\\\\\\\n                if num_ins as usize != num_layout_ins || num_outs as usize != num_layout_outs {\\\\\\\\n                    return false;\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                // NOTE: We completely ignore the speaker arrangements and only look at the channel\\\\\\\\n                //       counts here. This may cause issues at some point, but it works for now.\\\\\\\\n                let has_main_input = layout.main_input_channels.is_some();\\\\\\\\n                let aux_input_start_idx = if has_main_input { 0 } else { 1 };\\\\\\\\n                if has_main_input\\\\\\\\n                    &amp;&amp;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":701},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":702},{\\\\\\\"lineNumber\\\\\\\":703},{\\\\\\\"text\\\\\\\":\\\\\\\"impl&lt;P: Vst3Plugin&gt; IAudioProcessor for Wrapper&lt;P&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":704},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_bus_arrangements(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":705},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":706},{\\\\\\\"text\\\\\\\":\\\\\\\"        inputs: *mut vst3_sys::vst::SpeakerArrangement,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":707},{\\\\\\\"text\\\\\\\":\\\\\\\"        num_ins: i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":708},{\\\\\\\"text\\\\\\\":\\\\\\\"        outputs: *mut vst3_sys::vst::SpeakerArrangement,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":709},{\\\\\\\"text\\\\\\\":\\\\\\\"        num_outs: i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":710},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":711},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(inputs, outputs);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":712},{\\\\\\\"lineNumber\\\\\\\":713},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Why are these signed integers again?\\\\\\\",\\\\\\\"lineNumber\\\\\\\":714},{\\\\\\\"text\\\\\\\":\\\\\\\"        if num_ins &lt; 0 || num_outs &lt; 0 {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":715},{\\\\\\\"text\\\\\\\":\\\\\\\"            return kInvalidArgument;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":716},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":717},{\\\\\\\"lineNumber\\\\\\\":718},{\\\\\\\"text\\\\\\\":\\\\\\\"        // NIH-plug no longer supports flexible IO layouts. Instead we'll try to find an audio IO\\\\\\\",\\\\\\\"lineNumber\\\\\\\":719},{\\\\\\\"text\\\\\\\":\\\\\\\"        // layout that matches the host's requested layout.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":720},{\\\\\\\"text\\\\\\\":\\\\\\\"        let matching_layout = P::AUDIO_IO_LAYOUTS\\\\\\\",\\\\\\\"lineNumber\\\\\\\":721},{\\\\\\\"text\\\\\\\":\\\\\\\"            .iter()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":722},{\\\\\\\"text\\\\\\\":\\\\\\\"            .find(|layout| {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":723},{\\\\\\\"text\\\\\\\":\\\\\\\"                // If the number of ports/busses doesn't match then we can immediately discard the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":724},{\\\\\\\"text\\\\\\\":\\\\\\\"                // layout. VST3 doesn't allow for optional switchable ports like CLAP does. Only the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":725},{\\\\\\\"text\\\\\\\":\\\\\\\"                // channel counts can change.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":726},{\\\\\\\"text\\\\\\\":\\\\\\\"                let num_layout_ins = if layout.main_input_channels.is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":727},{\\\\\\\"text\\\\\\\":\\\\\\\"                    1\\\\\\\",\\\\\\\"lineNumber\\\\\\\":728},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":729},{\\\\\\\"text\\\\\\\":\\\\\\\"                    0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":730},{\\\\\\\"text\\\\\\\":\\\\\\\"                } + layout.aux_input_ports.len();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":731},{\\\\\\\"text\\\\\\\":\\\\\\\"                let num_layout_outs = if layout.main_output_channels.is_some() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":732},{\\\\\\\"text\\\\\\\":\\\\\\\"                    1\\\\\\\",\\\\\\\"lineNumber\\\\\\\":733},{\\\\\\\"text\\\\\\\":\\\\\\\"                } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":734},{\\\\\\\"text\\\\\\\":\\\\\\\"                    0\\\\\\\",\\\\\\\"lineNumber\\\\\\\":735},{\\\\\\\"text\\\\\\\":\\\\\\\"                } + layout.aux_output_ports.len();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":736},{\\\\\\\"text\\\\\\\":\\\\\\\"                if num_ins as usize != num_layout_ins || num_outs as usize != num_layout_outs {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":737},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return false;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":738},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":739},{\\\\\\\"lineNumber\\\\\\\":740},{\\\\\\\"text\\\\\\\":\\\\\\\"                // NOTE: We completely ignore the speaker arrangements and only look at the channel\\\\\\\",\\\\\\\"lineNumber\\\\\\\":741},{\\\\\\\"text\\\\\\\":\\\\\\\"                //       counts here. This may cause issues at some point, but it works for now.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":742},{\\\\\\\"text\\\\\\\":\\\\\\\"                let has_main_input = layout.main_input_channels.is_some();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":743},{\\\\\\\"text\\\\\\\":\\\\\\\"                let aux_input_start_idx = if has_main_input { 0 } else { 1 };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":744},{\\\\\\\"text\\\\\\\":\\\\\\\"                if has_main_input\\\\\\\",\\\\\\\"lineNumber\\\\\\\":745},{\\\\\\\"text\\\\\\\":\\\\\\\"                    &amp;&amp;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":746}]},\\\\\\\"score\\\\\\\":0.3930532932281494},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":466,\\\\\\\"column\\\\\\\":49},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":484,\\\\\\\"column\\\\\\\":97}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n        unsafe {\\\\\\\\n            state::serialize_object::&lt;P&gt;(\\\\\\\\n                self.params.clone(),\\\\\\\\n                state::make_params_iter(&amp;self.param_by_hash, &amp;self.param_id_to_hash),\\\\\\\\n            )\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Update the plugin's internal state, called by the plugin itself from the GUI thread. To\\\\\\\\n    /// prevent corrupting data and changing parameters during processing the actual state is only\\\\\\\\n    /// updated at the end of the audio processing cycle.\\\\\\\\n    pub fn set_state_object_from_gui(&amp;self, mut state: PluginState) {\\\\\\\\n        // Use a loop and timeouts to handle the super rare edge case when this function gets called\\\\\\\\n        // between a process call and the host disabling the plugin\\\\\\\\n        loop {\\\\\\\\n            if self.is_processing.load(Ordering::SeqCst) {\\\\\\\\n                // If the plugin is currently processing audio, then we'll perform the restore\\\\\\\\n                // operation at the end of the audio call. This involves sending the state to the\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":467},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":468},{\\\\\\\"text\\\\\\\":\\\\\\\"            state::serialize_object::&lt;P&gt;(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":469},{\\\\\\\"text\\\\\\\":\\\\\\\"                self.params.clone(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":470},{\\\\\\\"text\\\\\\\":\\\\\\\"                state::make_params_iter(&amp;self.param_by_hash, &amp;self.param_id_to_hash),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":471},{\\\\\\\"text\\\\\\\":\\\\\\\"            )\\\\\\\",\\\\\\\"lineNumber\\\\\\\":472},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":473},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":474},{\\\\\\\"lineNumber\\\\\\\":475},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Update the plugin's internal state, called by the plugin itself from the GUI thread. To\\\\\\\",\\\\\\\"lineNumber\\\\\\\":476},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// prevent corrupting data and changing parameters during processing the actual state is only\\\\\\\",\\\\\\\"lineNumber\\\\\\\":477},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// updated at the end of the audio processing cycle.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":478},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_state_object_from_gui(&amp;self, mut state: PluginState) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":479},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Use a loop and timeouts to handle the super rare edge case when this function gets called\\\\\\\",\\\\\\\"lineNumber\\\\\\\":480},{\\\\\\\"text\\\\\\\":\\\\\\\"        // between a process call and the host disabling the plugin\\\\\\\",\\\\\\\"lineNumber\\\\\\\":481},{\\\\\\\"text\\\\\\\":\\\\\\\"        loop {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":482},{\\\\\\\"text\\\\\\\":\\\\\\\"            if self.is_processing.load(Ordering::SeqCst) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":483},{\\\\\\\"text\\\\\\\":\\\\\\\"                // If the plugin is currently processing audio, then we'll perform the restore\\\\\\\",\\\\\\\"lineNumber\\\\\\\":484},{\\\\\\\"text\\\\\\\":\\\\\\\"                // operation at the end of the audio call. This involves sending the state to the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":485}]},\\\\\\\"score\\\\\\\":0.3924601972103119},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":424,\\\\\\\"column\\\\\\\":20},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":468,\\\\\\\"column\\\\\\\":40}},\\\\\\\"contents\\\\\\\":\\\\\\\"    pub fn param_id_from_ptr(&amp;self, param: ParamPtr) -&gt; Option&lt;&amp;str&gt; {\\\\\\\\n        self.param_ptr_to_hash\\\\\\\\n            .get(&amp;param)\\\\\\\\n            .and_then(|hash| self.param_id_by_hash.get(hash))\\\\\\\\n            .map(|s| s.as_str())\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Convenience function for setting a value for a parameter as triggered by a VST3 parameter\\\\\\\\n    /// update. The same rate is for updating parameter smoothing.\\\\\\\\n    ///\\\\\\\\n    /// After calling this function, you should call\\\\\\\\n    /// [&#96;notify_param_values_changed()&#96;][Self::notify_param_values_changed()] to allow the editor\\\\\\\\n    /// to update itself. This needs to be done separately so you can process parameter changes in\\\\\\\\n    /// batches.\\\\\\\\n    pub fn set_normalized_value_by_hash(\\\\\\\\n        &amp;self,\\\\\\\\n        hash: u32,\\\\\\\\n        normalized_value: f32,\\\\\\\\n        sample_rate: Option&lt;f32&gt;,\\\\\\\\n    ) -&gt; tresult {\\\\\\\\n        match self.param_by_hash.get(&amp;hash) {\\\\\\\\n            Some(param_ptr) =&gt; {\\\\\\\\n                if unsafe { param_ptr.set_normalized_value(normalized_value) } {\\\\\\\\n                    if let Some(sample_rate) = sample_rate {\\\\\\\\n                        unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\\n                    }\\\\\\\\n\\\\\\\\n                    let task_posted =\\\\\\\\n                        self.schedule_gui(Task::ParameterValueChanged(hash, normalized_value));\\\\\\\\n                    nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n                }\\\\\\\\n\\\\\\\\n                kResultOk\\\\\\\\n            }\\\\\\\\n            _ =&gt; kInvalidArgument,\\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    /// Get the plugin's state object, may be called by the plugin's GUI as part of its own preset\\\\\\\\n    /// management. The wrapper doesn't use these functions and serializes and deserializes directly\\\\\\\\n    /// the JSON in the relevant plugin API methods instead.\\\\\\\\n    pub fn get_state_object(&amp;self) -&gt; PluginState {\\\\\\\\n        unsafe {\\\\\\\\n            state::serialize_object::&lt;P&gt;\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn param_id_from_ptr(&amp;self, param: ParamPtr) -&gt; Option&lt;&amp;str&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":426},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.param_ptr_to_hash\\\\\\\",\\\\\\\"lineNumber\\\\\\\":427},{\\\\\\\"text\\\\\\\":\\\\\\\"            .get(&amp;param)\\\\\\\",\\\\\\\"lineNumber\\\\\\\":428},{\\\\\\\"text\\\\\\\":\\\\\\\"            .and_then(|hash| self.param_id_by_hash.get(hash))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":429},{\\\\\\\"text\\\\\\\":\\\\\\\"            .map(|s| s.as_str())\\\\\\\",\\\\\\\"lineNumber\\\\\\\":430},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":431},{\\\\\\\"lineNumber\\\\\\\":432},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Convenience function for setting a value for a parameter as triggered by a VST3 parameter\\\\\\\",\\\\\\\"lineNumber\\\\\\\":433},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// update. The same rate is for updating parameter smoothing.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":434},{\\\\\\\"text\\\\\\\":\\\\\\\"    ///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":435},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// After calling this function, you should call\\\\\\\",\\\\\\\"lineNumber\\\\\\\":436},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// [&#96;notify_param_values_changed()&#96;][Self::notify_param_values_changed()] to allow the editor\\\\\\\",\\\\\\\"lineNumber\\\\\\\":437},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// to update itself. This needs to be done separately so you can process parameter changes in\\\\\\\",\\\\\\\"lineNumber\\\\\\\":438},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// batches.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":439},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn set_normalized_value_by_hash(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":440},{\\\\\\\"text\\\\\\\":\\\\\\\"        &amp;self,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":441},{\\\\\\\"text\\\\\\\":\\\\\\\"        hash: u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":442},{\\\\\\\"text\\\\\\\":\\\\\\\"        normalized_value: f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":443},{\\\\\\\"text\\\\\\\":\\\\\\\"        sample_rate: Option&lt;f32&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":444},{\\\\\\\"text\\\\\\\":\\\\\\\"    ) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":445},{\\\\\\\"text\\\\\\\":\\\\\\\"        match self.param_by_hash.get(&amp;hash) {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":446},{\\\\\\\"text\\\\\\\":\\\\\\\"            Some(param_ptr) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":447},{\\\\\\\"text\\\\\\\":\\\\\\\"                if unsafe { param_ptr.set_normalized_value(normalized_value) } {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":448},{\\\\\\\"text\\\\\\\":\\\\\\\"                    if let Some(sample_rate) = sample_rate {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":449},{\\\\\\\"text\\\\\\\":\\\\\\\"                        unsafe { param_ptr.update_smoother(sample_rate, false) };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":450},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":451},{\\\\\\\"lineNumber\\\\\\\":452},{\\\\\\\"text\\\\\\\":\\\\\\\"                    let task_posted =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":453},{\\\\\\\"text\\\\\\\":\\\\\\\"                        self.schedule_gui(Task::ParameterValueChanged(hash, normalized_value));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":454},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":455},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":456},{\\\\\\\"lineNumber\\\\\\\":457},{\\\\\\\"text\\\\\\\":\\\\\\\"                kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":458},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":459},{\\\\\\\"text\\\\\\\":\\\\\\\"            _ =&gt; kInvalidArgument,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":460},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":461},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":462},{\\\\\\\"lineNumber\\\\\\\":463},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// Get the plugin's state object, may be called by the plugin's GUI as part of its own preset\\\\\\\",\\\\\\\"lineNumber\\\\\\\":464},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// management. The wrapper doesn't use these functions and serializes and deserializes directly\\\\\\\",\\\\\\\"lineNumber\\\\\\\":465},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// the JSON in the relevant plugin API methods instead.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":466},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub fn get_state_object(&amp;self) -&gt; PluginState {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":467},{\\\\\\\"text\\\\\\\":\\\\\\\"        unsafe {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":468},{\\\\\\\"text\\\\\\\":\\\\\\\"            state::serialize_object::&lt;P&gt;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":469}]},\\\\\\\"score\\\\\\\":0.39185094833374023},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/inner.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":482,\\\\\\\"column\\\\\\\":56},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":526,\\\\\\\"column\\\\\\\":5}},\\\\\\\"contents\\\\\\\":\\\\\\\" {\\\\\\\\n                // If the plugin is currently processing audio, then we'll perform the restore\\\\\\\\n                // operation at the end of the audio call. This involves sending the state to the\\\\\\\\n                // audio thread, having the audio thread handle the state restore at the very end of\\\\\\\\n                // the process function, and then sending the state back to this thread so it can be\\\\\\\\n                // deallocated without blocking the audio thread.\\\\\\\\n                match self\\\\\\\\n                    .updated_state_sender\\\\\\\\n                    .send_timeout(state, Duration::from_secs(1))\\\\\\\\n                {\\\\\\\\n                    Ok(_) =&gt; {\\\\\\\\n                        // As mentioned above, the state object will be passed back to this thread\\\\\\\\n                        // so we can deallocate it without blocking.\\\\\\\\n                        let state = self.updated_state_receiver.recv();\\\\\\\\n                        drop(state);\\\\\\\\n                        break;\\\\\\\\n                    }\\\\\\\\n                    Err(SendTimeoutError::Timeout(value)) =&gt; {\\\\\\\\n                        state = value;\\\\\\\\n                        continue;\\\\\\\\n                    }\\\\\\\\n                    Err(SendTimeoutError::Disconnected(_)) =&gt; {\\\\\\\\n                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"State update channel got disconnected\\\\\\\\\\\\\\\");\\\\\\\\n                        return;\\\\\\\\n                    }\\\\\\\\n                }\\\\\\\\n            } else {\\\\\\\\n                // Otherwise we'll set the state right here and now, since this function should be\\\\\\\\n                // called from a GUI thread\\\\\\\\n                self.set_state_inner(&amp;mut state);\\\\\\\\n                break;\\\\\\\\n            }\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // After the state has been updated, notify the host about the new parameter values\\\\\\\\n        let task_posted =\\\\\\\\n            self.event_loop\\\\\\\\n                .borrow()\\\\\\\\n                .as_ref()\\\\\\\\n                .unwrap()\\\\\\\\n                .schedule_gui(Task::TriggerRestart(\\\\\\\\n                    RestartFlags::kParamValuesChanged as i32,\\\\\\\\n                ));\\\\\\\\n        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\" {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":483},{\\\\\\\"text\\\\\\\":\\\\\\\"                // If the plugin is currently processing audio, then we'll perform the restore\\\\\\\",\\\\\\\"lineNumber\\\\\\\":484},{\\\\\\\"text\\\\\\\":\\\\\\\"                // operation at the end of the audio call. This involves sending the state to the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":485},{\\\\\\\"text\\\\\\\":\\\\\\\"                // audio thread, having the audio thread handle the state restore at the very end of\\\\\\\",\\\\\\\"lineNumber\\\\\\\":486},{\\\\\\\"text\\\\\\\":\\\\\\\"                // the process function, and then sending the state back to this thread so it can be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":487},{\\\\\\\"text\\\\\\\":\\\\\\\"                // deallocated without blocking the audio thread.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":488},{\\\\\\\"text\\\\\\\":\\\\\\\"                match self\\\\\\\",\\\\\\\"lineNumber\\\\\\\":489},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .updated_state_sender\\\\\\\",\\\\\\\"lineNumber\\\\\\\":490},{\\\\\\\"text\\\\\\\":\\\\\\\"                    .send_timeout(state, Duration::from_secs(1))\\\\\\\",\\\\\\\"lineNumber\\\\\\\":491},{\\\\\\\"text\\\\\\\":\\\\\\\"                {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":492},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Ok(_) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":493},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // As mentioned above, the state object will be passed back to this thread\\\\\\\",\\\\\\\"lineNumber\\\\\\\":494},{\\\\\\\"text\\\\\\\":\\\\\\\"                        // so we can deallocate it without blocking.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":495},{\\\\\\\"text\\\\\\\":\\\\\\\"                        let state = self.updated_state_receiver.recv();\\\\\\\",\\\\\\\"lineNumber\\\\\\\":496},{\\\\\\\"text\\\\\\\":\\\\\\\"                        drop(state);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":497},{\\\\\\\"text\\\\\\\":\\\\\\\"                        break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":498},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":499},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Err(SendTimeoutError::Timeout(value)) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":500},{\\\\\\\"text\\\\\\\":\\\\\\\"                        state = value;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":501},{\\\\\\\"text\\\\\\\":\\\\\\\"                        continue;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":502},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":503},{\\\\\\\"text\\\\\\\":\\\\\\\"                    Err(SendTimeoutError::Disconnected(_)) =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":504},{\\\\\\\"text\\\\\\\":\\\\\\\"                        nih_debug_assert_failure!(\\\\\\\\\\\\\\\"State update channel got disconnected\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":505},{\\\\\\\"text\\\\\\\":\\\\\\\"                        return;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":506},{\\\\\\\"text\\\\\\\":\\\\\\\"                    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":507},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":508},{\\\\\\\"text\\\\\\\":\\\\\\\"            } else {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":509},{\\\\\\\"text\\\\\\\":\\\\\\\"                // Otherwise we'll set the state right here and now, since this function should be\\\\\\\",\\\\\\\"lineNumber\\\\\\\":510},{\\\\\\\"text\\\\\\\":\\\\\\\"                // called from a GUI thread\\\\\\\",\\\\\\\"lineNumber\\\\\\\":511},{\\\\\\\"text\\\\\\\":\\\\\\\"                self.set_state_inner(&amp;mut state);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":512},{\\\\\\\"text\\\\\\\":\\\\\\\"                break;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":513},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":514},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":515},{\\\\\\\"lineNumber\\\\\\\":516},{\\\\\\\"text\\\\\\\":\\\\\\\"        // After the state has been updated, notify the host about the new parameter values\\\\\\\",\\\\\\\"lineNumber\\\\\\\":517},{\\\\\\\"text\\\\\\\":\\\\\\\"        let task_posted =\\\\\\\",\\\\\\\"lineNumber\\\\\\\":518},{\\\\\\\"text\\\\\\\":\\\\\\\"            self.event_loop\\\\\\\",\\\\\\\"lineNumber\\\\\\\":519},{\\\\\\\"text\\\\\\\":\\\\\\\"                .borrow()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":520},{\\\\\\\"text\\\\\\\":\\\\\\\"                .as_ref()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":521},{\\\\\\\"text\\\\\\\":\\\\\\\"                .unwrap()\\\\\\\",\\\\\\\"lineNumber\\\\\\\":522},{\\\\\\\"text\\\\\\\":\\\\\\\"                .schedule_gui(Task::TriggerRestart(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":523},{\\\\\\\"text\\\\\\\":\\\\\\\"                    RestartFlags::kParamValuesChanged as i32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":524},{\\\\\\\"text\\\\\\\":\\\\\\\"                ));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":525},{\\\\\\\"text\\\\\\\":\\\\\\\"        nih_debug_assert!(task_posted, \\\\\\\\\\\\\\\"The task queue is full, dropping task...\\\\\\\\\\\\\\\");\\\\\\\",\\\\\\\"lineNumber\\\\\\\":526},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":527}]},\\\\\\\"score\\\\\\\":0.3905881643295288},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/context.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":46,\\\\\\\"column\\\\\\\":3}},\\\\\\\"contents\\\\\\\":\\\\\\\"use atomic_refcell::AtomicRefMut;\\\\\\\\nuse std::cell::Cell;\\\\\\\\nuse std::collections::VecDeque;\\\\\\\\nuse std::sync::atomic::Ordering;\\\\\\\\nuse std::sync::Arc;\\\\\\\\nuse vst3_sys::vst::IComponentHandler;\\\\\\\\n\\\\\\\\nuse crate::prelude::{\\\\\\\\n    GuiContext, InitContext, ParamPtr, PluginApi, PluginNoteEvent, PluginState, ProcessContext,\\\\\\\\n    Transport, Vst3Plugin,\\\\\\\\n};\\\\\\\\n\\\\\\\\nuse super::inner::{Task, WrapperInner};\\\\\\\\n\\\\\\\\n/// An [&#96;InitContext&#96;] implementation for the wrapper.\\\\\\\\n///\\\\\\\\n/// # Note\\\\\\\\n///\\\\\\\\n/// Requests to change the latency are only sent when this object is dropped. Otherwise there's the\\\\\\\\n/// risk that the host will immediately deactivate/reactivate the plugin while still in the init\\\\\\\\n/// call. Reentrannt function calls are difficult to handle in Rust without forcing everything to\\\\\\\\n/// use interior mutability, so this will have to do for now. This does mean that &#96;Plugin&#96; mutex\\\\\\\\n/// lock has to be dropped before this object.\\\\\\\\npub(crate) struct WrapperInitContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\\n    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\\n    pub(super) pending_requests: PendingInitContextRequests,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// Any requests that should be sent out when the [&#96;WrapperInitContext&#96;] is dropped. See that\\\\\\\\n/// struct's docstring for mroe information.\\\\\\\\n#[derive(Debug, Default)]\\\\\\\\npub(crate) struct PendingInitContextRequests {\\\\\\\\n    /// The value of the last &#96;.set_latency_samples()&#96; call.\\\\\\\\n    latency_changed: Cell&lt;Option&lt;u32&gt;&gt;,\\\\\\\\n}\\\\\\\\n\\\\\\\\n/// A [&#96;ProcessContext&#96;] implementation for the wrapper. This is a separate object so it can hold on\\\\\\\\n/// to lock guards for event queues. Otherwise reading these events would require constant\\\\\\\\n/// unnecessary atomic operations to lock the uncontested locks.\\\\\\\\npub(crate) struct WrapperProcessContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\\n    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\\n    pub(super) input_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    pub(super) output_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\\n    pub(super) transport: Transport,\\\\\\\\n}\\\\\\\\n\\\\\\\\n///\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"use atomic_refcell::AtomicRefMut;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":1},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::cell::Cell;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":2},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::collections::VecDeque;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":3},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::atomic::Ordering;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":4},{\\\\\\\"text\\\\\\\":\\\\\\\"use std::sync::Arc;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":5},{\\\\\\\"text\\\\\\\":\\\\\\\"use vst3_sys::vst::IComponentHandler;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":6},{\\\\\\\"lineNumber\\\\\\\":7},{\\\\\\\"text\\\\\\\":\\\\\\\"use crate::prelude::{\\\\\\\",\\\\\\\"lineNumber\\\\\\\":8},{\\\\\\\"text\\\\\\\":\\\\\\\"    GuiContext, InitContext, ParamPtr, PluginApi, PluginNoteEvent, PluginState, ProcessContext,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":9},{\\\\\\\"text\\\\\\\":\\\\\\\"    Transport, Vst3Plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":10},{\\\\\\\"text\\\\\\\":\\\\\\\"};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":11},{\\\\\\\"lineNumber\\\\\\\":12},{\\\\\\\"text\\\\\\\":\\\\\\\"use super::inner::{Task, WrapperInner};\\\\\\\",\\\\\\\"lineNumber\\\\\\\":13},{\\\\\\\"lineNumber\\\\\\\":14},{\\\\\\\"text\\\\\\\":\\\\\\\"/// An [&#96;InitContext&#96;] implementation for the wrapper.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":15},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":16},{\\\\\\\"text\\\\\\\":\\\\\\\"/// # Note\\\\\\\",\\\\\\\"lineNumber\\\\\\\":17},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":18},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Requests to change the latency are only sent when this object is dropped. Otherwise there's the\\\\\\\",\\\\\\\"lineNumber\\\\\\\":19},{\\\\\\\"text\\\\\\\":\\\\\\\"/// risk that the host will immediately deactivate/reactivate the plugin while still in the init\\\\\\\",\\\\\\\"lineNumber\\\\\\\":20},{\\\\\\\"text\\\\\\\":\\\\\\\"/// call. Reentrannt function calls are difficult to handle in Rust without forcing everything to\\\\\\\",\\\\\\\"lineNumber\\\\\\\":21},{\\\\\\\"text\\\\\\\":\\\\\\\"/// use interior mutability, so this will have to do for now. This does mean that &#96;Plugin&#96; mutex\\\\\\\",\\\\\\\"lineNumber\\\\\\\":22},{\\\\\\\"text\\\\\\\":\\\\\\\"/// lock has to be dropped before this object.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":23},{\\\\\\\"text\\\\\\\":\\\\\\\"pub(crate) struct WrapperInitContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":24},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":25},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) pending_requests: PendingInitContextRequests,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":26},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":27},{\\\\\\\"lineNumber\\\\\\\":28},{\\\\\\\"text\\\\\\\":\\\\\\\"/// Any requests that should be sent out when the [&#96;WrapperInitContext&#96;] is dropped. See that\\\\\\\",\\\\\\\"lineNumber\\\\\\\":29},{\\\\\\\"text\\\\\\\":\\\\\\\"/// struct's docstring for mroe information.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":30},{\\\\\\\"text\\\\\\\":\\\\\\\"#[derive(Debug, Default)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":31},{\\\\\\\"text\\\\\\\":\\\\\\\"pub(crate) struct PendingInitContextRequests {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":32},{\\\\\\\"text\\\\\\\":\\\\\\\"    /// The value of the last &#96;.set_latency_samples()&#96; call.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":33},{\\\\\\\"text\\\\\\\":\\\\\\\"    latency_changed: Cell&lt;Option&lt;u32&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":34},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":35},{\\\\\\\"lineNumber\\\\\\\":36},{\\\\\\\"text\\\\\\\":\\\\\\\"/// A [&#96;ProcessContext&#96;] implementation for the wrapper. This is a separate object so it can hold on\\\\\\\",\\\\\\\"lineNumber\\\\\\\":37},{\\\\\\\"text\\\\\\\":\\\\\\\"/// to lock guards for event queues. Otherwise reading these events would require constant\\\\\\\",\\\\\\\"lineNumber\\\\\\\":38},{\\\\\\\"text\\\\\\\":\\\\\\\"/// unnecessary atomic operations to lock the uncontested locks.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":39},{\\\\\\\"text\\\\\\\":\\\\\\\"pub(crate) struct WrapperProcessContext&lt;'a, P: Vst3Plugin&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":40},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) inner: &amp;'a WrapperInner&lt;P&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":41},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) input_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":42},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) output_events_guard: AtomicRefMut&lt;'a, VecDeque&lt;PluginNoteEvent&lt;P&gt;&gt;&gt;,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":43},{\\\\\\\"text\\\\\\\":\\\\\\\"    pub(super) transport: Transport,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":44},{\\\\\\\"text\\\\\\\":\\\\\\\"}\\\\\\\",\\\\\\\"lineNumber\\\\\\\":45},{\\\\\\\"lineNumber\\\\\\\":46},{\\\\\\\"text\\\\\\\":\\\\\\\"///\\\\\\\",\\\\\\\"lineNumber\\\\\\\":47}]},\\\\\\\"score\\\\\\\":0.38639044761657715},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":894,\\\\\\\"column\\\\\\\":17},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":935,\\\\\\\"column\\\\\\\":10}},\\\\\\\"contents\\\\\\\":\\\\\\\"    }\\\\\\\\n\\\\\\\\n    unsafe fn set_processing(&amp;self, state: TBool) -&gt; tresult {\\\\\\\\n        let state = state != 0;\\\\\\\\n\\\\\\\\n        // Always reset the processing status when the plugin gets activated or deactivated\\\\\\\\n        self.inner.last_process_status.store(ProcessStatus::Normal);\\\\\\\\n        self.inner.is_processing.store(state, Ordering::SeqCst);\\\\\\\\n\\\\\\\\n        // This function is also used to reset buffers on the plugin, so we should do the same\\\\\\\\n        // thing. We don't call &#96;reset()&#96; in &#96;setup_processing()&#96; for that same reason.\\\\\\\\n        if state {\\\\\\\\n            // HACK: See the comment in &#96;IComponent::setActive()&#96;. This is needed to work around\\\\\\\\n            //       Ardour bugs.\\\\\\\\n            let mut plugin = match self.inner.plugin.try_lock() {\\\\\\\\n                Some(plugin) =&gt; plugin,\\\\\\\\n                None =&gt; {\\\\\\\\n                    nih_debug_assert_failure!(\\\\\\\\n                        \\\\\\\\\\\\\\\"The host tried to call IAudioProcessor::setProcessing(true) during a \\\\\\\\\\\\\\\\\\\\\\\\n                         reentrent call to IComponent::setActive(true), returning kResultOk. If \\\\\\\\\\\\\\\\\\\\\\\\n                         this is Ardour then it will still call \\\\\\\\\\\\\\\\\\\\\\\\n                         IAudioProcessor::setProcessing(true) later and everything will be fine. \\\\\\\\\\\\\\\\\\\\\\\\n                         Hopefully.\\\\\\\\\\\\\\\"\\\\\\\\n                    );\\\\\\\\n                    return kResultOk;\\\\\\\\n                }\\\\\\\\n            };\\\\\\\\n\\\\\\\\n            process_wrapper(|| plugin.reset());\\\\\\\\n        }\\\\\\\\n\\\\\\\\n        // We don't have any special handling for suspending and resuming plugins, yet\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Clippy doesn't understand our &#96;event_start_idx&#96;\\\\\\\\n    #[allow(clippy::mut_range_bound)]\\\\\\\\n    unsafe fn process(&amp;self, data: *mut vst3_sys::vst::ProcessData) -&gt; tresult {\\\\\\\\n        check_null_ptr!(data);\\\\\\\\n\\\\\\\\n        //\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":896},{\\\\\\\"lineNumber\\\\\\\":897},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_processing(&amp;self, state: TBool) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":898},{\\\\\\\"text\\\\\\\":\\\\\\\"        let state = state != 0;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":899},{\\\\\\\"lineNumber\\\\\\\":900},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Always reset the processing status when the plugin gets activated or deactivated\\\\\\\",\\\\\\\"lineNumber\\\\\\\":901},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.last_process_status.store(ProcessStatus::Normal);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":902},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.is_processing.store(state, Ordering::SeqCst);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":903},{\\\\\\\"lineNumber\\\\\\\":904},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This function is also used to reset buffers on the plugin, so we should do the same\\\\\\\",\\\\\\\"lineNumber\\\\\\\":905},{\\\\\\\"text\\\\\\\":\\\\\\\"        // thing. We don't call &#96;reset()&#96; in &#96;setup_processing()&#96; for that same reason.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":906},{\\\\\\\"text\\\\\\\":\\\\\\\"        if state {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":907},{\\\\\\\"text\\\\\\\":\\\\\\\"            // HACK: See the comment in &#96;IComponent::setActive()&#96;. This is needed to work around\\\\\\\",\\\\\\\"lineNumber\\\\\\\":908},{\\\\\\\"text\\\\\\\":\\\\\\\"            //       Ardour bugs.\\\\\\\",\\\\\\\"lineNumber\\\\\\\":909},{\\\\\\\"text\\\\\\\":\\\\\\\"            let mut plugin = match self.inner.plugin.try_lock() {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":910},{\\\\\\\"text\\\\\\\":\\\\\\\"                Some(plugin) =&gt; plugin,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":911},{\\\\\\\"text\\\\\\\":\\\\\\\"                None =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":912},{\\\\\\\"text\\\\\\\":\\\\\\\"                    nih_debug_assert_failure!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":913},{\\\\\\\"text\\\\\\\":\\\\\\\"                        \\\\\\\\\\\\\\\"The host tried to call IAudioProcessor::setProcessing(true) during a \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":914},{\\\\\\\"text\\\\\\\":\\\\\\\"                         reentrent call to IComponent::setActive(true), returning kResultOk. If \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":915},{\\\\\\\"text\\\\\\\":\\\\\\\"                         this is Ardour then it will still call \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":916},{\\\\\\\"text\\\\\\\":\\\\\\\"                         IAudioProcessor::setProcessing(true) later and everything will be fine. \\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\"lineNumber\\\\\\\":917},{\\\\\\\"text\\\\\\\":\\\\\\\"                         Hopefully.\\\\\\\\\\\\\\\"\\\\\\\",\\\\\\\"lineNumber\\\\\\\":918},{\\\\\\\"text\\\\\\\":\\\\\\\"                    );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":919},{\\\\\\\"text\\\\\\\":\\\\\\\"                    return kResultOk;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":920},{\\\\\\\"text\\\\\\\":\\\\\\\"                }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":921},{\\\\\\\"text\\\\\\\":\\\\\\\"            };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":922},{\\\\\\\"lineNumber\\\\\\\":923},{\\\\\\\"text\\\\\\\":\\\\\\\"            process_wrapper(|| plugin.reset());\\\\\\\",\\\\\\\"lineNumber\\\\\\\":924},{\\\\\\\"text\\\\\\\":\\\\\\\"        }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":925},{\\\\\\\"lineNumber\\\\\\\":926},{\\\\\\\"text\\\\\\\":\\\\\\\"        // We don't have any special handling for suspending and resuming plugins, yet\\\\\\\",\\\\\\\"lineNumber\\\\\\\":927},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":928},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":929},{\\\\\\\"lineNumber\\\\\\\":930},{\\\\\\\"text\\\\\\\":\\\\\\\"    // Clippy doesn't understand our &#96;event_start_idx&#96;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":931},{\\\\\\\"text\\\\\\\":\\\\\\\"    #[allow(clippy::mut_range_bound)]\\\\\\\",\\\\\\\"lineNumber\\\\\\\":932},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn process(&amp;self, data: *mut vst3_sys::vst::ProcessData) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":933},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(data);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":934},{\\\\\\\"lineNumber\\\\\\\":935},{\\\\\\\"text\\\\\\\":\\\\\\\"        //\\\\\\\",\\\\\\\"lineNumber\\\\\\\":936}]},\\\\\\\"score\\\\\\\":0.3836182951927185},{\\\\\\\"codeBlock\\\\\\\":{\\\\\\\"relativeWorkspacePath\\\\\\\":\\\\\\\"./nih-plug/src/wrapper/vst3/wrapper.rs\\\\\\\",\\\\\\\"range\\\\\\\":{\\\\\\\"startPosition\\\\\\\":{\\\\\\\"line\\\\\\\":860,\\\\\\\"column\\\\\\\":5},\\\\\\\"endPosition\\\\\\\":{\\\\\\\"line\\\\\\\":897,\\\\\\\"column\\\\\\\":60}},\\\\\\\"contents\\\\\\\":\\\\\\\"    unsafe fn setup_processing(&amp;self, setup: *const vst3_sys::vst::ProcessSetup) -&gt; tresult {\\\\\\\\n        check_null_ptr!(setup);\\\\\\\\n\\\\\\\\n        // There's no special handling for offline processing at the moment\\\\\\\\n        let setup = &amp;*setup;\\\\\\\\n        nih_debug_assert_eq!(\\\\\\\\n            setup.symbolic_sample_size,\\\\\\\\n            vst3_sys::vst::SymbolicSampleSizes::kSample32 as i32\\\\\\\\n        );\\\\\\\\n\\\\\\\\n        // This is needed when activating the plugin and when restoring state\\\\\\\\n        self.inner.current_buffer_config.store(Some(BufferConfig {\\\\\\\\n            sample_rate: setup.sample_rate as f32,\\\\\\\\n            min_buffer_size: None,\\\\\\\\n            max_buffer_size: setup.max_samples_per_block as u32,\\\\\\\\n            process_mode: self.inner.current_process_mode.load(),\\\\\\\\n        }));\\\\\\\\n\\\\\\\\n        let mode = match setup.process_mode {\\\\\\\\n            n if n == ProcessModes::kRealtime as i32 =&gt; ProcessMode::Realtime,\\\\\\\\n            n if n == ProcessModes::kPrefetch as i32 =&gt; ProcessMode::Buffered,\\\\\\\\n            n if n == ProcessModes::kOffline as i32 =&gt; ProcessMode::Offline,\\\\\\\\n            n =&gt; {\\\\\\\\n                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown rendering mode '{}', defaulting to realtime\\\\\\\\\\\\\\\", n);\\\\\\\\n                ProcessMode::Realtime\\\\\\\\n            }\\\\\\\\n        };\\\\\\\\n        self.inner.current_process_mode.store(mode);\\\\\\\\n\\\\\\\\n        // Initializing the plugin happens in &#96;IAudioProcessor::set_active()&#96; because the host may\\\\\\\\n        // still change the channel layouts at this point\\\\\\\\n\\\\\\\\n        kResultOk\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    unsafe fn set_processing(&amp;self, state: TBool) -&gt; tresult\\\\\\\",\\\\\\\"signatures\\\\\\\":{},\\\\\\\"detailedLines\\\\\\\":[{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn setup_processing(&amp;self, setup: *const vst3_sys::vst::ProcessSetup) -&gt; tresult {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":863},{\\\\\\\"text\\\\\\\":\\\\\\\"        check_null_ptr!(setup);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":864},{\\\\\\\"lineNumber\\\\\\\":865},{\\\\\\\"text\\\\\\\":\\\\\\\"        // There's no special handling for offline processing at the moment\\\\\\\",\\\\\\\"lineNumber\\\\\\\":866},{\\\\\\\"text\\\\\\\":\\\\\\\"        let setup = &amp;*setup;\\\\\\\",\\\\\\\"lineNumber\\\\\\\":867},{\\\\\\\"text\\\\\\\":\\\\\\\"        nih_debug_assert_eq!(\\\\\\\",\\\\\\\"lineNumber\\\\\\\":868},{\\\\\\\"text\\\\\\\":\\\\\\\"            setup.symbolic_sample_size,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":869},{\\\\\\\"text\\\\\\\":\\\\\\\"            vst3_sys::vst::SymbolicSampleSizes::kSample32 as i32\\\\\\\",\\\\\\\"lineNumber\\\\\\\":870},{\\\\\\\"text\\\\\\\":\\\\\\\"        );\\\\\\\",\\\\\\\"lineNumber\\\\\\\":871},{\\\\\\\"lineNumber\\\\\\\":872},{\\\\\\\"text\\\\\\\":\\\\\\\"        // This is needed when activating the plugin and when restoring state\\\\\\\",\\\\\\\"lineNumber\\\\\\\":873},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.current_buffer_config.store(Some(BufferConfig {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":874},{\\\\\\\"text\\\\\\\":\\\\\\\"            sample_rate: setup.sample_rate as f32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":875},{\\\\\\\"text\\\\\\\":\\\\\\\"            min_buffer_size: None,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":876},{\\\\\\\"text\\\\\\\":\\\\\\\"            max_buffer_size: setup.max_samples_per_block as u32,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":877},{\\\\\\\"text\\\\\\\":\\\\\\\"            process_mode: self.inner.current_process_mode.load(),\\\\\\\",\\\\\\\"lineNumber\\\\\\\":878},{\\\\\\\"text\\\\\\\":\\\\\\\"        }));\\\\\\\",\\\\\\\"lineNumber\\\\\\\":879},{\\\\\\\"lineNumber\\\\\\\":880},{\\\\\\\"text\\\\\\\":\\\\\\\"        let mode = match setup.process_mode {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":881},{\\\\\\\"text\\\\\\\":\\\\\\\"            n if n == ProcessModes::kRealtime as i32 =&gt; ProcessMode::Realtime,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":882},{\\\\\\\"text\\\\\\\":\\\\\\\"            n if n == ProcessModes::kPrefetch as i32 =&gt; ProcessMode::Buffered,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":883},{\\\\\\\"text\\\\\\\":\\\\\\\"            n if n == ProcessModes::kOffline as i32 =&gt; ProcessMode::Offline,\\\\\\\",\\\\\\\"lineNumber\\\\\\\":884},{\\\\\\\"text\\\\\\\":\\\\\\\"            n =&gt; {\\\\\\\",\\\\\\\"lineNumber\\\\\\\":885},{\\\\\\\"text\\\\\\\":\\\\\\\"                nih_debug_assert_failure!(\\\\\\\\\\\\\\\"Unknown rendering mode '{}', defaulting to realtime\\\\\\\\\\\\\\\", n);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":886},{\\\\\\\"text\\\\\\\":\\\\\\\"                ProcessMode::Realtime\\\\\\\",\\\\\\\"lineNumber\\\\\\\":887},{\\\\\\\"text\\\\\\\":\\\\\\\"            }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":888},{\\\\\\\"text\\\\\\\":\\\\\\\"        };\\\\\\\",\\\\\\\"lineNumber\\\\\\\":889},{\\\\\\\"text\\\\\\\":\\\\\\\"        self.inner.current_process_mode.store(mode);\\\\\\\",\\\\\\\"lineNumber\\\\\\\":890},{\\\\\\\"lineNumber\\\\\\\":891},{\\\\\\\"text\\\\\\\":\\\\\\\"        // Initializing the plugin happens in &#96;IAudioProcessor::set_active()&#96; because the host may\\\\\\\",\\\\\\\"lineNumber\\\\\\\":892},{\\\\\\\"text\\\\\\\":\\\\\\\"        // still change the channel layouts at this point\\\\\\\",\\\\\\\"lineNumber\\\\\\\":893},{\\\\\\\"lineNumber\\\\\\\":894},{\\\\\\\"text\\\\\\\":\\\\\\\"        kResultOk\\\\\\\",\\\\\\\"lineNumber\\\\\\\":895},{\\\\\\\"text\\\\\\\":\\\\\\\"    }\\\\\\\",\\\\\\\"lineNumber\\\\\\\":896},{\\\\\\\"lineNumber\\\\\\\":897},{\\\\\\\"text\\\\\\\":\\\\\\\"    unsafe fn set_processing(&amp;self, state: TBool) -&gt; tresult\\\\\\\",\\\\\\\"lineNumber\\\\\\\":898}]},\\\\\\\"score\\\\\\\":0.3813861608505249}]}\\\"},\\\"capabilityType\\\":15}\",\"e9ec6a27-6c91-458a-aa0a-2084bf70750a\":\"{\\\"_v\\\":3,\\\"type\\\":2,\\\"approximateLintErrors\\\":[],\\\"lints\\\":[],\\\"codebaseContextChunks\\\":[],\\\"commits\\\":[],\\\"pullRequests\\\":[],\\\"attachedCodeChunks\\\":[],\\\"assistantSuggestedDiffs\\\":[],\\\"gitDiffs\\\":[],\\\"interpreterResults\\\":[],\\\"images\\\":[],\\\"attachedFolders\\\":[],\\\"attachedFoldersNew\\\":[],\\\"bubbleId\\\":\\\"9213702f-3f2e-4929-b6bb-d94a09e3a20c\\\",\\\"userResponsesToSuggestedCodeBlocks\\\":[],\\\"suggestedCodeBlocks\\\":[],\\\"diffsForCompressingFiles\\\":[],\\\"relevantFiles\\\":[],\\\"toolResults\\\":[],\\\"notepads\\\":[],\\\"capabilities\\\":[],\\\"multiFileLinterErrors\\\":[],\\\"diffHistories\\\":[],\\\"recentLocationsHistory\\\":[],\\\"recentlyViewedFiles\\\":[],\\\"isAgentic\\\":false,\\\"fileDiffTrajectories\\\":[],\\\"existedSubsequentTerminalCommand\\\":false,\\\"existedPreviousTerminalCommand\\\":false,\\\"docsReferences\\\":[],\\\"webReferences\\\":[],\\\"aiWebSearchResults\\\":[],\\\"requestId\\\":\\\"\\\",\\\"attachedFoldersListDirResults\\\":[],\\\"humanChanges\\\":[],\\\"attachedHumanChanges\\\":false,\\\"summarizedComposers\\\":[],\\\"cursorRules\\\":[],\\\"contextPieces\\\":[],\\\"editTrailContexts\\\":[],\\\"allThinkingBlocks\\\":[],\\\"diffsSinceLastApply\\\":[],\\\"deletedFiles\\\":[],\\\"supportedTools\\\":[],\\\"tokenCount\\\":{\\\"inputTokens\\\":0,\\\"outputTokens\\\":0},\\\"attachedFileCodeChunksMetadataOnly\\\":[],\\\"consoleLogs\\\":[],\\\"uiElementPicked\\\":[],\\\"isRefunded\\\":false,\\\"knowledgeItems\\\":[],\\\"documentationSelections\\\":[],\\\"externalLinks\\\":[],\\\"projectLayouts\\\":[],\\\"unifiedMode\\\":2,\\\"capabilityContexts\\\":[],\\\"todos\\\":[],\\\"createdAt\\\":\\\"2026-02-16T20:55:58.056Z\\\",\\\"mcpDescriptors\\\":[],\\\"workspaceUris\\\":[],\\\"conversationState\\\":{\\\"rootPromptMessagesJson\\\":[],\\\"turnsOld\\\":[],\\\"todos\\\":[],\\\"pendingToolCalls\\\":[],\\\"turns\\\":[],\\\"previousWorkspaceUris\\\":[],\\\"fileStates\\\":{},\\\"summaryArchives\\\":[],\\\"turnTimings\\\":[],\\\"fileStatesV2\\\":{},\\\"subagentStates\\\":{},\\\"selfSummaryCount\\\":0,\\\"readPaths\\\":[]},\\\"text\\\":\\\"\\\\n## Summary: nih-plug CLAP and VST3 Wrapper Architecture\\\\n\\\\n### 1. File Structure\\\\n\\\\n**CLAP Wrapper (&#96;src/wrapper/clap/&#96;):**\\\\n- &#96;wrapper.rs&#96; â€” Main wrapper implementation (~3200 lines)\\\\n- &#96;descriptor.rs&#96; â€” Plugin descriptor construction (&#96;PluginDescriptor&#96;)\\\\n- &#96;context.rs&#96; â€” Context implementations (&#96;WrapperInitContext&#96;, &#96;WrapperProcessContext&#96;, &#96;WrapperGuiContext&#96;)\\\\n- &#96;util.rs&#96; â€” Utilities (stream I/O, pointer wrappers, macros)\\\\n- &#96;features.rs&#96; â€” Feature handling\\\\n\\\\n**VST3 Wrapper (&#96;src/wrapper/vst3/&#96;):**\\\\n- &#96;wrapper.rs&#96; â€” Main wrapper implementing COM interfaces (~1900 lines)\\\\n- &#96;inner.rs&#96; â€” Core wrapper state (&#96;WrapperInner&#96;)\\\\n- &#96;factory.rs&#96; â€” Factory implementation (&#96;PluginInfo&#96;, &#96;Factory&#96;)\\\\n- &#96;context.rs&#96; â€” Context implementations (similar to CLAP)\\\\n- &#96;view.rs&#96; â€” GUI view wrapper\\\\n- &#96;util.rs&#96; â€” Utilities (UTF-16 string handling, pointer wrappers)\\\\n- &#96;note_expressions.rs&#96; â€” Note expression translation\\\\n- &#96;param_units.rs&#96; â€” Parameter unit/group management\\\\n- &#96;subcategories.rs&#96; â€” VST3 subcategory handling\\\\n\\\\n### 2. Entry Point Exports\\\\n\\\\n**CLAP (&#96;clap_entry&#96;):**\\\\n- Generated by &#96;nih_export_clap!()&#96; macro in &#96;src/wrapper/clap.rs&#96;\\\\n- Exports a static &#96;clap_plugin_entry&#96; struct with:\\\\n  - &#96;init()&#96; â€” Sets up logger\\\\n  - &#96;deinit()&#96; â€” Cleanup\\\\n  - &#96;get_factory()&#96; â€” Returns factory pointer if ID matches &#96;CLAP_PLUGIN_FACTORY_ID&#96;\\\\n- Factory (&#96;clap_plugin_factory&#96;) provides:\\\\n  - &#96;get_plugin_count()&#96; â€” Number of plugins\\\\n  - &#96;get_plugin_descriptor()&#96; â€” Returns descriptor by index\\\\n  - &#96;create_plugin()&#96; â€” Creates &#96;Wrapper&lt;P&gt;&#96; instance, returns &#96;clap_plugin&#96; pointer\\\\n\\\\n**VST3 (&#96;GetPluginFactory&#96;):**\\\\n- Generated by &#96;nih_export_vst3!()&#96; macro in &#96;src/wrapper/vst3.rs&#96;\\\\n- Exports &#96;GetPluginFactory()&#96; function returning &#96;*mut c_void&#96;\\\\n- Creates &#96;Factory&#96; struct implementing &#96;IPluginFactory&#96;, &#96;IPluginFactory2&#96;, &#96;IPluginFactory3&#96;\\\\n- Factory provides class info and creates &#96;Wrapper&lt;P&gt;&#96; instances via &#96;create_instance()&#96;\\\\n\\\\n### 3. Process Function Translation\\\\n\\\\n**CLAP (&#96;clap_plugin::process&#96;):**\\\\n1. Event handling: Iterates &#96;clap_input_events&#96;, translates to framework &#96;NoteEvent&#96; types\\\\n2. Parameter handling: Processes &#96;CLAP_EVENT_PARAM_VALUE&#96; and &#96;CLAP_EVENT_PARAM_MOD&#96; events\\\\n3. Sample-accurate automation: If enabled, splits buffer at parameter change boundaries\\\\n4. Buffer setup: Uses &#96;BufferManager&#96; to create framework &#96;Buffer&#96; objects from host channel pointers\\\\n5. Transport: Extracts transport info from &#96;clap_process.transport&#96;\\\\n6. Plugin call: Calls &#96;plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context)&#96;\\\\n7. Output events: Translates framework events back to CLAP events in &#96;clap_output_events&#96;\\\\n\\\\n**VST3 (&#96;IAudioProcessor::process&#96;):**\\\\n1. Parameter changes: Reads from &#96;IParameterChanges&#96;, converts to framework parameter updates\\\\n2. MIDI CC handling: If enabled, converts MIDI CC parameter changes to &#96;NoteEvent::MidiCC&#96;\\\\n3. Event handling: Reads from &#96;IEventList&#96;, translates VST3 events to framework &#96;NoteEvent&#96;\\\\n4. Sample-accurate automation: If enabled, sorts parameter changes and note events, splits buffer\\\\n5. Buffer setup: Uses &#96;BufferManager&#96; to create framework buffers from &#96;ProcessData&#96; channel pointers\\\\n6. Transport: Extracts from &#96;ProcessContext&#96;\\\\n7. Plugin call: Calls &#96;plugin.process(buffers.main_buffer, &amp;mut aux, &amp;mut context)&#96;\\\\n8. Output events: Translates framework events back to VST3 &#96;Event&#96; structs\\\\n\\\\n### 4. Parameter Translation\\\\n\\\\n**CLAP:**\\\\n- Parameters identified by hash (computed from string ID)\\\\n- &#96;clap_plugin_params&#96; extension provides:\\\\n  - &#96;count()&#96; â€” Number of parameters\\\\n  - &#96;get_info()&#96; â€” Returns &#96;clap_param_info&#96; (name, range, flags, module/group)\\\\n  - &#96;get_value()&#96; â€” Returns plain value (normalized Ã— step_count)\\\\n  - &#96;value_to_text()&#96; / &#96;text_to_value()&#96; â€” String conversion\\\\n  - &#96;flush()&#96; â€” Processes queued parameter changes from GUI\\\\n- Parameter events: &#96;CLAP_EVENT_PARAM_VALUE&#96; (plain value) and &#96;CLAP_EVENT_PARAM_MOD&#96; (modulation offset)\\\\n- Polyphonic modulation: Supported via &#96;CLAP_EVENT_PARAM_MOD&#96; with &#96;note_id != -1&#96;\\\\n\\\\n**VST3:**\\\\n- Parameters identified by hash (u32 parameter ID)\\\\n- &#96;IEditController&#96; provides:\\\\n  - &#96;get_parameter_count()&#96; â€” Includes MIDI CC parameters if enabled\\\\n  - &#96;get_parameter_info()&#96; â€” Returns &#96;ParameterInfo&#96; (name, range, flags, unit)\\\\n  - &#96;get_param_normalized()&#96; / &#96;set_param_normalized()&#96; â€” Normalized value access\\\\n  - &#96;get_param_string_by_value()&#96; / &#96;get_param_value_by_string()&#96; â€” String conversion\\\\n- Parameter changes: Via &#96;IParameterChanges&#96; â†’ &#96;IParamValueQueue&#96; with sample offsets\\\\n- MIDI CC: Exposed as special parameters (128 CCs + channel pressure + pitch bend) Ã— 16 channels\\\\n- Units: Managed via &#96;ParamUnits&#96; for parameter grouping\\\\n\\\\n### 5. Event Translation\\\\n\\\\n**CLAP:**\\\\n- Input events: &#96;clap_input_events&#96; â†’ framework &#96;NoteEvent&#96;\\\\n  - &#96;CLAP_EVENT_NOTE_ON/OFF&#96; â†’ &#96;NoteEvent::NoteOn/NoteOff&#96;\\\\n  - &#96;CLAP_EVENT_NOTE_CHOKE&#96; â†’ &#96;NoteEvent::Choke&#96;\\\\n  - &#96;CLAP_EVENT_NOTE_EXPRESSION&#96; â†’ Various polyphonic expression events\\\\n  - &#96;CLAP_EVENT_MIDI&#96; â†’ Parsed MIDI messages\\\\n  - &#96;CLAP_EVENT_MIDI_SYSEX&#96; â†’ SysEx messages\\\\n- Output events: Framework events â†’ &#96;clap_output_events&#96;\\\\n  - Note events â†’ &#96;CLAP_EVENT_NOTE_ON/OFF&#96;\\\\n  - Polyphonic expressions â†’ &#96;CLAP_EVENT_NOTE_EXPRESSION&#96;\\\\n  - MIDI CC/pitch bend â†’ &#96;CLAP_EVENT_MIDI&#96;\\\\n\\\\n**VST3:**\\\\n- Input events: &#96;IEventList&#96; â†’ framework &#96;NoteEvent&#96;\\\\n  - &#96;kNoteOnEvent&#96; / &#96;kNoteOffEvent&#96; â†’ &#96;NoteEvent::NoteOn/NoteOff&#96;\\\\n  - &#96;kPolyPressureEvent&#96; â†’ &#96;NoteEvent::PolyPressure&#96;\\\\n  - &#96;kNoteExpressionValueEvent&#96; â†’ Various polyphonic expression events (via &#96;NoteExpressionController&#96;)\\\\n  - &#96;kDataEvent&#96; (SysEx) â†’ Parsed MIDI messages\\\\n- Output events: Framework events â†’ VST3 &#96;Event&#96; structs\\\\n  - Note events â†’ &#96;kNoteOnEvent&#96; / &#96;kNoteOffEvent&#96;\\\\n  - Polyphonic expressions â†’ &#96;kNoteExpressionValueEvent&#96;\\\\n  - MIDI CC/pitch bend â†’ &#96;kLegacyMIDICCOutEvent&#96;\\\\n\\\\n### 6. State Save/Load\\\\n\\\\n**CLAP (&#96;clap_plugin_state&#96; extension):**\\\\n- &#96;save()&#96;: Calls &#96;state::serialize_json()&#96; â†’ writes to &#96;clap_ostream&#96;\\\\n- &#96;load()&#96;: Reads from &#96;clap_istream&#96; â†’ &#96;state::deserialize_json()&#96; â†’ &#96;set_state_inner()&#96;\\\\n- State format: JSON with parameter values keyed by string IDs\\\\n- GUI state updates: Zero-capacity channel from GUI thread to audio thread, processed at end of &#96;process()&#96;\\\\n\\\\n**VST3 (&#96;IComponent::get_state&#96; / &#96;set_state&#96;):**\\\\n- &#96;get_state()&#96;: Calls &#96;state::serialize_json()&#96; â†’ writes to &#96;IBStream&#96;\\\\n- &#96;set_state()&#96;: Reads from &#96;IBStream&#96; â†’ &#96;state::deserialize_json()&#96; â†’ &#96;set_state_inner()&#96;\\\\n- State format: Same JSON format as CLAP\\\\n- GUI state updates: Same zero-capacity channel pattern as CLAP\\\\n\\\\n**Common State Handling (&#96;set_state_inner&#96;):**\\\\n1. Deserializes JSON to &#96;PluginState&#96; object\\\\n2. Updates parameter values via &#96;param_by_hash&#96; mapping\\\\n3. Reinitializes plugin if already initialized (calls &#96;plugin.initialize()&#96; again)\\\\n4. Resets plugin buffers\\\\n5. Notifies GUI thread of parameter value changes\\\\n\\\\n### Key Architectural Patterns\\\\n\\\\n1. **Wrapper struct pattern**: Both use a wrapper struct (&#96;Wrapper&lt;P&gt;&#96; / &#96;WrapperInner&lt;P&gt;&#96;) that holds the plugin instance and manages format-specific state\\\\n2. **Context objects**: Separate context types (&#96;InitContext&#96;, &#96;ProcessContext&#96;, &#96;GuiContext&#96;) provide API-agnostic interfaces\\\\n3. **Buffer management**: &#96;BufferManager&#96; pre-allocates buffers and creates framework &#96;Buffer&#96; objects from host pointers\\\\n4. **Event queuing**: Input/output events stored in &#96;VecDeque&#96; or &#96;ArrayQueue&#96; for realtime-safe access\\\\n5. **Parameter mapping**: Hash-based parameter ID system with bidirectional mappings (&#96;param_by_hash&#96;, &#96;param_ptr_to_hash&#96;, &#96;param_id_to_hash&#96;)\\\\n6. **Sample-accurate automation**: Both support block splitting when parameter changes occur mid-buffer\\\\n7. **Thread safety**: Uses atomic operations, lock-free queues, and careful mutex usage to maintain realtime safety\\\\n\\\\nThis architecture keeps plugin code format-agnostic while handling format-specific details in the wrappers.\\\"}\"},\"status\":\"completed\",\"context\":{\"composers\":[],\"selectedCommits\":[],\"selectedPullRequests\":[],\"selectedImages\":[],\"folderSelections\":[],\"fileSelections\":[],\"selections\":[],\"terminalSelections\":[],\"selectedDocs\":[],\"externalLinks\":[],\"cursorRules\":[],\"cursorCommands\":[],\"gitPRDiffSelections\":[],\"subagentSelections\":[],\"browserSelections\":[],\"mentions\":{\"composers\":{},\"selectedCommits\":{},\"selectedPullRequests\":{},\"gitDiff\":[],\"gitDiffFromBranchToMain\":[],\"selectedImages\":{},\"folderSelections\":{},\"fileSelections\":{},\"terminalFiles\":{},\"selections\":{},\"terminalSelections\":{},\"selectedDocs\":{},\"externalLinks\":{},\"diffHistory\":[],\"cursorRules\":{},\"cursorCommands\":{},\"uiElementSelections\":[],\"consoleLogs\":[],\"ideEditorsState\":[],\"gitPRDiffSelections\":{},\"subagentSelections\":{},\"browserSelections\":{}}},\"generatingBubbleIds\":[],\"isReadingLongFile\":false,\"codeBlockData\":{},\"originalFileStates\":{},\"newlyCreatedFiles\":[],\"newlyCreatedFolders\":[],\"createdAt\":1771275148627,\"hasChangedContext\":false,\"activeTabsShouldBeReactive\":true,\"capabilities\":[{\"type\":30,\"data\":{}},{\"type\":15,\"data\":{\"bubbleDataMap\":\"{}\"}}],\"name\":\"Explore nih-plug wrapper structure\",\"isFileListExpanded\":false,\"browserChipManuallyDisabled\":false,\"browserChipManuallyEnabled\":false,\"unifiedMode\":\"agent\",\"forceMode\":\"edit\",\"usageData\":{},\"allAttachedFileCodeChunksUris\":[],\"modelConfig\":{\"modelName\":\"composer-1\",\"maxMode\":false},\"subComposerIds\":[],\"capabilityContexts\":[],\"todos\":[],\"isQueueExpanded\":true,\"hasUnreadMessages\":false,\"gitHubPromptDismissed\":false,\"totalLinesAdded\":0,\"totalLinesRemoved\":0,\"addedFiles\":0,\"removedFiles\":0,\"isDraft\":false,\"isCreatingWorktree\":false,\"isApplyingWorktree\":false,\"isUndoingWorktree\":false,\"applied\":false,\"pendingCreateWorktree\":false,\"isBestOfNSubcomposer\":false,\"isBestOfNParent\":false,\"bestOfNJudgeWinner\":false,\"isSpec\":false,\"isProject\":false,\"isSpecSubagentDone\":false,\"stopHookLoopCount\":0,\"speculativeSummarizationEncryptionKey\":\"09yUwERta/M3hxb5oB8uc7TfQiPavdSYUUy0Viownxw=\",\"isNAL\":true,\"planModeSuggestionUsed\":false,\"debugModeSuggestionUsed\":false,\"conversationState\":\"~\",\"queueItems\":[],\"isAgentic\":true}"
}
```
Result:

```json
{
  "agentId": "5e832be2-93ad-46dc-b904-0e7344395026"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/events.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/ext/params.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now let me look at a few more files to complete my understanding - particularly the CLAP audio ports extension, state extension, and the VST3 controller/param_changes bindings.</details></think>

---

Let me check a few more key binding files.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/ext/audio_ports.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/ext/state.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/controller.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/param_changes.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a very thorough understanding of the codebase. Let me also check the CLAP note_ports extension since that's needed for the wrapper.</details></think>

---

Let me read one more key file, then I'll have everything needed for the plan.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/ext/note_ports.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/core/params.zig</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I have a comprehensive understanding of the entire codebase. Let me also check a couple more files for completeness - the CLAP host.zig and stream.zig bindings.</details></think>

---

Now I have a thorough understanding of the entire codebase. Let me read the remaining key files for completeness.

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/host.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/clap/stream.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/bindings/vst3/stream.zig</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** â€¢ Read file: /Users/b/code/z-plug/src/core/events.zig</summary>

</details>
</tool-use>

---

I now have a thorough understanding of the full codebase. Let me create the plan.

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Format Wrappers Implementation (Design Section 2.3)\n\n## Current State\n\nAll prerequisite layers are complete:\n- **Bindings layer**: CLAP (&#96;src/bindings/clap/&#96;) and VST3 (&#96;src/bindings/vst3/&#96;) are fully implemented\n- **Core framework**: All 6 modules in &#96;src/core/&#96; are implemented (&#96;plugin.zig&#96;, &#96;buffer.zig&#96;, &#96;params.zig&#96;, &#96;events.zig&#96;, &#96;state.zig&#96;, &#96;audio_layout.zig&#96;)\n- **Wrappers**: &#96;src/wrappers/&#96; does not exist yet -- this is the work to be done\n\n## Architecture\n\nEach wrapper must:\n1. Implement the format's ABI entry points (exported C functions)\n2. Own format-specific state (COM ref counts for VST3, host callback pointers for CLAP)\n3. Translate between the format's process call and the framework's &#96;processFn&#96;\n4. Map format-specific parameter changes to the framework's unified event model\n\n&#96;&#96;&#96;mermaid\nflowchart LR\n    subgraph core [Framework Core]\n        PI[\"Plugin(T)\"]\n        BUF[Buffer]\n        EVT[NoteEvent]\n        PM[ParamValues]\n        SC[SaveContext/LoadContext]\n    end\n    subgraph clap_wrap [CLAP Wrapper]\n        CE[entry.zig - clap_entry export]\n        CF[factory.zig - clap_plugin_factory]\n        CP[plugin.zig - clap_plugin impl]\n        CX[extensions.zig - params/ports/state]\n    end\n    subgraph vst3_wrap [VST3 Wrapper]\n        VF[factory.zig - GetPluginFactory export]\n        VC[component.zig - IComponent]\n        VP[processor.zig - IAudioProcessor]\n        VE[controller.zig - IEditController]\n    end\n    CE --&gt; CF --&gt; CP --&gt; PI\n    CP --&gt; BUF\n    CP --&gt; EVT\n    CX --&gt; PM\n    CX --&gt; SC\n    VF --&gt; VC --&gt; VP --&gt; PI\n    VP --&gt; BUF\n    VP --&gt; EVT\n    VE --&gt; PM\n&#96;&#96;&#96;\n\n## File Structure\n\n&#96;&#96;&#96;\nsrc/wrappers/\n  clap/\n    entry.zig          # clap_entry export, init/deinit, getFactory\n    factory.zig        # clap_plugin_factory (getPluginCount, getPluginDescriptor, createPlugin)\n    plugin.zig         # clap_plugin struct + lifecycle (init, destroy, activate, process, etc.)\n    extensions.zig     # Extension implementations (audio-ports, note-ports, params, state)\n    README.md\n  vst3/\n    factory.zig        # GetPluginFactory export, IPluginFactory COM object\n    component.zig      # IComponent + IAudioProcessor combined (single-component design)\n    controller.zig     # IEditController implementation\n    com.zig            # Comptime COM helpers (ref counting, queryInterface dispatch)\n    README.md\n&#96;&#96;&#96;\n\n---\n\n## CLAP Wrapper\n\n### 1. &#96;src/wrappers/clap/entry.zig&#96; -- Entry Point\n\nExport a &#96;pub const clap_entry: bindings.Entry&#96; at file scope. This is the symbol the host looks for when loading the &#96;.clap&#96; shared library.\n\n- &#96;init&#96;: Minimal setup (store plugin_path if needed). Return &#96;true&#96;.\n- &#96;deinit&#96;: Cleanup.\n- &#96;getFactory&#96;: If &#96;factory_id&#96; matches &#96;\"clap.plugin-factory\"&#96;, return pointer to the factory struct from &#96;factory.zig&#96;. Otherwise return &#96;null&#96;.\n\nThe export must be &#96;comptime&#96;-parameterized by the plugin type &#96;T&#96; so that &#96;Plugin(T)&#96; metadata is available. Use a pattern like:\n\n&#96;&#96;&#96;zig\npub fn ClapEntry(comptime T: type) type {\n    const P = core.Plugin(T);\n    _ = P; // used in factory\n    return struct {\n        pub const clap_entry = clap_bindings.Entry{\n            .version = .{ .major = 1, .minor = 2, .revision = 2 },\n            .init = entryInit,\n            .deinit = entryDeinit,\n            .getFactory = getFactory,\n        };\n        // ... static functions\n    };\n}\n&#96;&#96;&#96;\n\nThe plugin author's &#96;build.zig&#96; would arrange for &#96;clap_entry&#96; to be exported from the shared library (via &#96;@export&#96; or a comptime-generated exported symbol).\n\n### 2. &#96;src/wrappers/clap/factory.zig&#96; -- Plugin Factory\n\nImplements &#96;clap_plugin_factory&#96; (bindings at &#96;src/bindings/clap/factory/plugin.zig&#96;):\n- &#96;getPluginCount&#96;: Return 1 (single-plugin libraries for now).\n- &#96;getPluginDescriptor&#96;: Return a comptime-generated &#96;clap.Plugin.Descriptor&#96; populated from &#96;Plugin(T)&#96; metadata (&#96;name&#96;, &#96;vendor&#96;, &#96;url&#96;, &#96;version&#96;, &#96;plugin_id&#96;). Features array built from audio_io_layouts.\n- &#96;createPlugin&#96;: Allocate a &#96;PluginWrapper(T)&#96; instance (using &#96;std.heap.page_allocator&#96; -- allocation happens on main thread, not audio thread). Initialize the &#96;clap.Plugin&#96; struct with wrapper function pointers. Store the host pointer.\n\n### 3. &#96;src/wrappers/clap/plugin.zig&#96; -- Plugin Implementation\n\nThe core wrapper struct, parameterized by plugin type &#96;T&#96;:\n\n&#96;&#96;&#96;zig\nfn PluginWrapper(comptime T: type) type {\n    const P = core.Plugin(T);\n    return struct {\n        clap_plugin: clap_bindings.Plugin,   // first field -- host sees this pointer\n        host: *const clap_bindings.Host,\n        plugin: T,                           // the actual plugin instance\n        param_values: core.ParamValues(P.params.len),\n        buffer: core.Buffer,                 // scratch, re-pointed each process call\n        // ... pre-allocated event storage, buffer config, etc.\n    };\n}\n&#96;&#96;&#96;\n\nKey callbacks wired into &#96;clap_plugin&#96;:\n- **init**: Call &#96;P.init(&amp;self.plugin, layout, config)&#96;. Query host extensions.\n- **destroy**: Call &#96;P.deinit(&amp;self.plugin)&#96;. Free the wrapper allocation.\n- **activate**: Store sample_rate, min/max frames. Call &#96;P.reset()&#96;.\n- **deactivate**: No-op or call &#96;P.reset()&#96;.\n- **process**: The main translation function (see below).\n- **getExtension**: Return pointers to extension structs based on ID string.\n\n**Process translation** (&#96;process&#96; callback):\n1. Extract &#96;frames_count&#96; from &#96;clap_process_t&#96;.\n2. Map &#96;clap_process_t.audio_inputs/outputs&#96; pointers into framework &#96;Buffer&#96; (zero-copy: copy channel pointers, not data).\n3. Iterate &#96;in_events&#96; via &#96;InputEvents.size()&#96; / &#96;InputEvents.get()&#96;:\n   - &#96;note_on/off/choke/note_end&#96; -&gt; &#96;NoteEvent.note_on/off/choke/voice_terminated&#96;\n   - &#96;note_expression&#96; -&gt; &#96;NoteEvent.poly_*&#96; based on expression_id\n   - &#96;param_value&#96; -&gt; Update &#96;ParamValues&#96; atomically\n   - &#96;midi&#96; -&gt; Parse 3-byte MIDI -&gt; &#96;NoteEvent.midi_cc/channel_pressure/pitch_bend&#96;\n4. Map &#96;clap_process_t.transport&#96; to framework &#96;Transport&#96;.\n5. Build &#96;ProcessContext&#96; and call &#96;P.process(&amp;self.plugin, &amp;buffer, &amp;aux, &amp;context)&#96;.\n6. Map &#96;ProcessStatus&#96; return to &#96;clap.Process.Status&#96;.\n7. Translate output events from &#96;EventOutputList&#96; back to CLAP events via &#96;out_events.tryPush()&#96;.\n\n### 4. &#96;src/wrappers/clap/extensions.zig&#96; -- Extension Implementations\n\nEach extension is a comptime-generated &#96;extern struct&#96; of function pointers:\n\n- **audio-ports** (&#96;clap.ext.audio_ports&#96;): &#96;count&#96; returns number of I/O ports from &#96;audio_io_layouts&#96;. &#96;get&#96; fills &#96;audio_ports.Info&#96; (channel_count, port_type stereo/mono, flags).\n- **note-ports** (&#96;clap.ext.note_ports&#96;): Present if &#96;midi_input != .none&#96; or &#96;midi_output != .none&#96;. Reports supported dialects (CLAP notes + MIDI).\n- **params** (&#96;clap.ext.params&#96;): &#96;count&#96; returns &#96;P.params.len&#96;. &#96;getInfo&#96; fills &#96;params.Info&#96; from comptime &#96;Param&#96; data (name, min/max/default, flags mapped to CLAP param flags, ID from &#96;idHash&#96;). &#96;getValue&#96; reads from &#96;ParamValues&#96;. &#96;valueToText&#96;/&#96;textToValue&#96; format parameter values. &#96;flush&#96; processes parameter events outside of &#96;process&#96;.\n- **state** (&#96;clap.ext.state&#96;): &#96;save&#96; wraps &#96;clap.OStream&#96; into a &#96;std.io.AnyWriter&#96;, calls &#96;P.save()&#96;. &#96;load&#96; wraps &#96;clap.IStream&#96; into a &#96;std.io.AnyReader&#96;, calls &#96;P.load()&#96;.\n\n---\n\n## VST3 Wrapper\n\n### 5. &#96;src/wrappers/vst3/com.zig&#96; -- COM Helpers\n\nExtend the existing &#96;FUnknownImpl&#96; in bindings with:\n- **Proper reference counting**: Atomic &#96;ref_count&#96; field. &#96;addRef&#96; increments, &#96;release&#96; decrements and frees when zero.\n- **Generic &#96;queryInterface&#96; dispatch**: Already exists in &#96;src/bindings/vst3/funknown.zig&#96; as &#96;FUnknownImpl&#96;, but the &#96;addRef&#96;/&#96;release&#96; stubs need to be replaced with real implementations that operate on a ref_count field within the wrapper object.\n\n### 6. &#96;src/wrappers/vst3/factory.zig&#96; -- Plugin Factory + Export\n\nExport &#96;GetPluginFactory&#96; as a &#96;callconv(.c)&#96; function returning &#96;*anyopaque&#96;:\n\n&#96;&#96;&#96;zig\npub fn Vst3Factory(comptime T: type) type {\n    const P = core.Plugin(T);\n    return struct {\n        pub fn GetPluginFactory() callconv(.c) *anyopaque { ... }\n    };\n}\n&#96;&#96;&#96;\n\nImplements &#96;IPluginFactory&#96; (and &#96;IPluginFactory2&#96;, &#96;IPluginFactory3&#96;) via comptime vtables:\n- &#96;getFactoryInfo&#96;: Fill &#96;PFactoryInfo&#96; from &#96;P.vendor&#96;, &#96;P.url&#96;.\n- &#96;countClasses&#96;: Return 1 (processor class).\n- &#96;getClassInfo&#96;: Fill &#96;PClassInfo&#96; with TUID generated from &#96;P.plugin_id&#96; via &#96;guid.parseGuid&#96; or a string-to-GUID function, category &#96;\"Audio Module Class\"&#96;.\n- &#96;createInstance&#96;: Allocate a &#96;Vst3Component(T)&#96;, return as &#96;*anyopaque&#96;.\n\n**GUID generation**: The design calls for deriving a VST3 TUID from &#96;plugin_id&#96;. Use a deterministic hash (e.g., hash the plugin_id string into 16 bytes) so the GUID is stable. A comptime function &#96;pluginIdToTuid(comptime id: [:0]const u8) TUID&#96; will handle this.\n\n### 7. &#96;src/wrappers/vst3/component.zig&#96; -- IComponent + IAudioProcessor\n\nVST3 uses a \"single component\" pattern where &#96;IComponent&#96; and &#96;IAudioProcessor&#96; are implemented by the same object. The wrapper struct:\n\n&#96;&#96;&#96;zig\nfn Vst3Component(comptime T: type) type {\n    const P = core.Plugin(T);\n    return struct {\n        // COM interface pointers (must be at known offsets for queryInterface)\n        component_vtbl: *const IComponentVtbl,\n        processor_vtbl: *const IAudioProcessorVtbl,\n        controller_vtbl: *const IEditControllerVtbl,  // or separate object\n\n        ref_count: std.atomic.Value(u32),\n        plugin: T,\n        param_values: core.ParamValues(P.params.len),\n        // ... buffer config, host context pointer, etc.\n    };\n}\n&#96;&#96;&#96;\n\n**IComponent methods**:\n- &#96;initialize&#96;: Store host context. Call &#96;P.init()&#96;.\n- &#96;terminate&#96;: Call &#96;P.deinit()&#96;.\n- &#96;getBusCount&#96;: Derive from &#96;audio_io_layouts&#96;.\n- &#96;getBusInfo&#96;: Fill &#96;BusInfo&#96; from layout (channel count, name, direction).\n- &#96;setActive&#96;: Activate/deactivate processing. Call &#96;P.reset()&#96; on activate.\n- &#96;setState&#96;/&#96;getState&#96;: State persistence via &#96;IBStream&#96; -&gt; &#96;SaveContext&#96;/&#96;LoadContext&#96;.\n\n**IAudioProcessor methods**:\n- &#96;setupProcessing&#96;: Store &#96;ProcessSetup&#96; (sample rate, max block size).\n- &#96;process&#96;: The main translation function:\n  1. Read &#96;ProcessData.inputs/outputs&#96; -&gt; framework &#96;Buffer&#96; (zero-copy pointer mapping).\n  2. Read &#96;IParameterChanges&#96; (input): iterate param queues, get last point value, update &#96;ParamValues&#96;.\n  3. Read &#96;IEventList&#96; (input): translate VST3 events to &#96;NoteEvent&#96;.\n  4. Build &#96;ProcessContext&#96; from &#96;ProcessData.process_context&#96; (transport).\n  5. Call &#96;P.process()&#96;.\n  6. Map &#96;ProcessStatus&#96; to &#96;tresult&#96;.\n  7. Write output events to &#96;IEventList&#96; (output).\n  8. Write output parameter changes to &#96;IParameterChanges&#96; (output) if any.\n- &#96;setBusArrangements&#96;: Validate against &#96;audio_io_layouts&#96;.\n- &#96;getBusArrangement&#96;: Return speaker arrangement from layout.\n- &#96;canProcessSampleSize&#96;: Return &#96;kResultOk&#96; for 32-bit float.\n- &#96;getLatencySamples&#96;: Return 0 (latency reporting deferred to Phase 3).\n- &#96;getTailSamples&#96;: Return 0 (tail reporting deferred to Phase 3).\n\n### 8. &#96;src/wrappers/vst3/controller.zig&#96; -- IEditController\n\nIn VST3's \"single component\" model, the component also implements &#96;IEditController&#96; (queryInterface returns the same object for both IIDs).\n\n**IEditController methods**:\n- &#96;getParameterCount&#96;: Return &#96;P.params.len&#96;.\n- &#96;getParameterInfo&#96;: Fill &#96;ParameterInfo&#96; from comptime &#96;Param&#96; data. ID from &#96;idHash&#96;, title from name, step_count from type, flags mapped to VST3 flags.\n- &#96;getParamNormalized&#96;/&#96;setParamNormalized&#96;: Read/write &#96;ParamValues&#96;.\n- &#96;normalizedParamToPlain&#96;/&#96;plainParamToNormalized&#96;: Use &#96;FloatRange&#96;/&#96;IntRange&#96; normalize/unnormalize.\n- &#96;getParamStringByValue&#96;/&#96;getParamValueByString&#96;: Format values to/from String128.\n- &#96;setComponentState&#96;: Load parameter values from stream.\n- &#96;createView&#96;: Return null (GUI deferred).\n\n---\n\n## Build System Updates\n\n### 9. Update &#96;build.zig&#96;\n\n- Wire &#96;src/wrappers/clap/&#96; and &#96;src/wrappers/vst3/&#96; into the &#96;z_plug&#96; module (they import both &#96;core&#96; and &#96;bindings&#96;).\n- Add an &#96;addPlugin()&#96; helper function that plugin authors call from their &#96;build.zig&#96;. It should:\n  - Accept plugin source file, target formats (.clap, .vst3), target, optimize.\n  - Create a shared library compilation step.\n  - For CLAP: output as &#96;.clap&#96; (renamed &#96;.dylib&#96;/&#96;.so&#96;/&#96;.dll&#96;).\n  - For VST3: create macOS bundle structure (&#96;MyPlugin.vst3/Contents/MacOS/MyPlugin&#96;).\n  - Link the z_plug module with bindings.\n\n### 10. Update &#96;src/root.zig&#96;\n\n- Re-export wrapper entry points so plugin authors can use them:\n  - &#96;pub const ClapEntry = @import(\"wrappers/clap/entry.zig\").ClapEntry;&#96;\n  - &#96;pub const Vst3Factory = @import(\"wrappers/vst3/factory.zig\").Vst3Factory;&#96;\n- Add test references for wrapper modules.\n\n---\n\n## Testing Strategy\n\n- **Comptime tests**: Verify that wrapper metadata generation (CLAP descriptor, VST3 class info, parameter info arrays) produces correct values for a test plugin.\n- **Unit tests**: Test event translation functions (CLAP event -&gt; NoteEvent, NoteEvent -&gt; CLAP event; same for VST3).\n- **Unit tests**: Test parameter mapping (CLAP param_info generation, VST3 ParameterInfo generation).\n- **Unit tests**: Test state save/load stream adapters (wrap a buffer as CLAP IStream/OStream or VST3 IBStream).\n- **Integration test**: Build a minimal gain plugin to both formats, verify &#96;zig build&#96; succeeds.\n- Run &#96;zig build test&#96; to verify all existing tests still pass.\n\n---\n\n## Implementation Order\n\nImplement CLAP first (simpler ABI -- C structs, no COM), then VST3 (COM vtables). Within each:\n1. Entry point + factory (can test: plugin loads)\n2. Plugin lifecycle (init/destroy/activate/deactivate)\n3. Process callback (audio passes through)\n4. Parameter extension/controller (parameters visible in host)\n5. State extension (save/load)\n6. Tests throughout\n",
  "name": "Format Wrappers Implementation",
  "todos": [
    {
      "content": "CLAP entry.zig: Export clap_entry, init/deinit, getFactory pointing to plugin factory",
      "status": "pending",
      "id": "clap-entry"
    },
    {
      "content": "CLAP factory.zig: Implement clap_plugin_factory (getPluginCount, getPluginDescriptor, createPlugin with allocation)",
      "status": "pending",
      "id": "clap-factory"
    },
    {
      "content": "CLAP plugin.zig: PluginWrapper struct with lifecycle callbacks, process translation (buffer mapping, event translation, transport mapping)",
      "status": "pending",
      "id": "clap-plugin"
    },
    {
      "content": "CLAP extensions.zig: audio-ports, note-ports, params (count/getInfo/getValue/valueToText/flush), state (save/load via stream adapters)",
      "status": "pending",
      "id": "clap-extensions"
    },
    {
      "content": "VST3 com.zig: COM helpers with real atomic ref counting, queryInterface dispatch for multi-interface objects",
      "status": "pending",
      "id": "vst3-com"
    },
    {
      "content": "VST3 factory.zig: Export GetPluginFactory, IPluginFactory vtable, GUID generation from plugin_id, createInstance",
      "status": "pending",
      "id": "vst3-factory"
    },
    {
      "content": "VST3 component.zig: IComponent + IAudioProcessor (bus info, activate, process translation with IParameterChanges/IEventList mapping)",
      "status": "pending",
      "id": "vst3-component"
    },
    {
      "content": "VST3 controller.zig: IEditController (parameter info, normalized/plain conversion, string formatting, setComponentState)",
      "status": "pending",
      "id": "vst3-controller"
    },
    {
      "content": "Update build.zig: Wire wrapper modules, add addPlugin() helper for shared library output with platform bundling",
      "status": "pending",
      "id": "build-system"
    },
    {
      "content": "Update root.zig: Re-export ClapEntry and Vst3Factory, add wrapper test references",
      "status": "pending",
      "id": "root-exports"
    },
    {
      "content": "Add tests: comptime metadata generation, event translation roundtrips, parameter mapping, stream adapters, integration build test",
      "status": "pending",
      "id": "tests"
    },
    {
      "content": "Add README.md for src/wrappers/clap/ and src/wrappers/vst3/",
      "status": "pending",
      "id": "readmes"
    }
  ],
  "overview": "Implement the CLAP and VST3 format wrappers (section 2.3 of zig-plug-design.md) that bridge the API-agnostic core framework to the format-specific low-level bindings, enabling plugins to load in DAWs as both CLAP and VST3."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///Users/b/.cursor/plans/format_wrappers_implementation_c4210864.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

_**User**_

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

